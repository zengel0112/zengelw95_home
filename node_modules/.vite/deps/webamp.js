import {
  __commonJS
} from "./chunk-EWTE5DHJ.js";

// node_modules/webamp/built/webamp.bundle.js
var require_webamp_bundle = __commonJS({
  "node_modules/webamp/built/webamp.bundle.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["Webamp"] = factory();
      else
        root["Webamp"] = factory();
    })(window, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__2(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__2);
            module2.l = true;
            return module2.exports;
          }
          __webpack_require__2.m = modules;
          __webpack_require__2.c = installedModules;
          __webpack_require__2.d = function(exports2, name, getter) {
            if (!__webpack_require__2.o(exports2, name)) {
              Object.defineProperty(exports2, name, { enumerable: true, get: getter });
            }
          };
          __webpack_require__2.r = function(exports2) {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
              Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
            }
            Object.defineProperty(exports2, "__esModule", { value: true });
          };
          __webpack_require__2.t = function(value, mode) {
            if (mode & 1) value = __webpack_require__2(value);
            if (mode & 8) return value;
            if (mode & 4 && typeof value === "object" && value && value.__esModule) return value;
            var ns = /* @__PURE__ */ Object.create(null);
            __webpack_require__2.r(ns);
            Object.defineProperty(ns, "default", { enumerable: true, value });
            if (mode & 2 && typeof value != "string") for (var key in value) __webpack_require__2.d(ns, key, (function(key2) {
              return value[key2];
            }).bind(null, key));
            return ns;
          };
          __webpack_require__2.n = function(module2) {
            var getter = module2 && module2.__esModule ? (
              /******/
              function getDefault() {
                return module2["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module2;
              }
            );
            __webpack_require__2.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__2.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__2.p = "";
          return __webpack_require__2(__webpack_require__2.s = 117);
        }([
          /* 0 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            if (true) {
              module2.exports = __webpack_require__2(55);
            } else {
            }
          },
          /* 1 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            if (true) {
              module2.exports = __webpack_require__2(56);
            } else {
            }
          },
          /* 2 */
          /***/
          function(module2, exports2) {
            function _defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, {
                  value,
                  enumerable: true,
                  configurable: true,
                  writable: true
                });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            module2.exports = _defineProperty;
          },
          /* 3 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            exports2.__esModule = true;
            exports2.defaultMemoize = defaultMemoize;
            exports2.createSelectorCreator = createSelectorCreator;
            exports2.createStructuredSelector = createStructuredSelector;
            function defaultEqualityCheck(a, b) {
              return a === b;
            }
            function areArgumentsShallowlyEqual(equalityCheck, prev, next) {
              if (prev === null || next === null || prev.length !== next.length) {
                return false;
              }
              var length = prev.length;
              for (var i = 0; i < length; i++) {
                if (!equalityCheck(prev[i], next[i])) {
                  return false;
                }
              }
              return true;
            }
            function defaultMemoize(func) {
              var equalityCheck = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultEqualityCheck;
              var lastArgs = null;
              var lastResult = null;
              return function() {
                if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {
                  lastResult = func.apply(null, arguments);
                }
                lastArgs = arguments;
                return lastResult;
              };
            }
            function getDependencies(funcs) {
              var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;
              if (!dependencies.every(function(dep) {
                return typeof dep === "function";
              })) {
                var dependencyTypes = dependencies.map(function(dep) {
                  return typeof dep;
                }).join(", ");
                throw new Error("Selector creators expect all input-selectors to be functions, " + ("instead received the following types: [" + dependencyTypes + "]"));
              }
              return dependencies;
            }
            function createSelectorCreator(memoize) {
              for (var _len = arguments.length, memoizeOptions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                memoizeOptions[_key - 1] = arguments[_key];
              }
              return function() {
                for (var _len2 = arguments.length, funcs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  funcs[_key2] = arguments[_key2];
                }
                var recomputations = 0;
                var resultFunc = funcs.pop();
                var dependencies = getDependencies(funcs);
                var memoizedResultFunc = memoize.apply(void 0, [function() {
                  recomputations++;
                  return resultFunc.apply(null, arguments);
                }].concat(memoizeOptions));
                var selector = defaultMemoize(function() {
                  var params = [];
                  var length = dependencies.length;
                  for (var i = 0; i < length; i++) {
                    params.push(dependencies[i].apply(null, arguments));
                  }
                  return memoizedResultFunc.apply(null, params);
                });
                selector.resultFunc = resultFunc;
                selector.recomputations = function() {
                  return recomputations;
                };
                selector.resetRecomputations = function() {
                  return recomputations = 0;
                };
                return selector;
              };
            }
            var createSelector = exports2.createSelector = createSelectorCreator(defaultMemoize);
            function createStructuredSelector(selectors) {
              var selectorCreator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : createSelector;
              if (typeof selectors !== "object") {
                throw new Error("createStructuredSelector expects first argument to be an object " + ("where each property is a selector, instead received a " + typeof selectors));
              }
              var objectKeys = Object.keys(selectors);
              return selectorCreator(objectKeys.map(function(key) {
                return selectors[key];
              }), function() {
                for (var _len3 = arguments.length, values = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                  values[_key3] = arguments[_key3];
                }
                return values.reduce(function(composition, value, index) {
                  composition[objectKeys[index]] = value;
                  return composition;
                }, {});
              });
            }
          },
          /* 4 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            (function() {
              "use strict";
              var hasOwn = {}.hasOwnProperty;
              function classNames() {
                var classes = [];
                for (var i = 0; i < arguments.length; i++) {
                  var arg = arguments[i];
                  if (!arg) continue;
                  var argType = typeof arg;
                  if (argType === "string" || argType === "number") {
                    classes.push(arg);
                  } else if (Array.isArray(arg) && arg.length) {
                    var inner = classNames.apply(null, arg);
                    if (inner) {
                      classes.push(inner);
                    }
                  } else if (argType === "object") {
                    for (var key in arg) {
                      if (hasOwn.call(arg, key) && arg[key]) {
                        classes.push(key);
                      }
                    }
                  }
                }
                return classes.join(" ");
              }
              if (module2.exports) {
                classNames.default = classNames;
                module2.exports = classNames;
              } else if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                  return classNames;
                }).apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
              } else {
              }
            })();
          },
          /* 5 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            function checkDCE() {
              if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
                return;
              }
              if (false) {
              }
              try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
              } catch (err) {
                console.error(err);
              }
            }
            if (true) {
              checkDCE();
              module2.exports = __webpack_require__2(57);
            } else {
            }
          },
          /* 6 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const assert = __webpack_require__2(18);
            const ieee754 = __webpack_require__2(102);
            const maybeFlush = (b, o, len, flush) => {
              if (o + len > b.length) {
                if (typeof flush !== "function") {
                  throw new Error("Buffer out of space and no valid flush() function found");
                }
                flush(b, o);
                return 0;
              }
              return o;
            };
            exports2.UINT8 = {
              len: 1,
              get(buf, off) {
                return buf.readUInt8(off);
              },
              put(b, o, v, flush) {
                assert.equal(typeof o, "number");
                assert.equal(typeof v, "number");
                assert.ok(v >= 0 && v <= 255);
                assert.ok(o >= 0);
                assert.ok(this.len <= b.length);
                const no = maybeFlush(b, o, this.len, flush);
                b.writeUInt8(v, no);
                return no - o + this.len;
              }
            };
            exports2.UINT16_LE = {
              len: 2,
              get(buf, off) {
                return buf.readUInt16LE(off);
              },
              put(b, o, v, flush) {
                assert.equal(typeof o, "number");
                assert.equal(typeof v, "number");
                assert.ok(v >= 0 && v <= 65535);
                assert.ok(o >= 0);
                assert.ok(this.len <= b.length);
                const no = maybeFlush(b, o, this.len, flush);
                b.writeUInt16LE(v, no);
                return no - o + this.len;
              }
            };
            exports2.UINT16_BE = {
              len: 2,
              get(buf, off) {
                return buf.readUInt16BE(off);
              },
              put(b, o, v, flush) {
                assert.equal(typeof o, "number");
                assert.equal(typeof v, "number");
                assert.ok(v >= 0 && v <= 65535);
                assert.ok(o >= 0);
                assert.ok(this.len <= b.length);
                const no = maybeFlush(b, o, this.len, flush);
                b.writeUInt16BE(v, no);
                return no - o + this.len;
              }
            };
            exports2.UINT24_LE = {
              len: 3,
              get(buf, off) {
                return buf.readUIntLE(off, 3);
              },
              put(b, o, v, flush) {
                assert.equal(typeof o, "number");
                assert.equal(typeof v, "number");
                assert.ok(v >= 0 && v <= 16777215);
                assert.ok(o >= 0);
                assert.ok(this.len <= b.length);
                const no = maybeFlush(b, o, this.len, flush);
                b.writeUIntLE(v, no, 3);
                return no - o + this.len;
              }
            };
            exports2.UINT24_BE = {
              len: 3,
              get(buf, off) {
                return buf.readUIntBE(off, 3);
              },
              put(b, o, v, flush) {
                assert.equal(typeof o, "number");
                assert.equal(typeof v, "number");
                assert.ok(v >= 0 && v <= 16777215);
                assert.ok(o >= 0);
                assert.ok(this.len <= b.length);
                const no = maybeFlush(b, o, this.len, flush);
                b.writeUIntBE(v, no, 3);
                return no - o + this.len;
              }
            };
            exports2.UINT32_LE = {
              len: 4,
              get(buf, off) {
                return buf.readUInt32LE(off);
              },
              put(b, o, v, flush) {
                assert.equal(typeof o, "number");
                assert.equal(typeof v, "number");
                assert.ok(v >= 0 && v <= 4294967295);
                assert.ok(o >= 0);
                assert.ok(this.len <= b.length);
                const no = maybeFlush(b, o, this.len, flush);
                b.writeUInt32LE(v, no);
                return no - o + this.len;
              }
            };
            exports2.UINT32_BE = {
              len: 4,
              get(buf, off) {
                return buf.readUInt32BE(off);
              },
              put(b, o, v, flush) {
                assert.equal(typeof o, "number");
                assert.equal(typeof v, "number");
                assert.ok(v >= 0 && v <= 4294967295);
                assert.ok(o >= 0);
                assert.ok(this.len <= b.length);
                const no = maybeFlush(b, o, this.len, flush);
                b.writeUInt32BE(v, no);
                return no - o + this.len;
              }
            };
            exports2.INT8 = {
              len: 1,
              get(buf, off) {
                return buf.readInt8(off);
              },
              put(b, o, v, flush) {
                assert.equal(typeof o, "number");
                assert.equal(typeof v, "number");
                assert.ok(v >= -128 && v <= 127);
                assert.ok(o >= 0);
                assert.ok(this.len <= b.length);
                const no = maybeFlush(b, o, this.len, flush);
                b.writeInt8(v, no);
                return no - o + this.len;
              }
            };
            exports2.INT16_BE = {
              len: 2,
              get(buf, off) {
                return buf.readInt16BE(off);
              },
              put(b, o, v, flush) {
                assert.equal(typeof o, "number");
                assert.equal(typeof v, "number");
                assert.ok(v >= -32768 && v <= 32767);
                assert.ok(o >= 0);
                assert.ok(this.len <= b.length);
                const no = maybeFlush(b, o, this.len, flush);
                b.writeInt16BE(v, no);
                return no - o + this.len;
              }
            };
            exports2.INT16_LE = {
              len: 2,
              get(buf, off) {
                return buf.readInt16LE(off);
              },
              put(b, o, v, flush) {
                assert.equal(typeof o, "number");
                assert.equal(typeof v, "number");
                assert.ok(v >= -32768 && v <= 32767);
                assert.ok(o >= 0);
                assert.ok(this.len <= b.length);
                const no = maybeFlush(b, o, this.len, flush);
                b.writeInt16LE(v, no);
                return no - o + this.len;
              }
            };
            exports2.INT24_LE = {
              len: 3,
              get(buf, off) {
                return buf.readIntLE(off, 3);
              },
              put(b, o, v, flush) {
                assert.equal(typeof o, "number");
                assert.equal(typeof v, "number");
                assert.ok(v >= -8388608 && v <= 8388607);
                assert.ok(o >= 0);
                assert.ok(this.len <= b.length);
                const no = maybeFlush(b, o, this.len, flush);
                b.writeIntLE(v, no, 3);
                return no - o + this.len;
              }
            };
            exports2.INT24_BE = {
              len: 3,
              get(buf, off) {
                return buf.readIntBE(off, 3);
              },
              put(b, o, v, flush) {
                assert.equal(typeof o, "number");
                assert.equal(typeof v, "number");
                assert.ok(v >= -8388608 && v <= 8388607);
                assert.ok(o >= 0);
                assert.ok(this.len <= b.length);
                const no = maybeFlush(b, o, this.len, flush);
                b.writeIntBE(v, no, 3);
                return no - o + this.len;
              }
            };
            exports2.INT32_BE = {
              len: 4,
              get(buf, off) {
                return buf.readInt32BE(off);
              },
              put(b, o, v, flush) {
                assert.equal(typeof o, "number");
                assert.equal(typeof v, "number");
                assert.ok(v >= -2147483648 && v <= 2147483647);
                assert.ok(o >= 0);
                assert.ok(this.len <= b.length);
                const no = maybeFlush(b, o, this.len, flush);
                b.writeInt32BE(v, no);
                return no - o + this.len;
              }
            };
            exports2.INT32_LE = {
              len: 4,
              get(buf, off) {
                return buf.readInt32LE(off);
              },
              put(b, o, v, flush) {
                assert.equal(typeof o, "number");
                assert.equal(typeof v, "number");
                assert.ok(v >= -2147483648 && v <= 2147483647);
                assert.ok(o >= 0);
                assert.ok(this.len <= b.length);
                const no = maybeFlush(b, o, this.len, flush);
                b.writeInt32LE(v, no);
                return no - o + this.len;
              }
            };
            exports2.UINT64_LE = {
              len: 8,
              get(buf, off) {
                return readUIntLE(buf, off, this.len);
              },
              put(b, o, v) {
                return writeUIntLE(b, v, o, this.len);
              }
            };
            exports2.INT64_LE = {
              len: 8,
              get(buf, off) {
                return readIntLE(buf, off, this.len);
              },
              put(b, off, v) {
                return writeIntLE(b, v, off, this.len);
              }
            };
            exports2.UINT64_BE = {
              len: 8,
              get(b, off) {
                return readUIntBE(b, off, this.len);
              },
              put(b, o, v) {
                return writeUIntBE(b, v, o, this.len);
              }
            };
            exports2.INT64_BE = {
              len: 8,
              get(b, off) {
                return readIntBE(b, off, this.len);
              },
              put(b, off, v) {
                return writeIntBE(b, v, off, this.len);
              }
            };
            exports2.Float16_BE = {
              len: 2,
              get(b, off) {
                return ieee754.read(b, off, false, 10, this.len);
              },
              put(b, off, v) {
                return ieee754.write(b, v, off, false, 10, this.len);
              }
            };
            exports2.Float16_LE = {
              len: 2,
              get(b, off) {
                return ieee754.read(b, off, true, 10, this.len);
              },
              put(b, off, v) {
                return ieee754.write(b, v, off, true, 10, this.len);
              }
            };
            exports2.Float32_BE = {
              len: 4,
              get(b, off) {
                return b.readFloatBE(off);
              },
              put(b, off, v) {
                return b.writeFloatBE(v, off);
              }
            };
            exports2.Float32_LE = {
              len: 4,
              get(b, off) {
                return b.readFloatLE(off);
              },
              put(b, off, v) {
                return b.writeFloatLE(v, off);
              }
            };
            exports2.Float64_BE = {
              len: 8,
              get(b, off) {
                return b.readDoubleBE(off);
              },
              put(b, off, v) {
                return b.writeDoubleBE(v, off);
              }
            };
            exports2.Float64_LE = {
              len: 8,
              get(b, off) {
                return b.readDoubleLE(off);
              },
              put(b, off, v) {
                return b.writeDoubleLE(v, off);
              }
            };
            exports2.Float80_BE = {
              len: 10,
              get(b, off) {
                return ieee754.read(b, off, false, 63, this.len);
              },
              put(b, off, v) {
                return ieee754.write(b, v, off, false, 63, this.len);
              }
            };
            exports2.Float80_LE = {
              len: 10,
              get(b, off) {
                return ieee754.read(b, off, true, 63, this.len);
              },
              put(b, off, v) {
                return ieee754.write(b, v, off, true, 63, this.len);
              }
            };
            class IgnoreType {
              /**
               * @param len number of bytes to ignore
               */
              constructor(len) {
                this.len = len;
              }
              // ToDo: don't read, but skip data
              get(buf, off) {
              }
            }
            exports2.IgnoreType = IgnoreType;
            class BufferType {
              constructor(len) {
                this.len = len;
              }
              get(buf, off) {
                return buf.slice(off, off + this.len);
              }
            }
            exports2.BufferType = BufferType;
            class StringType {
              constructor(len, encoding) {
                this.len = len;
                this.encoding = encoding;
              }
              get(buf, off) {
                return buf.toString(this.encoding, off, off + this.len);
              }
            }
            exports2.StringType = StringType;
            class AnsiStringType {
              constructor(len) {
                this.len = len;
              }
              static decode(buffer, off, until) {
                let str = "";
                for (let i = off; i < until; ++i) {
                  str += AnsiStringType.codePointToString(AnsiStringType.singleByteDecoder(buffer[i]));
                }
                return str;
              }
              static inRange(a, min, max) {
                return min <= a && a <= max;
              }
              static codePointToString(cp) {
                if (cp <= 65535) {
                  return String.fromCharCode(cp);
                } else {
                  cp -= 65536;
                  return String.fromCharCode((cp >> 10) + 55296, (cp & 1023) + 56320);
                }
              }
              static singleByteDecoder(bite) {
                if (AnsiStringType.inRange(bite, 0, 127)) {
                  return bite;
                }
                const codePoint = AnsiStringType.windows1252[bite - 128];
                if (codePoint === null) {
                  throw Error("invaliding encoding");
                }
                return codePoint;
              }
              get(buf, off = 0) {
                return AnsiStringType.decode(buf, off, off + this.len);
              }
            }
            exports2.AnsiStringType = AnsiStringType;
            AnsiStringType.windows1252 = [
              8364,
              129,
              8218,
              402,
              8222,
              8230,
              8224,
              8225,
              710,
              8240,
              352,
              8249,
              338,
              141,
              381,
              143,
              144,
              8216,
              8217,
              8220,
              8221,
              8226,
              8211,
              8212,
              732,
              8482,
              353,
              8250,
              339,
              157,
              382,
              376,
              160,
              161,
              162,
              163,
              164,
              165,
              166,
              167,
              168,
              169,
              170,
              171,
              172,
              173,
              174,
              175,
              176,
              177,
              178,
              179,
              180,
              181,
              182,
              183,
              184,
              185,
              186,
              187,
              188,
              189,
              190,
              191,
              192,
              193,
              194,
              195,
              196,
              197,
              198,
              199,
              200,
              201,
              202,
              203,
              204,
              205,
              206,
              207,
              208,
              209,
              210,
              211,
              212,
              213,
              214,
              215,
              216,
              217,
              218,
              219,
              220,
              221,
              222,
              223,
              224,
              225,
              226,
              227,
              228,
              229,
              230,
              231,
              232,
              233,
              234,
              235,
              236,
              237,
              238,
              239,
              240,
              241,
              242,
              243,
              244,
              245,
              246,
              247,
              248,
              249,
              250,
              251,
              252,
              253,
              254,
              255
            ];
            function readUIntLE(buf, offset, byteLength) {
              offset = offset >>> 0;
              byteLength = byteLength >>> 0;
              let val = buf[offset];
              let mul = 1;
              let i = 0;
              while (++i < byteLength && (mul *= 256)) {
                val += buf[offset + i] * mul;
              }
              return val;
            }
            function writeUIntLE(buf, value, offset, byteLength) {
              value = +value;
              offset = offset >>> 0;
              byteLength = byteLength >>> 0;
              let mul = 1;
              let i = 0;
              buf[offset] = value & 255;
              while (++i < byteLength && (mul *= 256)) {
                buf[offset + i] = value / mul & 255;
              }
              return offset + byteLength;
            }
            function readIntLE(buf, offset, byteLength) {
              offset = offset >>> 0;
              byteLength = byteLength >>> 0;
              let val = buf[offset];
              let mul = 1;
              let i = 0;
              while (++i < byteLength && (mul *= 256)) {
                val += buf[offset + i] * mul;
              }
              mul *= 128;
              if (val >= mul)
                val -= Math.pow(2, 8 * byteLength);
              return val;
            }
            function writeIntLE(buf, value, offset, byteLength) {
              value = +value;
              offset = offset >>> 0;
              let i = 0;
              let mul = 1;
              let sub = 0;
              buf[offset] = value & 255;
              while (++i < byteLength && (mul *= 256)) {
                if (value < 0 && sub === 0 && buf[offset + i - 1] !== 0) {
                  sub = 1;
                }
                buf[offset + i] = (value / mul >> 0) - sub & 255;
              }
              return offset + byteLength;
            }
            exports2.writeIntLE = writeIntLE;
            function readUIntBE(buf, offset, byteLength) {
              offset = offset >>> 0;
              byteLength = byteLength >>> 0;
              let val = buf[offset + --byteLength];
              let mul = 1;
              while (byteLength > 0 && (mul *= 256)) {
                val += buf[offset + --byteLength] * mul;
              }
              return val;
            }
            exports2.readUIntBE = readUIntBE;
            function writeUIntBE(buf, value, offset, byteLength) {
              value = +value;
              offset = offset >>> 0;
              byteLength = byteLength >>> 0;
              let i = byteLength - 1;
              let mul = 1;
              buf[offset + i] = value & 255;
              while (--i >= 0 && (mul *= 256)) {
                buf[offset + i] = value / mul & 255;
              }
              return offset + byteLength;
            }
            exports2.writeUIntBE = writeUIntBE;
            function readIntBE(buf, offset, byteLength) {
              offset = offset >>> 0;
              byteLength = byteLength >>> 0;
              let i = byteLength;
              let mul = 1;
              let val = buf[offset + --i];
              while (i > 0 && (mul *= 256)) {
                val += buf[offset + --i] * mul;
              }
              mul *= 128;
              if (val >= mul)
                val -= Math.pow(2, 8 * byteLength);
              return val;
            }
            exports2.readIntBE = readIntBE;
            function writeIntBE(buf, value, offset, byteLength) {
              value = +value;
              offset = offset >>> 0;
              let i = byteLength - 1;
              let mul = 1;
              let sub = 0;
              buf[offset + i] = value & 255;
              while (--i >= 0 && (mul *= 256)) {
                if (value < 0 && sub === 0 && buf[offset + i + 1] !== 0) {
                  sub = 1;
                }
                buf[offset + i] = (value / mul >> 0) - sub & 255;
              }
              return offset + byteLength;
            }
            exports2.writeIntBE = writeIntBE;
          },
          /* 7 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            var objectWithoutPropertiesLoose = __webpack_require__2(65);
            function _objectWithoutProperties(source, excluded) {
              if (source == null) return {};
              var target = objectWithoutPropertiesLoose(source, excluded);
              var key, i;
              if (Object.getOwnPropertySymbols) {
                var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
                for (i = 0; i < sourceSymbolKeys.length; i++) {
                  key = sourceSymbolKeys[i];
                  if (excluded.indexOf(key) >= 0) continue;
                  if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
                  target[key] = source[key];
                }
              }
              return target;
            }
            module2.exports = _objectWithoutProperties;
          },
          /* 8 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            (function(process) {
              exports2.log = log;
              exports2.formatArgs = formatArgs;
              exports2.save = save;
              exports2.load = load;
              exports2.useColors = useColors;
              exports2.storage = localstorage();
              exports2.colors = [
                "#0000CC",
                "#0000FF",
                "#0033CC",
                "#0033FF",
                "#0066CC",
                "#0066FF",
                "#0099CC",
                "#0099FF",
                "#00CC00",
                "#00CC33",
                "#00CC66",
                "#00CC99",
                "#00CCCC",
                "#00CCFF",
                "#3300CC",
                "#3300FF",
                "#3333CC",
                "#3333FF",
                "#3366CC",
                "#3366FF",
                "#3399CC",
                "#3399FF",
                "#33CC00",
                "#33CC33",
                "#33CC66",
                "#33CC99",
                "#33CCCC",
                "#33CCFF",
                "#6600CC",
                "#6600FF",
                "#6633CC",
                "#6633FF",
                "#66CC00",
                "#66CC33",
                "#9900CC",
                "#9900FF",
                "#9933CC",
                "#9933FF",
                "#99CC00",
                "#99CC33",
                "#CC0000",
                "#CC0033",
                "#CC0066",
                "#CC0099",
                "#CC00CC",
                "#CC00FF",
                "#CC3300",
                "#CC3333",
                "#CC3366",
                "#CC3399",
                "#CC33CC",
                "#CC33FF",
                "#CC6600",
                "#CC6633",
                "#CC9900",
                "#CC9933",
                "#CCCC00",
                "#CCCC33",
                "#FF0000",
                "#FF0033",
                "#FF0066",
                "#FF0099",
                "#FF00CC",
                "#FF00FF",
                "#FF3300",
                "#FF3333",
                "#FF3366",
                "#FF3399",
                "#FF33CC",
                "#FF33FF",
                "#FF6600",
                "#FF6633",
                "#FF9900",
                "#FF9933",
                "#FFCC00",
                "#FFCC33"
              ];
              function useColors() {
                if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
                  return true;
                }
                if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
                  return false;
                }
                return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
                typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
                // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
                typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
                typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
              }
              function formatArgs(args) {
                args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
                if (!this.useColors) {
                  return;
                }
                const c = "color: " + this.color;
                args.splice(1, 0, c, "color: inherit");
                let index = 0;
                let lastC = 0;
                args[0].replace(/%[a-zA-Z%]/g, (match) => {
                  if (match === "%%") {
                    return;
                  }
                  index++;
                  if (match === "%c") {
                    lastC = index;
                  }
                });
                args.splice(lastC, 0, c);
              }
              function log(...args) {
                return typeof console === "object" && console.log && console.log(...args);
              }
              function save(namespaces) {
                try {
                  if (namespaces) {
                    exports2.storage.setItem("debug", namespaces);
                  } else {
                    exports2.storage.removeItem("debug");
                  }
                } catch (error) {
                }
              }
              function load() {
                let r;
                try {
                  r = exports2.storage.getItem("debug");
                } catch (error) {
                }
                if (!r && typeof process !== "undefined" && "env" in process) {
                  r = process.env.DEBUG;
                }
                return r;
              }
              function localstorage() {
                try {
                  return localStorage;
                } catch (error) {
                }
              }
              module2.exports = __webpack_require__2(120)(exports2);
              const { formatters } = module2.exports;
              formatters.j = function(v) {
                try {
                  return JSON.stringify(v);
                } catch (error) {
                  return "[UnexpectedJSONParseError]: " + error.message;
                }
              };
            }).call(this, __webpack_require__2(30));
          },
          /* 9 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            (function(global) {
              var base64 = __webpack_require__2(118);
              var ieee754 = __webpack_require__2(102);
              var isArray = __webpack_require__2(103);
              exports2.Buffer = Buffer2;
              exports2.SlowBuffer = SlowBuffer;
              exports2.INSPECT_MAX_BYTES = 50;
              Buffer2.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== void 0 ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
              exports2.kMaxLength = kMaxLength();
              function typedArraySupport() {
                try {
                  var arr = new Uint8Array(1);
                  arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                    return 42;
                  } };
                  return arr.foo() === 42 && // typed array instances can be augmented
                  typeof arr.subarray === "function" && // chrome 9-10 lack `subarray`
                  arr.subarray(1, 1).byteLength === 0;
                } catch (e) {
                  return false;
                }
              }
              function kMaxLength() {
                return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
              }
              function createBuffer(that, length) {
                if (kMaxLength() < length) {
                  throw new RangeError("Invalid typed array length");
                }
                if (Buffer2.TYPED_ARRAY_SUPPORT) {
                  that = new Uint8Array(length);
                  that.__proto__ = Buffer2.prototype;
                } else {
                  if (that === null) {
                    that = new Buffer2(length);
                  }
                  that.length = length;
                }
                return that;
              }
              function Buffer2(arg, encodingOrOffset, length) {
                if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
                  return new Buffer2(arg, encodingOrOffset, length);
                }
                if (typeof arg === "number") {
                  if (typeof encodingOrOffset === "string") {
                    throw new Error(
                      "If encoding is specified then the first argument must be a string"
                    );
                  }
                  return allocUnsafe(this, arg);
                }
                return from(this, arg, encodingOrOffset, length);
              }
              Buffer2.poolSize = 8192;
              Buffer2._augment = function(arr) {
                arr.__proto__ = Buffer2.prototype;
                return arr;
              };
              function from(that, value, encodingOrOffset, length) {
                if (typeof value === "number") {
                  throw new TypeError('"value" argument must not be a number');
                }
                if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
                  return fromArrayBuffer(that, value, encodingOrOffset, length);
                }
                if (typeof value === "string") {
                  return fromString(that, value, encodingOrOffset);
                }
                return fromObject(that, value);
              }
              Buffer2.from = function(value, encodingOrOffset, length) {
                return from(null, value, encodingOrOffset, length);
              };
              if (Buffer2.TYPED_ARRAY_SUPPORT) {
                Buffer2.prototype.__proto__ = Uint8Array.prototype;
                Buffer2.__proto__ = Uint8Array;
                if (typeof Symbol !== "undefined" && Symbol.species && Buffer2[Symbol.species] === Buffer2) {
                  Object.defineProperty(Buffer2, Symbol.species, {
                    value: null,
                    configurable: true
                  });
                }
              }
              function assertSize(size) {
                if (typeof size !== "number") {
                  throw new TypeError('"size" argument must be a number');
                } else if (size < 0) {
                  throw new RangeError('"size" argument must not be negative');
                }
              }
              function alloc(that, size, fill, encoding) {
                assertSize(size);
                if (size <= 0) {
                  return createBuffer(that, size);
                }
                if (fill !== void 0) {
                  return typeof encoding === "string" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
                }
                return createBuffer(that, size);
              }
              Buffer2.alloc = function(size, fill, encoding) {
                return alloc(null, size, fill, encoding);
              };
              function allocUnsafe(that, size) {
                assertSize(size);
                that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
                if (!Buffer2.TYPED_ARRAY_SUPPORT) {
                  for (var i = 0; i < size; ++i) {
                    that[i] = 0;
                  }
                }
                return that;
              }
              Buffer2.allocUnsafe = function(size) {
                return allocUnsafe(null, size);
              };
              Buffer2.allocUnsafeSlow = function(size) {
                return allocUnsafe(null, size);
              };
              function fromString(that, string, encoding) {
                if (typeof encoding !== "string" || encoding === "") {
                  encoding = "utf8";
                }
                if (!Buffer2.isEncoding(encoding)) {
                  throw new TypeError('"encoding" must be a valid string encoding');
                }
                var length = byteLength(string, encoding) | 0;
                that = createBuffer(that, length);
                var actual = that.write(string, encoding);
                if (actual !== length) {
                  that = that.slice(0, actual);
                }
                return that;
              }
              function fromArrayLike(that, array) {
                var length = array.length < 0 ? 0 : checked(array.length) | 0;
                that = createBuffer(that, length);
                for (var i = 0; i < length; i += 1) {
                  that[i] = array[i] & 255;
                }
                return that;
              }
              function fromArrayBuffer(that, array, byteOffset, length) {
                array.byteLength;
                if (byteOffset < 0 || array.byteLength < byteOffset) {
                  throw new RangeError("'offset' is out of bounds");
                }
                if (array.byteLength < byteOffset + (length || 0)) {
                  throw new RangeError("'length' is out of bounds");
                }
                if (byteOffset === void 0 && length === void 0) {
                  array = new Uint8Array(array);
                } else if (length === void 0) {
                  array = new Uint8Array(array, byteOffset);
                } else {
                  array = new Uint8Array(array, byteOffset, length);
                }
                if (Buffer2.TYPED_ARRAY_SUPPORT) {
                  that = array;
                  that.__proto__ = Buffer2.prototype;
                } else {
                  that = fromArrayLike(that, array);
                }
                return that;
              }
              function fromObject(that, obj) {
                if (Buffer2.isBuffer(obj)) {
                  var len = checked(obj.length) | 0;
                  that = createBuffer(that, len);
                  if (that.length === 0) {
                    return that;
                  }
                  obj.copy(that, 0, 0, len);
                  return that;
                }
                if (obj) {
                  if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
                    if (typeof obj.length !== "number" || isnan(obj.length)) {
                      return createBuffer(that, 0);
                    }
                    return fromArrayLike(that, obj);
                  }
                  if (obj.type === "Buffer" && isArray(obj.data)) {
                    return fromArrayLike(that, obj.data);
                  }
                }
                throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
              }
              function checked(length) {
                if (length >= kMaxLength()) {
                  throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
                }
                return length | 0;
              }
              function SlowBuffer(length) {
                if (+length != length) {
                  length = 0;
                }
                return Buffer2.alloc(+length);
              }
              Buffer2.isBuffer = function isBuffer(b) {
                return !!(b != null && b._isBuffer);
              };
              Buffer2.compare = function compare(a, b) {
                if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
                  throw new TypeError("Arguments must be Buffers");
                }
                if (a === b) return 0;
                var x = a.length;
                var y = b.length;
                for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                  if (a[i] !== b[i]) {
                    x = a[i];
                    y = b[i];
                    break;
                  }
                }
                if (x < y) return -1;
                if (y < x) return 1;
                return 0;
              };
              Buffer2.isEncoding = function isEncoding(encoding) {
                switch (String(encoding).toLowerCase()) {
                  case "hex":
                  case "utf8":
                  case "utf-8":
                  case "ascii":
                  case "latin1":
                  case "binary":
                  case "base64":
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return true;
                  default:
                    return false;
                }
              };
              Buffer2.concat = function concat(list, length) {
                if (!isArray(list)) {
                  throw new TypeError('"list" argument must be an Array of Buffers');
                }
                if (list.length === 0) {
                  return Buffer2.alloc(0);
                }
                var i;
                if (length === void 0) {
                  length = 0;
                  for (i = 0; i < list.length; ++i) {
                    length += list[i].length;
                  }
                }
                var buffer = Buffer2.allocUnsafe(length);
                var pos = 0;
                for (i = 0; i < list.length; ++i) {
                  var buf = list[i];
                  if (!Buffer2.isBuffer(buf)) {
                    throw new TypeError('"list" argument must be an Array of Buffers');
                  }
                  buf.copy(buffer, pos);
                  pos += buf.length;
                }
                return buffer;
              };
              function byteLength(string, encoding) {
                if (Buffer2.isBuffer(string)) {
                  return string.length;
                }
                if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
                  return string.byteLength;
                }
                if (typeof string !== "string") {
                  string = "" + string;
                }
                var len = string.length;
                if (len === 0) return 0;
                var loweredCase = false;
                for (; ; ) {
                  switch (encoding) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                      return len;
                    case "utf8":
                    case "utf-8":
                    case void 0:
                      return utf8ToBytes(string).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return len * 2;
                    case "hex":
                      return len >>> 1;
                    case "base64":
                      return base64ToBytes(string).length;
                    default:
                      if (loweredCase) return utf8ToBytes(string).length;
                      encoding = ("" + encoding).toLowerCase();
                      loweredCase = true;
                  }
                }
              }
              Buffer2.byteLength = byteLength;
              function slowToString(encoding, start, end) {
                var loweredCase = false;
                if (start === void 0 || start < 0) {
                  start = 0;
                }
                if (start > this.length) {
                  return "";
                }
                if (end === void 0 || end > this.length) {
                  end = this.length;
                }
                if (end <= 0) {
                  return "";
                }
                end >>>= 0;
                start >>>= 0;
                if (end <= start) {
                  return "";
                }
                if (!encoding) encoding = "utf8";
                while (true) {
                  switch (encoding) {
                    case "hex":
                      return hexSlice(this, start, end);
                    case "utf8":
                    case "utf-8":
                      return utf8Slice(this, start, end);
                    case "ascii":
                      return asciiSlice(this, start, end);
                    case "latin1":
                    case "binary":
                      return latin1Slice(this, start, end);
                    case "base64":
                      return base64Slice(this, start, end);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return utf16leSlice(this, start, end);
                    default:
                      if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                      encoding = (encoding + "").toLowerCase();
                      loweredCase = true;
                  }
                }
              }
              Buffer2.prototype._isBuffer = true;
              function swap(b, n, m) {
                var i = b[n];
                b[n] = b[m];
                b[m] = i;
              }
              Buffer2.prototype.swap16 = function swap16() {
                var len = this.length;
                if (len % 2 !== 0) {
                  throw new RangeError("Buffer size must be a multiple of 16-bits");
                }
                for (var i = 0; i < len; i += 2) {
                  swap(this, i, i + 1);
                }
                return this;
              };
              Buffer2.prototype.swap32 = function swap32() {
                var len = this.length;
                if (len % 4 !== 0) {
                  throw new RangeError("Buffer size must be a multiple of 32-bits");
                }
                for (var i = 0; i < len; i += 4) {
                  swap(this, i, i + 3);
                  swap(this, i + 1, i + 2);
                }
                return this;
              };
              Buffer2.prototype.swap64 = function swap64() {
                var len = this.length;
                if (len % 8 !== 0) {
                  throw new RangeError("Buffer size must be a multiple of 64-bits");
                }
                for (var i = 0; i < len; i += 8) {
                  swap(this, i, i + 7);
                  swap(this, i + 1, i + 6);
                  swap(this, i + 2, i + 5);
                  swap(this, i + 3, i + 4);
                }
                return this;
              };
              Buffer2.prototype.toString = function toString() {
                var length = this.length | 0;
                if (length === 0) return "";
                if (arguments.length === 0) return utf8Slice(this, 0, length);
                return slowToString.apply(this, arguments);
              };
              Buffer2.prototype.equals = function equals(b) {
                if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
                if (this === b) return true;
                return Buffer2.compare(this, b) === 0;
              };
              Buffer2.prototype.inspect = function inspect() {
                var str = "";
                var max = exports2.INSPECT_MAX_BYTES;
                if (this.length > 0) {
                  str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
                  if (this.length > max) str += " ... ";
                }
                return "<Buffer " + str + ">";
              };
              Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
                if (!Buffer2.isBuffer(target)) {
                  throw new TypeError("Argument must be a Buffer");
                }
                if (start === void 0) {
                  start = 0;
                }
                if (end === void 0) {
                  end = target ? target.length : 0;
                }
                if (thisStart === void 0) {
                  thisStart = 0;
                }
                if (thisEnd === void 0) {
                  thisEnd = this.length;
                }
                if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                  throw new RangeError("out of range index");
                }
                if (thisStart >= thisEnd && start >= end) {
                  return 0;
                }
                if (thisStart >= thisEnd) {
                  return -1;
                }
                if (start >= end) {
                  return 1;
                }
                start >>>= 0;
                end >>>= 0;
                thisStart >>>= 0;
                thisEnd >>>= 0;
                if (this === target) return 0;
                var x = thisEnd - thisStart;
                var y = end - start;
                var len = Math.min(x, y);
                var thisCopy = this.slice(thisStart, thisEnd);
                var targetCopy = target.slice(start, end);
                for (var i = 0; i < len; ++i) {
                  if (thisCopy[i] !== targetCopy[i]) {
                    x = thisCopy[i];
                    y = targetCopy[i];
                    break;
                  }
                }
                if (x < y) return -1;
                if (y < x) return 1;
                return 0;
              };
              function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
                if (buffer.length === 0) return -1;
                if (typeof byteOffset === "string") {
                  encoding = byteOffset;
                  byteOffset = 0;
                } else if (byteOffset > 2147483647) {
                  byteOffset = 2147483647;
                } else if (byteOffset < -2147483648) {
                  byteOffset = -2147483648;
                }
                byteOffset = +byteOffset;
                if (isNaN(byteOffset)) {
                  byteOffset = dir ? 0 : buffer.length - 1;
                }
                if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
                if (byteOffset >= buffer.length) {
                  if (dir) return -1;
                  else byteOffset = buffer.length - 1;
                } else if (byteOffset < 0) {
                  if (dir) byteOffset = 0;
                  else return -1;
                }
                if (typeof val === "string") {
                  val = Buffer2.from(val, encoding);
                }
                if (Buffer2.isBuffer(val)) {
                  if (val.length === 0) {
                    return -1;
                  }
                  return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
                } else if (typeof val === "number") {
                  val = val & 255;
                  if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
                    if (dir) {
                      return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                    } else {
                      return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                    }
                  }
                  return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
                }
                throw new TypeError("val must be string, number or Buffer");
              }
              function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                var indexSize = 1;
                var arrLength = arr.length;
                var valLength = val.length;
                if (encoding !== void 0) {
                  encoding = String(encoding).toLowerCase();
                  if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                    if (arr.length < 2 || val.length < 2) {
                      return -1;
                    }
                    indexSize = 2;
                    arrLength /= 2;
                    valLength /= 2;
                    byteOffset /= 2;
                  }
                }
                function read(buf, i2) {
                  if (indexSize === 1) {
                    return buf[i2];
                  } else {
                    return buf.readUInt16BE(i2 * indexSize);
                  }
                }
                var i;
                if (dir) {
                  var foundIndex = -1;
                  for (i = byteOffset; i < arrLength; i++) {
                    if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                      if (foundIndex === -1) foundIndex = i;
                      if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
                    } else {
                      if (foundIndex !== -1) i -= i - foundIndex;
                      foundIndex = -1;
                    }
                  }
                } else {
                  if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
                  for (i = byteOffset; i >= 0; i--) {
                    var found = true;
                    for (var j = 0; j < valLength; j++) {
                      if (read(arr, i + j) !== read(val, j)) {
                        found = false;
                        break;
                      }
                    }
                    if (found) return i;
                  }
                }
                return -1;
              }
              Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
                return this.indexOf(val, byteOffset, encoding) !== -1;
              };
              Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
                return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
              };
              Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
                return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
              };
              function hexWrite(buf, string, offset, length) {
                offset = Number(offset) || 0;
                var remaining = buf.length - offset;
                if (!length) {
                  length = remaining;
                } else {
                  length = Number(length);
                  if (length > remaining) {
                    length = remaining;
                  }
                }
                var strLen = string.length;
                if (strLen % 2 !== 0) throw new TypeError("Invalid hex string");
                if (length > strLen / 2) {
                  length = strLen / 2;
                }
                for (var i = 0; i < length; ++i) {
                  var parsed = parseInt(string.substr(i * 2, 2), 16);
                  if (isNaN(parsed)) return i;
                  buf[offset + i] = parsed;
                }
                return i;
              }
              function utf8Write(buf, string, offset, length) {
                return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
              }
              function asciiWrite(buf, string, offset, length) {
                return blitBuffer(asciiToBytes(string), buf, offset, length);
              }
              function latin1Write(buf, string, offset, length) {
                return asciiWrite(buf, string, offset, length);
              }
              function base64Write(buf, string, offset, length) {
                return blitBuffer(base64ToBytes(string), buf, offset, length);
              }
              function ucs2Write(buf, string, offset, length) {
                return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
              }
              Buffer2.prototype.write = function write(string, offset, length, encoding) {
                if (offset === void 0) {
                  encoding = "utf8";
                  length = this.length;
                  offset = 0;
                } else if (length === void 0 && typeof offset === "string") {
                  encoding = offset;
                  length = this.length;
                  offset = 0;
                } else if (isFinite(offset)) {
                  offset = offset | 0;
                  if (isFinite(length)) {
                    length = length | 0;
                    if (encoding === void 0) encoding = "utf8";
                  } else {
                    encoding = length;
                    length = void 0;
                  }
                } else {
                  throw new Error(
                    "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                  );
                }
                var remaining = this.length - offset;
                if (length === void 0 || length > remaining) length = remaining;
                if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
                  throw new RangeError("Attempt to write outside buffer bounds");
                }
                if (!encoding) encoding = "utf8";
                var loweredCase = false;
                for (; ; ) {
                  switch (encoding) {
                    case "hex":
                      return hexWrite(this, string, offset, length);
                    case "utf8":
                    case "utf-8":
                      return utf8Write(this, string, offset, length);
                    case "ascii":
                      return asciiWrite(this, string, offset, length);
                    case "latin1":
                    case "binary":
                      return latin1Write(this, string, offset, length);
                    case "base64":
                      return base64Write(this, string, offset, length);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return ucs2Write(this, string, offset, length);
                    default:
                      if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                      encoding = ("" + encoding).toLowerCase();
                      loweredCase = true;
                  }
                }
              };
              Buffer2.prototype.toJSON = function toJSON() {
                return {
                  type: "Buffer",
                  data: Array.prototype.slice.call(this._arr || this, 0)
                };
              };
              function base64Slice(buf, start, end) {
                if (start === 0 && end === buf.length) {
                  return base64.fromByteArray(buf);
                } else {
                  return base64.fromByteArray(buf.slice(start, end));
                }
              }
              function utf8Slice(buf, start, end) {
                end = Math.min(buf.length, end);
                var res = [];
                var i = start;
                while (i < end) {
                  var firstByte = buf[i];
                  var codePoint = null;
                  var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
                  if (i + bytesPerSequence <= end) {
                    var secondByte, thirdByte, fourthByte, tempCodePoint;
                    switch (bytesPerSequence) {
                      case 1:
                        if (firstByte < 128) {
                          codePoint = firstByte;
                        }
                        break;
                      case 2:
                        secondByte = buf[i + 1];
                        if ((secondByte & 192) === 128) {
                          tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                          if (tempCodePoint > 127) {
                            codePoint = tempCodePoint;
                          }
                        }
                        break;
                      case 3:
                        secondByte = buf[i + 1];
                        thirdByte = buf[i + 2];
                        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                          tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                          if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                            codePoint = tempCodePoint;
                          }
                        }
                        break;
                      case 4:
                        secondByte = buf[i + 1];
                        thirdByte = buf[i + 2];
                        fourthByte = buf[i + 3];
                        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                          tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                          if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                            codePoint = tempCodePoint;
                          }
                        }
                    }
                  }
                  if (codePoint === null) {
                    codePoint = 65533;
                    bytesPerSequence = 1;
                  } else if (codePoint > 65535) {
                    codePoint -= 65536;
                    res.push(codePoint >>> 10 & 1023 | 55296);
                    codePoint = 56320 | codePoint & 1023;
                  }
                  res.push(codePoint);
                  i += bytesPerSequence;
                }
                return decodeCodePointsArray(res);
              }
              var MAX_ARGUMENTS_LENGTH = 4096;
              function decodeCodePointsArray(codePoints) {
                var len = codePoints.length;
                if (len <= MAX_ARGUMENTS_LENGTH) {
                  return String.fromCharCode.apply(String, codePoints);
                }
                var res = "";
                var i = 0;
                while (i < len) {
                  res += String.fromCharCode.apply(
                    String,
                    codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
                  );
                }
                return res;
              }
              function asciiSlice(buf, start, end) {
                var ret = "";
                end = Math.min(buf.length, end);
                for (var i = start; i < end; ++i) {
                  ret += String.fromCharCode(buf[i] & 127);
                }
                return ret;
              }
              function latin1Slice(buf, start, end) {
                var ret = "";
                end = Math.min(buf.length, end);
                for (var i = start; i < end; ++i) {
                  ret += String.fromCharCode(buf[i]);
                }
                return ret;
              }
              function hexSlice(buf, start, end) {
                var len = buf.length;
                if (!start || start < 0) start = 0;
                if (!end || end < 0 || end > len) end = len;
                var out = "";
                for (var i = start; i < end; ++i) {
                  out += toHex(buf[i]);
                }
                return out;
              }
              function utf16leSlice(buf, start, end) {
                var bytes = buf.slice(start, end);
                var res = "";
                for (var i = 0; i < bytes.length; i += 2) {
                  res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
                }
                return res;
              }
              Buffer2.prototype.slice = function slice(start, end) {
                var len = this.length;
                start = ~~start;
                end = end === void 0 ? len : ~~end;
                if (start < 0) {
                  start += len;
                  if (start < 0) start = 0;
                } else if (start > len) {
                  start = len;
                }
                if (end < 0) {
                  end += len;
                  if (end < 0) end = 0;
                } else if (end > len) {
                  end = len;
                }
                if (end < start) end = start;
                var newBuf;
                if (Buffer2.TYPED_ARRAY_SUPPORT) {
                  newBuf = this.subarray(start, end);
                  newBuf.__proto__ = Buffer2.prototype;
                } else {
                  var sliceLen = end - start;
                  newBuf = new Buffer2(sliceLen, void 0);
                  for (var i = 0; i < sliceLen; ++i) {
                    newBuf[i] = this[i + start];
                  }
                }
                return newBuf;
              };
              function checkOffset(offset, ext, length) {
                if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
                if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
              }
              Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
                offset = offset | 0;
                byteLength2 = byteLength2 | 0;
                if (!noAssert) checkOffset(offset, byteLength2, this.length);
                var val = this[offset];
                var mul = 1;
                var i = 0;
                while (++i < byteLength2 && (mul *= 256)) {
                  val += this[offset + i] * mul;
                }
                return val;
              };
              Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
                offset = offset | 0;
                byteLength2 = byteLength2 | 0;
                if (!noAssert) {
                  checkOffset(offset, byteLength2, this.length);
                }
                var val = this[offset + --byteLength2];
                var mul = 1;
                while (byteLength2 > 0 && (mul *= 256)) {
                  val += this[offset + --byteLength2] * mul;
                }
                return val;
              };
              Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 1, this.length);
                return this[offset];
              };
              Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 2, this.length);
                return this[offset] | this[offset + 1] << 8;
              };
              Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 2, this.length);
                return this[offset] << 8 | this[offset + 1];
              };
              Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length);
                return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
              };
              Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length);
                return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
              };
              Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
                offset = offset | 0;
                byteLength2 = byteLength2 | 0;
                if (!noAssert) checkOffset(offset, byteLength2, this.length);
                var val = this[offset];
                var mul = 1;
                var i = 0;
                while (++i < byteLength2 && (mul *= 256)) {
                  val += this[offset + i] * mul;
                }
                mul *= 128;
                if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
                return val;
              };
              Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
                offset = offset | 0;
                byteLength2 = byteLength2 | 0;
                if (!noAssert) checkOffset(offset, byteLength2, this.length);
                var i = byteLength2;
                var mul = 1;
                var val = this[offset + --i];
                while (i > 0 && (mul *= 256)) {
                  val += this[offset + --i] * mul;
                }
                mul *= 128;
                if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
                return val;
              };
              Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 1, this.length);
                if (!(this[offset] & 128)) return this[offset];
                return (255 - this[offset] + 1) * -1;
              };
              Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 2, this.length);
                var val = this[offset] | this[offset + 1] << 8;
                return val & 32768 ? val | 4294901760 : val;
              };
              Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 2, this.length);
                var val = this[offset + 1] | this[offset] << 8;
                return val & 32768 ? val | 4294901760 : val;
              };
              Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length);
                return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
              };
              Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length);
                return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
              };
              Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length);
                return ieee754.read(this, offset, true, 23, 4);
              };
              Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 4, this.length);
                return ieee754.read(this, offset, false, 23, 4);
              };
              Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 8, this.length);
                return ieee754.read(this, offset, true, 52, 8);
              };
              Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
                if (!noAssert) checkOffset(offset, 8, this.length);
                return ieee754.read(this, offset, false, 52, 8);
              };
              function checkInt(buf, value, offset, ext, max, min) {
                if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
                if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
                if (offset + ext > buf.length) throw new RangeError("Index out of range");
              }
              Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
                value = +value;
                offset = offset | 0;
                byteLength2 = byteLength2 | 0;
                if (!noAssert) {
                  var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                  checkInt(this, value, offset, byteLength2, maxBytes, 0);
                }
                var mul = 1;
                var i = 0;
                this[offset] = value & 255;
                while (++i < byteLength2 && (mul *= 256)) {
                  this[offset + i] = value / mul & 255;
                }
                return offset + byteLength2;
              };
              Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
                value = +value;
                offset = offset | 0;
                byteLength2 = byteLength2 | 0;
                if (!noAssert) {
                  var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                  checkInt(this, value, offset, byteLength2, maxBytes, 0);
                }
                var i = byteLength2 - 1;
                var mul = 1;
                this[offset + i] = value & 255;
                while (--i >= 0 && (mul *= 256)) {
                  this[offset + i] = value / mul & 255;
                }
                return offset + byteLength2;
              };
              Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
                if (!Buffer2.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
                this[offset] = value & 255;
                return offset + 1;
              };
              function objectWriteUInt16(buf, value, offset, littleEndian) {
                if (value < 0) value = 65535 + value + 1;
                for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
                  buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
                }
              }
              Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
                if (Buffer2.TYPED_ARRAY_SUPPORT) {
                  this[offset] = value & 255;
                  this[offset + 1] = value >>> 8;
                } else {
                  objectWriteUInt16(this, value, offset, true);
                }
                return offset + 2;
              };
              Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
                if (Buffer2.TYPED_ARRAY_SUPPORT) {
                  this[offset] = value >>> 8;
                  this[offset + 1] = value & 255;
                } else {
                  objectWriteUInt16(this, value, offset, false);
                }
                return offset + 2;
              };
              function objectWriteUInt32(buf, value, offset, littleEndian) {
                if (value < 0) value = 4294967295 + value + 1;
                for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
                  buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
                }
              }
              Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
                if (Buffer2.TYPED_ARRAY_SUPPORT) {
                  this[offset + 3] = value >>> 24;
                  this[offset + 2] = value >>> 16;
                  this[offset + 1] = value >>> 8;
                  this[offset] = value & 255;
                } else {
                  objectWriteUInt32(this, value, offset, true);
                }
                return offset + 4;
              };
              Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
                if (Buffer2.TYPED_ARRAY_SUPPORT) {
                  this[offset] = value >>> 24;
                  this[offset + 1] = value >>> 16;
                  this[offset + 2] = value >>> 8;
                  this[offset + 3] = value & 255;
                } else {
                  objectWriteUInt32(this, value, offset, false);
                }
                return offset + 4;
              };
              Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert) {
                  var limit = Math.pow(2, 8 * byteLength2 - 1);
                  checkInt(this, value, offset, byteLength2, limit - 1, -limit);
                }
                var i = 0;
                var mul = 1;
                var sub = 0;
                this[offset] = value & 255;
                while (++i < byteLength2 && (mul *= 256)) {
                  if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                    sub = 1;
                  }
                  this[offset + i] = (value / mul >> 0) - sub & 255;
                }
                return offset + byteLength2;
              };
              Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert) {
                  var limit = Math.pow(2, 8 * byteLength2 - 1);
                  checkInt(this, value, offset, byteLength2, limit - 1, -limit);
                }
                var i = byteLength2 - 1;
                var mul = 1;
                var sub = 0;
                this[offset + i] = value & 255;
                while (--i >= 0 && (mul *= 256)) {
                  if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                    sub = 1;
                  }
                  this[offset + i] = (value / mul >> 0) - sub & 255;
                }
                return offset + byteLength2;
              };
              Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
                if (!Buffer2.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
                if (value < 0) value = 255 + value + 1;
                this[offset] = value & 255;
                return offset + 1;
              };
              Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
                if (Buffer2.TYPED_ARRAY_SUPPORT) {
                  this[offset] = value & 255;
                  this[offset + 1] = value >>> 8;
                } else {
                  objectWriteUInt16(this, value, offset, true);
                }
                return offset + 2;
              };
              Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
                if (Buffer2.TYPED_ARRAY_SUPPORT) {
                  this[offset] = value >>> 8;
                  this[offset + 1] = value & 255;
                } else {
                  objectWriteUInt16(this, value, offset, false);
                }
                return offset + 2;
              };
              Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
                if (Buffer2.TYPED_ARRAY_SUPPORT) {
                  this[offset] = value & 255;
                  this[offset + 1] = value >>> 8;
                  this[offset + 2] = value >>> 16;
                  this[offset + 3] = value >>> 24;
                } else {
                  objectWriteUInt32(this, value, offset, true);
                }
                return offset + 4;
              };
              Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
                if (value < 0) value = 4294967295 + value + 1;
                if (Buffer2.TYPED_ARRAY_SUPPORT) {
                  this[offset] = value >>> 24;
                  this[offset + 1] = value >>> 16;
                  this[offset + 2] = value >>> 8;
                  this[offset + 3] = value & 255;
                } else {
                  objectWriteUInt32(this, value, offset, false);
                }
                return offset + 4;
              };
              function checkIEEE754(buf, value, offset, ext, max, min) {
                if (offset + ext > buf.length) throw new RangeError("Index out of range");
                if (offset < 0) throw new RangeError("Index out of range");
              }
              function writeFloat(buf, value, offset, littleEndian, noAssert) {
                if (!noAssert) {
                  checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
                }
                ieee754.write(buf, value, offset, littleEndian, 23, 4);
                return offset + 4;
              }
              Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
                return writeFloat(this, value, offset, true, noAssert);
              };
              Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
                return writeFloat(this, value, offset, false, noAssert);
              };
              function writeDouble(buf, value, offset, littleEndian, noAssert) {
                if (!noAssert) {
                  checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
                }
                ieee754.write(buf, value, offset, littleEndian, 52, 8);
                return offset + 8;
              }
              Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
                return writeDouble(this, value, offset, true, noAssert);
              };
              Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
                return writeDouble(this, value, offset, false, noAssert);
              };
              Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
                if (!start) start = 0;
                if (!end && end !== 0) end = this.length;
                if (targetStart >= target.length) targetStart = target.length;
                if (!targetStart) targetStart = 0;
                if (end > 0 && end < start) end = start;
                if (end === start) return 0;
                if (target.length === 0 || this.length === 0) return 0;
                if (targetStart < 0) {
                  throw new RangeError("targetStart out of bounds");
                }
                if (start < 0 || start >= this.length) throw new RangeError("sourceStart out of bounds");
                if (end < 0) throw new RangeError("sourceEnd out of bounds");
                if (end > this.length) end = this.length;
                if (target.length - targetStart < end - start) {
                  end = target.length - targetStart + start;
                }
                var len = end - start;
                var i;
                if (this === target && start < targetStart && targetStart < end) {
                  for (i = len - 1; i >= 0; --i) {
                    target[i + targetStart] = this[i + start];
                  }
                } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
                  for (i = 0; i < len; ++i) {
                    target[i + targetStart] = this[i + start];
                  }
                } else {
                  Uint8Array.prototype.set.call(
                    target,
                    this.subarray(start, start + len),
                    targetStart
                  );
                }
                return len;
              };
              Buffer2.prototype.fill = function fill(val, start, end, encoding) {
                if (typeof val === "string") {
                  if (typeof start === "string") {
                    encoding = start;
                    start = 0;
                    end = this.length;
                  } else if (typeof end === "string") {
                    encoding = end;
                    end = this.length;
                  }
                  if (val.length === 1) {
                    var code = val.charCodeAt(0);
                    if (code < 256) {
                      val = code;
                    }
                  }
                  if (encoding !== void 0 && typeof encoding !== "string") {
                    throw new TypeError("encoding must be a string");
                  }
                  if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
                    throw new TypeError("Unknown encoding: " + encoding);
                  }
                } else if (typeof val === "number") {
                  val = val & 255;
                }
                if (start < 0 || this.length < start || this.length < end) {
                  throw new RangeError("Out of range index");
                }
                if (end <= start) {
                  return this;
                }
                start = start >>> 0;
                end = end === void 0 ? this.length : end >>> 0;
                if (!val) val = 0;
                var i;
                if (typeof val === "number") {
                  for (i = start; i < end; ++i) {
                    this[i] = val;
                  }
                } else {
                  var bytes = Buffer2.isBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
                  var len = bytes.length;
                  for (i = 0; i < end - start; ++i) {
                    this[i + start] = bytes[i % len];
                  }
                }
                return this;
              };
              var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
              function base64clean(str) {
                str = stringtrim(str).replace(INVALID_BASE64_RE, "");
                if (str.length < 2) return "";
                while (str.length % 4 !== 0) {
                  str = str + "=";
                }
                return str;
              }
              function stringtrim(str) {
                if (str.trim) return str.trim();
                return str.replace(/^\s+|\s+$/g, "");
              }
              function toHex(n) {
                if (n < 16) return "0" + n.toString(16);
                return n.toString(16);
              }
              function utf8ToBytes(string, units) {
                units = units || Infinity;
                var codePoint;
                var length = string.length;
                var leadSurrogate = null;
                var bytes = [];
                for (var i = 0; i < length; ++i) {
                  codePoint = string.charCodeAt(i);
                  if (codePoint > 55295 && codePoint < 57344) {
                    if (!leadSurrogate) {
                      if (codePoint > 56319) {
                        if ((units -= 3) > -1) bytes.push(239, 191, 189);
                        continue;
                      } else if (i + 1 === length) {
                        if ((units -= 3) > -1) bytes.push(239, 191, 189);
                        continue;
                      }
                      leadSurrogate = codePoint;
                      continue;
                    }
                    if (codePoint < 56320) {
                      if ((units -= 3) > -1) bytes.push(239, 191, 189);
                      leadSurrogate = codePoint;
                      continue;
                    }
                    codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
                  } else if (leadSurrogate) {
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                  }
                  leadSurrogate = null;
                  if (codePoint < 128) {
                    if ((units -= 1) < 0) break;
                    bytes.push(codePoint);
                  } else if (codePoint < 2048) {
                    if ((units -= 2) < 0) break;
                    bytes.push(
                      codePoint >> 6 | 192,
                      codePoint & 63 | 128
                    );
                  } else if (codePoint < 65536) {
                    if ((units -= 3) < 0) break;
                    bytes.push(
                      codePoint >> 12 | 224,
                      codePoint >> 6 & 63 | 128,
                      codePoint & 63 | 128
                    );
                  } else if (codePoint < 1114112) {
                    if ((units -= 4) < 0) break;
                    bytes.push(
                      codePoint >> 18 | 240,
                      codePoint >> 12 & 63 | 128,
                      codePoint >> 6 & 63 | 128,
                      codePoint & 63 | 128
                    );
                  } else {
                    throw new Error("Invalid code point");
                  }
                }
                return bytes;
              }
              function asciiToBytes(str) {
                var byteArray = [];
                for (var i = 0; i < str.length; ++i) {
                  byteArray.push(str.charCodeAt(i) & 255);
                }
                return byteArray;
              }
              function utf16leToBytes(str, units) {
                var c, hi, lo;
                var byteArray = [];
                for (var i = 0; i < str.length; ++i) {
                  if ((units -= 2) < 0) break;
                  c = str.charCodeAt(i);
                  hi = c >> 8;
                  lo = c % 256;
                  byteArray.push(lo);
                  byteArray.push(hi);
                }
                return byteArray;
              }
              function base64ToBytes(str) {
                return base64.toByteArray(base64clean(str));
              }
              function blitBuffer(src, dst, offset, length) {
                for (var i = 0; i < length; ++i) {
                  if (i + offset >= dst.length || i >= src.length) break;
                  dst[i + offset] = src[i];
                }
                return i;
              }
              function isnan(val) {
                return val !== val;
              }
            }).call(this, __webpack_require__2(17));
          },
          /* 10 */
          /***/
          function(module2, exports2) {
            module2.exports = function(useSourceMap) {
              var list = [];
              list.toString = function toString() {
                return this.map(function(item) {
                  var content = cssWithMappingToString(item, useSourceMap);
                  if (item[2]) {
                    return "@media " + item[2] + "{" + content + "}";
                  } else {
                    return content;
                  }
                }).join("");
              };
              list.i = function(modules, mediaQuery) {
                if (typeof modules === "string")
                  modules = [[null, modules, ""]];
                var alreadyImportedModules = {};
                for (var i = 0; i < this.length; i++) {
                  var id = this[i][0];
                  if (typeof id === "number")
                    alreadyImportedModules[id] = true;
                }
                for (i = 0; i < modules.length; i++) {
                  var item = modules[i];
                  if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
                    if (mediaQuery && !item[2]) {
                      item[2] = mediaQuery;
                    } else if (mediaQuery) {
                      item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
                    }
                    list.push(item);
                  }
                }
              };
              return list;
            };
            function cssWithMappingToString(item, useSourceMap) {
              var content = item[1] || "";
              var cssMapping = item[3];
              if (!cssMapping) {
                return content;
              }
              if (useSourceMap && typeof btoa === "function") {
                var sourceMapping = toComment(cssMapping);
                var sourceURLs = cssMapping.sources.map(function(source) {
                  return "/*# sourceURL=" + cssMapping.sourceRoot + source + " */";
                });
                return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
              }
              return [content].join("\n");
            }
            function toComment(sourceMap) {
              var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
              var data = "sourceMappingURL=data:application/json;charset=utf-8;base64," + base64;
              return "/*# " + data + " */";
            }
          },
          /* 11 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            var stylesInDom = {};
            var memoize = function(fn) {
              var memo;
              return function() {
                if (typeof memo === "undefined") memo = fn.apply(this, arguments);
                return memo;
              };
            };
            var isOldIE = memoize(function() {
              return window && document && document.all && !window.atob;
            });
            var getTarget = function(target, parent) {
              if (parent) {
                return parent.querySelector(target);
              }
              return document.querySelector(target);
            };
            var getElement = /* @__PURE__ */ function(fn) {
              var memo = {};
              return function(target, parent) {
                if (typeof target === "function") {
                  return target();
                }
                if (typeof memo[target] === "undefined") {
                  var styleTarget = getTarget.call(this, target, parent);
                  if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
                    try {
                      styleTarget = styleTarget.contentDocument.head;
                    } catch (e) {
                      styleTarget = null;
                    }
                  }
                  memo[target] = styleTarget;
                }
                return memo[target];
              };
            }();
            var singleton = null;
            var singletonCounter = 0;
            var stylesInsertedAtTop = [];
            var fixUrls = __webpack_require__2(70);
            module2.exports = function(list, options) {
              if (typeof DEBUG !== "undefined" && DEBUG) {
                if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
              }
              options = options || {};
              options.attrs = typeof options.attrs === "object" ? options.attrs : {};
              if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();
              if (!options.insertInto) options.insertInto = "head";
              if (!options.insertAt) options.insertAt = "bottom";
              var styles = listToStyles(list, options);
              addStylesToDom(styles, options);
              return function update(newList) {
                var mayRemove = [];
                for (var i = 0; i < styles.length; i++) {
                  var item = styles[i];
                  var domStyle = stylesInDom[item.id];
                  domStyle.refs--;
                  mayRemove.push(domStyle);
                }
                if (newList) {
                  var newStyles = listToStyles(newList, options);
                  addStylesToDom(newStyles, options);
                }
                for (var i = 0; i < mayRemove.length; i++) {
                  var domStyle = mayRemove[i];
                  if (domStyle.refs === 0) {
                    for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();
                    delete stylesInDom[domStyle.id];
                  }
                }
              };
            };
            function addStylesToDom(styles, options) {
              for (var i = 0; i < styles.length; i++) {
                var item = styles[i];
                var domStyle = stylesInDom[item.id];
                if (domStyle) {
                  domStyle.refs++;
                  for (var j = 0; j < domStyle.parts.length; j++) {
                    domStyle.parts[j](item.parts[j]);
                  }
                  for (; j < item.parts.length; j++) {
                    domStyle.parts.push(addStyle(item.parts[j], options));
                  }
                } else {
                  var parts = [];
                  for (var j = 0; j < item.parts.length; j++) {
                    parts.push(addStyle(item.parts[j], options));
                  }
                  stylesInDom[item.id] = { id: item.id, refs: 1, parts };
                }
              }
            }
            function listToStyles(list, options) {
              var styles = [];
              var newStyles = {};
              for (var i = 0; i < list.length; i++) {
                var item = list[i];
                var id = options.base ? item[0] + options.base : item[0];
                var css = item[1];
                var media = item[2];
                var sourceMap = item[3];
                var part = { css, media, sourceMap };
                if (!newStyles[id]) styles.push(newStyles[id] = { id, parts: [part] });
                else newStyles[id].parts.push(part);
              }
              return styles;
            }
            function insertStyleElement(options, style) {
              var target = getElement(options.insertInto);
              if (!target) {
                throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
              }
              var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];
              if (options.insertAt === "top") {
                if (!lastStyleElementInsertedAtTop) {
                  target.insertBefore(style, target.firstChild);
                } else if (lastStyleElementInsertedAtTop.nextSibling) {
                  target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
                } else {
                  target.appendChild(style);
                }
                stylesInsertedAtTop.push(style);
              } else if (options.insertAt === "bottom") {
                target.appendChild(style);
              } else if (typeof options.insertAt === "object" && options.insertAt.before) {
                var nextSibling = getElement(options.insertAt.before, target);
                target.insertBefore(style, nextSibling);
              } else {
                throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
              }
            }
            function removeStyleElement(style) {
              if (style.parentNode === null) return false;
              style.parentNode.removeChild(style);
              var idx = stylesInsertedAtTop.indexOf(style);
              if (idx >= 0) {
                stylesInsertedAtTop.splice(idx, 1);
              }
            }
            function createStyleElement(options) {
              var style = document.createElement("style");
              if (options.attrs.type === void 0) {
                options.attrs.type = "text/css";
              }
              if (options.attrs.nonce === void 0) {
                var nonce = getNonce();
                if (nonce) {
                  options.attrs.nonce = nonce;
                }
              }
              addAttrs(style, options.attrs);
              insertStyleElement(options, style);
              return style;
            }
            function createLinkElement(options) {
              var link = document.createElement("link");
              if (options.attrs.type === void 0) {
                options.attrs.type = "text/css";
              }
              options.attrs.rel = "stylesheet";
              addAttrs(link, options.attrs);
              insertStyleElement(options, link);
              return link;
            }
            function addAttrs(el, attrs) {
              Object.keys(attrs).forEach(function(key) {
                el.setAttribute(key, attrs[key]);
              });
            }
            function getNonce() {
              if (false) {
              }
              return __webpack_require__2.nc;
            }
            function addStyle(obj, options) {
              var style, update, remove, result;
              if (options.transform && obj.css) {
                result = typeof options.transform === "function" ? options.transform(obj.css) : options.transform.default(obj.css);
                if (result) {
                  obj.css = result;
                } else {
                  return function() {
                  };
                }
              }
              if (options.singleton) {
                var styleIndex = singletonCounter++;
                style = singleton || (singleton = createStyleElement(options));
                update = applyToSingletonTag.bind(null, style, styleIndex, false);
                remove = applyToSingletonTag.bind(null, style, styleIndex, true);
              } else if (obj.sourceMap && typeof URL === "function" && typeof URL.createObjectURL === "function" && typeof URL.revokeObjectURL === "function" && typeof Blob === "function" && typeof btoa === "function") {
                style = createLinkElement(options);
                update = updateLink.bind(null, style, options);
                remove = function() {
                  removeStyleElement(style);
                  if (style.href) URL.revokeObjectURL(style.href);
                };
              } else {
                style = createStyleElement(options);
                update = applyToTag.bind(null, style);
                remove = function() {
                  removeStyleElement(style);
                };
              }
              update(obj);
              return function updateStyle(newObj) {
                if (newObj) {
                  if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
                    return;
                  }
                  update(obj = newObj);
                } else {
                  remove();
                }
              };
            }
            var replaceText = /* @__PURE__ */ function() {
              var textStore = [];
              return function(index, replacement) {
                textStore[index] = replacement;
                return textStore.filter(Boolean).join("\n");
              };
            }();
            function applyToSingletonTag(style, index, remove, obj) {
              var css = remove ? "" : obj.css;
              if (style.styleSheet) {
                style.styleSheet.cssText = replaceText(index, css);
              } else {
                var cssNode = document.createTextNode(css);
                var childNodes = style.childNodes;
                if (childNodes[index]) style.removeChild(childNodes[index]);
                if (childNodes.length) {
                  style.insertBefore(cssNode, childNodes[index]);
                } else {
                  style.appendChild(cssNode);
                }
              }
            }
            function applyToTag(style, obj) {
              var css = obj.css;
              var media = obj.media;
              if (media) {
                style.setAttribute("media", media);
              }
              if (style.styleSheet) {
                style.styleSheet.cssText = css;
              } else {
                while (style.firstChild) {
                  style.removeChild(style.firstChild);
                }
                style.appendChild(document.createTextNode(css));
              }
            }
            function updateLink(link, options, obj) {
              var css = obj.css;
              var sourceMap = obj.sourceMap;
              var autoFixUrls = options.convertToAbsoluteUrls === void 0 && sourceMap;
              if (options.convertToAbsoluteUrls || autoFixUrls) {
                css = fixUrls(css);
              }
              if (sourceMap) {
                css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
              }
              var blob = new Blob([css], { type: "text/css" });
              var oldSrc = link.href;
              link.href = URL.createObjectURL(blob);
              if (oldSrc) URL.revokeObjectURL(oldSrc);
            }
          },
          /* 12 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__2) {
            "use strict";
            __webpack_require__2.r(__webpack_exports__);
            __webpack_require__2.d(__webpack_exports__, "__DO_NOT_USE__ActionTypes", function() {
              return ActionTypes;
            });
            __webpack_require__2.d(__webpack_exports__, "applyMiddleware", function() {
              return applyMiddleware;
            });
            __webpack_require__2.d(__webpack_exports__, "bindActionCreators", function() {
              return bindActionCreators;
            });
            __webpack_require__2.d(__webpack_exports__, "combineReducers", function() {
              return combineReducers;
            });
            __webpack_require__2.d(__webpack_exports__, "compose", function() {
              return compose;
            });
            __webpack_require__2.d(__webpack_exports__, "createStore", function() {
              return createStore;
            });
            var symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(28);
            var randomString = function randomString2() {
              return Math.random().toString(36).substring(7).split("").join(".");
            };
            var ActionTypes = {
              INIT: "@@redux/INIT" + randomString(),
              REPLACE: "@@redux/REPLACE" + randomString(),
              PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
                return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
              }
            };
            function isPlainObject(obj) {
              if (typeof obj !== "object" || obj === null) return false;
              var proto = obj;
              while (Object.getPrototypeOf(proto) !== null) {
                proto = Object.getPrototypeOf(proto);
              }
              return Object.getPrototypeOf(obj) === proto;
            }
            function createStore(reducer, preloadedState, enhancer) {
              var _ref2;
              if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
                throw new Error("It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function.");
              }
              if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
                enhancer = preloadedState;
                preloadedState = void 0;
              }
              if (typeof enhancer !== "undefined") {
                if (typeof enhancer !== "function") {
                  throw new Error("Expected the enhancer to be a function.");
                }
                return enhancer(createStore)(reducer, preloadedState);
              }
              if (typeof reducer !== "function") {
                throw new Error("Expected the reducer to be a function.");
              }
              var currentReducer = reducer;
              var currentState = preloadedState;
              var currentListeners = [];
              var nextListeners = currentListeners;
              var isDispatching = false;
              function ensureCanMutateNextListeners() {
                if (nextListeners === currentListeners) {
                  nextListeners = currentListeners.slice();
                }
              }
              function getState() {
                if (isDispatching) {
                  throw new Error("You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
                }
                return currentState;
              }
              function subscribe(listener) {
                if (typeof listener !== "function") {
                  throw new Error("Expected the listener to be a function.");
                }
                if (isDispatching) {
                  throw new Error("You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api-reference/store#subscribelistener for more details.");
                }
                var isSubscribed = true;
                ensureCanMutateNextListeners();
                nextListeners.push(listener);
                return function unsubscribe() {
                  if (!isSubscribed) {
                    return;
                  }
                  if (isDispatching) {
                    throw new Error("You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api-reference/store#subscribelistener for more details.");
                  }
                  isSubscribed = false;
                  ensureCanMutateNextListeners();
                  var index = nextListeners.indexOf(listener);
                  nextListeners.splice(index, 1);
                  currentListeners = null;
                };
              }
              function dispatch(action) {
                if (!isPlainObject(action)) {
                  throw new Error("Actions must be plain objects. Use custom middleware for async actions.");
                }
                if (typeof action.type === "undefined") {
                  throw new Error('Actions may not have an undefined "type" property. Have you misspelled a constant?');
                }
                if (isDispatching) {
                  throw new Error("Reducers may not dispatch actions.");
                }
                try {
                  isDispatching = true;
                  currentState = currentReducer(currentState, action);
                } finally {
                  isDispatching = false;
                }
                var listeners = currentListeners = nextListeners;
                for (var i = 0; i < listeners.length; i++) {
                  var listener = listeners[i];
                  listener();
                }
                return action;
              }
              function replaceReducer(nextReducer) {
                if (typeof nextReducer !== "function") {
                  throw new Error("Expected the nextReducer to be a function.");
                }
                currentReducer = nextReducer;
                dispatch({
                  type: ActionTypes.REPLACE
                });
              }
              function observable() {
                var _ref;
                var outerSubscribe = subscribe;
                return _ref = {
                  /**
                   * The minimal observable subscription method.
                   * @param {Object} observer Any object that can be used as an observer.
                   * The observer object should have a `next` method.
                   * @returns {subscription} An object with an `unsubscribe` method that can
                   * be used to unsubscribe the observable from the store, and prevent further
                   * emission of values from the observable.
                   */
                  subscribe: function subscribe2(observer) {
                    if (typeof observer !== "object" || observer === null) {
                      throw new TypeError("Expected the observer to be an object.");
                    }
                    function observeState() {
                      if (observer.next) {
                        observer.next(getState());
                      }
                    }
                    observeState();
                    var unsubscribe = outerSubscribe(observeState);
                    return {
                      unsubscribe
                    };
                  }
                }, _ref[symbol_observable__WEBPACK_IMPORTED_MODULE_0__[
                  /* default */
                  "a"
                ]] = function() {
                  return this;
                }, _ref;
              }
              dispatch({
                type: ActionTypes.INIT
              });
              return _ref2 = {
                dispatch,
                subscribe,
                getState,
                replaceReducer
              }, _ref2[symbol_observable__WEBPACK_IMPORTED_MODULE_0__[
                /* default */
                "a"
              ]] = observable, _ref2;
            }
            function warning(message) {
              if (typeof console !== "undefined" && typeof console.error === "function") {
                console.error(message);
              }
              try {
                throw new Error(message);
              } catch (e) {
              }
            }
            function getUndefinedStateErrorMessage(key, action) {
              var actionType = action && action.type;
              var actionDescription = actionType && 'action "' + String(actionType) + '"' || "an action";
              return "Given " + actionDescription + ', reducer "' + key + '" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.';
            }
            function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
              var reducerKeys = Object.keys(reducers);
              var argumentName = action && action.type === ActionTypes.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
              if (reducerKeys.length === 0) {
                return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
              }
              if (!isPlainObject(inputState)) {
                return "The " + argumentName + ' has unexpected type of "' + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
              }
              var unexpectedKeys = Object.keys(inputState).filter(function(key) {
                return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
              });
              unexpectedKeys.forEach(function(key) {
                unexpectedKeyCache[key] = true;
              });
              if (action && action.type === ActionTypes.REPLACE) return;
              if (unexpectedKeys.length > 0) {
                return "Unexpected " + (unexpectedKeys.length > 1 ? "keys" : "key") + " " + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
              }
            }
            function assertReducerShape(reducers) {
              Object.keys(reducers).forEach(function(key) {
                var reducer = reducers[key];
                var initialState = reducer(void 0, {
                  type: ActionTypes.INIT
                });
                if (typeof initialState === "undefined") {
                  throw new Error('Reducer "' + key + `" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);
                }
                if (typeof reducer(void 0, {
                  type: ActionTypes.PROBE_UNKNOWN_ACTION()
                }) === "undefined") {
                  throw new Error('Reducer "' + key + '" returned undefined when probed with a random type. ' + ("Don't try to handle " + ActionTypes.INIT + ' or other actions in "redux/*" ') + "namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.");
                }
              });
            }
            function combineReducers(reducers) {
              var reducerKeys = Object.keys(reducers);
              var finalReducers = {};
              for (var i = 0; i < reducerKeys.length; i++) {
                var key = reducerKeys[i];
                if (false) {
                }
                if (typeof reducers[key] === "function") {
                  finalReducers[key] = reducers[key];
                }
              }
              var finalReducerKeys = Object.keys(finalReducers);
              var unexpectedKeyCache;
              if (false) {
              }
              var shapeAssertionError;
              try {
                assertReducerShape(finalReducers);
              } catch (e) {
                shapeAssertionError = e;
              }
              return function combination(state, action) {
                if (state === void 0) {
                  state = {};
                }
                if (shapeAssertionError) {
                  throw shapeAssertionError;
                }
                if (false) {
                  var warningMessage;
                }
                var hasChanged = false;
                var nextState = {};
                for (var _i = 0; _i < finalReducerKeys.length; _i++) {
                  var _key = finalReducerKeys[_i];
                  var reducer = finalReducers[_key];
                  var previousStateForKey = state[_key];
                  var nextStateForKey = reducer(previousStateForKey, action);
                  if (typeof nextStateForKey === "undefined") {
                    var errorMessage = getUndefinedStateErrorMessage(_key, action);
                    throw new Error(errorMessage);
                  }
                  nextState[_key] = nextStateForKey;
                  hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
                }
                hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
                return hasChanged ? nextState : state;
              };
            }
            function bindActionCreator(actionCreator, dispatch) {
              return function() {
                return dispatch(actionCreator.apply(this, arguments));
              };
            }
            function bindActionCreators(actionCreators, dispatch) {
              if (typeof actionCreators === "function") {
                return bindActionCreator(actionCreators, dispatch);
              }
              if (typeof actionCreators !== "object" || actionCreators === null) {
                throw new Error("bindActionCreators expected an object or a function, instead received " + (actionCreators === null ? "null" : typeof actionCreators) + '. Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?');
              }
              var boundActionCreators = {};
              for (var key in actionCreators) {
                var actionCreator = actionCreators[key];
                if (typeof actionCreator === "function") {
                  boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
                }
              }
              return boundActionCreators;
            }
            function _defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, {
                  value,
                  enumerable: true,
                  configurable: true,
                  writable: true
                });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                keys.push.apply(keys, Object.getOwnPropertySymbols(object));
              }
              if (enumerableOnly) keys = keys.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
              return keys;
            }
            function _objectSpread2(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  ownKeys(source, true).forEach(function(key) {
                    _defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  ownKeys(source).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function compose() {
              for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
                funcs[_key] = arguments[_key];
              }
              if (funcs.length === 0) {
                return function(arg) {
                  return arg;
                };
              }
              if (funcs.length === 1) {
                return funcs[0];
              }
              return funcs.reduce(function(a, b) {
                return function() {
                  return a(b.apply(void 0, arguments));
                };
              });
            }
            function applyMiddleware() {
              for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
                middlewares[_key] = arguments[_key];
              }
              return function(createStore2) {
                return function() {
                  var store = createStore2.apply(void 0, arguments);
                  var _dispatch = function dispatch() {
                    throw new Error("Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
                  };
                  var middlewareAPI = {
                    getState: store.getState,
                    dispatch: function dispatch() {
                      return _dispatch.apply(void 0, arguments);
                    }
                  };
                  var chain = middlewares.map(function(middleware) {
                    return middleware(middlewareAPI);
                  });
                  _dispatch = compose.apply(void 0, chain)(store.dispatch);
                  return _objectSpread2({}, store, {
                    dispatch: _dispatch
                  });
                };
              };
            }
            function isCrushed() {
            }
            if (false) {
            }
          },
          /* 13 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var key = {
              fullscreenEnabled: 0,
              fullscreenElement: 1,
              requestFullscreen: 2,
              exitFullscreen: 3,
              fullscreenchange: 4,
              fullscreenerror: 5
            };
            var webkit = ["webkitFullscreenEnabled", "webkitFullscreenElement", "webkitRequestFullscreen", "webkitExitFullscreen", "webkitfullscreenchange", "webkitfullscreenerror"];
            var moz = ["mozFullScreenEnabled", "mozFullScreenElement", "mozRequestFullScreen", "mozCancelFullScreen", "mozfullscreenchange", "mozfullscreenerror"];
            var ms = ["msFullscreenEnabled", "msFullscreenElement", "msRequestFullscreen", "msExitFullscreen", "MSFullscreenChange", "MSFullscreenError"];
            var document2 = typeof window !== "undefined" && typeof window.document !== "undefined" ? window.document : {};
            var vendor = "fullscreenEnabled" in document2 && Object.keys(key) || webkit[0] in document2 && webkit || moz[0] in document2 && moz || ms[0] in document2 && ms || [];
            exports2.default = {
              requestFullscreen: function requestFullscreen(element) {
                return element[vendor[key.requestFullscreen]]();
              },
              requestFullscreenFunction: function requestFullscreenFunction(element) {
                return element[vendor[key.requestFullscreen]];
              },
              get exitFullscreen() {
                return document2[vendor[key.exitFullscreen]].bind(document2);
              },
              addEventListener: function addEventListener(type, handler, options) {
                return document2.addEventListener(vendor[key[type]], handler, options);
              },
              removeEventListener: function removeEventListener(type, handler, options) {
                return document2.removeEventListener(vendor[key[type]], handler, options);
              },
              get fullscreenEnabled() {
                return Boolean(document2[vendor[key.fullscreenEnabled]]);
              },
              set fullscreenEnabled(val) {
              },
              get fullscreenElement() {
                return document2[vendor[key.fullscreenElement]];
              },
              set fullscreenElement(val) {
              },
              get onfullscreenchange() {
                return document2[("on" + vendor[key.fullscreenchange]).toLowerCase()];
              },
              set onfullscreenchange(handler) {
                return document2[("on" + vendor[key.fullscreenchange]).toLowerCase()] = handler;
              },
              get onfullscreenerror() {
                return document2[("on" + vendor[key.fullscreenerror]).toLowerCase()];
              },
              set onfullscreenerror(handler) {
                return document2[("on" + vendor[key.fullscreenerror]).toLowerCase()] = handler;
              }
            };
          },
          /* 14 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const assert = __webpack_require__2(18);
            const Windows1292Decoder_1 = __webpack_require__2(137);
            class Util {
              /**
               *
               * @param buffer
               * @param start
               * @param end
               * @param encoding // ToDo: ts.enum
               * @return {number}
               */
              static findZero(buffer, start, end, encoding) {
                let i = start;
                if (encoding === "utf16") {
                  while (buffer[i] !== 0 || buffer[i + 1] !== 0) {
                    if (i >= end)
                      return end;
                    i += 2;
                  }
                  return i;
                } else {
                  while (buffer[i] !== 0) {
                    if (i >= end)
                      return end;
                    i++;
                  }
                  return i;
                }
              }
              static trimRightNull(x) {
                const pos0 = x.indexOf("\0");
                return pos0 === -1 ? x : x.substr(0, pos0);
              }
              static swapBytes(buffer) {
                const l = buffer.length;
                assert.ok((l & 1) === 0, "Buffer length must be even");
                for (let i = 0; i < l; i += 2) {
                  const a = buffer[i];
                  buffer[i] = buffer[i + 1];
                  buffer[i + 1] = a;
                }
                return buffer;
              }
              static readUTF16String(buffer) {
                let offset = 0;
                if (buffer[0] === 254 && buffer[1] === 255) {
                  buffer = Util.swapBytes(buffer);
                  offset = 2;
                } else if (buffer[0] === 255 && buffer[1] === 254) {
                  offset = 2;
                }
                return buffer.toString("ucs2", offset);
              }
              /**
               *
               * @param buffer Decoder input data
               * @param encoding 'utf16le' | 'utf16' | 'utf8' | 'iso-8859-1'
               * @return {string}
               */
              static decodeString(buffer, encoding) {
                if (buffer[0] === 255 && buffer[1] === 254 && buffer[2] === 254 && buffer[3] === 255) {
                  buffer = buffer.slice(2);
                }
                if (encoding === "utf16le" || encoding === "utf16") {
                  return Util.readUTF16String(buffer);
                } else if (encoding === "utf8") {
                  return buffer.toString("utf8");
                } else if (encoding === "iso-8859-1") {
                  return Windows1292Decoder_1.Windows1292Decoder.decode(buffer);
                }
                throw Error(encoding + " encoding is not supported!");
              }
              static stripNulls(str) {
                str = str.replace(/^\x00+/g, "");
                str = str.replace(/\x00+$/g, "");
                return str;
              }
              /**
               * Read bit-aligned number start from buffer
               * Total offset in bits = byteOffset * 8 + bitOffset
               * @param buf Byte buffer
               * @param byteOffset Starting offset in bytes
               * @param bitOffset Starting offset in bits: 0 = lsb
               * @param len Length of number in bits
               * @return {number} decoded bit aligned number
               */
              static getBitAllignedNumber(buf, byteOffset, bitOffset, len) {
                const byteOff = byteOffset + ~~(bitOffset / 8);
                const bitOff = bitOffset % 8;
                let value = buf[byteOff];
                value &= 255 >> bitOff;
                const bitsRead = 8 - bitOff;
                const bitsLeft = len - bitsRead;
                if (bitsLeft < 0) {
                  value >>= 8 - bitOff - len;
                } else if (bitsLeft > 0) {
                  value <<= bitsLeft;
                  value |= Util.getBitAllignedNumber(buf, byteOffset, bitOffset + bitsRead, bitsLeft);
                }
                return value;
              }
              /**
               * Read bit-aligned number start from buffer
               * Total offset in bits = byteOffset * 8 + bitOffset
               * @param buf Byte buffer
               * @param byteOffset Starting offset in bytes
               * @param bitOffset Starting offset in bits: 0 = most significant bit, 7 is least significant bit
               * @return {number} decoded bit aligned number
               */
              static isBitSet(buf, byteOffset, bitOffset) {
                return Util.getBitAllignedNumber(buf, byteOffset, bitOffset, 1) === 1;
              }
              static a2hex(str) {
                const arr = [];
                for (let i = 0, l = str.length; i < l; i++) {
                  const hex = Number(str.charCodeAt(i)).toString(16);
                  arr.push(hex.length === 1 ? "0" + hex : hex);
                }
                return arr.join(" ");
              }
            }
            Util.strtokBITSET = {
              get: (buf, off, bit) => {
                return (buf[off] & 1 << bit) !== 0;
              },
              len: 1
            };
            exports2.default = Util;
          },
          /* 15 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            (function(Buffer2) {
              Object.defineProperty(exports2, "__esModule", { value: true });
              const Util_1 = __webpack_require__2(14);
              const validFourCC = /^[\w-©][\w-\x000-3]/;
              exports2.FourCcToken = {
                len: 4,
                get: (buf, off) => {
                  const id = buf.toString("binary", off, off + exports2.FourCcToken.len);
                  if (!id.match(validFourCC)) {
                    throw new Error(`FourCC contains invalid characters: ${Util_1.default.a2hex(id)}`);
                  }
                  return id;
                },
                put: (buffer, offset, id) => {
                  const str = Buffer2.from(id, "binary");
                  if (str.length !== 4)
                    throw new Error("Invalid length");
                  return str.copy(buffer, offset);
                }
              };
            }).call(this, __webpack_require__2(9).Buffer);
          },
          /* 16 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__2) {
            "use strict";
            __webpack_require__2.r(__webpack_exports__);
            __webpack_require__2.d(__webpack_exports__, "unpackString", function() {
              return (
                /* binding */
                unpackString
              );
            });
            __webpack_require__2.d(__webpack_exports__, "packString", function() {
              return (
                /* binding */
                packString
              );
            });
            __webpack_require__2.d(__webpack_exports__, "packStringTo", function() {
              return (
                /* binding */
                packStringTo
              );
            });
            __webpack_require__2.d(__webpack_exports__, "packArrayTo", function() {
              return (
                /* binding */
                packArrayTo
              );
            });
            __webpack_require__2.d(__webpack_exports__, "unpackArrayTo", function() {
              return (
                /* binding */
                unpackArrayTo
              );
            });
            __webpack_require__2.d(__webpack_exports__, "packTo", function() {
              return (
                /* binding */
                packTo
              );
            });
            __webpack_require__2.d(__webpack_exports__, "pack", function() {
              return (
                /* binding */
                byte_data_pack
              );
            });
            __webpack_require__2.d(__webpack_exports__, "packArray", function() {
              return (
                /* binding */
                packArray
              );
            });
            __webpack_require__2.d(__webpack_exports__, "unpackArray", function() {
              return (
                /* binding */
                unpackArray
              );
            });
            __webpack_require__2.d(__webpack_exports__, "unpack", function() {
              return (
                /* binding */
                byte_data_unpack
              );
            });
            function endianness(bytes, offset, start = 0, end = bytes.length) {
              if (end % offset) {
                throw new Error("Bad buffer length.");
              }
              for (let index = start; index < end; index += offset) {
                swap(bytes, offset, index);
              }
            }
            function swap(bytes, offset, index) {
              offset--;
              for (let x = 0; x < offset; x++) {
                let theByte = bytes[index + x];
                bytes[index + x] = bytes[index + offset];
                bytes[index + offset] = theByte;
                offset--;
              }
            }
            function unpack(buffer, start = 0, end = buffer.length) {
              let str = "";
              for (let index = start; index < end; ) {
                let lowerBoundary = 128;
                let upperBoundary = 191;
                let replace = false;
                let charCode = buffer[index++];
                if (charCode >= 0 && charCode <= 127) {
                  str += String.fromCharCode(charCode);
                } else {
                  let count = 0;
                  if (charCode >= 194 && charCode <= 223) {
                    count = 1;
                  } else if (charCode >= 224 && charCode <= 239) {
                    count = 2;
                    if (buffer[index] === 224) {
                      lowerBoundary = 160;
                    }
                    if (buffer[index] === 237) {
                      upperBoundary = 159;
                    }
                  } else if (charCode >= 240 && charCode <= 244) {
                    count = 3;
                    if (buffer[index] === 240) {
                      lowerBoundary = 144;
                    }
                    if (buffer[index] === 244) {
                      upperBoundary = 143;
                    }
                  } else {
                    replace = true;
                  }
                  charCode = charCode & (1 << 8 - count - 1) - 1;
                  for (let i = 0; i < count; i++) {
                    if (buffer[index] < lowerBoundary || buffer[index] > upperBoundary) {
                      replace = true;
                    }
                    charCode = charCode << 6 | buffer[index] & 63;
                    index++;
                  }
                  if (replace) {
                    str += String.fromCharCode(65533);
                  } else if (charCode <= 65535) {
                    str += String.fromCharCode(charCode);
                  } else {
                    charCode -= 65536;
                    str += String.fromCharCode(
                      (charCode >> 10 & 1023) + 55296,
                      (charCode & 1023) + 56320
                    );
                  }
                }
              }
              return str;
            }
            function pack(str, buffer, index = 0) {
              for (let i = 0, len = str.length; i < len; i++) {
                let codePoint = str.codePointAt(i);
                if (codePoint < 128) {
                  buffer[index] = codePoint;
                  index++;
                } else {
                  let count = 0;
                  let offset = 0;
                  if (codePoint <= 2047) {
                    count = 1;
                    offset = 192;
                  } else if (codePoint <= 65535) {
                    count = 2;
                    offset = 224;
                  } else if (codePoint <= 1114111) {
                    count = 3;
                    offset = 240;
                    i++;
                  }
                  buffer[index] = (codePoint >> 6 * count) + offset;
                  index++;
                  while (count > 0) {
                    buffer[index] = 128 | codePoint >> 6 * (count - 1) & 63;
                    index++;
                    count--;
                  }
                }
              }
              return index;
            }
            class IntParser {
              /**
               * @param {number} bits The number of bits used by the integer.
               * @param {boolean} [signed=false] True for signed, false otherwise.
               * @param {boolean} [clamp=false] True to clamp on overflow.
               */
              constructor(bits, signed = false, clamp = false) {
                this.bits = bits;
                this.bytes = bits < 8 ? 1 : Math.ceil(bits / 8);
                this.max = Math.pow(2, bits) - 1;
                this.min = 0;
                let r = 8 - ((bits - 1 | 7) + 1 - bits);
                this.lastByteMask_ = Math.pow(2, r > 0 ? r : 8) - 1;
                this.unpack = this.unpackUnsigned_;
                if (signed) {
                  this.max = Math.pow(2, bits) / 2 - 1;
                  this.min = -this.max - 1;
                  this.unpack = this.unpackSigned_;
                }
                if (clamp) {
                  this.overflow_ = this.overflowClamp_;
                }
              }
              /**
               * Write one unsigned integer to a byte buffer.
               * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.
               * @param {number} num The number. Overflows are truncated.
               * @param {number} [index=0] The index being written in the byte buffer.
               * @return {number} The next index to write on the byte buffer.
               */
              pack(buffer, num, index = 0) {
                if (num !== num || num.constructor != Number) {
                  throw new TypeError();
                }
                num = this.overflow_(num);
                buffer[index] = (num < 0 ? num + Math.pow(2, this.bits) : num) & 255;
                index++;
                for (let i = 2, len = this.bytes; i < len; i++) {
                  buffer[index] = Math.floor(num / Math.pow(2, (i - 1) * 8)) & 255;
                  index++;
                }
                if (this.bits > 8) {
                  buffer[index] = Math.floor(
                    num / Math.pow(2, (this.bytes - 1) * 8)
                  ) & this.lastByteMask_;
                  index++;
                }
                return index;
              }
              /**
               * Read one unsigned integer from a byte buffer.
               * Does not check for overflows.
               * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.
               * @param {number} [index=0] The index to read.
               * @return {number}
               */
              unpack_(buffer, index = 0) {
                let num = 0;
                for (let x = 0; x < this.bytes; x++) {
                  num += buffer[index + x] * Math.pow(256, x);
                }
                return num;
              }
              unpackUnsigned_(buffer, index = 0) {
                return this.overflow_(this.unpack_(buffer, index));
              }
              /**
               * Read one two's complement signed integer from a byte buffer.
               * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.
               * @param {number} [index=0] The index to read.
               * @return {number}
               */
              unpackSigned_(buffer, index = 0) {
                return this.overflow_(this.sign_(this.unpack_(buffer, index)));
              }
              /**
               * Truncate values in case of overflow.
               * @param {number} num The number.
               * @private
               */
              overflow_(num) {
                if (num > this.max || num < this.min) {
                  throw new RangeError();
                }
                return num;
              }
              /**
               * Truncate values in case of overflow.
               * @param {number} num The number.
               * @private
               */
              overflowClamp_(num) {
                if (num > this.max) {
                  return this.max;
                } else if (num < this.min) {
                  return this.min;
                }
                return num;
              }
              /**
               * Sign a number.
               * @param {number} num The number.
               * @return {number}
               * @private
               */
              sign_(num) {
                if (num > this.max) {
                  num -= this.max * 2 + 2;
                }
                return num;
              }
            }
            class IEEE754Buffer {
              /**
               * Pack a IEEE 754 floating point number.
               * @param {number} ebits The exponent bits.
               * @param {number} fbits The fraction bits.
               */
              constructor(ebits, fbits) {
                this.ebits = ebits;
                this.fbits = fbits;
                this.bias = (1 << ebits - 1) - 1;
                this.numBytes = Math.ceil((ebits + fbits) / 8);
                this.biasP2 = Math.pow(2, this.bias + 1);
                this.ebitsFbits = ebits + fbits;
                this.fbias = Math.pow(2, -(8 * this.numBytes - 1 - ebits));
              }
              /**
               * Pack a IEEE 754 floating point number.
               * @param {!Uint8Array|!Array<number>} buffer The buffer.
               * @param {number} num The number.
               * @param {number} index The index to write on the buffer.
               * @return {number} The next index to write on the buffer.
               * @throws {TypeError} If input is not a number.
               */
              pack(buffer, num, index) {
                if (typeof num != "number") {
                  throw new TypeError();
                }
                if (Math.abs(num) > this.biasP2 - this.ebitsFbits * 2) {
                  num = num < 0 ? -Infinity : Infinity;
                }
                let sign = ((num = +num) || 1 / num) < 0 ? 1 : num < 0 ? 1 : 0;
                num = Math.abs(num);
                let exp = Math.min(Math.floor(Math.log(num) / Math.LN2), 1023);
                let fraction = roundToEven(num / Math.pow(2, exp) * Math.pow(2, this.fbits));
                if (num !== num) {
                  fraction = Math.pow(2, this.fbits - 1);
                  exp = (1 << this.ebits) - 1;
                } else if (num !== 0) {
                  if (num >= Math.pow(2, 1 - this.bias)) {
                    if (fraction / Math.pow(2, this.fbits) >= 2) {
                      exp = exp + 1;
                      fraction = 1;
                    }
                    if (exp > this.bias) {
                      exp = (1 << this.ebits) - 1;
                      fraction = 0;
                    } else {
                      exp = exp + this.bias;
                      fraction = roundToEven(fraction) - Math.pow(2, this.fbits);
                    }
                  } else {
                    fraction = roundToEven(num / Math.pow(2, 1 - this.bias - this.fbits));
                    exp = 0;
                  }
                }
                return this.packFloatBits_(buffer, index, sign, exp, fraction);
              }
              /**
               * Unpack a IEEE 754 floating point number.
               * Derived from IEEE754 by DeNA Co., Ltd., MIT License. 
               * Adapted to handle NaN. Should port the solution to the original repo.
               * @param {!Uint8Array|!Array<number>} buffer The buffer.
               * @param {number} index The index to read from the buffer.
               * @return {number} The floating point number.
               */
              unpack(buffer, index) {
                let eMax = (1 << this.ebits) - 1;
                let significand;
                let leftBits = "";
                for (let i = this.numBytes - 1; i >= 0; i--) {
                  let t = buffer[i + index].toString(2);
                  leftBits += "00000000".substring(t.length) + t;
                }
                let sign = leftBits.charAt(0) == "1" ? -1 : 1;
                leftBits = leftBits.substring(1);
                let exponent = parseInt(leftBits.substring(0, this.ebits), 2);
                leftBits = leftBits.substring(this.ebits);
                if (exponent == eMax) {
                  if (parseInt(leftBits, 2) !== 0) {
                    return NaN;
                  }
                  return sign * Infinity;
                } else if (exponent === 0) {
                  exponent += 1;
                  significand = parseInt(leftBits, 2);
                } else {
                  significand = parseInt("1" + leftBits, 2);
                }
                return sign * significand * this.fbias * Math.pow(2, exponent - this.bias);
              }
              /**
               * Pack a IEEE754 from its sign, exponent and fraction bits
               * and place it in a byte buffer.
               * @param {!Uint8Array|!Array<number>} buffer The byte buffer to write to.
               * @param {number} index The buffer index to write.
               * @param {number} sign The sign.
               * @param {number} exp the exponent.
               * @param {number} fraction The fraction.
               * @return {number}
               * @private
               */
              packFloatBits_(buffer, index, sign, exp, fraction) {
                let bits = [];
                bits.push(sign);
                for (let i = this.ebits; i > 0; i -= 1) {
                  bits[i] = exp % 2 ? 1 : 0;
                  exp = Math.floor(exp / 2);
                }
                let len = bits.length;
                for (let i = this.fbits; i > 0; i -= 1) {
                  bits[len + i] = fraction % 2 ? 1 : 0;
                  fraction = Math.floor(fraction / 2);
                }
                let str = bits.join("");
                let numBytes = this.numBytes + index - 1;
                let k = index;
                while (numBytes >= index) {
                  buffer[numBytes] = parseInt(str.substring(0, 8), 2);
                  str = str.substring(8);
                  numBytes--;
                  k++;
                }
                return k;
              }
            }
            function roundToEven(n) {
              let w = Math.floor(n);
              let f = n - w;
              if (f < 0.5) {
                return w;
              }
              if (f > 0.5) {
                return w + 1;
              }
              return w % 2 ? w + 1 : w;
            }
            function unpackString(buffer, index = 0, end = buffer.length) {
              return unpack(buffer, index, end);
            }
            function packString(str) {
              let buffer = [];
              pack(str, buffer, 0);
              return buffer;
            }
            function packStringTo(str, buffer, index = 0) {
              return pack(str, buffer, index);
            }
            function packArrayTo(values, theType, buffer, index = 0, clamp = false) {
              theType = theType || {};
              let packer = getParser_(theType.bits, theType.fp, theType.signed, clamp);
              let offset = Math.ceil(theType.bits / 8);
              let i = 0;
              let start = index;
              try {
                for (let valuesLen = values.length; i < valuesLen; i++) {
                  index = packer.pack(buffer, values[i], index);
                }
                if (theType.be) {
                  endianness(buffer, offset, start, index);
                }
              } catch (e) {
                throwValueError_(e, values[i], i);
              }
              return index;
            }
            function unpackArrayTo(buffer, theType, output, start = 0, end = buffer.length, safe = false, clamp = false) {
              theType = theType || {};
              let packer = getParser_(theType.bits, theType.fp, theType.signed, clamp);
              let offset = Math.ceil(theType.bits / 8);
              end = getUnpackLen_(buffer, start, end, offset, safe);
              let index = 0;
              let j = start;
              try {
                if (theType.be) {
                  endianness(buffer, offset, start, end);
                }
                for (; j < end; j += offset, index++) {
                  output[index] = packer.unpack(buffer, j);
                }
                if (theType.be) {
                  endianness(buffer, offset, start, end);
                }
              } catch (e) {
                throwValueError_(e, buffer.slice(j, j + offset), j);
              }
            }
            function packTo(value, theType, buffer, index = 0, clamp = false) {
              return packArrayTo([value], theType, buffer, index, clamp);
            }
            function byte_data_pack(value, theType, clamp = false) {
              let output = [];
              packTo(value, theType, output, 0, clamp);
              return output;
            }
            function packArray(values, theType, clamp = false) {
              let output = [];
              packArrayTo(values, theType, output, 0, clamp);
              return output;
            }
            function unpackArray(buffer, theType, start = 0, end = buffer.length, safe = false, clamp = false) {
              let output = [];
              unpackArrayTo(buffer, theType, output, start, end, safe, clamp);
              return output;
            }
            function byte_data_unpack(buffer, theType, index = 0, clamp = false) {
              return unpackArray(
                buffer,
                theType,
                index,
                index + Math.ceil(theType.bits / 8),
                true,
                clamp
              )[0];
            }
            function throwValueError_(err, value, index) {
              err.message = err.constructor.name + " at index " + index + ": " + value;
              throw err;
            }
            function getUnpackLen_(buffer, start, end, offset, safe) {
              let extra = (end - start) % offset;
              if (safe && (extra || buffer.length < offset)) {
                throw new Error("Bad buffer length");
              }
              return end - extra;
            }
            function getParser_(bits, fp, signed, clamp) {
              if (fp) {
                validateFloatType(bits);
              } else {
                validateIntType(bits);
              }
              if (fp && bits === 16) {
                return new IEEE754Buffer(5, 11);
              } else if (fp && bits == 32) {
                return new IEEE754Buffer(8, 23);
              } else if (fp && bits == 64) {
                return new IEEE754Buffer(11, 52);
              }
              return new IntParser(bits, signed, clamp);
            }
            const TYPE_ERR = "Unsupported type";
            function validateFloatType(bits) {
              if (!bits || bits !== 16 && bits !== 32 && bits !== 64) {
                throw new Error(TYPE_ERR + ": float, bits: " + bits);
              }
            }
            function validateIntType(bits) {
              if (!bits || bits < 1 || bits > 53) {
                throw new Error(TYPE_ERR + ": int, bits: " + bits);
              }
            }
          },
          /* 17 */
          /***/
          function(module2, exports2) {
            var g;
            g = /* @__PURE__ */ function() {
              return this;
            }();
            try {
              g = g || new Function("return this")();
            } catch (e) {
              if (typeof window === "object") g = window;
            }
            module2.exports = g;
          },
          /* 18 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            (function(global) {
              var objectAssign = __webpack_require__2(23);
              function compare(a, b) {
                if (a === b) {
                  return 0;
                }
                var x = a.length;
                var y = b.length;
                for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                  if (a[i] !== b[i]) {
                    x = a[i];
                    y = b[i];
                    break;
                  }
                }
                if (x < y) {
                  return -1;
                }
                if (y < x) {
                  return 1;
                }
                return 0;
              }
              function isBuffer(b) {
                if (global.Buffer && typeof global.Buffer.isBuffer === "function") {
                  return global.Buffer.isBuffer(b);
                }
                return !!(b != null && b._isBuffer);
              }
              var util = __webpack_require__2(126);
              var hasOwn = Object.prototype.hasOwnProperty;
              var pSlice = Array.prototype.slice;
              var functionsHaveNames = function() {
                return (function foo() {
                }).name === "foo";
              }();
              function pToString(obj) {
                return Object.prototype.toString.call(obj);
              }
              function isView(arrbuf) {
                if (isBuffer(arrbuf)) {
                  return false;
                }
                if (typeof global.ArrayBuffer !== "function") {
                  return false;
                }
                if (typeof ArrayBuffer.isView === "function") {
                  return ArrayBuffer.isView(arrbuf);
                }
                if (!arrbuf) {
                  return false;
                }
                if (arrbuf instanceof DataView) {
                  return true;
                }
                if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
                  return true;
                }
                return false;
              }
              var assert = module2.exports = ok;
              var regex = /\s*function\s+([^\(\s]*)\s*/;
              function getName(func) {
                if (!util.isFunction(func)) {
                  return;
                }
                if (functionsHaveNames) {
                  return func.name;
                }
                var str = func.toString();
                var match = str.match(regex);
                return match && match[1];
              }
              assert.AssertionError = function AssertionError(options) {
                this.name = "AssertionError";
                this.actual = options.actual;
                this.expected = options.expected;
                this.operator = options.operator;
                if (options.message) {
                  this.message = options.message;
                  this.generatedMessage = false;
                } else {
                  this.message = getMessage(this);
                  this.generatedMessage = true;
                }
                var stackStartFunction = options.stackStartFunction || fail;
                if (Error.captureStackTrace) {
                  Error.captureStackTrace(this, stackStartFunction);
                } else {
                  var err = new Error();
                  if (err.stack) {
                    var out = err.stack;
                    var fn_name = getName(stackStartFunction);
                    var idx = out.indexOf("\n" + fn_name);
                    if (idx >= 0) {
                      var next_line = out.indexOf("\n", idx + 1);
                      out = out.substring(next_line + 1);
                    }
                    this.stack = out;
                  }
                }
              };
              util.inherits(assert.AssertionError, Error);
              function truncate(s, n) {
                if (typeof s === "string") {
                  return s.length < n ? s : s.slice(0, n);
                } else {
                  return s;
                }
              }
              function inspect(something) {
                if (functionsHaveNames || !util.isFunction(something)) {
                  return util.inspect(something);
                }
                var rawname = getName(something);
                var name = rawname ? ": " + rawname : "";
                return "[Function" + name + "]";
              }
              function getMessage(self2) {
                return truncate(inspect(self2.actual), 128) + " " + self2.operator + " " + truncate(inspect(self2.expected), 128);
              }
              function fail(actual, expected, message, operator, stackStartFunction) {
                throw new assert.AssertionError({
                  message,
                  actual,
                  expected,
                  operator,
                  stackStartFunction
                });
              }
              assert.fail = fail;
              function ok(value, message) {
                if (!value) fail(value, true, message, "==", assert.ok);
              }
              assert.ok = ok;
              assert.equal = function equal(actual, expected, message) {
                if (actual != expected) fail(actual, expected, message, "==", assert.equal);
              };
              assert.notEqual = function notEqual(actual, expected, message) {
                if (actual == expected) {
                  fail(actual, expected, message, "!=", assert.notEqual);
                }
              };
              assert.deepEqual = function deepEqual(actual, expected, message) {
                if (!_deepEqual(actual, expected, false)) {
                  fail(actual, expected, message, "deepEqual", assert.deepEqual);
                }
              };
              assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
                if (!_deepEqual(actual, expected, true)) {
                  fail(actual, expected, message, "deepStrictEqual", assert.deepStrictEqual);
                }
              };
              function _deepEqual(actual, expected, strict2, memos) {
                if (actual === expected) {
                  return true;
                } else if (isBuffer(actual) && isBuffer(expected)) {
                  return compare(actual, expected) === 0;
                } else if (util.isDate(actual) && util.isDate(expected)) {
                  return actual.getTime() === expected.getTime();
                } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
                  return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
                } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
                  return strict2 ? actual === expected : actual == expected;
                } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
                  return compare(
                    new Uint8Array(actual.buffer),
                    new Uint8Array(expected.buffer)
                  ) === 0;
                } else if (isBuffer(actual) !== isBuffer(expected)) {
                  return false;
                } else {
                  memos = memos || { actual: [], expected: [] };
                  var actualIndex = memos.actual.indexOf(actual);
                  if (actualIndex !== -1) {
                    if (actualIndex === memos.expected.indexOf(expected)) {
                      return true;
                    }
                  }
                  memos.actual.push(actual);
                  memos.expected.push(expected);
                  return objEquiv(actual, expected, strict2, memos);
                }
              }
              function isArguments(object) {
                return Object.prototype.toString.call(object) == "[object Arguments]";
              }
              function objEquiv(a, b, strict2, actualVisitedObjects) {
                if (a === null || a === void 0 || b === null || b === void 0)
                  return false;
                if (util.isPrimitive(a) || util.isPrimitive(b))
                  return a === b;
                if (strict2 && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
                  return false;
                var aIsArgs = isArguments(a);
                var bIsArgs = isArguments(b);
                if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
                  return false;
                if (aIsArgs) {
                  a = pSlice.call(a);
                  b = pSlice.call(b);
                  return _deepEqual(a, b, strict2);
                }
                var ka = objectKeys(a);
                var kb = objectKeys(b);
                var key, i;
                if (ka.length !== kb.length)
                  return false;
                ka.sort();
                kb.sort();
                for (i = ka.length - 1; i >= 0; i--) {
                  if (ka[i] !== kb[i])
                    return false;
                }
                for (i = ka.length - 1; i >= 0; i--) {
                  key = ka[i];
                  if (!_deepEqual(a[key], b[key], strict2, actualVisitedObjects))
                    return false;
                }
                return true;
              }
              assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
                if (_deepEqual(actual, expected, false)) {
                  fail(actual, expected, message, "notDeepEqual", assert.notDeepEqual);
                }
              };
              assert.notDeepStrictEqual = notDeepStrictEqual;
              function notDeepStrictEqual(actual, expected, message) {
                if (_deepEqual(actual, expected, true)) {
                  fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
                }
              }
              assert.strictEqual = function strictEqual(actual, expected, message) {
                if (actual !== expected) {
                  fail(actual, expected, message, "===", assert.strictEqual);
                }
              };
              assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
                if (actual === expected) {
                  fail(actual, expected, message, "!==", assert.notStrictEqual);
                }
              };
              function expectedException(actual, expected) {
                if (!actual || !expected) {
                  return false;
                }
                if (Object.prototype.toString.call(expected) == "[object RegExp]") {
                  return expected.test(actual);
                }
                try {
                  if (actual instanceof expected) {
                    return true;
                  }
                } catch (e) {
                }
                if (Error.isPrototypeOf(expected)) {
                  return false;
                }
                return expected.call({}, actual) === true;
              }
              function _tryBlock(block) {
                var error;
                try {
                  block();
                } catch (e) {
                  error = e;
                }
                return error;
              }
              function _throws(shouldThrow, block, expected, message) {
                var actual;
                if (typeof block !== "function") {
                  throw new TypeError('"block" argument must be a function');
                }
                if (typeof expected === "string") {
                  message = expected;
                  expected = null;
                }
                actual = _tryBlock(block);
                message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
                if (shouldThrow && !actual) {
                  fail(actual, expected, "Missing expected exception" + message);
                }
                var userProvidedMessage = typeof message === "string";
                var isUnwantedException = !shouldThrow && util.isError(actual);
                var isUnexpectedException = !shouldThrow && actual && !expected;
                if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
                  fail(actual, expected, "Got unwanted exception" + message);
                }
                if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
                  throw actual;
                }
              }
              assert.throws = function(block, error, message) {
                _throws(true, block, error, message);
              };
              assert.doesNotThrow = function(block, error, message) {
                _throws(false, block, error, message);
              };
              assert.ifError = function(err) {
                if (err) throw err;
              };
              function strict(value, message) {
                if (!value) fail(value, true, message, "==", strict);
              }
              assert.strict = objectAssign(strict, assert, {
                equal: assert.strictEqual,
                deepEqual: assert.deepStrictEqual,
                notEqual: assert.notStrictEqual,
                notDeepEqual: assert.notDeepStrictEqual
              });
              assert.strict.strict = assert.strict;
              var objectKeys = Object.keys || function(obj) {
                var keys = [];
                for (var key in obj) {
                  if (hasOwn.call(obj, key)) keys.push(key);
                }
                return keys;
              };
            }).call(this, __webpack_require__2(17));
          },
          /* 19 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var invariant = function(condition, format, a, b, c, d, e, f) {
              if (false) {
              }
              if (!condition) {
                var error;
                if (format === void 0) {
                  error = new Error(
                    "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
                  );
                } else {
                  var args = [a, b, c, d, e, f];
                  var argIndex = 0;
                  error = new Error(
                    format.replace(/%s/g, function() {
                      return args[argIndex++];
                    })
                  );
                  error.name = "Invariant Violation";
                }
                error.framesToPop = 1;
                throw error;
              }
            };
            module2.exports = invariant;
          },
          /* 20 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            class BasicParser {
              constructor() {
                this.warnings = [];
              }
              /**
               * Initialize parser with output (metadata), input (tokenizer) & parsing options (options).
               * @param {INativeMetadataCollector} metadata Output
               * @param {ITokenizer} tokenizer Input
               * @param {IOptions} options Parsing options
               */
              init(metadata, tokenizer, options) {
                this.metadata = metadata;
                this.tokenizer = tokenizer;
                this.options = options;
                return this;
              }
            }
            exports2.BasicParser = BasicParser;
          },
          /* 21 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const ID3v1Parser_1 = __webpack_require__2(48);
            class CommonTagMapper {
              constructor(tagTypes, tagMap) {
                this.tagTypes = tagTypes;
                this.tagMap = tagMap;
              }
              static parseGenre(origVal) {
                const split = origVal.trim().split(/\((.*?)\)/g).filter((val) => {
                  return val !== "";
                });
                const array = [];
                for (let cur of split) {
                  if (/^\d+$/.test(cur) && !isNaN(parseInt(cur, 10))) {
                    cur = ID3v1Parser_1.Genres[cur];
                  }
                  array.push(cur);
                }
                return array.filter((val) => {
                  return val !== void 0;
                }).join("/");
              }
              static fixPictureMimeType(pictureType) {
                pictureType = pictureType.toLocaleLowerCase();
                switch (pictureType) {
                  case "image/jpg":
                    return "image/jpeg";
                }
                return pictureType;
              }
              static toIntOrNull(str) {
                const cleaned = parseInt(str, 10);
                return isNaN(cleaned) ? null : cleaned;
              }
              // TODO: a string of 1of1 would fail to be converted
              // converts 1/10 to no : 1, of : 10
              // or 1 to no : 1, of : 0
              static normalizeTrack(origVal) {
                const split = origVal.toString().split("/");
                return {
                  no: parseInt(split[0], 10) || null,
                  of: parseInt(split[1], 10) || null
                };
              }
              /**
               * Process and set common tags
               * @param comTags Target metadata to
               * write common tags to
               * @param tag     Native tag
               * @param value   Native tag value
               * @return common name
               */
              mapGenericTag(tag) {
                tag = { id: tag.id, value: tag.value };
                this.postMap(tag);
                const id = this.getCommonName(tag.id);
                return id ? { id, value: tag.value } : null;
              }
              /**
               * Convert native tag key to common tag key
               * @tag  Native header tag
               * @return common tag name (alias)
               */
              getCommonName(tag) {
                return this.tagMap[tag];
              }
              /**
               * Handle post mapping exceptions / correction
               * @param {string} tag Tag e.g. {"©alb", "Buena Vista Social Club")
               */
              postMap(tag) {
                return;
              }
            }
            CommonTagMapper.maxRatingScore = 1;
            exports2.CommonTagMapper = CommonTagMapper;
          },
          /* 22 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.endOfFile = "End-Of-File";
          },
          /* 23 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var getOwnPropertySymbols = Object.getOwnPropertySymbols;
            var hasOwnProperty = Object.prototype.hasOwnProperty;
            var propIsEnumerable = Object.prototype.propertyIsEnumerable;
            function toObject(val) {
              if (val === null || val === void 0) {
                throw new TypeError("Object.assign cannot be called with null or undefined");
              }
              return Object(val);
            }
            function shouldUseNative() {
              try {
                if (!Object.assign) {
                  return false;
                }
                var test1 = new String("abc");
                test1[5] = "de";
                if (Object.getOwnPropertyNames(test1)[0] === "5") {
                  return false;
                }
                var test2 = {};
                for (var i = 0; i < 10; i++) {
                  test2["_" + String.fromCharCode(i)] = i;
                }
                var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
                  return test2[n];
                });
                if (order2.join("") !== "0123456789") {
                  return false;
                }
                var test3 = {};
                "abcdefghijklmnopqrst".split("").forEach(function(letter) {
                  test3[letter] = letter;
                });
                if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
                  return false;
                }
                return true;
              } catch (err) {
                return false;
              }
            }
            module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
              var from;
              var to = toObject(target);
              var symbols;
              for (var s = 1; s < arguments.length; s++) {
                from = Object(arguments[s]);
                for (var key in from) {
                  if (hasOwnProperty.call(from, key)) {
                    to[key] = from[key];
                  }
                }
                if (getOwnPropertySymbols) {
                  symbols = getOwnPropertySymbols(from);
                  for (var i = 0; i < symbols.length; i++) {
                    if (propIsEnumerable.call(from, symbols[i])) {
                      to[symbols[i]] = from[symbols[i]];
                    }
                  }
                }
              }
              return to;
            };
          },
          /* 24 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var pna = __webpack_require__2(44);
            var objectKeys = Object.keys || function(obj) {
              var keys2 = [];
              for (var key in obj) {
                keys2.push(key);
              }
              return keys2;
            };
            module2.exports = Duplex;
            var util = Object.create(__webpack_require__2(34));
            util.inherits = __webpack_require__2(31);
            var Readable = __webpack_require__2(107);
            var Writable = __webpack_require__2(53);
            util.inherits(Duplex, Readable);
            {
              var keys = objectKeys(Writable.prototype);
              for (var v = 0; v < keys.length; v++) {
                var method = keys[v];
                if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
              }
            }
            function Duplex(options) {
              if (!(this instanceof Duplex)) return new Duplex(options);
              Readable.call(this, options);
              Writable.call(this, options);
              if (options && options.readable === false) this.readable = false;
              if (options && options.writable === false) this.writable = false;
              this.allowHalfOpen = true;
              if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
              this.once("end", onend);
            }
            Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
              // making it explicit this property is not enumerable
              // because otherwise some prototype manipulation in
              // userland will fail
              enumerable: false,
              get: function() {
                return this._writableState.highWaterMark;
              }
            });
            function onend() {
              if (this.allowHalfOpen || this._writableState.ended) return;
              pna.nextTick(onEndNT, this);
            }
            function onEndNT(self2) {
              self2.end();
            }
            Object.defineProperty(Duplex.prototype, "destroyed", {
              get: function() {
                if (this._readableState === void 0 || this._writableState === void 0) {
                  return false;
                }
                return this._readableState.destroyed && this._writableState.destroyed;
              },
              set: function(value) {
                if (this._readableState === void 0 || this._writableState === void 0) {
                  return;
                }
                this._readableState.destroyed = value;
                this._writableState.destroyed = value;
              }
            });
            Duplex.prototype._destroy = function(err, cb) {
              this.push(null);
              this.end();
              pna.nextTick(cb, err);
            };
          },
          /* 25 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            var root = __webpack_require__2(79);
            var Symbol2 = root.Symbol;
            module2.exports = Symbol2;
          },
          /* 26 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            if (true) {
              module2.exports = __webpack_require__2(63);
            } else {
            }
          },
          /* 27 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var reactIs = __webpack_require__2(26);
            var REACT_STATICS = {
              childContextTypes: true,
              contextType: true,
              contextTypes: true,
              defaultProps: true,
              displayName: true,
              getDefaultProps: true,
              getDerivedStateFromError: true,
              getDerivedStateFromProps: true,
              mixins: true,
              propTypes: true,
              type: true
            };
            var KNOWN_STATICS = {
              name: true,
              length: true,
              prototype: true,
              caller: true,
              callee: true,
              arguments: true,
              arity: true
            };
            var FORWARD_REF_STATICS = {
              "$$typeof": true,
              render: true,
              defaultProps: true,
              displayName: true,
              propTypes: true
            };
            var MEMO_STATICS = {
              "$$typeof": true,
              compare: true,
              defaultProps: true,
              displayName: true,
              propTypes: true,
              type: true
            };
            var TYPE_STATICS = {};
            TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
            TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
            function getStatics(component) {
              if (reactIs.isMemo(component)) {
                return MEMO_STATICS;
              }
              return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
            }
            var defineProperty = Object.defineProperty;
            var getOwnPropertyNames = Object.getOwnPropertyNames;
            var getOwnPropertySymbols = Object.getOwnPropertySymbols;
            var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
            var getPrototypeOf = Object.getPrototypeOf;
            var objectPrototype = Object.prototype;
            function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
              if (typeof sourceComponent !== "string") {
                if (objectPrototype) {
                  var inheritedComponent = getPrototypeOf(sourceComponent);
                  if (inheritedComponent && inheritedComponent !== objectPrototype) {
                    hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
                  }
                }
                var keys = getOwnPropertyNames(sourceComponent);
                if (getOwnPropertySymbols) {
                  keys = keys.concat(getOwnPropertySymbols(sourceComponent));
                }
                var targetStatics = getStatics(targetComponent);
                var sourceStatics = getStatics(sourceComponent);
                for (var i = 0; i < keys.length; ++i) {
                  var key = keys[i];
                  if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
                    var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                    try {
                      defineProperty(targetComponent, key, descriptor);
                    } catch (e) {
                    }
                  }
                }
              }
              return targetComponent;
            }
            module2.exports = hoistNonReactStatics;
          },
          /* 28 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__2) {
            "use strict";
            (function(global, module3) {
              var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(36);
              var root;
              if (typeof self !== "undefined") {
                root = self;
              } else if (typeof window !== "undefined") {
                root = window;
              } else if (typeof global !== "undefined") {
                root = global;
              } else if (true) {
                root = module3;
              } else {
              }
              var result = Object(_ponyfill_js__WEBPACK_IMPORTED_MODULE_0__[
                /* default */
                "a"
              ])(root);
              __webpack_exports__["a"] = result;
            }).call(this, __webpack_require__2(17), __webpack_require__2(64)(module2));
          },
          /* 29 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            var parser = __webpack_require__2(66);
            var creator = __webpack_require__2(67);
            module2.exports = {
              parser,
              creator
            };
          },
          /* 30 */
          /***/
          function(module2, exports2) {
            var process = module2.exports = {};
            var cachedSetTimeout;
            var cachedClearTimeout;
            function defaultSetTimout() {
              throw new Error("setTimeout has not been defined");
            }
            function defaultClearTimeout() {
              throw new Error("clearTimeout has not been defined");
            }
            (function() {
              try {
                if (typeof setTimeout === "function") {
                  cachedSetTimeout = setTimeout;
                } else {
                  cachedSetTimeout = defaultSetTimout;
                }
              } catch (e) {
                cachedSetTimeout = defaultSetTimout;
              }
              try {
                if (typeof clearTimeout === "function") {
                  cachedClearTimeout = clearTimeout;
                } else {
                  cachedClearTimeout = defaultClearTimeout;
                }
              } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
              }
            })();
            function runTimeout(fun) {
              if (cachedSetTimeout === setTimeout) {
                return setTimeout(fun, 0);
              }
              if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                cachedSetTimeout = setTimeout;
                return setTimeout(fun, 0);
              }
              try {
                return cachedSetTimeout(fun, 0);
              } catch (e) {
                try {
                  return cachedSetTimeout.call(null, fun, 0);
                } catch (e2) {
                  return cachedSetTimeout.call(this, fun, 0);
                }
              }
            }
            function runClearTimeout(marker) {
              if (cachedClearTimeout === clearTimeout) {
                return clearTimeout(marker);
              }
              if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                cachedClearTimeout = clearTimeout;
                return clearTimeout(marker);
              }
              try {
                return cachedClearTimeout(marker);
              } catch (e) {
                try {
                  return cachedClearTimeout.call(null, marker);
                } catch (e2) {
                  return cachedClearTimeout.call(this, marker);
                }
              }
            }
            var queue = [];
            var draining = false;
            var currentQueue;
            var queueIndex = -1;
            function cleanUpNextTick() {
              if (!draining || !currentQueue) {
                return;
              }
              draining = false;
              if (currentQueue.length) {
                queue = currentQueue.concat(queue);
              } else {
                queueIndex = -1;
              }
              if (queue.length) {
                drainQueue();
              }
            }
            function drainQueue() {
              if (draining) {
                return;
              }
              var timeout = runTimeout(cleanUpNextTick);
              draining = true;
              var len = queue.length;
              while (len) {
                currentQueue = queue;
                queue = [];
                while (++queueIndex < len) {
                  if (currentQueue) {
                    currentQueue[queueIndex].run();
                  }
                }
                queueIndex = -1;
                len = queue.length;
              }
              currentQueue = null;
              draining = false;
              runClearTimeout(timeout);
            }
            process.nextTick = function(fun) {
              var args = new Array(arguments.length - 1);
              if (arguments.length > 1) {
                for (var i = 1; i < arguments.length; i++) {
                  args[i - 1] = arguments[i];
                }
              }
              queue.push(new Item(fun, args));
              if (queue.length === 1 && !draining) {
                runTimeout(drainQueue);
              }
            };
            function Item(fun, array) {
              this.fun = fun;
              this.array = array;
            }
            Item.prototype.run = function() {
              this.fun.apply(null, this.array);
            };
            process.title = "browser";
            process.browser = true;
            process.env = {};
            process.argv = [];
            process.version = "";
            process.versions = {};
            function noop() {
            }
            process.on = noop;
            process.addListener = noop;
            process.once = noop;
            process.off = noop;
            process.removeListener = noop;
            process.removeAllListeners = noop;
            process.emit = noop;
            process.prependListener = noop;
            process.prependOnceListener = noop;
            process.listeners = function(name) {
              return [];
            };
            process.binding = function(name) {
              throw new Error("process.binding is not supported");
            };
            process.cwd = function() {
              return "/";
            };
            process.chdir = function(dir) {
              throw new Error("process.chdir is not supported");
            };
            process.umask = function() {
              return 0;
            };
          },
          /* 31 */
          /***/
          function(module2, exports2) {
            if (typeof Object.create === "function") {
              module2.exports = function inherits(ctor, superCtor) {
                if (superCtor) {
                  ctor.super_ = superCtor;
                  ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                      value: ctor,
                      enumerable: false,
                      writable: true,
                      configurable: true
                    }
                  });
                }
              };
            } else {
              module2.exports = function inherits(ctor, superCtor) {
                if (superCtor) {
                  ctor.super_ = superCtor;
                  var TempCtor = function() {
                  };
                  TempCtor.prototype = superCtor.prototype;
                  ctor.prototype = new TempCtor();
                  ctor.prototype.constructor = ctor;
                }
              };
            }
          },
          /* 32 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            (function(Buffer2) {
              var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function(resolve2, reject2) {
                  function fulfilled(value) {
                    try {
                      step(generator.next(value));
                    } catch (e) {
                      reject2(e);
                    }
                  }
                  function rejected(value) {
                    try {
                      step(generator["throw"](value));
                    } catch (e) {
                      reject2(e);
                    }
                  }
                  function step(result) {
                    result.done ? resolve2(result.value) : new P(function(resolve3) {
                      resolve3(result.value);
                    }).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
              };
              Object.defineProperty(exports2, "__esModule", { value: true });
              const Token = __webpack_require__2(6);
              const Util_1 = __webpack_require__2(14);
              const FrameParser_1 = __webpack_require__2(146);
              const ID3v2_1 = __webpack_require__2(33);
              class ID3v2Parser {
                static removeUnsyncBytes(buffer) {
                  let readI = 0;
                  let writeI = 0;
                  while (readI < buffer.length - 1) {
                    if (readI !== writeI) {
                      buffer[writeI] = buffer[readI];
                    }
                    readI += buffer[readI] === 255 && buffer[readI + 1] === 0 ? 2 : 1;
                    writeI++;
                  }
                  if (readI < buffer.length) {
                    buffer[writeI++] = buffer[readI++];
                  }
                  return buffer.slice(0, writeI);
                }
                static readFrameHeader(v, majorVer) {
                  let header;
                  switch (majorVer) {
                    case 2:
                      header = {
                        id: v.toString("ascii", 0, 3),
                        length: Token.UINT24_BE.get(v, 3)
                      };
                      break;
                    case 3:
                      header = {
                        id: v.toString("ascii", 0, 4),
                        length: Token.UINT32_BE.get(v, 4),
                        flags: ID3v2Parser.readFrameFlags(v.slice(8, 10))
                      };
                      break;
                    case 4:
                      header = {
                        id: v.toString("ascii", 0, 4),
                        length: ID3v2_1.ID3v2Token.UINT32SYNCSAFE.get(v, 4),
                        flags: ID3v2Parser.readFrameFlags(v.slice(8, 10))
                      };
                      break;
                    default:
                      throw new Error("Unexpected majorVer: " + majorVer);
                  }
                  return header;
                }
                static getFrameHeaderLength(majorVer) {
                  switch (majorVer) {
                    case 2:
                      return 6;
                    case 3:
                    case 4:
                      return 10;
                    default:
                      throw new Error("header versionIndex is incorrect");
                  }
                }
                static readFrameFlags(b) {
                  return {
                    status: {
                      tag_alter_preservation: Util_1.default.strtokBITSET.get(b, 0, 6),
                      file_alter_preservation: Util_1.default.strtokBITSET.get(b, 0, 5),
                      read_only: Util_1.default.strtokBITSET.get(b, 0, 4)
                    },
                    format: {
                      grouping_identity: Util_1.default.strtokBITSET.get(b, 1, 7),
                      compression: Util_1.default.strtokBITSET.get(b, 1, 3),
                      encryption: Util_1.default.strtokBITSET.get(b, 1, 2),
                      unsynchronisation: Util_1.default.strtokBITSET.get(b, 1, 1),
                      data_length_indicator: Util_1.default.strtokBITSET.get(b, 1, 0)
                    }
                  };
                }
                static readFrameData(buf, frameHeader, majorVer, includeCovers) {
                  switch (majorVer) {
                    case 2:
                      return FrameParser_1.default.readData(buf, frameHeader.id, majorVer, includeCovers);
                    case 3:
                    case 4:
                      if (frameHeader.flags.format.unsynchronisation) {
                        buf = ID3v2Parser.removeUnsyncBytes(buf);
                      }
                      if (frameHeader.flags.format.data_length_indicator) {
                        buf = buf.slice(4, buf.length);
                      }
                      return FrameParser_1.default.readData(buf, frameHeader.id, majorVer, includeCovers);
                    default:
                      throw new Error("Unexpected majorVer: " + majorVer);
                  }
                }
                /**
                 * Create a combined tag key, of tag & description
                 * @param {string} tag e.g.: COM
                 * @param {string} description e.g. iTunPGAP
                 * @returns {string} e.g. COM:iTunPGAP
                 */
                static makeDescriptionTagName(tag, description) {
                  return tag + (description ? ":" + description : "");
                }
                parse(metadata, tokenizer, options) {
                  return __awaiter(this, void 0, void 0, function* () {
                    this.tokenizer = tokenizer;
                    this.metadata = metadata;
                    this.options = options;
                    const id3Header = yield this.tokenizer.readToken(ID3v2_1.ID3v2Token.Header);
                    if (id3Header.fileIdentifier !== "ID3") {
                      throw new Error("expected ID3-header file-identifier 'ID3' was not found");
                    }
                    this.id3Header = id3Header;
                    this.headerType = "ID3v2." + id3Header.version.major;
                    if (id3Header.flags.isExtendedHeader) {
                      return this.parseExtendedHeader();
                    } else {
                      return this.parseId3Data(id3Header.size);
                    }
                  });
                }
                parseExtendedHeader() {
                  return __awaiter(this, void 0, void 0, function* () {
                    const extendedHeader = yield this.tokenizer.readToken(ID3v2_1.ID3v2Token.ExtendedHeader);
                    const dataRemaining = extendedHeader.size - ID3v2_1.ID3v2Token.ExtendedHeader.len;
                    if (dataRemaining > 0) {
                      return this.parseExtendedHeaderData(dataRemaining, extendedHeader.size);
                    } else {
                      return this.parseId3Data(this.id3Header.size - extendedHeader.size);
                    }
                  });
                }
                parseExtendedHeaderData(dataRemaining, extendedHeaderSize) {
                  return __awaiter(this, void 0, void 0, function* () {
                    const buffer = Buffer2.alloc(dataRemaining);
                    yield this.tokenizer.readBuffer(buffer, 0, dataRemaining);
                    return this.parseId3Data(this.id3Header.size - extendedHeaderSize);
                  });
                }
                parseId3Data(dataLen) {
                  return __awaiter(this, void 0, void 0, function* () {
                    const buffer = Buffer2.alloc(dataLen);
                    yield this.tokenizer.readBuffer(buffer, 0, dataLen);
                    for (const tag of this.parseMetadata(buffer)) {
                      if (tag.id === "TXXX") {
                        for (const text of tag.value.text) {
                          this.addTag(ID3v2Parser.makeDescriptionTagName(tag.id, tag.value.description), text);
                        }
                      } else if (tag.id === "COM") {
                        for (const value of tag.value) {
                          this.addTag(ID3v2Parser.makeDescriptionTagName(tag.id, value.description), value.text);
                        }
                      } else if (Array.isArray(tag.value)) {
                        for (const value of tag.value) {
                          this.addTag(tag.id, value);
                        }
                      } else {
                        this.addTag(tag.id, tag.value);
                      }
                    }
                  });
                }
                addTag(id, value) {
                  this.metadata.addTag(this.headerType, id, value);
                }
                parseMetadata(data) {
                  let offset = 0;
                  const tags = [];
                  while (true) {
                    if (offset === data.length)
                      break;
                    const frameHeaderLength = ID3v2Parser.getFrameHeaderLength(this.id3Header.version.major);
                    if (offset + frameHeaderLength > data.length) {
                      break;
                    }
                    const frameHeaderBytes = data.slice(offset, offset += frameHeaderLength);
                    const frameHeader = ID3v2Parser.readFrameHeader(frameHeaderBytes, this.id3Header.version.major);
                    if (frameHeader.id === "" || frameHeader.id === "\0\0\0\0" || "ABCDEFGHIJKLMNOPQRSTUVWXYZ".indexOf(frameHeader.id[0]) === -1) {
                      break;
                    }
                    const frameDataBytes = data.slice(offset, offset += frameHeader.length);
                    const values = ID3v2Parser.readFrameData(frameDataBytes, frameHeader, this.id3Header.version.major, !this.options.skipCovers);
                    tags.push({ id: frameHeader.id, value: values });
                  }
                  return tags;
                }
              }
              exports2.ID3v2Parser = ID3v2Parser;
            }).call(this, __webpack_require__2(9).Buffer);
          },
          /* 33 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const Token = __webpack_require__2(6);
            const Util_1 = __webpack_require__2(14);
            var AttachedPictureType;
            (function(AttachedPictureType2) {
              AttachedPictureType2[AttachedPictureType2["Other"] = 0] = "Other";
              AttachedPictureType2[AttachedPictureType2["32x32 pixels 'file icon' (PNG only)"] = 1] = "32x32 pixels 'file icon' (PNG only)";
              AttachedPictureType2[AttachedPictureType2["Other file icon"] = 2] = "Other file icon";
              AttachedPictureType2[AttachedPictureType2["Cover (front)"] = 3] = "Cover (front)";
              AttachedPictureType2[AttachedPictureType2["Cover (back)"] = 4] = "Cover (back)";
              AttachedPictureType2[AttachedPictureType2["Leaflet page"] = 5] = "Leaflet page";
              AttachedPictureType2[AttachedPictureType2["Media (e.g. label side of CD)"] = 6] = "Media (e.g. label side of CD)";
              AttachedPictureType2[AttachedPictureType2["Lead artist/lead performer/soloist"] = 7] = "Lead artist/lead performer/soloist";
              AttachedPictureType2[AttachedPictureType2["Artist/performer"] = 8] = "Artist/performer";
              AttachedPictureType2[AttachedPictureType2["Conductor"] = 9] = "Conductor";
              AttachedPictureType2[AttachedPictureType2["Band/Orchestra"] = 10] = "Band/Orchestra";
              AttachedPictureType2[AttachedPictureType2["Composer"] = 11] = "Composer";
              AttachedPictureType2[AttachedPictureType2["Lyricist/text writer"] = 12] = "Lyricist/text writer";
              AttachedPictureType2[AttachedPictureType2["Recording Location"] = 13] = "Recording Location";
              AttachedPictureType2[AttachedPictureType2["During recording"] = 14] = "During recording";
              AttachedPictureType2[AttachedPictureType2["During performance"] = 15] = "During performance";
              AttachedPictureType2[AttachedPictureType2["Movie/video screen capture"] = 16] = "Movie/video screen capture";
              AttachedPictureType2[AttachedPictureType2["A bright coloured fish"] = 17] = "A bright coloured fish";
              AttachedPictureType2[AttachedPictureType2["Illustration"] = 18] = "Illustration";
              AttachedPictureType2[AttachedPictureType2["Band/artist logotype"] = 19] = "Band/artist logotype";
              AttachedPictureType2[AttachedPictureType2["Publisher/Studio logotype"] = 20] = "Publisher/Studio logotype";
            })(AttachedPictureType = exports2.AttachedPictureType || (exports2.AttachedPictureType = {}));
            class ID3v2Token {
            }
            ID3v2Token.UINT32SYNCSAFE = {
              get: (buf, off) => {
                return buf[off + 3] & 127 | buf[off + 2] << 7 | buf[off + 1] << 14 | buf[off] << 21;
              },
              len: 4
            };
            ID3v2Token.Header = {
              len: 10,
              get: (buf, off) => {
                return {
                  // ID3v2/file identifier   "ID3"
                  fileIdentifier: new Token.StringType(3, "ascii").get(buf, off),
                  // ID3v2 versionIndex
                  version: {
                    major: Token.INT8.get(buf, off + 3),
                    revision: Token.INT8.get(buf, off + 4)
                  },
                  // ID3v2 flags
                  flags: {
                    // Raw flags value
                    raw: Token.INT8.get(buf, off + 4),
                    // Unsynchronisation
                    unsynchronisation: Util_1.default.strtokBITSET.get(buf, off + 5, 7),
                    // Extended header
                    isExtendedHeader: Util_1.default.strtokBITSET.get(buf, off + 5, 6),
                    // Experimental indicator
                    expIndicator: Util_1.default.strtokBITSET.get(buf, off + 5, 5),
                    footer: Util_1.default.strtokBITSET.get(buf, off + 5, 4)
                  },
                  size: ID3v2Token.UINT32SYNCSAFE.get(buf, off + 6)
                };
              }
            };
            ID3v2Token.ExtendedHeader = {
              len: 10,
              get: (buf, off) => {
                return {
                  // Extended header size
                  size: Token.UINT32_BE.get(buf, off),
                  // Extended Flags
                  extendedFlags: Token.UINT16_BE.get(buf, off + 4),
                  // Size of padding
                  sizeOfPadding: Token.UINT32_BE.get(buf, off + 6),
                  // CRC data present
                  crcDataPresent: Util_1.default.strtokBITSET.get(buf, off + 4, 31)
                };
              }
            };
            exports2.ID3v2Token = ID3v2Token;
          },
          /* 34 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            (function(Buffer2) {
              function isArray(arg) {
                if (Array.isArray) {
                  return Array.isArray(arg);
                }
                return objectToString(arg) === "[object Array]";
              }
              exports2.isArray = isArray;
              function isBoolean(arg) {
                return typeof arg === "boolean";
              }
              exports2.isBoolean = isBoolean;
              function isNull(arg) {
                return arg === null;
              }
              exports2.isNull = isNull;
              function isNullOrUndefined(arg) {
                return arg == null;
              }
              exports2.isNullOrUndefined = isNullOrUndefined;
              function isNumber(arg) {
                return typeof arg === "number";
              }
              exports2.isNumber = isNumber;
              function isString(arg) {
                return typeof arg === "string";
              }
              exports2.isString = isString;
              function isSymbol(arg) {
                return typeof arg === "symbol";
              }
              exports2.isSymbol = isSymbol;
              function isUndefined(arg) {
                return arg === void 0;
              }
              exports2.isUndefined = isUndefined;
              function isRegExp(re) {
                return objectToString(re) === "[object RegExp]";
              }
              exports2.isRegExp = isRegExp;
              function isObject(arg) {
                return typeof arg === "object" && arg !== null;
              }
              exports2.isObject = isObject;
              function isDate(d) {
                return objectToString(d) === "[object Date]";
              }
              exports2.isDate = isDate;
              function isError(e) {
                return objectToString(e) === "[object Error]" || e instanceof Error;
              }
              exports2.isError = isError;
              function isFunction(arg) {
                return typeof arg === "function";
              }
              exports2.isFunction = isFunction;
              function isPrimitive(arg) {
                return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
                typeof arg === "undefined";
              }
              exports2.isPrimitive = isPrimitive;
              exports2.isBuffer = Buffer2.isBuffer;
              function objectToString(o) {
                return Object.prototype.toString.call(o);
              }
            }).call(this, __webpack_require__2(9).Buffer);
          },
          /* 35 */
          /***/
          function(module2, exports2) {
            var PRESET_VALUES = ["hz60", "hz170", "hz310", "hz600", "hz1000", "hz3000", "hz6000", "hz12000", "hz14000", "hz16000", "preamp"];
            var HEADER = "Winamp EQ library file v1.1";
            module2.exports = {
              PRESET_VALUES,
              HEADER
            };
          },
          /* 36 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__2) {
            "use strict";
            __webpack_require__2.d(__webpack_exports__, "a", function() {
              return symbolObservablePonyfill;
            });
            function symbolObservablePonyfill(root) {
              var result;
              var Symbol2 = root.Symbol;
              if (typeof Symbol2 === "function") {
                if (Symbol2.observable) {
                  result = Symbol2.observable;
                } else {
                  result = Symbol2("observable");
                  Symbol2.observable = result;
                }
              } else {
                result = "@@observable";
              }
              return result;
            }
            ;
          },
          /* 37 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var compose = __webpack_require__2(12).compose;
            exports2.__esModule = true;
            exports2.composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
              if (arguments.length === 0) return void 0;
              if (typeof arguments[0] === "object") return compose;
              return compose.apply(null, arguments);
            };
            exports2.devToolsEnhancer = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__ : function() {
              return function(noop) {
                return noop;
              };
            };
          },
          /* 38 */
          /***/
          function(module2) {
            module2.exports = JSON.parse('{"images":{"EQ_PREAMP_LINE":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHEAAAABCAYAAADpXEERAAAAE0lEQVQoU2Pcdfruf4ZRMKRDAAD1lwNjTqcaUQAAAABJRU5ErkJggg==","EQ_GRAPH_LINE_COLORS":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAATCAYAAABRC2cZAAAAR0lEQVQYV2O4rCT9n+F9kOJ/hvfViv8ZHkzSQCE2afxneH/HEJm49Nr0PwOYWPLIAkp0PjL4z1B41uQ/Q9QGnf8MWrPEIAQANWYwvnlToNIAAAAASUVORK5CYII="},"colors":["rgb(0,0,0)","rgb(24,33,41)","rgb(239,49,16)","rgb(206,41,16)","rgb(214,90,0)","rgb(214,102,0)","rgb(214,115,0)","rgb(198,123,8)","rgb(222,165,24)","rgb(214,181,33)","rgb(189,222,41)","rgb(148,222,33)","rgb(41,206,16)","rgb(50,190,16)","rgb(57,181,16)","rgb(49,156,8)","rgb(41,148,0)","rgb(24,132,8)","rgb(255,255,255)","rgb(214,214,222)","rgb(181,189,189)","rgb(160,170,175)","rgb(148,156,165)","rgb(150,150,150)"],"playlistStyle":{"normal":"#00FF00","current":"#FFFFFF","normalbg":"#000000","selectedbg":"#0000FF","font":"Arial"}}');
          },
          /* 39 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            module2.exports = TinyQueue;
            module2.exports.default = TinyQueue;
            function TinyQueue(data, compare) {
              if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);
              this.data = data || [];
              this.length = this.data.length;
              this.compare = compare || defaultCompare;
              if (this.length > 0) {
                for (var i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);
              }
            }
            function defaultCompare(a, b) {
              return a < b ? -1 : a > b ? 1 : 0;
            }
            TinyQueue.prototype = {
              push: function(item) {
                this.data.push(item);
                this.length++;
                this._up(this.length - 1);
              },
              pop: function() {
                if (this.length === 0) return void 0;
                var top = this.data[0];
                this.length--;
                if (this.length > 0) {
                  this.data[0] = this.data[this.length];
                  this._down(0);
                }
                this.data.pop();
                return top;
              },
              peek: function() {
                return this.data[0];
              },
              _up: function(pos) {
                var data = this.data;
                var compare = this.compare;
                var item = data[pos];
                while (pos > 0) {
                  var parent = pos - 1 >> 1;
                  var current = data[parent];
                  if (compare(item, current) >= 0) break;
                  data[pos] = current;
                  pos = parent;
                }
                data[pos] = item;
              },
              _down: function(pos) {
                var data = this.data;
                var compare = this.compare;
                var halfLength = this.length >> 1;
                var item = data[pos];
                while (pos < halfLength) {
                  var left = (pos << 1) + 1;
                  var right = left + 1;
                  var best = data[left];
                  if (right < this.length && compare(data[right], best) < 0) {
                    left = right;
                    best = data[right];
                  }
                  if (compare(best, item) >= 0) break;
                  data[pos] = best;
                  pos = left;
                }
                data[pos] = item;
              }
            };
          },
          /* 40 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            var deburrLetter = __webpack_require__2(75), toString = __webpack_require__2(77);
            var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
            var rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
            var rsCombo = "[" + rsComboRange + "]";
            var reComboMark = RegExp(rsCombo, "g");
            function deburr(string) {
              string = toString(string);
              return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
            }
            module2.exports = deburr;
          },
          /* 41 */
          /***/
          function(module2) {
            module2.exports = JSON.parse('{"type":"Winamp EQ library file v1.1","presets":[{"name":"Classical","hz60":33,"hz170":33,"hz310":33,"hz600":33,"hz1000":33,"hz3000":33,"hz6000":20,"hz12000":20,"hz14000":20,"hz16000":16,"preamp":33},{"name":"Club","hz60":33,"hz170":33,"hz310":38,"hz600":42,"hz1000":42,"hz3000":42,"hz6000":38,"hz12000":33,"hz14000":33,"hz16000":33,"preamp":33},{"name":"Dance","hz60":48,"hz170":44,"hz310":36,"hz600":32,"hz1000":32,"hz3000":22,"hz6000":20,"hz12000":20,"hz14000":32,"hz16000":32,"preamp":33},{"name":"Laptop speakers/headphones","hz60":40,"hz170":50,"hz310":41,"hz600":26,"hz1000":28,"hz3000":35,"hz6000":40,"hz12000":48,"hz14000":53,"hz16000":56,"preamp":33},{"name":"Large hall","hz60":49,"hz170":49,"hz310":42,"hz600":42,"hz1000":33,"hz3000":24,"hz6000":24,"hz12000":24,"hz14000":33,"hz16000":33,"preamp":33},{"name":"Party","hz60":44,"hz170":44,"hz310":33,"hz600":33,"hz1000":33,"hz3000":33,"hz6000":33,"hz12000":33,"hz14000":44,"hz16000":44,"preamp":33},{"name":"Pop","hz60":29,"hz170":40,"hz310":44,"hz600":45,"hz1000":41,"hz3000":30,"hz6000":28,"hz12000":28,"hz14000":29,"hz16000":29,"preamp":33},{"name":"Reggae","hz60":33,"hz170":33,"hz310":31,"hz600":22,"hz1000":33,"hz3000":43,"hz6000":43,"hz12000":33,"hz14000":33,"hz16000":33,"preamp":33},{"name":"Rock","hz60":45,"hz170":40,"hz310":23,"hz600":19,"hz1000":26,"hz3000":39,"hz6000":47,"hz12000":50,"hz14000":50,"hz16000":50,"preamp":33},{"name":"Soft","hz60":40,"hz170":35,"hz310":30,"hz600":28,"hz1000":30,"hz3000":39,"hz6000":46,"hz12000":48,"hz14000":50,"hz16000":52,"preamp":33},{"name":"Ska","hz60":28,"hz170":24,"hz310":25,"hz600":31,"hz1000":39,"hz3000":42,"hz6000":47,"hz12000":48,"hz14000":50,"hz16000":48,"preamp":33},{"name":"Full Bass","hz60":48,"hz170":48,"hz310":48,"hz600":42,"hz1000":35,"hz3000":25,"hz6000":18,"hz12000":15,"hz14000":14,"hz16000":14,"preamp":33},{"name":"Soft Rock","hz60":39,"hz170":39,"hz310":36,"hz600":31,"hz1000":25,"hz3000":23,"hz6000":26,"hz12000":31,"hz14000":37,"hz16000":47,"preamp":33},{"name":"Full Treble","hz60":16,"hz170":16,"hz310":16,"hz600":25,"hz1000":37,"hz3000":50,"hz6000":58,"hz12000":58,"hz14000":58,"hz16000":60,"preamp":33},{"name":"Full Bass & Treble","hz60":44,"hz170":42,"hz310":33,"hz600":20,"hz1000":24,"hz3000":35,"hz6000":46,"hz12000":50,"hz14000":52,"hz16000":52,"preamp":33},{"name":"Live","hz60":24,"hz170":33,"hz310":39,"hz600":41,"hz1000":42,"hz3000":42,"hz6000":39,"hz12000":37,"hz14000":37,"hz16000":36,"preamp":33},{"name":"Techno","hz60":45,"hz170":42,"hz310":33,"hz600":23,"hz1000":24,"hz3000":33,"hz6000":45,"hz12000":48,"hz14000":48,"hz16000":47,"preamp":33}]}');
          },
          /* 42 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var __read = this && this.__read || function(o, n) {
              var m = typeof Symbol === "function" && o[Symbol.iterator];
              if (!m) return o;
              var i2 = m.call(o), r, ar = [], e;
              try {
                while ((n === void 0 || n-- > 0) && !(r = i2.next()).done) ar.push(r.value);
              } catch (error) {
                e = { error };
              } finally {
                try {
                  if (r && !r.done && (m = i2["return"])) m.call(i2);
                } finally {
                  if (e) throw e.error;
                }
              }
              return ar;
            };
            var __spread = this && this.__spread || function() {
              for (var ar = [], i2 = 0; i2 < arguments.length; i2++) ar = ar.concat(__read(arguments[i2]));
              return ar;
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.convertAniBinaryToCSS = void 0;
            var parser_1 = __webpack_require__2(96);
            var JIFFIES_PER_MS = 1e3 / 60;
            function convertAniBinaryToCSS(selector, aniBinary) {
              var ani = readAni(aniBinary);
              var animationName = "ani-cursor-" + uniqueId();
              var keyframes = ani.frames.map(function(_a) {
                var url = _a.url, percents = _a.percents;
                var percent = percents.map(function(num) {
                  return num + "%";
                }).join(", ");
                return percent + " { cursor: url(" + url + "), auto; }";
              });
              var timingFunction = "step-end";
              var pseudoSelector = ":hover";
              return "\n    @keyframes " + animationName + " {\n        " + keyframes.join("\n") + "\n    }\n    " + selector + pseudoSelector + " {\n        animation: " + animationName + " " + ani.duration + "ms " + timingFunction + " infinite;\n    }\n   ";
            }
            exports2.convertAniBinaryToCSS = convertAniBinaryToCSS;
            function readAni(contents) {
              var _a;
              var ani = parser_1.parseAni(contents);
              var rate = (_a = ani.rate) !== null && _a !== void 0 ? _a : ani.images.map(function() {
                return ani.metadata.iDispRate;
              });
              var duration = sum(rate);
              var frames = ani.images.map(function(image) {
                return {
                  url: curUrlFromByteArray(image),
                  percents: []
                };
              });
              var elapsed = 0;
              rate.forEach(function(r, i2) {
                var frameIdx = ani.seq ? ani.seq[i2] : i2;
                frames[frameIdx].percents.push(elapsed / duration * 100);
                elapsed += r;
              });
              return { duration: duration * JIFFIES_PER_MS, frames };
            }
            var i = 0;
            var uniqueId = function() {
              return i++;
            };
            function base64FromDataArray(dataArray) {
              return window.btoa(String.fromCharCode.apply(String, __spread(dataArray)));
            }
            function curUrlFromByteArray(arr) {
              var base64 = base64FromDataArray(arr);
              return "data:image/x-win-bitmap;base64," + base64;
            }
            function sum(values) {
              return values.reduce(function(total, value) {
                return total + value;
              }, 0);
            }
          },
          /* 43 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const ReadStreamTokenizer_1 = __webpack_require__2(123);
            const BufferTokenizer_1 = __webpack_require__2(129);
            function fromStream(stream2, size) {
              return new ReadStreamTokenizer_1.ReadStreamTokenizer(stream2, size);
            }
            exports2.fromStream = fromStream;
            function fromBuffer(buffer) {
              return new BufferTokenizer_1.BufferTokenizer(buffer);
            }
            exports2.fromBuffer = fromBuffer;
          },
          /* 44 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            (function(process) {
              if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
                module2.exports = { nextTick };
              } else {
                module2.exports = process;
              }
              function nextTick(fn, arg1, arg2, arg3) {
                if (typeof fn !== "function") {
                  throw new TypeError('"callback" argument must be a function');
                }
                var len = arguments.length;
                var args, i;
                switch (len) {
                  case 0:
                  case 1:
                    return process.nextTick(fn);
                  case 2:
                    return process.nextTick(function afterTickOne() {
                      fn.call(null, arg1);
                    });
                  case 3:
                    return process.nextTick(function afterTickTwo() {
                      fn.call(null, arg1, arg2);
                    });
                  case 4:
                    return process.nextTick(function afterTickThree() {
                      fn.call(null, arg1, arg2, arg3);
                    });
                  default:
                    args = new Array(len - 1);
                    i = 0;
                    while (i < args.length) {
                      args[i++] = arguments[i];
                    }
                    return process.nextTick(function afterTick() {
                      fn.apply(null, args);
                    });
                }
              }
            }).call(this, __webpack_require__2(30));
          },
          /* 45 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            (function(Buffer2) {
              var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function(resolve2, reject2) {
                  function fulfilled(value) {
                    try {
                      step(generator.next(value));
                    } catch (e) {
                      reject2(e);
                    }
                  }
                  function rejected(value) {
                    try {
                      step(generator["throw"](value));
                    } catch (e) {
                      reject2(e);
                    }
                  }
                  function step(result) {
                    result.done ? resolve2(result.value) : new P(function(resolve3) {
                      resolve3(result.value);
                    }).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
              };
              Object.defineProperty(exports2, "__esModule", { value: true });
              const initDebug = __webpack_require__2(8);
              const FileType = __webpack_require__2(105);
              const Token = __webpack_require__2(6);
              const assert = __webpack_require__2(18);
              const Util_1 = __webpack_require__2(14);
              const BasicParser_1 = __webpack_require__2(20);
              const APEv2Token_1 = __webpack_require__2(159);
              const debug = initDebug("music-metadata:parser:APEv2");
              const tagFormat = "APEv2";
              const preamble = "APETAGEX";
              class APEv2Parser extends BasicParser_1.BasicParser {
                constructor() {
                  super(...arguments);
                  this.ape = {};
                }
                /**
                 * Calculate the media file duration
                 * @param ah ApeHeader
                 * @return {number} duration in seconds
                 */
                static calculateDuration(ah) {
                  let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;
                  duration += ah.finalFrameBlocks;
                  return duration / ah.sampleRate;
                }
                /**
                 * @param {INativeMetadataCollector} metadata
                 * @param {ITokenizer} tokenizer
                 * @param {IOptions} options
                 * @returns {Promise<boolean>} True if tags have been found
                 */
                static parseTagHeader(metadata, tokenizer, options) {
                  return __awaiter(this, void 0, void 0, function* () {
                    if (tokenizer.fileSize && tokenizer.fileSize - tokenizer.position < APEv2Token_1.TagFooter.len) {
                      debug(`No APEv2 header found, end-of-file reached`);
                      return;
                    }
                    const footer = yield tokenizer.peekToken(APEv2Token_1.TagFooter);
                    if (footer.ID === preamble) {
                      yield tokenizer.ignore(APEv2Token_1.TagFooter.len);
                      const tags = yield tokenizer.readToken(APEv2Token_1.TagField(footer));
                      APEv2Parser.parseTags(metadata, footer, tags, 0, !options.skipCovers);
                    } else {
                      debug(`APEv2 header not found at offset=${tokenizer.position}`);
                      if (tokenizer.fileSize) {
                        const remaining = tokenizer.fileSize - tokenizer.position;
                        const buffer = Buffer2.alloc(remaining);
                        yield tokenizer.readBuffer(buffer);
                        return APEv2Parser.parseTagFooter(metadata, buffer, !options.skipCovers);
                      }
                    }
                  });
                }
                static parseTagFooter(metadata, buffer, includeCovers) {
                  const footer = APEv2Token_1.TagFooter.get(buffer, buffer.length - APEv2Token_1.TagFooter.len);
                  assert.equal(footer.ID, preamble, "APEv2 Footer preamble");
                  this.parseTags(metadata, footer, buffer, buffer.length - footer.size, includeCovers);
                }
                static parseTags(metadata, footer, buffer, offset, includeCovers) {
                  for (let i = 0; i < footer.fields; i++) {
                    const tagItemHeader = APEv2Token_1.TagItemHeader.get(buffer, offset);
                    offset += APEv2Token_1.TagItemHeader.len;
                    let zero = Util_1.default.findZero(buffer, offset, buffer.length);
                    const key = buffer.toString("ascii", offset, zero);
                    offset = zero + 1;
                    switch (tagItemHeader.flags.dataType) {
                      case APEv2Token_1.DataType.text_utf8: {
                        const value = buffer.toString("utf8", offset, offset += tagItemHeader.size);
                        const values = value.split(/\x00/g);
                        for (const val of values) {
                          metadata.addTag(tagFormat, key, val);
                        }
                        break;
                      }
                      case APEv2Token_1.DataType.binary:
                        if (includeCovers) {
                          const picData = buffer.slice(offset, offset + tagItemHeader.size);
                          let off = 0;
                          zero = Util_1.default.findZero(picData, off, picData.length);
                          const description = picData.toString("utf8", off, zero);
                          off = zero + 1;
                          const data = Buffer2.from(picData.slice(off));
                          const fileType2 = FileType(data);
                          if (fileType2) {
                            if (fileType2.mime.indexOf("image/") === 0) {
                              const picture = {
                                description,
                                data,
                                format: fileType2.mime
                              };
                              offset += tagItemHeader.size;
                              metadata.addTag(tagFormat, key, picture);
                            } else {
                              debug(`Unexpected binary tag of type': ${fileType2.mime}`);
                            }
                          } else {
                            debug(`Failed to determine file type for binary tag: ${key}`);
                          }
                        }
                        break;
                      case APEv2Token_1.DataType.external_info:
                        debug(`Ignore external info ${key}`);
                        break;
                      default:
                        throw new Error(`Unexpected data-type: ${tagItemHeader.flags.dataType}`);
                    }
                  }
                }
                parse() {
                  return __awaiter(this, void 0, void 0, function* () {
                    const descriptor = yield this.tokenizer.readToken(APEv2Token_1.DescriptorParser);
                    assert.equal(descriptor.ID, "MAC ", "descriptor.ID");
                    this.ape.descriptor = descriptor;
                    const lenExp = descriptor.descriptorBytes - APEv2Token_1.DescriptorParser.len;
                    const header = yield lenExp > 0 ? this.parseDescriptorExpansion(lenExp) : this.parseHeader();
                    yield this.tokenizer.readToken(new Token.IgnoreType(header.forwardBytes));
                    return APEv2Parser.parseTagHeader(this.metadata, this.tokenizer, this.options);
                  });
                }
                parseDescriptorExpansion(lenExp) {
                  return __awaiter(this, void 0, void 0, function* () {
                    yield this.tokenizer.readToken(new Token.IgnoreType(lenExp));
                    return this.parseHeader();
                  });
                }
                parseHeader() {
                  return __awaiter(this, void 0, void 0, function* () {
                    const header = yield this.tokenizer.readToken(APEv2Token_1.Header);
                    this.metadata.setFormat("lossless", true);
                    this.metadata.setFormat("dataformat", "Monkey's Audio");
                    this.metadata.setFormat("bitsPerSample", header.bitsPerSample);
                    this.metadata.setFormat("sampleRate", header.sampleRate);
                    this.metadata.setFormat("numberOfChannels", header.channel);
                    this.metadata.setFormat("duration", APEv2Parser.calculateDuration(header));
                    return {
                      forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes + this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes
                    };
                  });
                }
              }
              exports2.APEv2Parser = APEv2Parser;
            }).call(this, __webpack_require__2(9).Buffer);
          },
          /* 46 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))(function(resolve2, reject2) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function rejected(value) {
                  try {
                    step(generator["throw"](value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function step(result) {
                  result.done ? resolve2(result.value) : new P(function(resolve3) {
                    resolve3(result.value);
                  }).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
              });
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            const type_1 = __webpack_require__2(22);
            const ID3v2_1 = __webpack_require__2(33);
            const ID3v2Parser_1 = __webpack_require__2(32);
            const ID3v1Parser_1 = __webpack_require__2(48);
            const _debug = __webpack_require__2(8);
            const BasicParser_1 = __webpack_require__2(20);
            const debug = _debug("music-metadata:parser:ID3");
            class AbstractID3Parser extends BasicParser_1.BasicParser {
              constructor() {
                super(...arguments);
                this.id3parser = new ID3v2Parser_1.ID3v2Parser();
              }
              static startsWithID3v2Header(tokenizer) {
                return __awaiter(this, void 0, void 0, function* () {
                  return (yield tokenizer.peekToken(ID3v2_1.ID3v2Token.Header)).fileIdentifier === "ID3";
                });
              }
              parse() {
                return this.parseID3v2().catch((err) => {
                  if (err.message === type_1.endOfFile)
                    return;
                  else
                    throw err;
                });
              }
              finalize() {
                return;
              }
              parseID3v2() {
                return __awaiter(this, void 0, void 0, function* () {
                  yield this.tryReadId3v2Headers();
                  debug("End of ID3v2 header, go to MPEG-parser: pos=%s", this.tokenizer.position);
                  yield this._parse();
                  if (this.options.skipPostHeaders && this.metadata.hasAny()) {
                    this.finalize();
                  } else {
                    const id3v1parser = new ID3v1Parser_1.ID3v1Parser();
                    yield id3v1parser.init(this.metadata, this.tokenizer, this.options).parse();
                    this.finalize();
                  }
                });
              }
              tryReadId3v2Headers() {
                return __awaiter(this, void 0, void 0, function* () {
                  const id3Header = yield this.tokenizer.peekToken(ID3v2_1.ID3v2Token.Header);
                  if (id3Header.fileIdentifier === "ID3") {
                    debug("Found ID3v2 header, pos=%s", this.tokenizer.position);
                    yield this.id3parser.parse(this.metadata, this.tokenizer, this.options);
                    return this.tryReadId3v2Headers();
                  }
                });
              }
            }
            exports2.AbstractID3Parser = AbstractID3Parser;
          },
          /* 47 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__2) {
            "use strict";
            __webpack_require__2.r(__webpack_exports__);
            var defineProperty = __webpack_require__2(2);
            var defineProperty_default = __webpack_require__2.n(defineProperty);
            var jsx_runtime = __webpack_require__2(0);
            var react = __webpack_require__2(1);
            var react_default = __webpack_require__2.n(react);
            var react_dom = __webpack_require__2(5);
            var react_dom_default = __webpack_require__2.n(react_dom);
            var prop_types = __webpack_require__2(60);
            var ReactReduxContext = react_default.a.createContext(null);
            if (false) {
            }
            var components_Context = ReactReduxContext;
            function defaultNoopBatch(callback) {
              callback();
            }
            var batch_batch = defaultNoopBatch;
            var setBatch = function setBatch2(newBatch) {
              return batch_batch = newBatch;
            };
            var getBatch = function getBatch2() {
              return batch_batch;
            };
            var nullListeners = {
              notify: function notify() {
              }
            };
            function createListenerCollection() {
              var batch = getBatch();
              var first = null;
              var last = null;
              return {
                clear: function clear() {
                  first = null;
                  last = null;
                },
                notify: function notify() {
                  batch(function() {
                    var listener = first;
                    while (listener) {
                      listener.callback();
                      listener = listener.next;
                    }
                  });
                },
                get: function get() {
                  var listeners = [];
                  var listener = first;
                  while (listener) {
                    listeners.push(listener);
                    listener = listener.next;
                  }
                  return listeners;
                },
                subscribe: function subscribe(callback) {
                  var isSubscribed = true;
                  var listener = last = {
                    callback,
                    next: null,
                    prev: last
                  };
                  if (listener.prev) {
                    listener.prev.next = listener;
                  } else {
                    first = listener;
                  }
                  return function unsubscribe() {
                    if (!isSubscribed || first === null) return;
                    isSubscribed = false;
                    if (listener.next) {
                      listener.next.prev = listener.prev;
                    } else {
                      last = listener.prev;
                    }
                    if (listener.prev) {
                      listener.prev.next = listener.next;
                    } else {
                      first = listener.next;
                    }
                  };
                }
              };
            }
            var Subscription = function() {
              function Subscription2(store, parentSub) {
                this.store = store;
                this.parentSub = parentSub;
                this.unsubscribe = null;
                this.listeners = nullListeners;
                this.handleChangeWrapper = this.handleChangeWrapper.bind(this);
              }
              var _proto = Subscription2.prototype;
              _proto.addNestedSub = function addNestedSub(listener) {
                this.trySubscribe();
                return this.listeners.subscribe(listener);
              };
              _proto.notifyNestedSubs = function notifyNestedSubs() {
                this.listeners.notify();
              };
              _proto.handleChangeWrapper = function handleChangeWrapper() {
                if (this.onStateChange) {
                  this.onStateChange();
                }
              };
              _proto.isSubscribed = function isSubscribed() {
                return Boolean(this.unsubscribe);
              };
              _proto.trySubscribe = function trySubscribe() {
                if (!this.unsubscribe) {
                  this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.handleChangeWrapper) : this.store.subscribe(this.handleChangeWrapper);
                  this.listeners = createListenerCollection();
                }
              };
              _proto.tryUnsubscribe = function tryUnsubscribe() {
                if (this.unsubscribe) {
                  this.unsubscribe();
                  this.unsubscribe = null;
                  this.listeners.clear();
                  this.listeners = nullListeners;
                }
              };
              return Subscription2;
            }();
            function Provider(_ref) {
              var store = _ref.store, context = _ref.context, children = _ref.children;
              var contextValue = Object(react["useMemo"])(function() {
                var subscription = new Subscription(store);
                subscription.onStateChange = subscription.notifyNestedSubs;
                return {
                  store,
                  subscription
                };
              }, [store]);
              var previousState = Object(react["useMemo"])(function() {
                return store.getState();
              }, [store]);
              Object(react["useEffect"])(function() {
                var subscription = contextValue.subscription;
                subscription.trySubscribe();
                if (previousState !== store.getState()) {
                  subscription.notifyNestedSubs();
                }
                return function() {
                  subscription.tryUnsubscribe();
                  subscription.onStateChange = null;
                };
              }, [contextValue, previousState]);
              var Context = context || ReactReduxContext;
              return react_default.a.createElement(Context.Provider, {
                value: contextValue
              }, children);
            }
            if (false) {
            }
            var components_Provider = Provider;
            function _extends() {
              _extends = Object.assign || function(target) {
                for (var i = 1; i < arguments.length; i++) {
                  var source = arguments[i];
                  for (var key in source) {
                    if (Object.prototype.hasOwnProperty.call(source, key)) {
                      target[key] = source[key];
                    }
                  }
                }
                return target;
              };
              return _extends.apply(this, arguments);
            }
            function _objectWithoutPropertiesLoose(source, excluded) {
              if (source == null) return {};
              var target = {};
              var sourceKeys = Object.keys(source);
              var key, i;
              for (i = 0; i < sourceKeys.length; i++) {
                key = sourceKeys[i];
                if (excluded.indexOf(key) >= 0) continue;
                target[key] = source[key];
              }
              return target;
            }
            var hoist_non_react_statics_cjs = __webpack_require__2(27);
            var hoist_non_react_statics_cjs_default = __webpack_require__2.n(hoist_non_react_statics_cjs);
            var react_is = __webpack_require__2(26);
            var useIsomorphicLayoutEffect = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? react["useLayoutEffect"] : react["useEffect"];
            var EMPTY_ARRAY = [];
            var NO_SUBSCRIPTION_ARRAY = [null, null];
            var stringifyComponent = function stringifyComponent2(Comp) {
              try {
                return JSON.stringify(Comp);
              } catch (err) {
                return String(Comp);
              }
            };
            function storeStateUpdatesReducer(state, action) {
              var updateCount = state[1];
              return [action.payload, updateCount + 1];
            }
            function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
              useIsomorphicLayoutEffect(function() {
                return effectFunc.apply(void 0, effectArgs);
              }, dependencies);
            }
            function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs) {
              lastWrapperProps.current = wrapperProps;
              lastChildProps.current = actualChildProps;
              renderIsScheduled.current = false;
              if (childPropsFromStoreUpdate.current) {
                childPropsFromStoreUpdate.current = null;
                notifyNestedSubs();
              }
            }
            function subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch) {
              if (!shouldHandleStateChanges) return;
              var didUnsubscribe = false;
              var lastThrownError = null;
              var checkForUpdates = function checkForUpdates2() {
                if (didUnsubscribe) {
                  return;
                }
                var latestStoreState = store.getState();
                var newChildProps, error;
                try {
                  newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);
                } catch (e) {
                  error = e;
                  lastThrownError = e;
                }
                if (!error) {
                  lastThrownError = null;
                }
                if (newChildProps === lastChildProps.current) {
                  if (!renderIsScheduled.current) {
                    notifyNestedSubs();
                  }
                } else {
                  lastChildProps.current = newChildProps;
                  childPropsFromStoreUpdate.current = newChildProps;
                  renderIsScheduled.current = true;
                  forceComponentUpdateDispatch({
                    type: "STORE_UPDATED",
                    payload: {
                      error
                    }
                  });
                }
              };
              subscription.onStateChange = checkForUpdates;
              subscription.trySubscribe();
              checkForUpdates();
              var unsubscribeWrapper = function unsubscribeWrapper2() {
                didUnsubscribe = true;
                subscription.tryUnsubscribe();
                subscription.onStateChange = null;
                if (lastThrownError) {
                  throw lastThrownError;
                }
              };
              return unsubscribeWrapper;
            }
            var initStateUpdates = function initStateUpdates2() {
              return [null, 0];
            };
            function connectAdvanced(selectorFactory, _ref) {
              if (_ref === void 0) {
                _ref = {};
              }
              var _ref2 = _ref, _ref2$getDisplayName = _ref2.getDisplayName, getDisplayName = _ref2$getDisplayName === void 0 ? function(name) {
                return "ConnectAdvanced(" + name + ")";
              } : _ref2$getDisplayName, _ref2$methodName = _ref2.methodName, methodName = _ref2$methodName === void 0 ? "connectAdvanced" : _ref2$methodName, _ref2$renderCountProp = _ref2.renderCountProp, renderCountProp = _ref2$renderCountProp === void 0 ? void 0 : _ref2$renderCountProp, _ref2$shouldHandleSta = _ref2.shouldHandleStateChanges, shouldHandleStateChanges = _ref2$shouldHandleSta === void 0 ? true : _ref2$shouldHandleSta, _ref2$storeKey = _ref2.storeKey, storeKey = _ref2$storeKey === void 0 ? "store" : _ref2$storeKey, _ref2$withRef = _ref2.withRef, withRef = _ref2$withRef === void 0 ? false : _ref2$withRef, _ref2$forwardRef = _ref2.forwardRef, forwardRef = _ref2$forwardRef === void 0 ? false : _ref2$forwardRef, _ref2$context = _ref2.context, context = _ref2$context === void 0 ? ReactReduxContext : _ref2$context, connectOptions = _objectWithoutPropertiesLoose(_ref2, ["getDisplayName", "methodName", "renderCountProp", "shouldHandleStateChanges", "storeKey", "withRef", "forwardRef", "context"]);
              if (false) {
                var customStoreWarningMessage;
              }
              var Context = context;
              return function wrapWithConnect(WrappedComponent) {
                if (false) {
                }
                var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
                var displayName = getDisplayName(wrappedComponentName);
                var selectorFactoryOptions = _extends({}, connectOptions, {
                  getDisplayName,
                  methodName,
                  renderCountProp,
                  shouldHandleStateChanges,
                  storeKey,
                  displayName,
                  wrappedComponentName,
                  WrappedComponent
                });
                var pure = connectOptions.pure;
                function createChildSelector(store) {
                  return selectorFactory(store.dispatch, selectorFactoryOptions);
                }
                var usePureOnlyMemo = pure ? react["useMemo"] : function(callback) {
                  return callback();
                };
                function ConnectFunction(props) {
                  var _useMemo = Object(react["useMemo"])(function() {
                    var reactReduxForwardedRef2 = props.reactReduxForwardedRef, wrapperProps2 = _objectWithoutPropertiesLoose(props, ["reactReduxForwardedRef"]);
                    return [props.context, reactReduxForwardedRef2, wrapperProps2];
                  }, [props]), propsContext = _useMemo[0], reactReduxForwardedRef = _useMemo[1], wrapperProps = _useMemo[2];
                  var ContextToUse = Object(react["useMemo"])(function() {
                    return propsContext && propsContext.Consumer && Object(react_is["isContextConsumer"])(react_default.a.createElement(propsContext.Consumer, null)) ? propsContext : Context;
                  }, [propsContext, Context]);
                  var contextValue = Object(react["useContext"])(ContextToUse);
                  var didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);
                  var didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);
                  if (false) {
                  }
                  var store = didStoreComeFromProps ? props.store : contextValue.store;
                  var childPropsSelector = Object(react["useMemo"])(function() {
                    return createChildSelector(store);
                  }, [store]);
                  var _useMemo2 = Object(react["useMemo"])(function() {
                    if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;
                    var subscription2 = new Subscription(store, didStoreComeFromProps ? null : contextValue.subscription);
                    var notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);
                    return [subscription2, notifyNestedSubs2];
                  }, [store, didStoreComeFromProps, contextValue]), subscription = _useMemo2[0], notifyNestedSubs = _useMemo2[1];
                  var overriddenContextValue = Object(react["useMemo"])(function() {
                    if (didStoreComeFromProps) {
                      return contextValue;
                    }
                    return _extends({}, contextValue, {
                      subscription
                    });
                  }, [didStoreComeFromProps, contextValue, subscription]);
                  var _useReducer = Object(react["useReducer"])(storeStateUpdatesReducer, EMPTY_ARRAY, initStateUpdates), _useReducer$ = _useReducer[0], previousStateUpdateResult = _useReducer$[0], forceComponentUpdateDispatch = _useReducer[1];
                  if (previousStateUpdateResult && previousStateUpdateResult.error) {
                    throw previousStateUpdateResult.error;
                  }
                  var lastChildProps = Object(react["useRef"])();
                  var lastWrapperProps = Object(react["useRef"])(wrapperProps);
                  var childPropsFromStoreUpdate = Object(react["useRef"])();
                  var renderIsScheduled = Object(react["useRef"])(false);
                  var actualChildProps = usePureOnlyMemo(function() {
                    if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
                      return childPropsFromStoreUpdate.current;
                    }
                    return childPropsSelector(store.getState(), wrapperProps);
                  }, [store, previousStateUpdateResult, wrapperProps]);
                  useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs]);
                  useIsomorphicLayoutEffectWithArgs(subscribeUpdates, [shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch], [store, subscription, childPropsSelector]);
                  var renderedWrappedComponent = Object(react["useMemo"])(function() {
                    return react_default.a.createElement(WrappedComponent, _extends({}, actualChildProps, {
                      ref: reactReduxForwardedRef
                    }));
                  }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);
                  var renderedChild = Object(react["useMemo"])(function() {
                    if (shouldHandleStateChanges) {
                      return react_default.a.createElement(ContextToUse.Provider, {
                        value: overriddenContextValue
                      }, renderedWrappedComponent);
                    }
                    return renderedWrappedComponent;
                  }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);
                  return renderedChild;
                }
                var Connect = pure ? react_default.a.memo(ConnectFunction) : ConnectFunction;
                Connect.WrappedComponent = WrappedComponent;
                Connect.displayName = displayName;
                if (forwardRef) {
                  var forwarded = react_default.a.forwardRef(function forwardConnectRef(props, ref) {
                    return react_default.a.createElement(Connect, _extends({}, props, {
                      reactReduxForwardedRef: ref
                    }));
                  });
                  forwarded.displayName = displayName;
                  forwarded.WrappedComponent = WrappedComponent;
                  return hoist_non_react_statics_cjs_default()(forwarded, WrappedComponent);
                }
                return hoist_non_react_statics_cjs_default()(Connect, WrappedComponent);
              };
            }
            function is(x, y) {
              if (x === y) {
                return x !== 0 || y !== 0 || 1 / x === 1 / y;
              } else {
                return x !== x && y !== y;
              }
            }
            function shallowEqual(objA, objB) {
              if (is(objA, objB)) return true;
              if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
                return false;
              }
              var keysA = Object.keys(objA);
              var keysB = Object.keys(objB);
              if (keysA.length !== keysB.length) return false;
              for (var i = 0; i < keysA.length; i++) {
                if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
                  return false;
                }
              }
              return true;
            }
            var redux = __webpack_require__2(12);
            function isPlainObject(obj) {
              if (typeof obj !== "object" || obj === null) return false;
              var proto = Object.getPrototypeOf(obj);
              if (proto === null) return true;
              var baseProto = proto;
              while (Object.getPrototypeOf(baseProto) !== null) {
                baseProto = Object.getPrototypeOf(baseProto);
              }
              return proto === baseProto;
            }
            function warning(message) {
              if (typeof console !== "undefined" && typeof console.error === "function") {
                console.error(message);
              }
              try {
                throw new Error(message);
              } catch (e) {
              }
            }
            function verifyPlainObject(value, displayName, methodName) {
              if (!isPlainObject(value)) {
                warning(methodName + "() in " + displayName + " must return a plain object. Instead received " + value + ".");
              }
            }
            function wrapMapToPropsConstant(getConstant) {
              return function initConstantSelector(dispatch, options) {
                var constant = getConstant(dispatch, options);
                function constantSelector() {
                  return constant;
                }
                constantSelector.dependsOnOwnProps = false;
                return constantSelector;
              };
            }
            function getDependsOnOwnProps(mapToProps) {
              return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== void 0 ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
            }
            function wrapMapToPropsFunc(mapToProps, methodName) {
              return function initProxySelector(dispatch, _ref) {
                var displayName = _ref.displayName;
                var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
                  return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
                };
                proxy.dependsOnOwnProps = true;
                proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
                  proxy.mapToProps = mapToProps;
                  proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
                  var props = proxy(stateOrDispatch, ownProps);
                  if (typeof props === "function") {
                    proxy.mapToProps = props;
                    proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
                    props = proxy(stateOrDispatch, ownProps);
                  }
                  if (false) {
                  }
                  return props;
                };
                return proxy;
              };
            }
            function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
              return typeof mapDispatchToProps === "function" ? wrapMapToPropsFunc(mapDispatchToProps, "mapDispatchToProps") : void 0;
            }
            function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
              return !mapDispatchToProps ? wrapMapToPropsConstant(function(dispatch) {
                return {
                  dispatch
                };
              }) : void 0;
            }
            function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
              return mapDispatchToProps && typeof mapDispatchToProps === "object" ? wrapMapToPropsConstant(function(dispatch) {
                return Object(redux["bindActionCreators"])(mapDispatchToProps, dispatch);
              }) : void 0;
            }
            var connect_mapDispatchToProps = [whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject];
            function whenMapStateToPropsIsFunction(mapStateToProps) {
              return typeof mapStateToProps === "function" ? wrapMapToPropsFunc(mapStateToProps, "mapStateToProps") : void 0;
            }
            function whenMapStateToPropsIsMissing(mapStateToProps) {
              return !mapStateToProps ? wrapMapToPropsConstant(function() {
                return {};
              }) : void 0;
            }
            var connect_mapStateToProps = [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing];
            function defaultMergeProps(stateProps, dispatchProps, ownProps) {
              return _extends({}, ownProps, stateProps, dispatchProps);
            }
            function wrapMergePropsFunc(mergeProps) {
              return function initMergePropsProxy(dispatch, _ref) {
                var displayName = _ref.displayName, pure = _ref.pure, areMergedPropsEqual = _ref.areMergedPropsEqual;
                var hasRunOnce = false;
                var mergedProps;
                return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
                  var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);
                  if (hasRunOnce) {
                    if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;
                  } else {
                    hasRunOnce = true;
                    mergedProps = nextMergedProps;
                    if (false) {
                    }
                  }
                  return mergedProps;
                };
              };
            }
            function whenMergePropsIsFunction(mergeProps) {
              return typeof mergeProps === "function" ? wrapMergePropsFunc(mergeProps) : void 0;
            }
            function whenMergePropsIsOmitted(mergeProps) {
              return !mergeProps ? function() {
                return defaultMergeProps;
              } : void 0;
            }
            var connect_mergeProps = [whenMergePropsIsFunction, whenMergePropsIsOmitted];
            function verify(selector, methodName, displayName) {
              if (!selector) {
                throw new Error("Unexpected value for " + methodName + " in " + displayName + ".");
              } else if (methodName === "mapStateToProps" || methodName === "mapDispatchToProps") {
                if (!Object.prototype.hasOwnProperty.call(selector, "dependsOnOwnProps")) {
                  warning("The selector for " + methodName + " of " + displayName + " did not specify a value for dependsOnOwnProps.");
                }
              }
            }
            function verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, displayName) {
              verify(mapStateToProps, "mapStateToProps", displayName);
              verify(mapDispatchToProps, "mapDispatchToProps", displayName);
              verify(mergeProps, "mergeProps", displayName);
            }
            function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {
              return function impureFinalPropsSelector(state, ownProps) {
                return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);
              };
            }
            function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {
              var areStatesEqual = _ref.areStatesEqual, areOwnPropsEqual = _ref.areOwnPropsEqual, areStatePropsEqual = _ref.areStatePropsEqual;
              var hasRunAtLeastOnce = false;
              var state;
              var ownProps;
              var stateProps;
              var dispatchProps;
              var mergedProps;
              function handleFirstCall(firstState, firstOwnProps) {
                state = firstState;
                ownProps = firstOwnProps;
                stateProps = mapStateToProps(state, ownProps);
                dispatchProps = mapDispatchToProps(dispatch, ownProps);
                mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
                hasRunAtLeastOnce = true;
                return mergedProps;
              }
              function handleNewPropsAndNewState() {
                stateProps = mapStateToProps(state, ownProps);
                if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
                mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
                return mergedProps;
              }
              function handleNewProps() {
                if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);
                if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
                mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
                return mergedProps;
              }
              function handleNewState() {
                var nextStateProps = mapStateToProps(state, ownProps);
                var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
                stateProps = nextStateProps;
                if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
                return mergedProps;
              }
              function handleSubsequentCalls(nextState, nextOwnProps) {
                var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
                var stateChanged = !areStatesEqual(nextState, state);
                state = nextState;
                ownProps = nextOwnProps;
                if (propsChanged && stateChanged) return handleNewPropsAndNewState();
                if (propsChanged) return handleNewProps();
                if (stateChanged) return handleNewState();
                return mergedProps;
              }
              return function pureFinalPropsSelector(nextState, nextOwnProps) {
                return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
              };
            }
            function finalPropsSelectorFactory(dispatch, _ref2) {
              var initMapStateToProps = _ref2.initMapStateToProps, initMapDispatchToProps = _ref2.initMapDispatchToProps, initMergeProps = _ref2.initMergeProps, options = _objectWithoutPropertiesLoose(_ref2, ["initMapStateToProps", "initMapDispatchToProps", "initMergeProps"]);
              var mapStateToProps = initMapStateToProps(dispatch, options);
              var mapDispatchToProps = initMapDispatchToProps(dispatch, options);
              var mergeProps = initMergeProps(dispatch, options);
              if (false) {
              }
              var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;
              return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
            }
            function match(arg, factories, name) {
              for (var i = factories.length - 1; i >= 0; i--) {
                var result = factories[i](arg);
                if (result) return result;
              }
              return function(dispatch, options) {
                throw new Error("Invalid value of type " + typeof arg + " for " + name + " argument when connecting component " + options.wrappedComponentName + ".");
              };
            }
            function strictEqual(a, b) {
              return a === b;
            }
            function createConnect(_temp) {
              var _ref = _temp === void 0 ? {} : _temp, _ref$connectHOC = _ref.connectHOC, connectHOC = _ref$connectHOC === void 0 ? connectAdvanced : _ref$connectHOC, _ref$mapStateToPropsF = _ref.mapStateToPropsFactories, mapStateToPropsFactories = _ref$mapStateToPropsF === void 0 ? connect_mapStateToProps : _ref$mapStateToPropsF, _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories, mapDispatchToPropsFactories = _ref$mapDispatchToPro === void 0 ? connect_mapDispatchToProps : _ref$mapDispatchToPro, _ref$mergePropsFactor = _ref.mergePropsFactories, mergePropsFactories = _ref$mergePropsFactor === void 0 ? connect_mergeProps : _ref$mergePropsFactor, _ref$selectorFactory = _ref.selectorFactory, selectorFactory = _ref$selectorFactory === void 0 ? finalPropsSelectorFactory : _ref$selectorFactory;
              return function connect(mapStateToProps, mapDispatchToProps, mergeProps, _ref2) {
                if (_ref2 === void 0) {
                  _ref2 = {};
                }
                var _ref3 = _ref2, _ref3$pure = _ref3.pure, pure = _ref3$pure === void 0 ? true : _ref3$pure, _ref3$areStatesEqual = _ref3.areStatesEqual, areStatesEqual = _ref3$areStatesEqual === void 0 ? strictEqual : _ref3$areStatesEqual, _ref3$areOwnPropsEqua = _ref3.areOwnPropsEqual, areOwnPropsEqual = _ref3$areOwnPropsEqua === void 0 ? shallowEqual : _ref3$areOwnPropsEqua, _ref3$areStatePropsEq = _ref3.areStatePropsEqual, areStatePropsEqual = _ref3$areStatePropsEq === void 0 ? shallowEqual : _ref3$areStatePropsEq, _ref3$areMergedPropsE = _ref3.areMergedPropsEqual, areMergedPropsEqual = _ref3$areMergedPropsE === void 0 ? shallowEqual : _ref3$areMergedPropsE, extraOptions = _objectWithoutPropertiesLoose(_ref3, ["pure", "areStatesEqual", "areOwnPropsEqual", "areStatePropsEqual", "areMergedPropsEqual"]);
                var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, "mapStateToProps");
                var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, "mapDispatchToProps");
                var initMergeProps = match(mergeProps, mergePropsFactories, "mergeProps");
                return connectHOC(selectorFactory, _extends({
                  // used in error messages
                  methodName: "connect",
                  // used to compute Connect's displayName from the wrapped component's displayName.
                  getDisplayName: function getDisplayName(name) {
                    return "Connect(" + name + ")";
                  },
                  // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
                  shouldHandleStateChanges: Boolean(mapStateToProps),
                  // passed through to selectorFactory
                  initMapStateToProps,
                  initMapDispatchToProps,
                  initMergeProps,
                  pure,
                  areStatesEqual,
                  areOwnPropsEqual,
                  areStatePropsEqual,
                  areMergedPropsEqual
                }, extraOptions));
              };
            }
            var connect_connect = createConnect();
            function useReduxContext_useReduxContext() {
              var contextValue = Object(react["useContext"])(ReactReduxContext);
              if (false) {
              }
              return contextValue;
            }
            function createStoreHook(context) {
              if (context === void 0) {
                context = ReactReduxContext;
              }
              var useReduxContext = context === ReactReduxContext ? useReduxContext_useReduxContext : function() {
                return Object(react["useContext"])(context);
              };
              return function useStore() {
                var _useReduxContext = useReduxContext(), store = _useReduxContext.store;
                return store;
              };
            }
            var useStore_useStore = createStoreHook();
            function createDispatchHook(context) {
              if (context === void 0) {
                context = ReactReduxContext;
              }
              var useStore = context === ReactReduxContext ? useStore_useStore : createStoreHook(context);
              return function useDispatch2() {
                var store = useStore();
                return store.dispatch;
              };
            }
            var useDispatch = createDispatchHook();
            var refEquality = function refEquality2(a, b) {
              return a === b;
            };
            function useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub) {
              var _useReducer = Object(react["useReducer"])(function(s) {
                return s + 1;
              }, 0), forceRender = _useReducer[1];
              var subscription = Object(react["useMemo"])(function() {
                return new Subscription(store, contextSub);
              }, [store, contextSub]);
              var latestSubscriptionCallbackError = Object(react["useRef"])();
              var latestSelector = Object(react["useRef"])();
              var latestStoreState = Object(react["useRef"])();
              var latestSelectedState = Object(react["useRef"])();
              var storeState = store.getState();
              var selectedState;
              try {
                if (selector !== latestSelector.current || storeState !== latestStoreState.current || latestSubscriptionCallbackError.current) {
                  selectedState = selector(storeState);
                } else {
                  selectedState = latestSelectedState.current;
                }
              } catch (err) {
                if (latestSubscriptionCallbackError.current) {
                  err.message += "\nThe error may be correlated with this previous error:\n" + latestSubscriptionCallbackError.current.stack + "\n\n";
                }
                throw err;
              }
              useIsomorphicLayoutEffect(function() {
                latestSelector.current = selector;
                latestStoreState.current = storeState;
                latestSelectedState.current = selectedState;
                latestSubscriptionCallbackError.current = void 0;
              });
              useIsomorphicLayoutEffect(function() {
                function checkForUpdates() {
                  try {
                    var newSelectedState = latestSelector.current(store.getState());
                    if (equalityFn(newSelectedState, latestSelectedState.current)) {
                      return;
                    }
                    latestSelectedState.current = newSelectedState;
                  } catch (err) {
                    latestSubscriptionCallbackError.current = err;
                  }
                  forceRender();
                }
                subscription.onStateChange = checkForUpdates;
                subscription.trySubscribe();
                checkForUpdates();
                return function() {
                  return subscription.tryUnsubscribe();
                };
              }, [store, subscription]);
              return selectedState;
            }
            function createSelectorHook(context) {
              if (context === void 0) {
                context = ReactReduxContext;
              }
              var useReduxContext = context === ReactReduxContext ? useReduxContext_useReduxContext : function() {
                return Object(react["useContext"])(context);
              };
              return function useSelector(selector, equalityFn) {
                if (equalityFn === void 0) {
                  equalityFn = refEquality;
                }
                if (false) {
                }
                var _useReduxContext = useReduxContext(), store = _useReduxContext.store, contextSub = _useReduxContext.subscription;
                var selectedState = useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub);
                Object(react["useDebugValue"])(selectedState);
                return selectedState;
              };
            }
            var useSelector_useSelector = createSelectorHook();
            setBatch(react_dom["unstable_batchedUpdates"]);
            function createThunkMiddleware(extraArgument) {
              return function(_ref) {
                var dispatch = _ref.dispatch, getState = _ref.getState;
                return function(next) {
                  return function(action) {
                    if (typeof action === "function") {
                      return action(dispatch, getState, extraArgument);
                    }
                    return next(action);
                  };
                };
              };
            }
            var thunk = createThunkMiddleware();
            thunk.withExtraArgument = createThunkMiddleware;
            var es = thunk;
            var redux_devtools_extension = __webpack_require__2(37);
            const ADD_TRACK_FROM_URL = "ADD_TRACK_FROM_URL";
            const CLOSE_WINAMP = "CLOSE_WINAMP";
            const OPEN_WINAMP = "OPEN_WINAMP";
            const MINIMIZE_WINAMP = "MINIMIZE_WINAMP";
            const IS_PLAYING = "IS_PLAYING";
            const IS_STOPPED = "IS_STOPPED";
            const PAUSE = "PAUSE";
            const PLAY = "PLAY";
            const SEEK_TO_PERCENT_COMPLETE = "SEEK_TO_PERCENT_COMPLETE";
            const SET_BALANCE = "SET_BALANCE";
            const SET_BAND_VALUE = "SET_BAND_VALUE";
            const SET_FOCUS = "SET_FOCUS";
            const SET_BAND_FOCUS = "SET_BAND_FOCUS";
            const SET_FOCUSED_WINDOW = "SET_FOCUSED_WINDOW";
            const SET_MEDIA = "SET_MEDIA";
            const SET_SCRUB_POSITION = "SET_SCRUB_POSITION";
            const SET_SKIN_DATA = "SET_SKIN_DATA";
            const SET_VOLUME = "SET_VOLUME";
            const START_WORKING = "START_WORKING";
            const STEP_MARQUEE = "STEP_MARQUEE";
            const STOP = "STOP";
            const STOP_WORKING = "STOP_WORKING";
            const TOGGLE_DOUBLESIZE_MODE = "TOGGLE_DOUBLESIZE_MODE";
            const SET_EQ_AUTO = "SET_EQ_AUTO";
            const SET_EQ_ON = "SET_EQ_ON";
            const SET_EQ_OFF = "SET_EQ_OFF";
            const TOGGLE_LLAMA_MODE = "TOGGLE_LLAMA_MODE";
            const TOGGLE_REPEAT = "TOGGLE_REPEAT";
            const TOGGLE_SHUFFLE = "TOGGLE_SHUFFLE";
            const TOGGLE_TIME_MODE = "TOGGLE_TIME_MODE";
            const TOGGLE_VISUALIZER_STYLE = "TOGGLE_VISUALIZER_STYLE";
            const UNSET_FOCUS = "UNSET_FOCUS";
            const UPDATE_TIME_ELAPSED = "UPDATE_TIME_ELAPSED";
            const SET_USER_MESSAGE = "SET_USER_MESSAGE";
            const UNSET_USER_MESSAGE = "UNSET_USER_MESSAGE";
            const SET_PLAYLIST_SCROLL_POSITION = "SET_PLAYLIST_SCROLL_POSITION";
            const CLICKED_TRACK = "CLICKED_TRACK";
            const CTRL_CLICKED_TRACK = "CTRL_CLICKED_TRACK";
            const SHIFT_CLICKED_TRACK = "SHIFT_CLICKED_TRACK";
            const SELECT_ALL = "SELECT_ALL";
            const SELECT_ZERO = "SELECT_ZERO";
            const INVERT_SELECTION = "INVERT_SELECTION";
            const REMOVE_ALL_TRACKS = "REMOVE_ALL_TRACKS";
            const CROP_TRACKS = "CROP_TRACKS";
            const FILE_INFO = "FILE_INFO";
            const REMOVE_TRACKS = "REMOVE_TRACKS";
            const SET_AVAILABLE_SKINS = "SET_AVAILABLE_SKINS";
            const REVERSE_LIST = "REVERSE_LIST";
            const RANDOMIZE_LIST = "RANDOMIZE_LIST";
            const SET_TRACK_ORDER = "SET_TRACK_ORDER";
            const PLAY_TRACK = "PLAY_TRACK";
            const BUFFER_TRACK = "BUFFER_TRACK";
            const DRAG_SELECTED = "DRAG_SELECTED";
            const SET_MEDIA_TAGS = "SET_MEDIA_TAGS";
            const SET_MEDIA_DURATION = "SET_MEDIA_DURATION";
            const TOGGLE_WINDOW = "TOGGLE_WINDOW";
            const CLOSE_WINDOW = "CLOSE_WINDOW";
            const MEDIA_TAG_REQUEST_INITIALIZED = "MEDIA_TAG_REQUEST_INITIALIZED";
            const MEDIA_TAG_REQUEST_FAILED = "MEDIA_TAG_REQUEST_FAILED";
            const NETWORK_CONNECTED = "NETWORK_CONNECTED";
            const NETWORK_DISCONNECTED = "NETWORK_DISCONNECTED";
            const UPDATE_WINDOW_POSITIONS = "UPDATE_WINDOW_POSITIONS";
            const WINDOW_SIZE_CHANGED = "WINDOW_SIZE_CHANGED";
            const TOGGLE_WINDOW_SHADE_MODE = "TOGGLE_WINDOW_SHADE_MODE";
            const LOADED = "LOADED";
            const SET_Z_INDEX = "SET_Z_INDEX";
            const DISABLE_MARQUEE = "DISABLE_MARQUEE";
            const SET_DUMMY_VIZ_DATA = "SET_DUMMY_VIZ_DATA";
            const LOADING = "LOADING";
            const CLOSE_REQUESTED = "CLOSE_REQUESTED";
            const LOAD_SERIALIZED_STATE = "LOAD_SERIALIZED_STATE";
            const RESET_WINDOW_SIZES = "RESET_WINDOW_SIZES";
            const BROWSER_WINDOW_SIZE_CHANGED = "BROWSER_WINDOW_SIZE_CHANGED";
            const LOAD_DEFAULT_SKIN = "LOAD_DEFAULT_SKIN";
            const ENABLE_MILKDROP = "ENABLE_MILKDROP";
            const SET_MILKDROP_DESKTOP = "SET_MILKDROP_DESKTOP";
            const SET_VISUALIZER_STYLE = "SET_VISUALIZER_STYLE";
            const GOT_BUTTERCHURN_PRESETS = "GOT_BUTTERCHURN_PRESETS";
            const GOT_BUTTERCHURN = "GOT_BUTTERCHURN";
            const RESOLVE_PRESET_AT_INDEX = "RESOLVE_PRESET_AT_INDEX";
            const SELECT_PRESET_AT_INDEX = "SELECT_PRESET_AT_INDEX";
            const TOGGLE_PRESET_OVERLAY = "TOGGLE_PRESET_OVERLAY";
            const PRESET_REQUESTED = "PRESET_REQUESTED";
            const TOGGLE_RANDOMIZE_PRESETS = "TOGGLE_RANDOMIZE_PRESETS";
            const TOGGLE_PRESET_CYCLING = "TOGGLE_PRESET_CYCLING";
            const SCHEDULE_MILKDROP_MESSAGE = "SCHEDULE_MILKDROP_MESSAGE";
            const SET_MILKDROP_FULLSCREEN = "SET_MILKDROP_FULLSCREEN";
            var baseSkin = __webpack_require__2(38);
            const BANDS = [60, 170, 310, 600, 1e3, 3e3, 6e3, 12e3, 14e3, 16e3];
            const WINDOWS = {
              MAIN: "main",
              PLAYLIST: "playlist",
              EQUALIZER: "equalizer",
              MILKDROP: "milkdrop"
            };
            const LOAD_STYLE = {
              BUFFER: "BUFFER",
              PLAY: "PLAY",
              NONE: "NONE"
            };
            const MEDIA_TAG_REQUEST_STATUS = {
              INITIALIZED: "INITIALIZED",
              FAILED: "FAILED",
              COMPLETE: "COMPLETE",
              NOT_REQUESTED: "NOT_REQUESTED"
            };
            const UTF8_ELLIPSIS = "…";
            const CHARACTER_WIDTH = 5;
            const WINDOW_RESIZE_SEGMENT_WIDTH = 25;
            const WINDOW_RESIZE_SEGMENT_HEIGHT = 29;
            const WINDOW_HEIGHT = 116;
            const WINDOW_WIDTH = 275;
            const TRACK_HEIGHT = 13;
            const LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
            const DEFAULT_SKIN = baseSkin;
            const VISUALIZERS = {
              OSCILLOSCOPE: "OSCILLOSCOPE",
              BAR: "BAR",
              NONE: "NONE",
              MILKDROP: "MILKDROP"
            };
            const VISUALIZER_ORDER = [
              VISUALIZERS.BAR,
              VISUALIZERS.OSCILLOSCOPE,
              // TODO: Verify the order
              VISUALIZERS.NONE
            ];
            const TIME_MODE = {
              ELAPSED: "ELAPSED",
              REMAINING: "REMAINING"
            };
            const MEDIA_STATUS = {
              PLAYING: "PLAYING",
              STOPPED: "STOPPED",
              PAUSED: "PAUSED"
            };
            function imgFromUrl(url) {
              return new Promise((resolve2, reject2) => {
                const img = new Image();
                img.onload = () => {
                  resolve2(img);
                };
                img.onerror = reject2;
                img.src = url;
              });
            }
            const getTimeObj = (time) => {
              if (time == null) {
                return {
                  minutesFirstDigit: " ",
                  minutesSecondDigit: " ",
                  secondsFirstDigit: " ",
                  secondsSecondDigit: " "
                };
              }
              const minutes = Math.floor(time / 60);
              const seconds = time % 60;
              const digits = time == null ? [" ", " ", " ", " "] : [String(Math.floor(minutes / 10)), String(Math.floor(minutes % 10)), String(Math.floor(seconds / 10)), String(Math.floor(seconds % 10))];
              const [minutesFirstDigit, minutesSecondDigit, secondsFirstDigit, secondsSecondDigit] = digits;
              return {
                minutesFirstDigit,
                minutesSecondDigit,
                secondsFirstDigit,
                secondsSecondDigit
              };
            };
            const getTimeStr = (time, truncate = true) => {
              if (time == null) {
                return "";
              }
              const {
                minutesFirstDigit,
                minutesSecondDigit,
                secondsFirstDigit,
                secondsSecondDigit
              } = getTimeObj(time);
              return [truncate && minutesFirstDigit === "0" ? "" : minutesFirstDigit, minutesSecondDigit, ":", secondsFirstDigit, secondsSecondDigit].join("");
            };
            const parseViscolors = (text) => {
              const entries = text.split("\n");
              const regex = /^\s*(\d+)\s*,?\s*(\d+)\s*,?\s*(\d+)/;
              const colors = [...DEFAULT_SKIN.colors];
              entries.map((line) => regex.exec(line)).filter(Boolean).map((matches) => matches.slice(1, 4).join(",")).map((rgb, i) => {
                colors[i] = `rgb(${rgb})`;
              });
              return colors;
            };
            const SECTION_REGEX = /^\s*\[(.+?)\]\s*$/;
            const PROPERTY_REGEX = /^\s*([^;][^=]*)\s*=\s*(.*)\s*$/;
            const parseIni = (text) => {
              let section, match2;
              return text.split(/[\r\n]+/g).reduce((data, line) => {
                if ((match2 = line.match(PROPERTY_REGEX)) && section != null) {
                  const key = match2[1].trim().toLowerCase();
                  const value = match2[2].replace(/\=.*$/g, "").trim().replace(/(^")|("$)|(^')|('$)/g, "");
                  data[section][key] = value;
                } else if (match2 = line.match(SECTION_REGEX)) {
                  section = match2[1].trim().toLowerCase();
                  data[section] = {};
                }
                return data;
              }, {});
            };
            const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
            const sum = (values) => values.reduce((total, value) => total + value, 0);
            function base64FromDataArray(dataArray) {
              return window.btoa(Array.from(dataArray).map((byte) => String.fromCharCode(byte)).join(""));
            }
            const base64FromArrayBuffer = (arrayBuffer) => {
              return base64FromDataArray(new Uint8Array(arrayBuffer));
            };
            function downloadURI(uri, name) {
              const link = document.createElement("a");
              link.download = name;
              link.href = uri;
              window.document.body.appendChild(link);
              link.click();
              window.document.body.removeChild(link);
            }
            const toPercent = (min, max, value) => (value - min) / (max - min);
            const percentToRange = (percent, min, max) => min + Math.round(percent * (max - min));
            const percentToIndex = (percent, length) => percentToRange(percent, 0, length - 1);
            const rebound = (oldMin, oldMax, newMin, newMax) => (oldValue) => percentToRange(toPercent(oldMin, oldMax, oldValue), newMin, newMax);
            const normalizeEqBand = rebound(1, 64, 0, 100);
            const denormalizeEqBand = rebound(0, 100, 1, 64);
            function merge(target, source) {
              const s = source;
              const t = target;
              for (const key of Object.keys(s)) {
                if (s[key] instanceof Object) Object.assign(s[key], merge(t[key], s[key]));
              }
              Object.assign(target || {}, source);
              return target;
            }
            function segment(min, max, value, newValues) {
              const ratio = toPercent(min, max, value);
              return newValues[percentToIndex(ratio, newValues.length)];
            }
            function utils_shuffle(array) {
              const sorted = [...array];
              let m = sorted.length;
              while (m) {
                const i = Math.floor(Math.random() * m--);
                const val = sorted[m];
                sorted[m] = sorted[i];
                sorted[i] = val;
              }
              return sorted;
            }
            function sort(array, iteratee) {
              return [...array].sort((a, b) => {
                const aKey = iteratee(a);
                const bKey = iteratee(b);
                if (aKey < bKey) {
                  return -1;
                } else if (aKey > bKey) {
                  return 1;
                }
                return 0;
              });
            }
            function moveSelected(arr, isSelected, offset) {
              const newArr = new Array(arr.length);
              let next = 0;
              for (let i = 0; i < newArr.length; i++) {
                const from = i - offset;
                if (from >= 0 && from < arr.length && isSelected(from)) {
                  newArr[i] = arr[from];
                } else {
                  while (next < arr.length && isSelected(next)) {
                    next++;
                  }
                  newArr[i] = arr[next];
                  next++;
                }
              }
              return newArr;
            }
            function spliceIn(original, start, newValues) {
              const newArr = [...original];
              newArr.splice(start, 0, ...newValues);
              return newArr;
            }
            function replaceAtIndex(arr, index, newValue) {
              return [...arr.slice(0, index), newValue, ...arr.slice(index + 1)];
            }
            function debounce(func, delay) {
              let timeout;
              let callbackArgs = [];
              return function(context, ...args) {
                callbackArgs = args;
                if (timeout != null) {
                  clearTimeout(timeout);
                }
                timeout = window.setTimeout(() => {
                  func.apply(context, callbackArgs);
                }, delay);
              };
            }
            function throttle(func, delay) {
              let timeout = null;
              let callbackArgs = [];
              return function(context, ...args) {
                callbackArgs = args;
                if (!timeout) {
                  timeout = window.setTimeout(() => {
                    func.apply(context, callbackArgs);
                    timeout = null;
                  }, delay);
                }
              };
            }
            let counter = 0;
            function uniqueId() {
              return counter++;
            }
            function objectForEach(obj, cb) {
              Object.keys(obj).forEach((key) => cb(obj[key], key));
            }
            function objectMap(obj, cb) {
              const modified = {};
              Object.keys(obj).forEach((key) => modified[key] = cb(obj[key], key));
              return modified;
            }
            function objectFilter(obj, predicate) {
              return Object.keys(obj).reduce((newObj, key) => {
                if (predicate(obj[key], key)) {
                  newObj[key] = obj[key];
                }
                return newObj;
              }, {});
            }
            const calculateBoundingBox = (windows) => {
              if (windows.length === 0) {
                return null;
              }
              const windowSizes = windows.map((w) => ({
                left: w.x,
                top: w.y,
                bottom: w.y + w.height,
                right: w.x + w.width
              }));
              return windowSizes.reduce((b, w) => ({
                left: Math.min(b.left, w.left),
                top: Math.min(b.top, w.top),
                bottom: Math.max(b.bottom, w.bottom),
                right: Math.max(b.right, w.right)
              }));
            };
            function findLastIndex(arr, cb) {
              for (let i = arr.length - 1; i >= 0; i--) {
                if (cb(arr[i])) {
                  return i;
                }
              }
              return -1;
            }
            function utils_getWindowSize() {
              return {
                width: Math.max(document.body.scrollWidth, document.documentElement.scrollWidth, document.body.offsetWidth, document.documentElement.offsetWidth, document.body.clientWidth, document.documentElement.clientWidth),
                height: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight)
              };
            }
            function getScreenSize() {
              return {
                width: window.screen.width,
                height: window.screen.height
              };
            }
            function getPos(e) {
              switch (e.type) {
                case "touchstart":
                case "touchmove": {
                  var _targetTouches$;
                  const touch = (_targetTouches$ = e.targetTouches[0]) !== null && _targetTouches$ !== void 0 ? _targetTouches$ : e.touches[0];
                  if (touch == null) {
                    throw new Error("Unexpected touch event with zero touch targets.");
                  }
                  return touch;
                }
                case "mousedown":
                case "mousemove": {
                  return e;
                }
                default:
                  throw new Error(`Unexpected event type: ${e.type}`);
              }
            }
            function getX(e) {
              return getPos(e).clientX;
            }
            function getY(e) {
              return getPos(e).clientY;
            }
            function weakMapMemoize(func) {
              const cache = /* @__PURE__ */ new WeakMap();
              return (value) => {
                if (!cache.has(value)) {
                  cache.set(value, func(value));
                }
                return cache.get(value);
              };
            }
            function ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function _objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            const defaultPlaylistState = {
              trackOrder: [],
              currentTrack: null,
              lastSelectedIndex: null,
              selectedTracks: /* @__PURE__ */ new Set()
            };
            function toggleSetMembership(set, value) {
              if (set.has(value)) {
                set.delete(value);
              } else {
                set.add(value);
              }
            }
            const playlist = (state = defaultPlaylistState, action) => {
              switch (action.type) {
                case CLICKED_TRACK:
                  return _objectSpread(_objectSpread({}, state), {}, {
                    selectedTracks: /* @__PURE__ */ new Set([state.trackOrder[action.index]]),
                    lastSelectedIndex: action.index
                  });
                case CTRL_CLICKED_TRACK: {
                  const id = state.trackOrder[action.index];
                  const newSelectedTracks = new Set(state.selectedTracks);
                  toggleSetMembership(newSelectedTracks, id);
                  return _objectSpread(_objectSpread({}, state), {}, {
                    selectedTracks: newSelectedTracks,
                    // Using this as the lastClickedIndex is kinda funny, since you
                    // may have just _un_selected the track. However, this is what
                    // Winamp 2 does, so we'll copy it.
                    lastSelectedIndex: action.index
                  });
                }
                case SHIFT_CLICKED_TRACK:
                  if (state.lastSelectedIndex == null) {
                    return state;
                  }
                  const clickedIndex = action.index;
                  const start = Math.min(clickedIndex, state.lastSelectedIndex);
                  const end = Math.max(clickedIndex, state.lastSelectedIndex);
                  const selectedTracks = new Set(state.trackOrder.slice(start, end + 1));
                  return _objectSpread(_objectSpread({}, state), {}, {
                    selectedTracks
                  });
                case SELECT_ALL:
                  return _objectSpread(_objectSpread({}, state), {}, {
                    selectedTracks: new Set(state.trackOrder)
                  });
                case SELECT_ZERO:
                  return _objectSpread(_objectSpread({}, state), {}, {
                    selectedTracks: /* @__PURE__ */ new Set()
                  });
                case INVERT_SELECTION:
                  return _objectSpread(_objectSpread({}, state), {}, {
                    selectedTracks: new Set(state.trackOrder.filter((id) => !state.selectedTracks.has(id)))
                  });
                case REMOVE_ALL_TRACKS:
                  return _objectSpread(_objectSpread({}, state), {}, {
                    trackOrder: [],
                    currentTrack: null,
                    selectedTracks: /* @__PURE__ */ new Set(),
                    lastSelectedIndex: null
                  });
                case REMOVE_TRACKS:
                  const actionIds = new Set(action.ids.map(Number));
                  const {
                    currentTrack
                  } = state;
                  return _objectSpread(_objectSpread({}, state), {}, {
                    trackOrder: state.trackOrder.filter((trackId) => !actionIds.has(trackId)),
                    currentTrack: actionIds.has(Number(currentTrack)) ? null : currentTrack,
                    selectedTracks: new Set(Array.from(state.selectedTracks).filter((id) => actionIds.has(id))),
                    // TODO: This could probably be made to work, but we clear it just to be safe.
                    lastSelectedIndex: null
                  });
                case REVERSE_LIST:
                  return _objectSpread(_objectSpread({}, state), {}, {
                    trackOrder: [...state.trackOrder].reverse(),
                    // TODO: This could probably be made to work, but we clear it just to be safe.
                    lastSelectedIndex: null
                  });
                case RANDOMIZE_LIST:
                  return _objectSpread(_objectSpread({}, state), {}, {
                    trackOrder: utils_shuffle(state.trackOrder)
                  });
                case SET_TRACK_ORDER:
                  const {
                    trackOrder
                  } = action;
                  return _objectSpread(_objectSpread({}, state), {}, {
                    trackOrder
                  });
                case ADD_TRACK_FROM_URL:
                  const atIndex = action.atIndex == null ? state.trackOrder.length : action.atIndex;
                  return _objectSpread(_objectSpread({}, state), {}, {
                    trackOrder: [...state.trackOrder.slice(0, atIndex), Number(action.id), ...state.trackOrder.slice(atIndex)],
                    // TODO: This could probably be made to work, but we clear it just to be safe.
                    lastSelectedIndex: null
                  });
                case PLAY_TRACK:
                case BUFFER_TRACK:
                  return _objectSpread(_objectSpread({}, state), {}, {
                    currentTrack: action.id
                  });
                case DRAG_SELECTED:
                  return _objectSpread(_objectSpread({}, state), {}, {
                    trackOrder: moveSelected(state.trackOrder, (i) => state.selectedTracks.has(state.trackOrder[i]), action.offset),
                    // TODO: This could probably be made to work, but we clear it just to be safe.
                    lastSelectedIndex: null
                  });
                default:
                  return state;
              }
            };
            var reducers_playlist = playlist;
            var objectWithoutProperties = __webpack_require__2(7);
            var objectWithoutProperties_default = __webpack_require__2.n(objectWithoutProperties);
            function windows_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function windows_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  windows_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  windows_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            const defaultWindowsState = {
              focused: WINDOWS.MAIN,
              positionsAreRelative: true,
              genWindows: {
                // TODO: Remove static capabilites and derive them from ids/generic
                [WINDOWS.MAIN]: {
                  title: "Main Window",
                  size: [0, 0],
                  open: true,
                  shade: false,
                  canResize: false,
                  canShade: true,
                  canDouble: true,
                  hotkey: "Alt+W",
                  position: {
                    x: 0,
                    y: 0
                  }
                },
                [WINDOWS.EQUALIZER]: {
                  title: "Equalizer",
                  size: [0, 0],
                  open: true,
                  shade: false,
                  canResize: false,
                  canShade: true,
                  canDouble: true,
                  hotkey: "Alt+G",
                  position: {
                    x: 0,
                    y: 0
                  }
                },
                [WINDOWS.PLAYLIST]: {
                  title: "Playlist Editor",
                  size: [0, 0],
                  open: true,
                  shade: false,
                  canResize: true,
                  canShade: true,
                  canDouble: false,
                  hotkey: "Alt+E",
                  position: {
                    x: 0,
                    y: 0
                  }
                }
              },
              browserWindowSize: {
                width: 0,
                height: 0
              },
              windowOrder: [WINDOWS.PLAYLIST, WINDOWS.EQUALIZER, WINDOWS.MILKDROP, WINDOWS.MAIN]
            };
            const windows_windows = (state = defaultWindowsState, action) => {
              switch (action.type) {
                case ENABLE_MILKDROP:
                  return windows_objectSpread(windows_objectSpread({}, state), {}, {
                    genWindows: windows_objectSpread(windows_objectSpread({}, state.genWindows), {}, {
                      [WINDOWS.MILKDROP]: {
                        title: "Milkdrop",
                        size: [0, 0],
                        open: action.open,
                        shade: false,
                        canResize: true,
                        canShade: false,
                        canDouble: false,
                        position: {
                          x: 0,
                          y: 0
                        }
                      }
                    })
                  });
                case SET_FOCUSED_WINDOW:
                  let windowOrder = state.windowOrder;
                  if (action.window != null) {
                    windowOrder = [...state.windowOrder.filter((windowId) => windowId !== action.window), action.window];
                  }
                  return windows_objectSpread(windows_objectSpread({}, state), {}, {
                    focused: action.window,
                    windowOrder
                  });
                case TOGGLE_WINDOW_SHADE_MODE:
                  const {
                    canShade
                  } = state.genWindows[action.windowId];
                  if (!canShade) {
                    throw new Error(`Tried to shade/unshade a window that cannot be shaded: ${action.windowId}`);
                  }
                  return windows_objectSpread(windows_objectSpread({}, state), {}, {
                    genWindows: windows_objectSpread(windows_objectSpread({}, state.genWindows), {}, {
                      [action.windowId]: windows_objectSpread(windows_objectSpread({}, state.genWindows[action.windowId]), {}, {
                        shade: !state.genWindows[action.windowId].shade
                      })
                    })
                  });
                case TOGGLE_WINDOW:
                  const windowState = state.genWindows[action.windowId];
                  return windows_objectSpread(windows_objectSpread({}, state), {}, {
                    genWindows: windows_objectSpread(windows_objectSpread({}, state.genWindows), {}, {
                      [action.windowId]: windows_objectSpread(windows_objectSpread({}, windowState), {}, {
                        open: !windowState.open
                      })
                    })
                  });
                case CLOSE_WINDOW:
                  return windows_objectSpread(windows_objectSpread({}, state), {}, {
                    genWindows: windows_objectSpread(windows_objectSpread({}, state.genWindows), {}, {
                      [action.windowId]: windows_objectSpread(windows_objectSpread({}, state.genWindows[action.windowId]), {}, {
                        open: false
                      })
                    })
                  });
                case WINDOW_SIZE_CHANGED:
                  const {
                    canResize
                  } = state.genWindows[action.windowId];
                  if (!canResize) {
                    throw new Error(`Tried to resize a window that cannot be resized: ${action.windowId}`);
                  }
                  return windows_objectSpread(windows_objectSpread({}, state), {}, {
                    genWindows: windows_objectSpread(windows_objectSpread({}, state.genWindows), {}, {
                      [action.windowId]: windows_objectSpread(windows_objectSpread({}, state.genWindows[action.windowId]), {}, {
                        size: action.size
                      })
                    })
                  });
                case UPDATE_WINDOW_POSITIONS:
                  return windows_objectSpread(windows_objectSpread({}, state), {}, {
                    positionsAreRelative: action.absolute === true ? false : state.positionsAreRelative,
                    genWindows: objectMap(state.genWindows, (w, windowId) => {
                      const newPosition = action.positions[windowId];
                      if (newPosition == null) {
                        return w;
                      }
                      return windows_objectSpread(windows_objectSpread({}, w), {}, {
                        position: newPosition
                      });
                    })
                  });
                case RESET_WINDOW_SIZES:
                  return windows_objectSpread(windows_objectSpread({}, state), {}, {
                    genWindows: objectMap(state.genWindows, (w) => windows_objectSpread(windows_objectSpread({}, w), {}, {
                      // Not sure why TypeScript can't figure this out for itself.
                      size: [0, 0]
                    }))
                  });
                case LOAD_SERIALIZED_STATE: {
                  const {
                    genWindows,
                    focused,
                    positionsAreRelative
                  } = action.serializedState.windows;
                  return windows_objectSpread(windows_objectSpread({}, state), {}, {
                    positionsAreRelative,
                    genWindows: objectMap(state.genWindows, (w, windowId) => {
                      const serializedW = genWindows[windowId];
                      if (serializedW == null) {
                        return w;
                      }
                      const {
                        hidden
                      } = serializedW, rest = objectWithoutProperties_default()(serializedW, ["hidden"]);
                      return windows_objectSpread(windows_objectSpread({}, w), rest);
                    }),
                    focused
                  });
                }
                case BROWSER_WINDOW_SIZE_CHANGED:
                  return windows_objectSpread(windows_objectSpread({}, state), {}, {
                    browserWindowSize: {
                      height: action.height,
                      width: action.width
                    }
                  });
                default:
                  return state;
              }
            };
            function getSerializedState(state) {
              return {
                positionsAreRelative: state.positionsAreRelative,
                genWindows: objectMap(state.genWindows, (w) => {
                  return {
                    size: w.size,
                    open: w.open,
                    hidden: false,
                    // Not used any more
                    shade: w.shade || false,
                    position: w.position
                  };
                }),
                focused: state.focused
              };
            }
            var reducers_windows = windows_windows;
            function media_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function media_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  media_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  media_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            const defaultState = {
              timeMode: TIME_MODE.ELAPSED,
              timeElapsed: 0,
              // The winamp ini file declares the default volume as "200".
              // The UI seems to show a default volume near 78, which would
              // math with the default value being 200 out of 255.
              volume: Math.round(200 / 255 * 100),
              balance: 0,
              shuffle: false,
              repeat: false,
              // TODO: Enforce possible values
              status: MEDIA_STATUS.STOPPED
            };
            const media_media = (state = defaultState, action) => {
              switch (action.type) {
                case PLAY:
                case IS_PLAYING:
                  return media_objectSpread(media_objectSpread({}, state), {}, {
                    status: MEDIA_STATUS.PLAYING
                  });
                case PAUSE:
                  return media_objectSpread(media_objectSpread({}, state), {}, {
                    status: MEDIA_STATUS.PAUSED
                  });
                case STOP:
                case IS_STOPPED:
                  return media_objectSpread(media_objectSpread({}, state), {}, {
                    status: MEDIA_STATUS.STOPPED
                  });
                case TOGGLE_TIME_MODE:
                  const newMode = state.timeMode === TIME_MODE.REMAINING ? TIME_MODE.ELAPSED : TIME_MODE.REMAINING;
                  return media_objectSpread(media_objectSpread({}, state), {}, {
                    timeMode: newMode
                  });
                case UPDATE_TIME_ELAPSED:
                  return media_objectSpread(media_objectSpread({}, state), {}, {
                    timeElapsed: action.elapsed
                  });
                case SET_MEDIA:
                  return media_objectSpread({}, state);
                case SET_VOLUME:
                  return media_objectSpread(media_objectSpread({}, state), {}, {
                    volume: action.volume
                  });
                case SET_BALANCE:
                  return media_objectSpread(media_objectSpread({}, state), {}, {
                    balance: action.balance
                  });
                case TOGGLE_REPEAT:
                  return media_objectSpread(media_objectSpread({}, state), {}, {
                    repeat: !state.repeat
                  });
                case TOGGLE_SHUFFLE:
                  return media_objectSpread(media_objectSpread({}, state), {}, {
                    shuffle: !state.shuffle
                  });
                case LOAD_SERIALIZED_STATE:
                  return media_objectSpread(media_objectSpread({}, state), action.serializedState.media);
                default:
                  return state;
              }
            };
            function media_getSerializedState(state) {
              const {
                volume,
                balance,
                shuffle,
                repeat
              } = state;
              return {
                volume,
                balance,
                shuffle,
                repeat
              };
            }
            var reducers_media = media_media;
            var lib = __webpack_require__2(3);
            function display_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function display_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  display_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  display_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            const defaultSkinGenExColors = {
              itemBackground: "rgb(0,0,0)",
              itemForeground: "rgb(0,255,0)",
              windowBackground: "rgb(56,55,87)",
              buttonText: "rgb(57,57,66)",
              windowText: "rgb(255,255,255)",
              divider: "rgb(117,116,139)",
              playlistSelection: "rgb(0,0,198)",
              listHeaderBackground: "rgb(72,72,120)",
              listHeaderText: "rgb(255,255,255)",
              listHeaderFrameTopAndLeft: "rgb(108,108,180)",
              listHeaderFrameBottomAndRight: "rgb(36,36,60)",
              listHeaderFramePressed: "rgb(18,18,30)",
              listHeaderDeadArea: "rgb(36,36,60)",
              scrollbarOne: "rgb(36,36,60)",
              scrollbarTwo: "rgb(36,36,60)",
              pressedScrollbarOne: "rgb(121,130,150)",
              pressedScrollbarTwo: "rgb(78,88,110)",
              scrollbarDeadArea: "rgb(36,36,60)",
              listTextHighlighted: "rgb(0,198,255)",
              listTextHighlightedBackground: "rgb(0,198,255)",
              listTextSelected: "rgb(0,198,255)",
              listTextSelectedBackground: "rgb(0,198,255)"
            };
            const defaultDisplayState = {
              doubled: false,
              marqueeStep: 0,
              disableMarquee: false,
              loading: true,
              llama: false,
              closed: false,
              working: false,
              skinImages: DEFAULT_SKIN.images,
              skinColors: DEFAULT_SKIN.colors,
              skinCursors: null,
              skinPlaylistStyle: null,
              skinRegion: {},
              visualizerStyle: 0,
              // Index into VISUALIZER_ORDER
              dummyVizData: null,
              playlistScrollPosition: 0,
              skinGenLetterWidths: null,
              // TODO: Get the default value for this?
              skinGenExColors: defaultSkinGenExColors,
              additionalVisualizers: [],
              zIndex: 0
            };
            const display = (state = defaultDisplayState, action) => {
              switch (action.type) {
                case LOAD_DEFAULT_SKIN: {
                  const {
                    skinImages,
                    skinColors,
                    skinCursors,
                    skinPlaylistStyle,
                    skinRegion,
                    skinGenLetterWidths,
                    skinGenExColors
                  } = defaultDisplayState;
                  return display_objectSpread(display_objectSpread({}, state), {}, {
                    skinImages,
                    skinColors,
                    skinCursors,
                    skinPlaylistStyle,
                    skinRegion,
                    skinGenLetterWidths,
                    skinGenExColors
                  });
                }
                case TOGGLE_DOUBLESIZE_MODE:
                  return display_objectSpread(display_objectSpread({}, state), {}, {
                    doubled: !state.doubled
                  });
                case TOGGLE_LLAMA_MODE:
                  return display_objectSpread(display_objectSpread({}, state), {}, {
                    llama: !state.llama
                  });
                case STEP_MARQUEE:
                  return state.disableMarquee ? state : display_objectSpread(display_objectSpread({}, state), {}, {
                    marqueeStep: state.marqueeStep + 1
                  });
                case DISABLE_MARQUEE:
                  return display_objectSpread(display_objectSpread({}, state), {}, {
                    disableMarquee: true
                  });
                case STOP_WORKING:
                  return display_objectSpread(display_objectSpread({}, state), {}, {
                    working: false
                  });
                case START_WORKING:
                  return display_objectSpread(display_objectSpread({}, state), {}, {
                    working: true
                  });
                case CLOSE_WINAMP:
                  return display_objectSpread(display_objectSpread({}, state), {}, {
                    closed: true
                  });
                case OPEN_WINAMP:
                  return display_objectSpread(display_objectSpread({}, state), {}, {
                    closed: false
                  });
                case LOADING:
                  return display_objectSpread(display_objectSpread({}, state), {}, {
                    loading: true
                  });
                case LOADED:
                  return display_objectSpread(display_objectSpread({}, state), {}, {
                    loading: false
                  });
                case SET_SKIN_DATA:
                  const {
                    data
                  } = action;
                  return display_objectSpread(display_objectSpread({}, state), {}, {
                    loading: false,
                    skinImages: data.skinImages,
                    skinColors: data.skinColors,
                    skinPlaylistStyle: data.skinPlaylistStyle,
                    skinCursors: data.skinCursors,
                    skinRegion: data.skinRegion,
                    skinGenLetterWidths: data.skinGenLetterWidths,
                    skinGenExColors: data.skinGenExColors || defaultSkinGenExColors
                  });
                case TOGGLE_VISUALIZER_STYLE:
                  return display_objectSpread(display_objectSpread({}, state), {}, {
                    visualizerStyle: (state.visualizerStyle + 1) % VISUALIZER_ORDER.length
                  });
                case SET_PLAYLIST_SCROLL_POSITION:
                  return display_objectSpread(display_objectSpread({}, state), {}, {
                    playlistScrollPosition: action.position
                  });
                case SET_Z_INDEX:
                  return display_objectSpread(display_objectSpread({}, state), {}, {
                    zIndex: action.zIndex
                  });
                case SET_DUMMY_VIZ_DATA:
                  return display_objectSpread(display_objectSpread({}, state), {}, {
                    dummyVizData: action.data
                  });
                case LOAD_SERIALIZED_STATE: {
                  const _action$serializedSta = action.serializedState.display, {
                    skinCursors
                  } = _action$serializedSta, rest = objectWithoutProperties_default()(_action$serializedSta, ["skinCursors"]);
                  const upgrade = (url) => ({
                    type: "cur",
                    url
                  });
                  const newSkinCursors = skinCursors == null ? null : objectMap(skinCursors, upgrade);
                  return display_objectSpread(display_objectSpread({}, state), {}, {
                    skinCursors: newSkinCursors
                  }, rest);
                }
                default:
                  return state;
              }
            };
            var reducers_display = display;
            const display_getSerializedState = (state) => {
              const {
                visualizerStyle,
                doubled,
                llama,
                marqueeStep,
                skinImages,
                skinCursors,
                skinRegion,
                skinGenLetterWidths,
                skinColors,
                skinPlaylistStyle
              } = state;
              let newCursors = null;
              if (skinCursors != null) {
                newCursors = objectMap(skinCursors, (cursor) => {
                  return cursor.type === "cur" ? cursor.url : void 0;
                });
              }
              return {
                visualizerStyle,
                doubled,
                llama,
                marqueeStep,
                skinImages,
                skinCursors: newCursors,
                skinRegion,
                skinGenLetterWidths,
                skinColors,
                skinPlaylistStyle
              };
            };
            const getVisualizerStyle = Object(lib["createSelector"])((state) => state.visualizerStyle, (visualizationStyle) => {
              return VISUALIZER_ORDER[visualizationStyle];
            });
            function userInput_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function userInput_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  userInput_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  userInput_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            const defaultUserInput = {
              focus: null,
              bandFocused: null,
              scrubPosition: 0,
              userMessage: null
            };
            const userInput = (state = defaultUserInput, action) => {
              switch (action.type) {
                case SET_FOCUS:
                  return userInput_objectSpread(userInput_objectSpread({}, state), {}, {
                    focus: action.input,
                    bandFocused: null
                  });
                case SET_BAND_FOCUS:
                  return userInput_objectSpread(userInput_objectSpread({}, state), {}, {
                    focus: action.input,
                    bandFocused: action.bandFocused
                  });
                case UNSET_FOCUS:
                  return userInput_objectSpread(userInput_objectSpread({}, state), {}, {
                    focus: null,
                    bandFocused: null
                  });
                case SET_SCRUB_POSITION:
                  return userInput_objectSpread(userInput_objectSpread({}, state), {}, {
                    scrubPosition: action.position
                  });
                case SET_USER_MESSAGE:
                  return userInput_objectSpread(userInput_objectSpread({}, state), {}, {
                    userMessage: action.message
                  });
                case UNSET_USER_MESSAGE:
                  return userInput_objectSpread(userInput_objectSpread({}, state), {}, {
                    userMessage: null
                  });
                default:
                  return state;
              }
            };
            var reducers_userInput = userInput;
            function equalizer_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function equalizer_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  equalizer_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  equalizer_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            const equalizer_defaultState = {
              on: true,
              auto: false,
              sliders: {
                preamp: 50,
                60: 50,
                170: 50,
                310: 50,
                600: 50,
                1e3: 50,
                3e3: 50,
                6e3: 50,
                12e3: 50,
                14e3: 50,
                16e3: 50
              }
            };
            const equalizer = (state = equalizer_defaultState, action) => {
              switch (action.type) {
                case SET_BAND_VALUE:
                  const newSliders = equalizer_objectSpread(equalizer_objectSpread({}, state.sliders), {}, {
                    [action.band]: action.value
                  });
                  return equalizer_objectSpread(equalizer_objectSpread({}, state), {}, {
                    sliders: newSliders
                  });
                case SET_EQ_ON:
                  return equalizer_objectSpread(equalizer_objectSpread({}, state), {}, {
                    on: true
                  });
                case SET_EQ_OFF:
                  return equalizer_objectSpread(equalizer_objectSpread({}, state), {}, {
                    on: false
                  });
                case SET_EQ_AUTO:
                  return equalizer_objectSpread(equalizer_objectSpread({}, state), {}, {
                    auto: action.value
                  });
                case LOAD_SERIALIZED_STATE:
                  return action.serializedState.equalizer || state;
                default:
                  return state;
              }
            };
            function equalizer_getSerializedState(state) {
              return state;
            }
            var reducers_equalizer = equalizer;
            function network_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function network_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  network_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  network_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            const network = (state = {
              connected: true
            }, action) => {
              switch (action.type) {
                case NETWORK_CONNECTED:
                  return network_objectSpread(network_objectSpread({}, state), {}, {
                    connected: true
                  });
                case NETWORK_DISCONNECTED:
                  return network_objectSpread(network_objectSpread({}, state), {}, {
                    connected: false
                  });
                default:
                  return state;
              }
            };
            var reducers_network = network;
            function settings_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function settings_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  settings_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  settings_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            const defaultSettingsState = {
              availableSkins: []
            };
            const settings = (state = defaultSettingsState, action) => {
              switch (action.type) {
                case SET_AVAILABLE_SKINS:
                  return settings_objectSpread(settings_objectSpread({}, state), {}, {
                    availableSkins: action.skins
                  });
                default:
                  return state;
              }
            };
            var reducers_settings = settings;
            var browser = __webpack_require__2(19);
            var browser_default = __webpack_require__2.n(browser);
            function genMediaTags(file, musicMetadata) {
              browser_default()(file != null, "Attempted to get the tags of media file without passing a file");
              const options = {
                duration: true,
                skipPostHeaders: true
                // avoid unnecessary data to be read
              };
              if (typeof file === "string") {
                return musicMetadata.fetchFromUrl(file, options);
              }
              return musicMetadata.parseBlob(file, options);
            }
            function genMediaDuration(url) {
              browser_default()(typeof url === "string", "Attempted to get the duration of media file without passing a url");
              return new Promise((resolve2, reject2) => {
                const audio = document.createElement("audio");
                audio.crossOrigin = "anonymous";
                const durationChange = () => {
                  resolve2(audio.duration);
                  audio.removeEventListener("durationchange", durationChange);
                  audio.src = "";
                };
                audio.addEventListener("durationchange", durationChange);
                audio.addEventListener("error", (e) => {
                  reject2(e);
                });
                audio.src = url;
              });
            }
            async function genArrayBufferFromFileReference(fileReference) {
              browser_default()(fileReference != null, "Attempt to get an ArrayBuffer without assigning a fileReference");
              return new Promise((resolve2, reject2) => {
                const reader = new FileReader();
                reader.onload = () => {
                  resolve2(reader.result);
                };
                reader.onerror = reject2;
                reader.readAsArrayBuffer(fileReference);
              });
            }
            async function genStringFromFileReference(fileReference) {
              return new Promise((resolve2, reject2) => {
                const reader = new FileReader();
                reader.onload = () => {
                  resolve2(reader.result);
                };
                reader.onerror = reject2;
                reader.readAsText(fileReference);
              });
            }
            async function promptForFileReferences({
              accept,
              directory = false
            } = {
              accept: null,
              directory: false
            }) {
              return new Promise((resolve2) => {
                const fileInput = document.createElement("input");
                if (accept) fileInput.setAttribute("accept", accept);
                fileInput.type = "file";
                fileInput.multiple = true;
                fileInput.webkitdirectory = directory;
                fileInput.directory = directory;
                fileInput.mozdirectory = directory;
                fileInput.value = null;
                fileInput.addEventListener("change", (e) => {
                  const files = e.target.files;
                  resolve2(files);
                });
                fileInput.click();
              });
            }
            function urlIsBlobUrl(url) {
              return /^blob:/.test(url);
            }
            function curUrlFromByteArray(arr) {
              const base64 = base64FromDataArray(arr);
              return `data:image/x-win-bitmap;base64,${base64}`;
            }
            function filenameFromUrl(url) {
              if (urlIsBlobUrl(url)) {
                return null;
              }
              const lastSegment = url.split("/").pop();
              if (lastSegment == null) {
                return null;
              }
              return lastSegment.split("#")[0].split("?")[0];
            }
            const trackName = weakMapMemoize((track) => {
              const {
                artist,
                title,
                defaultName,
                url
              } = track;
              if (artist && title) {
                return `${artist} - ${title}`;
              } else if (title) {
                return title;
              } else if (defaultName) {
                return defaultName;
              } else if (url) {
                const filename = filenameFromUrl(url);
                if (filename) {
                  return filename;
                }
              }
              return "???";
            });
            const trackFilename = weakMapMemoize((track) => {
              if (track.url) {
                const urlFilename = filenameFromUrl(track.url);
                if (urlFilename != null) {
                  return urlFilename;
                }
              }
              if (track.defaultName) {
                return track.defaultName;
              }
              return "???";
            });
            function tracks_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function tracks_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  tracks_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  tracks_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            const tracks_defaultPlaylistState = {};
            const tracks_tracks = (state = tracks_defaultPlaylistState, action) => {
              var _action$duration;
              switch (action.type) {
                case ADD_TRACK_FROM_URL:
                  return tracks_objectSpread(tracks_objectSpread({}, state), {}, {
                    [action.id]: {
                      id: action.id,
                      defaultName: action.defaultName || null,
                      duration: (_action$duration = action.duration) !== null && _action$duration !== void 0 ? _action$duration : null,
                      url: action.url,
                      mediaTagsRequestStatus: MEDIA_TAG_REQUEST_STATUS.INITIALIZED
                    }
                  });
                case SET_MEDIA: {
                  const newTrack = tracks_objectSpread(tracks_objectSpread({}, state[action.id]), {}, {
                    duration: action.length
                  });
                  return tracks_objectSpread(tracks_objectSpread({}, state), {}, {
                    [action.id]: newTrack
                  });
                }
                case MEDIA_TAG_REQUEST_INITIALIZED:
                  return tracks_objectSpread(tracks_objectSpread({}, state), {}, {
                    [action.id]: tracks_objectSpread(tracks_objectSpread({}, state[action.id]), {}, {
                      mediaTagsRequestStatus: MEDIA_TAG_REQUEST_STATUS.INITIALIZED
                    })
                  });
                case MEDIA_TAG_REQUEST_FAILED:
                  return tracks_objectSpread(tracks_objectSpread({}, state), {}, {
                    [action.id]: tracks_objectSpread(tracks_objectSpread({}, state[action.id]), {}, {
                      mediaTagsRequestStatus: MEDIA_TAG_REQUEST_STATUS.FAILED
                    })
                  });
                case SET_MEDIA_DURATION: {
                  return tracks_objectSpread(tracks_objectSpread({}, state), {}, {
                    [action.id]: tracks_objectSpread(tracks_objectSpread({}, state[action.id]), {}, {
                      duration: action.duration
                    })
                  });
                }
                case SET_MEDIA_TAGS:
                  const track = state[action.id];
                  const {
                    sampleRate,
                    bitrate,
                    numberOfChannels,
                    title,
                    artist,
                    album,
                    albumArtUrl
                  } = action;
                  const {
                    kbps,
                    khz,
                    channels
                  } = track;
                  return tracks_objectSpread(tracks_objectSpread({}, state), {}, {
                    [action.id]: tracks_objectSpread(tracks_objectSpread({}, track), {}, {
                      mediaTagsRequestStatus: MEDIA_TAG_REQUEST_STATUS.COMPLETE,
                      title,
                      artist,
                      album,
                      albumArtUrl,
                      kbps: bitrate != null ? String(Math.round(bitrate / 1e3)) : kbps,
                      khz: sampleRate != null ? String(Math.round(sampleRate / 1e3)) : khz,
                      channels: numberOfChannels != null ? numberOfChannels : channels
                    })
                  });
                default:
                  return state;
              }
            };
            var reducers_tracks = tracks_tracks;
            const getTrackDisplayName = (state, id = null) => {
              if (id == null) {
                return null;
              }
              const track = state[id];
              if (track == null) {
                return null;
              }
              return trackName(track);
            };
            let TransitionType;
            (function(TransitionType2) {
              TransitionType2[TransitionType2["IMMEDIATE"] = 0] = "IMMEDIATE";
              TransitionType2[TransitionType2["DEFAULT"] = 1] = "DEFAULT";
              TransitionType2[TransitionType2["USER_PRESET"] = 2] = "USER_PRESET";
            })(TransitionType || (TransitionType = {}));
            function milkdrop_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function milkdrop_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  milkdrop_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  milkdrop_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            const defaultMilkdropState = {
              display: "WINDOW",
              overlay: false,
              presetHistory: [],
              presets: [],
              currentPresetIndex: null,
              butterchurn: null,
              transitionType: TransitionType.DEFAULT,
              randomize: true,
              cycling: true,
              message: null
            };
            const milkdrop_milkdrop = (state = defaultMilkdropState, action) => {
              switch (action.type) {
                case SET_MILKDROP_DESKTOP:
                  return milkdrop_objectSpread(milkdrop_objectSpread({}, state), {}, {
                    display: action.enabled ? "DESKTOP" : "WINDOW"
                  });
                case SET_MILKDROP_FULLSCREEN:
                  return milkdrop_objectSpread(milkdrop_objectSpread({}, state), {}, {
                    display: action.enabled ? "FULLSCREEN" : "WINDOW"
                  });
                case GOT_BUTTERCHURN:
                  return milkdrop_objectSpread(milkdrop_objectSpread({}, state), {}, {
                    butterchurn: action.butterchurn
                  });
                case GOT_BUTTERCHURN_PRESETS:
                  return milkdrop_objectSpread(milkdrop_objectSpread({}, state), {}, {
                    presets: state.presets.concat(action.presets)
                  });
                case PRESET_REQUESTED:
                  if (action.addToHistory) {
                    return milkdrop_objectSpread(milkdrop_objectSpread({}, state), {}, {
                      presetHistory: [...state.presetHistory, action.index]
                    });
                  }
                  return milkdrop_objectSpread(milkdrop_objectSpread({}, state), {}, {
                    presetHistory: state.presetHistory.slice(0, -1)
                  });
                case RESOLVE_PRESET_AT_INDEX:
                  const preset = state.presets[action.index];
                  return milkdrop_objectSpread(milkdrop_objectSpread({}, state), {}, {
                    presets: replaceAtIndex(state.presets, action.index, {
                      type: "RESOLVED",
                      name: preset.name,
                      preset: action.json
                    })
                  });
                case SELECT_PRESET_AT_INDEX:
                  return milkdrop_objectSpread(milkdrop_objectSpread({}, state), {}, {
                    currentPresetIndex: action.index,
                    transitionType: action.transitionType
                  });
                case TOGGLE_PRESET_OVERLAY:
                  return milkdrop_objectSpread(milkdrop_objectSpread({}, state), {}, {
                    overlay: !state.overlay
                  });
                case TOGGLE_RANDOMIZE_PRESETS:
                  return milkdrop_objectSpread(milkdrop_objectSpread({}, state), {}, {
                    randomize: !state.randomize
                  });
                case TOGGLE_PRESET_CYCLING:
                  return milkdrop_objectSpread(milkdrop_objectSpread({}, state), {}, {
                    cycling: !state.cycling
                  });
                case SCHEDULE_MILKDROP_MESSAGE:
                  return milkdrop_objectSpread(milkdrop_objectSpread({}, state), {}, {
                    message: {
                      text: action.message,
                      time: Date.now()
                    }
                  });
                default:
                  return state;
              }
            };
            var reducers_milkdrop = milkdrop_milkdrop;
            const reducer = Object(redux["combineReducers"])({
              userInput: reducers_userInput,
              windows: reducers_windows,
              display: reducers_display,
              settings: reducers_settings,
              equalizer: reducers_equalizer,
              playlist: reducers_playlist,
              media: reducers_media,
              network: reducers_network,
              tracks: reducers_tracks,
              milkdrop: reducers_milkdrop
            });
            var reducers = reducer;
            function playlistHtml_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function playlistHtml_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  playlistHtml_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  playlistHtml_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            const getAsDataURI = (text) => `data:text/html;base64,${window.btoa(text)}`;
            const noshadeStyle = {
              height: "2px",
              borderWidth: 0,
              color: "gray",
              backgroundColor: "gray"
            };
            const Body = (props) => {
              return Object(jsx_runtime["jsx"])("body", playlistHtml_objectSpread({}, props));
            };
            const Font = (props) => {
              return Object(jsx_runtime["jsx"])("font", playlistHtml_objectSpread({}, props));
            };
            const Hr = (props) => {
              return Object(jsx_runtime["jsx"])("hr", playlistHtml_objectSpread({}, props));
            };
            const Div = (props) => {
              return Object(jsx_runtime["jsx"])("div", playlistHtml_objectSpread({}, props));
            };
            const Table = (props) => {
              return Object(jsx_runtime["jsx"])("table", playlistHtml_objectSpread({}, props));
            };
            const Playlist = (props) => Object(jsx_runtime["jsxs"])("html", {
              children: [Object(jsx_runtime["jsxs"])("head", {
                children: [Object(jsx_runtime["jsx"])("link", {
                  rel: "stylesheet",
                  href: "null"
                }), Object(jsx_runtime["jsx"])("style", {
                  type: "text/css",
                  children: `
        body { background: #000040; }
        .para1 { margin-top: -42px; margin-left: 145px; margin-right: 10px; font-family: "font2, Arial"; font-size: 30px; line-height: 35px; text-align: left; color: #E1E1E1; }
        .para2 { margin-top: 15px; margin-left: 15px; margin-right: 50px; font-family: "font1, Arial Black"; font-size: 50px; line-height: 40px; text-align: left; color: #004080; }
        `
                }), Object(jsx_runtime["jsx"])("title", {
                  children: "Winamp Generated PlayList"
                })]
              }), Object(jsx_runtime["jsxs"])(Body, {
                bgcolor: "#000080",
                topmargin: "0",
                leftmargin: "0",
                text: "#FFFFFF",
                children: [Object(jsx_runtime["jsxs"])(Div, {
                  align: "center",
                  children: [Object(jsx_runtime["jsx"])(Div, {
                    className: "para2",
                    align: "center",
                    children: Object(jsx_runtime["jsx"])("p", {
                      children: "WINAMP"
                    })
                  }), Object(jsx_runtime["jsx"])(Div, {
                    className: "para1",
                    align: "center",
                    children: Object(jsx_runtime["jsx"])("p", {
                      children: "playlist"
                    })
                  })]
                }), Object(jsx_runtime["jsx"])(Hr, {
                  align: "left",
                  width: "90%",
                  size: "1",
                  color: "#FFBF00",
                  style: noshadeStyle
                }), Object(jsx_runtime["jsx"])(Div, {
                  align: "right",
                  children: Object(jsx_runtime["jsx"])(Table, {
                    border: "0",
                    cellSpacing: "0",
                    cellPadding: "0",
                    width: "98%",
                    children: Object(jsx_runtime["jsx"])("tbody", {
                      children: Object(jsx_runtime["jsx"])("tr", {
                        children: Object(jsx_runtime["jsxs"])("td", {
                          children: [Object(jsx_runtime["jsx"])("small", {
                            children: Object(jsx_runtime["jsxs"])("small", {
                              children: [Object(jsx_runtime["jsx"])(Font, {
                                face: "Arial",
                                color: "#FFBF00",
                                children: props.numberOfTracks
                              }), Object(jsx_runtime["jsx"])(Font, {
                                color: "#409FFF",
                                face: "Arial",
                                children: " track in playlist, average track length: "
                              }), Object(jsx_runtime["jsx"])(Font, {
                                face: "Arial",
                                color: "#FFBF00",
                                children: props.averageTrackLength
                              })]
                            })
                          }), Object(jsx_runtime["jsx"])("br", {}), Object(jsx_runtime["jsx"])("small", {
                            children: Object(jsx_runtime["jsxs"])("small", {
                              children: [Object(jsx_runtime["jsx"])(Font, {
                                color: "#409FFF",
                                face: "Arial",
                                children: "Playlist length: "
                              }), Object(jsx_runtime["jsx"])(Font, {
                                face: "Arial",
                                color: "#FFBF00",
                                children: props.playlistLengthMinutes
                              }), Object(jsx_runtime["jsx"])(Font, {
                                color: "#409FFF",
                                face: "Arial",
                                children: " minutes "
                              }), Object(jsx_runtime["jsx"])(Font, {
                                face: "Arial",
                                color: "#FFBF00",
                                children: props.playlistLengthSeconds
                              }), Object(jsx_runtime["jsx"])(Font, {
                                color: "#409FFF",
                                face: "Arial",
                                children: " second "
                              }), Object(jsx_runtime["jsx"])("br", {}), Object(jsx_runtime["jsxs"])(Font, {
                                color: "#409FFF",
                                face: "Arial",
                                children: ["Right-click ", Object(jsx_runtime["jsx"])("a", {
                                  href: "./",
                                  children: "here"
                                }), " to save this HTML file."]
                              })]
                            })
                          })]
                        })
                      })
                    })
                  })
                }), Object(jsx_runtime["jsxs"])("blockquote", {
                  children: [Object(jsx_runtime["jsx"])("p", {
                    children: Object(jsx_runtime["jsx"])(Font, {
                      color: "#FFBF00",
                      face: "Arial",
                      children: Object(jsx_runtime["jsx"])("big", {
                        children: "Playlist files:"
                      })
                    })
                  }), Object(jsx_runtime["jsx"])("ul", {
                    children: Object(jsx_runtime["jsx"])(Font, {
                      face: "Arial",
                      color: "#FFFFFF",
                      children: Object(jsx_runtime["jsx"])("small", {
                        children: props.tracks.map((track) => Object(jsx_runtime["jsxs"])("span", {
                          children: [track, Object(jsx_runtime["jsx"])("br", {})]
                        }, track))
                      })
                    })
                  })]
                }), Object(jsx_runtime["jsx"])(Hr, {
                  align: "left",
                  width: "90%",
                  size: "1",
                  color: "#FFBF00",
                  style: noshadeStyle
                })]
              })]
            });
            const createPlaylistHTML = (props) => {
              const node = document.createElement("div");
              Object(react_dom["render"])(Object(jsx_runtime["jsx"])(Playlist, playlistHtml_objectSpread({}, props)), node);
              return node.innerHTML;
            };
            const createPlaylistURL = (props) => getAsDataURI(createPlaylistHTML(props));
            const getBalanceText = (balance) => {
              if (balance === 0) {
                return "Balance: Center";
              }
              const direction = balance > 0 ? "Right" : "Left";
              return `Balance: ${Math.abs(balance)}% ${direction}`;
            };
            const getVolumeText = (volume) => `Volume: ${volume}%`;
            const getPositionText = (duration, seekToPercent) => {
              const newElapsedStr = getTimeStr(duration * seekToPercent / 100, false);
              const durationStr = getTimeStr(duration, false);
              return `Seek to: ${newElapsedStr}/${durationStr} (${seekToPercent}%)`;
            };
            const getDoubleSizeModeText = (enabled) => `${enabled ? "Disable" : "Enable"} doublesize mode`;
            const formatHz = (hz) => hz < 1e3 ? `${hz}HZ` : `${hz / 1e3}KHZ`;
            const ensureSign = (num) => num > 0 ? `+${num}` : num.toString();
            const roundToTenths = (num) => (Math.round(num * 10) / 10).toFixed(1);
            const getEqText = (band, level) => {
              const db = roundToTenths((level - 50) / 50 * 12);
              const label = band === "preamp" ? "Preamp" : formatHz(band);
              return `EQ: ${label} ${ensureSign(db)} DB`;
            };
            function getPositionDiff(graph, sizeDiff) {
              const newGraph = {};
              const positionDiff = {};
              for (const key of Object.keys(graph)) {
                newGraph[key] = {
                  above: [],
                  left: []
                };
                positionDiff[key] = {
                  x: 0,
                  y: 0
                };
              }
              for (const [key, neighbors] of Object.entries(graph)) {
                const {
                  below,
                  right
                } = neighbors;
                if (right != null) {
                  newGraph[right].left.push(key);
                }
                if (below != null) {
                  newGraph[below].above.push(key);
                }
              }
              function walkRight(key) {
                const node = newGraph[key];
                const nodeSizeDiff = sizeDiff[key];
                node.left.forEach((left) => {
                  positionDiff[left].x += nodeSizeDiff.width + positionDiff[key].x;
                  walkRight(left);
                });
              }
              function walkDown(key) {
                const node = newGraph[key];
                const nodeSizeDiff = sizeDiff[key];
                node.above.forEach((above) => {
                  positionDiff[above].y += nodeSizeDiff.height + positionDiff[key].y;
                  walkDown(above);
                });
              }
              for (const [key, neighbors] of Object.entries(graph)) {
                if (neighbors.below == null) {
                  walkDown(key);
                }
                if (neighbors.right == null) {
                  walkRight(key);
                }
              }
              return positionDiff;
            }
            function generateGraph(windows) {
              const bottoms = {};
              const rights = {};
              for (const w of windows) {
                const bottom = w.y + w.height;
                if (bottoms[bottom]) {
                  bottoms[bottom].push(w);
                } else {
                  bottoms[bottom] = [w];
                }
                const right = w.x + w.width;
                if (rights[right]) {
                  rights[right].push(w);
                } else {
                  rights[right] = [w];
                }
              }
              const graph = {};
              for (const w of windows) {
                const edges = {};
                const top = w.y;
                const left = w.x;
                const tops = bottoms[top];
                const lefts = rights[left];
                if (tops) {
                  for (const below of tops) {
                    const isToTheLeft = below.x + below.width < w.x;
                    const isToTheRight = below.x > w.x + w.width;
                    const overlapsInX = !(isToTheLeft || isToTheRight);
                    if (overlapsInX) {
                      edges.below = below.key;
                      break;
                    }
                  }
                }
                if (lefts) {
                  for (const right of lefts) {
                    const isAbove = right.y + right.height < w.y;
                    const isBelow = right.y > w.y + w.height;
                    const overlapsInY = !(isAbove || isBelow);
                    if (overlapsInY) {
                      edges.right = right.key;
                      break;
                    }
                  }
                }
                graph[w.key] = edges;
              }
              return graph;
            }
            function selectors_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function selectors_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  selectors_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  selectors_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            const getSliders = (state) => state.equalizer.sliders;
            const getEqfData = Object(lib["createSelector"])(getSliders, (sliders) => {
              const preset = {
                name: "Entry1",
                preamp: denormalizeEqBand(sliders.preamp)
              };
              BANDS.forEach((band) => {
                preset[`hz${band}`] = denormalizeEqBand(sliders[band]);
              });
              const eqfData = {
                presets: [preset],
                type: "Winamp EQ library file v1.1"
              };
              return eqfData;
            });
            const getTracks = (state) => state.tracks;
            const getTrackUrl = (state) => {
              return (id) => {
                var _state$tracks$id;
                return (_state$tracks$id = state.tracks[id]) === null || _state$tracks$id === void 0 ? void 0 : _state$tracks$id.url;
              };
            };
            const getTrackOrder = (state) => state.playlist.trackOrder;
            const getTrackCount = Object(lib["createSelector"])(getTrackOrder, (trackOrder) => trackOrder.length);
            const getOrderedTracks = Object(lib["createSelector"])(getTracks, getTrackOrder, (tracks, trackOrder) => trackOrder.filter((id) => tracks[id]));
            const getUserTracks = Object(lib["createSelector"])(getTracks, getTrackOrder, (tracks, trackOrder) => trackOrder.map((id) => {
              const track = tracks[id];
              return {
                url: track.url,
                metaData: {
                  artist: track.artist || "",
                  title: track.title || "",
                  album: track.album,
                  albumArtUrl: track.albumArtUrl || ""
                }
              };
            }));
            const getOrderedTrackObjects = Object(lib["createSelector"])(getTracks, getOrderedTracks, (tracks, trackOrder) => trackOrder.map((id) => tracks[id]));
            const getSelectedTrackIds = (state) => {
              return state.playlist.selectedTracks;
            };
            const getSelectedTrackObjects = Object(lib["createSelector"])(getOrderedTrackObjects, getSelectedTrackIds, (tracks, selectedIds) => tracks.filter((track) => selectedIds.has(track.id)));
            const runningTimeFromTracks = (tracks) => tracks.reduce((time, track) => time + Number(track.duration), 0);
            const getTotalRunningTime = Object(lib["createSelector"])(getOrderedTrackObjects, runningTimeFromTracks);
            const getSelectedRunningTime = Object(lib["createSelector"])(getSelectedTrackObjects, runningTimeFromTracks);
            const getRunningTimeMessage = Object(lib["createSelector"])(getTotalRunningTime, getSelectedRunningTime, (totalRunningTime, selectedRunningTime) => `${getTimeStr(selectedRunningTime)}/${getTimeStr(totalRunningTime)}`);
            const getCurrentTrackIndex = (state) => {
              const {
                playlist: playlist2
              } = state;
              if (playlist2.currentTrack == null) {
                return -1;
              }
              return playlist2.trackOrder.indexOf(playlist2.currentTrack);
            };
            const getCurrentTrackNumber = Object(lib["createSelector"])(getCurrentTrackIndex, (currentTrackIndex) => currentTrackIndex + 1);
            const getCurrentTrackId = (state) => state.playlist.currentTrack;
            const getRandomTrackId = (state) => {
              const {
                playlist: {
                  trackOrder,
                  currentTrack
                }
              } = state;
              if (trackOrder.length === 0) {
                return null;
              }
              let nextId;
              do {
                nextId = trackOrder[Math.floor(trackOrder.length * Math.random())];
              } while (nextId === currentTrack && trackOrder.length > 1);
              return nextId;
            };
            const getNextTrackId = (state, n = 1) => {
              const {
                playlist: {
                  trackOrder
                },
                media: {
                  repeat,
                  shuffle
                }
              } = state;
              if (shuffle) {
                return getRandomTrackId(state);
              }
              const trackCount = getTrackCount(state);
              if (trackCount === 0) {
                return null;
              }
              const currentIndex = getCurrentTrackIndex(state);
              let nextIndex = currentIndex + n;
              if (repeat) {
                nextIndex = nextIndex % trackCount;
                if (nextIndex < 0) {
                  nextIndex += trackCount;
                }
                return trackOrder[nextIndex];
              }
              if (currentIndex === trackCount - 1 && n > 0) {
                return null;
              } else if (currentIndex === 0 && n < 0) {
                return null;
              }
              nextIndex = clamp(nextIndex, 0, trackCount - 1);
              return trackOrder[nextIndex];
            };
            const getGenWindows = (state) => {
              return state.windows.genWindows;
            };
            const selectors_getWindowOpen = Object(lib["createSelector"])(getGenWindows, (genWindows) => {
              return (windowId) => genWindows[windowId].open;
            });
            const selectors_getWindowHidden = Object(lib["createSelector"])(getMilkdropWindowEnabled, (milkdropWindowEnabled) => {
              return (windowId) => {
                return windowId === WINDOWS.MILKDROP && !milkdropWindowEnabled;
              };
            });
            const selectors_getWindowShade = Object(lib["createSelector"])(getGenWindows, (genWindows) => {
              return (windowId) => genWindows[windowId].shade;
            });
            const selectors_getWindowSize = Object(lib["createSelector"])(getGenWindows, (genWindows) => {
              return (windowId) => genWindows[windowId].size;
            });
            const getWindowPositions = Object(lib["createSelector"])(getGenWindows, (windows) => objectMap(windows, (w) => w.position));
            const BASE_WINDOW_HEIGHT = 58;
            const getNumberOfVisibleTracks = Object(lib["createSelector"])(selectors_getWindowSize, (getWindowSize_) => {
              const playlistSize = getWindowSize_("playlist");
              return Math.floor((BASE_WINDOW_HEIGHT + WINDOW_RESIZE_SEGMENT_HEIGHT * playlistSize[1]) / TRACK_HEIGHT);
            });
            const getOverflowTrackCount = Object(lib["createSelector"])(getTrackCount, getNumberOfVisibleTracks, (trackCount, numberOfVisibleTracks) => Math.max(0, trackCount - numberOfVisibleTracks));
            const _getPlaylistScrollPosition = (state) => state.display.playlistScrollPosition;
            const getPlaylistScrollPosition = Object(lib["createSelector"])(getOverflowTrackCount, _getPlaylistScrollPosition, (overflowTrackCount, playlistScrollPosition) => {
              if (overflowTrackCount === 0) {
                return 0;
              }
              return Math.round(Math.round(overflowTrackCount * playlistScrollPosition / 100) / overflowTrackCount * 100);
            });
            const getScrollOffset = Object(lib["createSelector"])(_getPlaylistScrollPosition, getTrackCount, getNumberOfVisibleTracks, (playlistScrollPosition, trackCount, numberOfVisibleTracks) => {
              const overflow = Math.max(0, trackCount - numberOfVisibleTracks);
              return percentToIndex(playlistScrollPosition / 100, overflow + 1);
            });
            const getVisibleTrackIds = Object(lib["createSelector"])(getScrollOffset, getTrackOrder, getNumberOfVisibleTracks, (offset, trackOrder, numberOfVisibleTracks) => trackOrder.slice(offset, offset + numberOfVisibleTracks));
            function getAllTracksAreVisible(state) {
              return getVisibleTrackIds(state).length === state.playlist.trackOrder.length;
            }
            const getTrackIsVisibleFunction = Object(lib["createSelector"])(getVisibleTrackIds, (visibleTrackIds) => {
              return (id) => visibleTrackIds.includes(id);
            });
            const getVisibleTracks = Object(lib["createSelector"])(getVisibleTrackIds, getTracks, (visibleTrackIds, tracks) => visibleTrackIds.map((id) => tracks[id]));
            const getPlaylist = (state) => state.playlist;
            const getDuration = (state) => {
              const {
                playlist: playlist2,
                tracks
              } = state;
              if (playlist2.currentTrack == null) {
                return null;
              }
              const currentTrack = tracks[playlist2.currentTrack];
              return currentTrack && currentTrack.duration;
            };
            const selectors_getTrackDisplayName = Object(lib["createSelector"])(getTracks, (tracks) => {
              return Object(lib["defaultMemoize"])((trackId) => getTrackDisplayName(tracks, trackId));
            });
            const getCurrentTrackDisplayName = Object(lib["createSelector"])(getCurrentTrackId, selectors_getTrackDisplayName, (id, getName) => {
              return getName(id);
            });
            const getMediaStatus = (state) => {
              return state.media.status;
            };
            const getMediaIsPlaying = (state) => state.media.status === MEDIA_STATUS.PLAYING;
            const getCurrentTrack = Object(lib["createSelector"])(getCurrentTrackId, getTracks, (trackId, tracks) => {
              return trackId == null ? null : tracks[trackId];
            });
            const getCurrentlyPlayingTrackIdIfLoaded = Object(lib["createSelector"])(getMediaIsPlaying, getCurrentTrack, (mediaIsPlaying, currentTrack) => {
              if (!mediaIsPlaying || !currentTrack || currentTrack.mediaTagsRequestStatus === MEDIA_TAG_REQUEST_STATUS.INITIALIZED) {
                return null;
              }
              return currentTrack.id;
            });
            const getCurrentTrackInfo = Object(lib["createSelector"])(getCurrentTrack, (track) => {
              if (track == null) {
                return null;
              }
              return {
                url: track.url,
                metaData: {
                  title: track.title || null,
                  artist: track.artist || null,
                  album: track.album || null,
                  albumArtUrl: track.albumArtUrl || null
                }
              };
            });
            const getMinimalMediaText = Object(lib["createSelector"])(getCurrentTrackNumber, getCurrentTrackDisplayName, (trackNumber, name) => name == null ? null : `${trackNumber}. ${name}`);
            const getMediaText = Object(lib["createSelector"])(getMinimalMediaText, getDuration, (minimalMediaText, duration) => minimalMediaText == null ? null : `${minimalMediaText} (${getTimeStr(duration)})`);
            const getNumberOfTracks = (state) => getTrackOrder(state).length;
            const getPlaylistDuration = Object(lib["createSelector"])(getTracks, (tracks) => Object.values(tracks).reduce((total, track) => total + (track.duration || 0), 0));
            const getPlaylistURL = Object(lib["createSelector"])(getNumberOfTracks, getPlaylistDuration, getTrackOrder, getTracks, selectors_getTrackDisplayName, (numberOfTracks, playlistDuration, trackOrder, tracks, getDisplayName) => createPlaylistURL({
              numberOfTracks,
              averageTrackLength: getTimeStr(playlistDuration / numberOfTracks),
              // TODO: Handle hours
              playlistLengthMinutes: Math.floor(playlistDuration / 60),
              playlistLengthSeconds: Math.floor(playlistDuration % 60),
              tracks: trackOrder.map((id, i) => `${i + 1}. ${getDisplayName(id)} (${getTimeStr(tracks[id].duration)})`)
            }));
            const selectors_WINDOW_HEIGHT = 116;
            const SHADE_WINDOW_HEIGHT = 14;
            function getWPixelSize(w, doubled) {
              const [width, height] = w.size;
              const doubledMultiplier = doubled && w.canDouble ? 2 : 1;
              const pix = {
                height: selectors_WINDOW_HEIGHT + height * WINDOW_RESIZE_SEGMENT_HEIGHT,
                width: WINDOW_WIDTH + width * WINDOW_RESIZE_SEGMENT_WIDTH
              };
              return {
                height: (w.shade ? SHADE_WINDOW_HEIGHT : pix.height) * doubledMultiplier,
                width: pix.width * doubledMultiplier
              };
            }
            function getFocusedWindow(state) {
              return state.windows.focused;
            }
            function getWindowPosition(state) {
              return (windowId) => state.windows.genWindows[windowId].position;
            }
            function getPositionsAreRelative(state) {
              return state.windows.positionsAreRelative;
            }
            function getDoubled(state) {
              return state.display.doubled;
            }
            function getLlamaMode(state) {
              return state.display.llama;
            }
            function getZIndex(state) {
              return state.display.zIndex;
            }
            const getWindowSizes = Object(lib["createSelector"])(getGenWindows, getDoubled, (windows, doubled) => {
              return objectMap(windows, (w) => getWPixelSize(w, doubled));
            });
            const selectors_getWindowPixelSize = Object(lib["createSelector"])(getWindowSizes, (sizes) => {
              return (windowId) => sizes[windowId];
            });
            const getWindowOrder = (state) => state.windows.windowOrder;
            const getNormalizedWindowOrder = Object(lib["createSelector"])(getWindowOrder, getGenWindows, (windowOrder, genWindows) => {
              return [WINDOWS.MAIN, ...windowOrder.filter((windowId) => windowId !== WINDOWS.MAIN && genWindows[windowId] != null)];
            });
            const getWindowsInfo = Object(lib["createSelector"])(getWindowSizes, getWindowPositions, getNormalizedWindowOrder, (sizes, positions, windowOrder) => {
              return windowOrder.map((key) => selectors_objectSpread(selectors_objectSpread({
                key
              }, sizes[key]), positions[key]));
            });
            const getWindowGraph = Object(lib["createSelector"])(getWindowsInfo, generateGraph);
            const defaultPlaylistStyle = {
              normal: "#00FF00",
              current: "#FFFFFF",
              normalbg: "#000000",
              selectedbg: "#0000C6",
              font: "Arial"
            };
            function getSkinColors(state) {
              return state.display.skinColors;
            }
            const getSkinPlaylistStyle = (state) => {
              return state.display.skinPlaylistStyle || defaultPlaylistStyle;
            };
            const selectors_getVisualizerStyle = (state) => {
              const milkdrop = state.windows.genWindows[WINDOWS.MILKDROP];
              if (milkdrop != null && milkdrop.open) {
                return VISUALIZERS.MILKDROP;
              }
              return getVisualizerStyle(state.display);
            };
            const getVolume = (state) => state.media.volume;
            const getBalance = (state) => state.media.balance;
            const getShuffle = (state) => state.media.shuffle;
            const getRepeat = (state) => state.media.repeat;
            const getChannels = Object(lib["createSelector"])(getCurrentTrack, (track) => {
              return track != null ? track.channels || null : null;
            });
            const getTimeElapsed = (state) => {
              return state.media.timeElapsed;
            };
            function getSerlializedState(state) {
              return {
                version: 1,
                media: media_getSerializedState(state.media),
                equalizer: equalizer_getSerializedState(state.equalizer),
                display: display_getSerializedState(state.display),
                windows: getSerializedState(state.windows)
              };
            }
            function getEqualizerEnabled(state) {
              return state.equalizer.on;
            }
            function getEqualizerAuto(state) {
              return state.equalizer.auto;
            }
            function getBrowserWindowSize(state) {
              return state.windows.browserWindowSize;
            }
            const getOpenWindows = Object(lib["createSelector"])(getGenWindows, (genWindows) => objectFilter(genWindows, (w) => w.open));
            const getStackedLayoutPositions = Object(lib["createSelector"])(getOpenWindows, getDoubled, (openWindows, doubled) => {
              let offset = 0;
              return objectMap(openWindows, (w) => {
                const position = {
                  x: 0,
                  y: offset
                };
                offset += getWPixelSize(w, doubled).height;
                return position;
              });
            });
            const getUserInputFocus = (state) => {
              return state.userInput.focus;
            };
            const getUserInputScrubPosition = (state) => {
              return state.userInput.scrubPosition;
            };
            const getMarqueeText = (state) => {
              const defaultText = "Winamp 2.91";
              if (state.userInput.userMessage != null) {
                return state.userInput.userMessage;
              }
              switch (getUserInputFocus(state)) {
                case "balance":
                  return getBalanceText(state.media.balance);
                case "volume":
                  return getVolumeText(state.media.volume);
                case "position":
                  const duration = getDuration(state);
                  if (duration == null) {
                    return defaultText;
                  }
                  return getPositionText(duration, getUserInputScrubPosition(state));
                case "double":
                  return getDoubleSizeModeText(state.display.doubled);
                case "eq":
                  const band = state.userInput.bandFocused;
                  if (band == null) {
                    return defaultText;
                  }
                  return getEqText(band, state.equalizer.sliders[band]);
                default:
                  break;
              }
              if (state.playlist.currentTrack != null) {
                const mediaText = getMediaText(state);
                if (mediaText == null) {
                  return defaultText;
                }
                return mediaText;
              }
              return defaultText;
            };
            const getKbps = Object(lib["createSelector"])(getCurrentTrack, (track) => {
              return track != null ? track.kbps || null : null;
            });
            const getKhz = Object(lib["createSelector"])(getCurrentTrack, (track) => {
              return track != null ? track.khz || null : null;
            });
            function getMilkdropMessage(state) {
              return state.milkdrop.message;
            }
            function getMilkdropWindowEnabled(state) {
              return state.milkdrop.display === "WINDOW";
            }
            function getMilkdropDesktopEnabled(state) {
              return state.milkdrop.display === "DESKTOP";
            }
            function getMilkdropFullscreenEnabled(state) {
              return state.milkdrop.display === "FULLSCREEN";
            }
            function selectors_getPresets(state) {
              return state.milkdrop.presets;
            }
            function getButterchurn(state) {
              return state.milkdrop.butterchurn;
            }
            function getPresetTransitionType(state) {
              return state.milkdrop.transitionType;
            }
            function getCurrentPresetIndex(state) {
              return state.milkdrop.currentPresetIndex;
            }
            function getCurrentPreset(state) {
              const index = getCurrentPresetIndex(state);
              if (index == null) {
                return null;
              }
              const preset = state.milkdrop.presets[index];
              if (preset == null || preset.type === "UNRESOLVED") {
                return null;
              }
              return preset.preset;
            }
            function getPresetNames(state) {
              return state.milkdrop.presets.map((preset) => preset.name);
            }
            function getPresetOverlayOpen(state) {
              return state.milkdrop.overlay;
            }
            function getPresetsAreCycling(state) {
              return state.milkdrop.cycling;
            }
            function getRandomizePresets(state) {
              return state.milkdrop.randomize;
            }
            function getClosed(state) {
              return state.display.closed;
            }
            function getSkinImages(state) {
              return state.display.skinImages;
            }
            function getSkinCursors(state) {
              return state.display.skinCursors;
            }
            function getSkinRegion(state) {
              return state.display.skinRegion;
            }
            function getSkinLetterWidths(state) {
              return state.display.skinGenLetterWidths;
            }
            function getPreampLineUrl(state) {
              return state.display.skinImages.EQ_PREAMP_LINE;
            }
            function getLineColorsUrl(state) {
              return state.display.skinImages.EQ_GRAPH_LINE_COLORS;
            }
            const getPreampLineImage = Object(lib["createSelector"])(getPreampLineUrl, async (url) => {
              if (url == null) {
                return null;
              }
              return imgFromUrl(url);
            });
            const getLineColorsImage = Object(lib["createSelector"])(getLineColorsUrl, async (url) => {
              if (url == null) {
                return null;
              }
              return imgFromUrl(url);
            });
            function getDummyVizData(state) {
              return state.display.dummyVizData;
            }
            function getMarqueeStep(state) {
              return state.display.marqueeStep;
            }
            function getNetworkConnected(state) {
              return state.network.connected;
            }
            function getTimeMode(state) {
              return state.media.timeMode;
            }
            function getLoading(state) {
              return state.display.loading;
            }
            function getWorking(state) {
              return state.display.working;
            }
            function getAvaliableSkins(state) {
              return state.settings.availableSkins;
            }
            function snapUtils_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function snapUtils_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  snapUtils_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  snapUtils_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            const SNAP_DISTANCE = 15;
            const snapUtils_top = (box) => box.y;
            const snapUtils_bottom = (box) => box.y + box.height;
            const snapUtils_left = (box) => box.x;
            const snapUtils_right = (box) => box.x + box.width;
            const near = (a, b) => Math.abs(a - b) < SNAP_DISTANCE;
            const overlapX = (a, b) => snapUtils_left(a) <= snapUtils_right(b) + SNAP_DISTANCE && snapUtils_left(b) <= snapUtils_right(a) + SNAP_DISTANCE;
            const overlapY = (a, b) => snapUtils_top(a) <= snapUtils_bottom(b) + SNAP_DISTANCE && snapUtils_top(b) <= snapUtils_bottom(a) + SNAP_DISTANCE;
            const snap = (boxA, boxB) => {
              let x, y;
              if (overlapY(boxA, boxB)) {
                if (near(snapUtils_left(boxA), snapUtils_right(boxB))) {
                  x = snapUtils_right(boxB);
                } else if (near(snapUtils_right(boxA), snapUtils_left(boxB))) {
                  x = snapUtils_left(boxB) - boxA.width;
                } else if (near(snapUtils_left(boxA), snapUtils_left(boxB))) {
                  x = snapUtils_left(boxB);
                } else if (near(snapUtils_right(boxA), snapUtils_right(boxB))) {
                  x = snapUtils_right(boxB) - boxA.width;
                }
              }
              if (overlapX(boxA, boxB)) {
                if (near(snapUtils_top(boxA), snapUtils_bottom(boxB))) {
                  y = snapUtils_bottom(boxB);
                } else if (near(snapUtils_bottom(boxA), snapUtils_top(boxB))) {
                  y = snapUtils_top(boxB) - boxA.height;
                } else if (near(snapUtils_top(boxA), snapUtils_top(boxB))) {
                  y = snapUtils_top(boxB);
                } else if (near(snapUtils_bottom(boxA), snapUtils_bottom(boxB))) {
                  y = snapUtils_bottom(boxB) - boxA.height;
                }
              }
              return {
                x,
                y
              };
            };
            const snapUtils_snapDiff = (a, b) => {
              const newPos = snap(a, b);
              return {
                x: newPos.x === void 0 ? 0 : newPos.x - a.x,
                y: newPos.y === void 0 ? 0 : newPos.y - a.y
              };
            };
            const snapDiffManyToMany = (as, bs) => {
              let x = 0;
              let y = 0;
              for (const a of as) {
                for (const b of bs) {
                  const diff = snapUtils_snapDiff(a, b);
                  x = x || diff.x;
                  y = y || diff.y;
                  if (x !== void 0 && x > 0 && y !== void 0 && y > 0) {
                    break;
                  }
                }
              }
              return {
                x,
                y
              };
            };
            const snapToMany = (boxA, otherBoxes) => {
              let x;
              let y;
              otherBoxes.forEach((boxB) => {
                const newPos = snap(boxA, boxB);
                x = newPos.x || x;
                y = newPos.y || y;
              });
              return {
                x,
                y
              };
            };
            const snapWithin = (boxA, boundingBox) => {
              let x, y;
              if (boxA.x - SNAP_DISTANCE < 0) {
                x = 0;
              } else if (boxA.x + boxA.width + SNAP_DISTANCE > boundingBox.width) {
                x = boundingBox.width - boxA.width;
              }
              if (boxA.y - SNAP_DISTANCE < 0) {
                y = 0;
              } else if (boxA.y + boxA.height + SNAP_DISTANCE > boundingBox.height) {
                y = boundingBox.height - boxA.height;
              }
              return {
                x,
                y
              };
            };
            const snapWithinDiff = (a, b) => {
              const newPos = snapWithin(a, b);
              return {
                x: newPos.x === void 0 ? 0 : newPos.x - a.x,
                y: newPos.y === void 0 ? 0 : newPos.y - a.y
              };
            };
            const applySnap = (original, ...snaps) => snaps.reduce((previous, snapped) => snapUtils_objectSpread(snapUtils_objectSpread({}, previous), {}, {
              x: typeof snapped.x !== "undefined" ? snapped.x : previous.x,
              y: typeof snapped.y !== "undefined" ? snapped.y : previous.y
            }), original);
            const snapUtils_boundingBox = (nodes) => {
              const boxes = nodes.slice();
              const firstNode = boxes.pop();
              if (firstNode == null) {
                throw new Error("boundingBox must be called with at least one node");
              }
              const bounding = {
                top: snapUtils_top(firstNode),
                right: snapUtils_right(firstNode),
                bottom: snapUtils_bottom(firstNode),
                left: snapUtils_left(firstNode)
              };
              boxes.forEach((node) => {
                bounding.top = Math.min(bounding.top, snapUtils_top(node));
                bounding.right = Math.max(bounding.right, snapUtils_right(node));
                bounding.bottom = Math.max(bounding.bottom, snapUtils_bottom(node));
                bounding.left = Math.min(bounding.left, snapUtils_left(node));
              });
              return {
                x: bounding.left,
                y: bounding.top,
                width: bounding.right - bounding.left,
                height: bounding.bottom - bounding.top
              };
            };
            function traceConnection(areConnected) {
              return (candidates, node) => {
                const connected = /* @__PURE__ */ new Set();
                const checkNode = (n) => {
                  for (const candidate of candidates) {
                    if (!connected.has(candidate) && areConnected(candidate, n)) {
                      connected.add(candidate);
                      checkNode(candidate);
                    }
                  }
                };
                checkNode(node);
                return connected;
              };
            }
            const applyDiff = (a, b) => ({
              x: a.x + b.x,
              y: a.y + b.y
            });
            const applyMultipleDiffs = (initial, ...diffs) => {
              const metaDiff = diffs.reduce((m, diff) => ({
                // Use the smallest non-zero diff for each axis.
                // TODO: Min should be the absolute value
                x: m.x === 0 || diff.x === 0 ? m.x + diff.x : Math.min(m.x, diff.x),
                y: m.y === 0 || diff.y === 0 ? m.y + diff.y : Math.min(m.y, diff.y)
              }));
              return applyDiff(initial, metaDiff);
            };
            function actionCreators_windows_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function actionCreators_windows_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  actionCreators_windows_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  actionCreators_windows_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function withWindowGraphIntegrity(action) {
              return (dispatch, getState) => {
                const state = getState();
                const graph = getWindowGraph(state);
                const originalSizes = getWindowSizes(state);
                dispatch(action);
                const newSizes = getWindowSizes(getState());
                const sizeDiff = {};
                for (const window2 of Object.keys(newSizes)) {
                  const original = originalSizes[window2];
                  const current = newSizes[window2];
                  sizeDiff[window2] = {
                    height: current.height - original.height,
                    width: current.width - original.width
                  };
                }
                const positionDiff = getPositionDiff(graph, sizeDiff);
                const windowPositions = getWindowPositions(state);
                const newPositions = objectMap(windowPositions, (position, key) => applyDiff(position, positionDiff[key]));
                dispatch(windows_updateWindowPositions(newPositions));
              };
            }
            function windows_toggleDoubleSizeMode() {
              return withWindowGraphIntegrity({
                type: TOGGLE_DOUBLESIZE_MODE
              });
            }
            function toggleLlamaMode() {
              return {
                type: TOGGLE_LLAMA_MODE
              };
            }
            function windows_toggleEqualizerShadeMode() {
              return withWindowGraphIntegrity({
                type: TOGGLE_WINDOW_SHADE_MODE,
                windowId: "equalizer"
              });
            }
            function windows_toggleMainWindowShadeMode() {
              return withWindowGraphIntegrity({
                type: TOGGLE_WINDOW_SHADE_MODE,
                windowId: "main"
              });
            }
            function togglePlaylistShadeMode() {
              return withWindowGraphIntegrity({
                type: TOGGLE_WINDOW_SHADE_MODE,
                windowId: "playlist"
              });
            }
            function windows_closeWindow(windowId) {
              return {
                type: CLOSE_WINDOW,
                windowId
              };
            }
            function windows_setFocusedWindow(window2) {
              return {
                type: SET_FOCUSED_WINDOW,
                window: window2
              };
            }
            function windows_setWindowSize(windowId, size) {
              return {
                type: WINDOW_SIZE_CHANGED,
                windowId,
                size
              };
            }
            function windows_toggleWindow(windowId) {
              return {
                type: TOGGLE_WINDOW,
                windowId
              };
            }
            function windows_updateWindowPositions(positions, absolute) {
              return {
                type: UPDATE_WINDOW_POSITIONS,
                positions,
                absolute
              };
            }
            function centerWindowsInContainer(container) {
              return (dispatch, getState) => {
                if (!getPositionsAreRelative(getState())) {
                  return;
                }
                const {
                  left,
                  top
                } = container.getBoundingClientRect();
                const {
                  scrollWidth: width,
                  scrollHeight: height
                } = container;
                dispatch(centerWindows({
                  left,
                  top,
                  width,
                  height
                }));
              };
            }
            function centerWindowsInView() {
              return centerWindows({
                left: window.scrollX,
                top: window.scrollY,
                width: window.innerWidth,
                height: window.innerHeight
              });
            }
            function centerWindows(box) {
              return (dispatch, getState) => {
                const state = getState();
                const windowsInfo = getWindowsInfo(state);
                const getOpen = selectors_getWindowOpen(state);
                const {
                  top,
                  left,
                  width,
                  height
                } = box;
                const offsetLeft = left + window.scrollX;
                const offsetTop = top + window.scrollY;
                const bounding = calculateBoundingBox(windowsInfo.filter((w) => getOpen(w.key)));
                if (bounding == null) {
                  return;
                }
                const boxHeight = bounding.bottom - bounding.top;
                const boxWidth = bounding.right - bounding.left;
                const move = {
                  x: Math.ceil(offsetLeft - bounding.left + (width - boxWidth) / 2),
                  y: Math.ceil(offsetTop - bounding.top + (height - boxHeight) / 2)
                };
                const newPositions = windowsInfo.reduce((pos, w) => actionCreators_windows_objectSpread(actionCreators_windows_objectSpread({}, pos), {}, {
                  [w.key]: {
                    x: move.x + w.x,
                    y: move.y + w.y
                  }
                }), {});
                dispatch(windows_updateWindowPositions(newPositions, true));
              };
            }
            function windows_browserWindowSizeChanged(size) {
              return (dispatch) => {
                dispatch(actionCreators_windows_objectSpread({
                  type: BROWSER_WINDOW_SIZE_CHANGED
                }, size));
                dispatch(ensureWindowsAreOnScreen());
              };
            }
            function resetWindowSizes() {
              return {
                type: RESET_WINDOW_SIZES
              };
            }
            function stackWindows() {
              return (dispatch, getState) => {
                dispatch(windows_updateWindowPositions(getStackedLayoutPositions(getState())));
              };
            }
            function ensureWindowsAreOnScreen() {
              return (dispatch, getState) => {
                const state = getState();
                const windowsInfo = getWindowsInfo(state);
                const getOpen = selectors_getWindowOpen(state);
                const {
                  height,
                  width
                } = utils_getWindowSize();
                const bounding = calculateBoundingBox(windowsInfo.filter((w) => getOpen(w.key)));
                if (bounding == null) {
                  return;
                }
                const positions = getWindowPositions(state);
                if (bounding.left >= 0 && bounding.top >= 0 && bounding.right <= width && bounding.bottom <= height) {
                  return;
                }
                const boundingHeight = bounding.bottom - bounding.top;
                const boundingWidth = bounding.right - bounding.left;
                if (boundingWidth <= width && boundingHeight <= height) {
                  let moveY = 0;
                  let moveX = 0;
                  if (bounding.top <= 0) {
                    moveY = bounding.top;
                  } else if (bounding.bottom > height) {
                    moveY = bounding.bottom - height;
                  }
                  if (bounding.left <= 0) {
                    moveX = bounding.left;
                  } else if (bounding.right > width) {
                    moveX = bounding.right - width;
                  }
                  const newPositions = objectMap(positions, (position) => ({
                    x: position.x - moveX,
                    y: position.y - moveY
                  }));
                  dispatch(windows_updateWindowPositions(newPositions));
                  return;
                }
                dispatch(resetWindowSizes());
                dispatch(stackWindows());
                dispatch(centerWindowsInView());
              };
            }
            function playTrack(id) {
              return (dispatch, getState) => {
                const state = getState();
                const isStopped = getMediaStatus(state) === MEDIA_STATUS.STOPPED;
                if (isStopped) {
                  dispatch({
                    type: BUFFER_TRACK,
                    id
                  });
                } else {
                  dispatch({
                    type: PLAY_TRACK,
                    id
                  });
                }
              };
            }
            function media_playTrackNow(id) {
              return {
                type: PLAY_TRACK,
                id
              };
            }
            function media_play() {
              return (dispatch, getState) => {
                const state = getState();
                if (state.media.status === MEDIA_STATUS.STOPPED && state.playlist.currentTrack == null && state.playlist.trackOrder.length === 0) {
                  dispatch(files_openMediaFileDialog());
                } else {
                  dispatch({
                    type: PLAY
                  });
                }
              };
            }
            function media_pause() {
              return (dispatch, getState) => {
                const {
                  status
                } = getState().media;
                if (status === MEDIA_STATUS.PLAYING) {
                  dispatch({
                    type: PAUSE
                  });
                } else {
                  dispatch({
                    type: PLAY
                  });
                }
              };
            }
            function media_stop() {
              return {
                type: STOP
              };
            }
            function media_nextN(n) {
              return (dispatch, getState) => {
                const nextTrackId = getNextTrackId(getState(), n);
                if (nextTrackId == null) {
                  dispatch({
                    type: IS_STOPPED
                  });
                  return;
                }
                dispatch(playTrack(nextTrackId));
              };
            }
            function media_next() {
              return media_nextN(1);
            }
            function media_previous() {
              return media_nextN(-1);
            }
            function seekToTime(seconds) {
              return function(dispatch, getState) {
                const state = getState();
                const duration = getDuration(state);
                if (duration == null) {
                  return;
                }
                dispatch({
                  type: SEEK_TO_PERCENT_COMPLETE,
                  percent: seconds / duration * 100
                });
              };
            }
            function media_seekForward(seconds) {
              return function(dispatch, getState) {
                const timeElapsed = getTimeElapsed(getState());
                dispatch(seekToTime(timeElapsed + seconds));
              };
            }
            function media_seekBackward(seconds) {
              return media_seekForward(-seconds);
            }
            function media_setVolume(volume) {
              return {
                type: SET_VOLUME,
                volume: clamp(volume, 0, 100)
              };
            }
            function adjustVolume(volumeDiff) {
              return (dispatch, getState) => {
                const currentVolume = getState().media.volume;
                return dispatch(media_setVolume(currentVolume + volumeDiff));
              };
            }
            function media_scrollVolume(e) {
              e.preventDefault();
              return (dispatch, getState) => {
                const currentVolume = getState().media.volume;
                return dispatch(media_setVolume(currentVolume + e.deltaY));
              };
            }
            function media_setBalance(balance) {
              balance = clamp(balance, -100, 100);
              if (Math.abs(balance) < 25) {
                balance = 0;
              }
              return {
                type: SET_BALANCE,
                balance
              };
            }
            function media_toggleRepeat() {
              return {
                type: TOGGLE_REPEAT
              };
            }
            function media_toggleShuffle() {
              return {
                type: TOGGLE_SHUFFLE
              };
            }
            function media_toggleTimeMode() {
              return {
                type: TOGGLE_TIME_MODE
              };
            }
            const BAND_SNAP_DISTANCE = 5;
            const BAND_MID_POINT_VALUE = 50;
            function _snapBandValue(value) {
              if (value < BAND_MID_POINT_VALUE + BAND_SNAP_DISTANCE && value > BAND_MID_POINT_VALUE - BAND_SNAP_DISTANCE) {
                return BAND_MID_POINT_VALUE;
              }
              return value;
            }
            function setEqBand(band, value) {
              return {
                type: SET_BAND_VALUE,
                band,
                value: _snapBandValue(value)
              };
            }
            function _setEqTo(value) {
              return (dispatch) => {
                Object.values(BANDS).forEach((band) => {
                  dispatch({
                    type: SET_BAND_VALUE,
                    value,
                    band
                  });
                });
              };
            }
            function equalizer_setEqToMax() {
              return _setEqTo(100);
            }
            function equalizer_setEqToMid() {
              return _setEqTo(50);
            }
            function equalizer_setEqToMin() {
              return _setEqTo(0);
            }
            function setPreamp(value) {
              return {
                type: SET_BAND_VALUE,
                band: "preamp",
                value: _snapBandValue(value)
              };
            }
            function equalizer_toggleEq() {
              return (dispatch, getState) => {
                if (getState().equalizer.on) {
                  dispatch({
                    type: SET_EQ_OFF
                  });
                } else {
                  dispatch({
                    type: SET_EQ_ON
                  });
                }
              };
            }
            function toggleEqAuto() {
              return (dispatch) => {
                dispatch({
                  type: SET_EQ_AUTO,
                  value: false
                });
              };
            }
            var winamp_eqf = __webpack_require__2(29);
            const FONT_LOOKUP = {
              a: [0, 0],
              b: [0, 1],
              c: [0, 2],
              d: [0, 3],
              e: [0, 4],
              f: [0, 5],
              g: [0, 6],
              h: [0, 7],
              i: [0, 8],
              j: [0, 9],
              k: [0, 10],
              l: [0, 11],
              m: [0, 12],
              n: [0, 13],
              o: [0, 14],
              p: [0, 15],
              q: [0, 16],
              r: [0, 17],
              s: [0, 18],
              t: [0, 19],
              u: [0, 20],
              v: [0, 21],
              w: [0, 22],
              x: [0, 23],
              y: [0, 24],
              z: [0, 25],
              '"': [0, 26],
              "@": [0, 27],
              " ": [0, 30],
              "0": [1, 0],
              "1": [1, 1],
              "2": [1, 2],
              "3": [1, 3],
              "4": [1, 4],
              "5": [1, 5],
              "6": [1, 6],
              "7": [1, 7],
              "8": [1, 8],
              "9": [1, 9],
              [UTF8_ELLIPSIS]: [1, 10],
              ".": [1, 11],
              ":": [1, 12],
              "(": [1, 13],
              ")": [1, 14],
              "-": [1, 15],
              "'": [1, 16],
              "!": [1, 17],
              _: [1, 18],
              "+": [1, 19],
              "\\": [1, 20],
              "/": [1, 21],
              "[": [1, 22],
              "]": [1, 23],
              "^": [1, 24],
              "&": [1, 25],
              "%": [1, 26],
              ",": [1, 27],
              "=": [1, 28],
              $: [1, 29],
              "#": [1, 30],
              Å: [2, 0],
              Ö: [2, 1],
              Ä: [2, 2],
              "?": [2, 3],
              "*": [2, 4],
              "<": [1, 22],
              ">": [1, 23],
              "{": [1, 22],
              "}": [1, 23]
            };
            const imageConstFromChar = (char) => `CHARACTER_${char.charCodeAt(0)}`;
            const CHAR_X = 5;
            const CHAR_Y = 6;
            const characterSprites = [];
            for (const key in FONT_LOOKUP) {
              if (FONT_LOOKUP.hasOwnProperty(key)) {
                const position = FONT_LOOKUP[key];
                characterSprites.push({
                  name: imageConstFromChar(key),
                  y: position[0] * CHAR_Y,
                  x: position[1] * CHAR_X,
                  width: CHAR_X,
                  height: CHAR_Y
                });
              }
            }
            const skinSprites_sprites = {
              BALANCE: [{
                name: "MAIN_BALANCE_BACKGROUND",
                x: 9,
                y: 0,
                width: 38,
                height: 420
              }, {
                name: "MAIN_BALANCE_THUMB",
                x: 15,
                y: 422,
                width: 14,
                height: 11
              }, {
                name: "MAIN_BALANCE_THUMB_ACTIVE",
                x: 0,
                y: 422,
                width: 14,
                height: 11
              }],
              CBUTTONS: [{
                name: "MAIN_PREVIOUS_BUTTON",
                x: 0,
                y: 0,
                width: 23,
                height: 18
              }, {
                name: "MAIN_PREVIOUS_BUTTON_ACTIVE",
                x: 0,
                y: 18,
                width: 23,
                height: 18
              }, {
                name: "MAIN_PLAY_BUTTON",
                x: 23,
                y: 0,
                width: 23,
                height: 18
              }, {
                name: "MAIN_PLAY_BUTTON_ACTIVE",
                x: 23,
                y: 18,
                width: 23,
                height: 18
              }, {
                name: "MAIN_PAUSE_BUTTON",
                x: 46,
                y: 0,
                width: 23,
                height: 18
              }, {
                name: "MAIN_PAUSE_BUTTON_ACTIVE",
                x: 46,
                y: 18,
                width: 23,
                height: 18
              }, {
                name: "MAIN_STOP_BUTTON",
                x: 69,
                y: 0,
                width: 23,
                height: 18
              }, {
                name: "MAIN_STOP_BUTTON_ACTIVE",
                x: 69,
                y: 18,
                width: 23,
                height: 18
              }, {
                name: "MAIN_NEXT_BUTTON",
                x: 92,
                y: 0,
                width: 23,
                height: 18
              }, {
                name: "MAIN_NEXT_BUTTON_ACTIVE",
                x: 92,
                y: 18,
                width: 22,
                height: 18
              }, {
                name: "MAIN_EJECT_BUTTON",
                x: 114,
                y: 0,
                width: 22,
                height: 16
              }, {
                name: "MAIN_EJECT_BUTTON_ACTIVE",
                x: 114,
                y: 16,
                width: 22,
                height: 16
              }],
              MAIN: [{
                name: "MAIN_WINDOW_BACKGROUND",
                x: 0,
                y: 0,
                width: 275,
                height: 116
              }],
              MONOSTER: [{
                name: "MAIN_STEREO",
                x: 0,
                y: 12,
                width: 29,
                height: 12
              }, {
                name: "MAIN_STEREO_SELECTED",
                x: 0,
                y: 0,
                width: 29,
                height: 12
              }, {
                name: "MAIN_MONO",
                x: 29,
                y: 12,
                width: 27,
                height: 12
              }, {
                name: "MAIN_MONO_SELECTED",
                x: 29,
                y: 0,
                width: 27,
                height: 12
              }],
              NUMBERS: [{
                name: "NO_MINUS_SIGN",
                x: 9,
                y: 6,
                width: 5,
                height: 1
              }, {
                name: "MINUS_SIGN",
                x: 20,
                y: 6,
                width: 5,
                height: 1
              }, {
                name: "DIGIT_0",
                x: 0,
                y: 0,
                width: 9,
                height: 13
              }, {
                name: "DIGIT_1",
                x: 9,
                y: 0,
                width: 9,
                height: 13
              }, {
                name: "DIGIT_2",
                x: 18,
                y: 0,
                width: 9,
                height: 13
              }, {
                name: "DIGIT_3",
                x: 27,
                y: 0,
                width: 9,
                height: 13
              }, {
                name: "DIGIT_4",
                x: 36,
                y: 0,
                width: 9,
                height: 13
              }, {
                name: "DIGIT_5",
                x: 45,
                y: 0,
                width: 9,
                height: 13
              }, {
                name: "DIGIT_6",
                x: 54,
                y: 0,
                width: 9,
                height: 13
              }, {
                name: "DIGIT_7",
                x: 63,
                y: 0,
                width: 9,
                height: 13
              }, {
                name: "DIGIT_8",
                x: 72,
                y: 0,
                width: 9,
                height: 13
              }, {
                name: "DIGIT_9",
                x: 81,
                y: 0,
                width: 9,
                height: 13
              }],
              NUMS_EX: [{
                name: "NO_MINUS_SIGN_EX",
                x: 90,
                y: 0,
                width: 9,
                height: 13
              }, {
                name: "MINUS_SIGN_EX",
                x: 99,
                y: 0,
                width: 9,
                height: 13
              }, {
                name: "DIGIT_0_EX",
                x: 0,
                y: 0,
                width: 9,
                height: 13
              }, {
                name: "DIGIT_1_EX",
                x: 9,
                y: 0,
                width: 9,
                height: 13
              }, {
                name: "DIGIT_2_EX",
                x: 18,
                y: 0,
                width: 9,
                height: 13
              }, {
                name: "DIGIT_3_EX",
                x: 27,
                y: 0,
                width: 9,
                height: 13
              }, {
                name: "DIGIT_4_EX",
                x: 36,
                y: 0,
                width: 9,
                height: 13
              }, {
                name: "DIGIT_5_EX",
                x: 45,
                y: 0,
                width: 9,
                height: 13
              }, {
                name: "DIGIT_6_EX",
                x: 54,
                y: 0,
                width: 9,
                height: 13
              }, {
                name: "DIGIT_7_EX",
                x: 63,
                y: 0,
                width: 9,
                height: 13
              }, {
                name: "DIGIT_8_EX",
                x: 72,
                y: 0,
                width: 9,
                height: 13
              }, {
                name: "DIGIT_9_EX",
                x: 81,
                y: 0,
                width: 9,
                height: 13
              }],
              PLAYPAUS: [{
                name: "MAIN_PLAYING_INDICATOR",
                x: 0,
                y: 0,
                width: 9,
                height: 9
              }, {
                name: "MAIN_PAUSED_INDICATOR",
                x: 9,
                y: 0,
                width: 9,
                height: 9
              }, {
                name: "MAIN_STOPPED_INDICATOR",
                x: 18,
                y: 0,
                width: 9,
                height: 9
              }, {
                name: "MAIN_NOT_WORKING_INDICATOR",
                x: 36,
                y: 0,
                width: 9,
                height: 9
              }, {
                name: "MAIN_WORKING_INDICATOR",
                x: 39,
                y: 0,
                width: 9,
                height: 9
              }],
              PLEDIT: [{
                name: "PLAYLIST_TOP_TILE",
                x: 127,
                y: 21,
                width: 25,
                height: 20
              }, {
                name: "PLAYLIST_TOP_LEFT_CORNER",
                x: 0,
                y: 21,
                width: 25,
                height: 20
              }, {
                name: "PLAYLIST_TITLE_BAR",
                x: 26,
                y: 21,
                width: 100,
                height: 20
              }, {
                name: "PLAYLIST_TOP_RIGHT_CORNER",
                x: 153,
                y: 21,
                width: 25,
                height: 20
              }, {
                name: "PLAYLIST_TOP_TILE_SELECTED",
                x: 127,
                y: 0,
                width: 25,
                height: 20
              }, {
                name: "PLAYLIST_TOP_LEFT_SELECTED",
                x: 0,
                y: 0,
                width: 25,
                height: 20
              }, {
                name: "PLAYLIST_TITLE_BAR_SELECTED",
                x: 26,
                y: 0,
                width: 100,
                height: 20
              }, {
                name: "PLAYLIST_TOP_RIGHT_CORNER_SELECTED",
                x: 153,
                y: 0,
                width: 25,
                height: 20
              }, {
                name: "PLAYLIST_LEFT_TILE",
                x: 0,
                y: 42,
                width: 12,
                height: 29
              }, {
                name: "PLAYLIST_RIGHT_TILE",
                x: 31,
                y: 42,
                width: 20,
                height: 29
              }, {
                name: "PLAYLIST_BOTTOM_TILE",
                x: 179,
                y: 0,
                width: 25,
                height: 38
              }, {
                name: "PLAYLIST_BOTTOM_LEFT_CORNER",
                x: 0,
                y: 72,
                width: 125,
                height: 38
              }, {
                name: "PLAYLIST_BOTTOM_RIGHT_CORNER",
                x: 126,
                y: 72,
                width: 150,
                height: 38
              }, {
                name: "PLAYLIST_VISUALIZER_BACKGROUND",
                x: 205,
                y: 0,
                width: 75,
                height: 38
              }, {
                name: "PLAYLIST_SHADE_BACKGROUND",
                x: 72,
                y: 57,
                width: 25,
                height: 14
              }, {
                name: "PLAYLIST_SHADE_BACKGROUND_LEFT",
                x: 72,
                y: 42,
                width: 25,
                height: 14
              }, {
                name: "PLAYLIST_SHADE_BACKGROUND_RIGHT",
                x: 99,
                y: 57,
                width: 50,
                height: 14
              }, {
                name: "PLAYLIST_SHADE_BACKGROUND_RIGHT_SELECTED",
                x: 99,
                y: 42,
                width: 50,
                height: 14
              }, {
                name: "PLAYLIST_SCROLL_HANDLE_SELECTED",
                x: 61,
                y: 53,
                width: 8,
                height: 18
              }, {
                name: "PLAYLIST_SCROLL_HANDLE",
                x: 52,
                y: 53,
                width: 8,
                height: 18
              }, {
                name: "PLAYLIST_ADD_URL",
                x: 0,
                y: 111,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_ADD_URL_SELECTED",
                x: 23,
                y: 111,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_ADD_DIR",
                x: 0,
                y: 130,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_ADD_DIR_SELECTED",
                x: 23,
                y: 130,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_ADD_FILE",
                x: 0,
                y: 149,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_ADD_FILE_SELECTED",
                x: 23,
                y: 149,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_REMOVE_ALL",
                x: 54,
                y: 111,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_REMOVE_ALL_SELECTED",
                x: 77,
                y: 111,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_CROP",
                x: 54,
                y: 130,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_CROP_SELECTED",
                x: 77,
                y: 130,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_REMOVE_SELECTED",
                x: 54,
                y: 149,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_REMOVE_SELECTED_SELECTED",
                x: 77,
                y: 149,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_REMOVE_MISC",
                x: 54,
                y: 168,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_REMOVE_MISC_SELECTED",
                x: 77,
                y: 168,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_INVERT_SELECTION",
                x: 104,
                y: 111,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_INVERT_SELECTION_SELECTED",
                x: 127,
                y: 111,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_SELECT_ZERO",
                x: 104,
                y: 130,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_SELECT_ZERO_SELECTED",
                x: 127,
                y: 130,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_SELECT_ALL",
                x: 104,
                y: 149,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_SELECT_ALL_SELECTED",
                x: 127,
                y: 149,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_SORT_LIST",
                x: 154,
                y: 111,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_SORT_LIST_SELECTED",
                x: 177,
                y: 111,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_FILE_INFO",
                x: 154,
                y: 130,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_FILE_INFO_SELECTED",
                x: 177,
                y: 130,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_MISC_OPTIONS",
                x: 154,
                y: 149,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_MISC_OPTIONS_SELECTED",
                x: 177,
                y: 149,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_NEW_LIST",
                x: 204,
                y: 111,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_NEW_LIST_SELECTED",
                x: 227,
                y: 111,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_SAVE_LIST",
                x: 204,
                y: 130,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_SAVE_LIST_SELECTED",
                x: 227,
                y: 130,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_LOAD_LIST",
                x: 204,
                y: 149,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_LOAD_LIST_SELECTED",
                x: 227,
                y: 149,
                width: 22,
                height: 18
              }, {
                name: "PLAYLIST_ADD_MENU_BAR",
                x: 48,
                y: 111,
                width: 3,
                height: 54
              }, {
                name: "PLAYLIST_REMOVE_MENU_BAR",
                x: 100,
                y: 111,
                width: 3,
                height: 72
              }, {
                name: "PLAYLIST_SELECT_MENU_BAR",
                x: 150,
                y: 111,
                width: 3,
                height: 54
              }, {
                name: "PLAYLIST_MISC_MENU_BAR",
                x: 200,
                y: 111,
                width: 3,
                height: 54
              }, {
                name: "PLAYLIST_LIST_BAR",
                x: 250,
                y: 111,
                width: 3,
                height: 54
              }, {
                name: "PLAYLIST_CLOSE_SELECTED",
                x: 52,
                y: 42,
                width: 9,
                height: 9
              }, {
                name: "PLAYLIST_COLLAPSE_SELECTED",
                x: 62,
                y: 42,
                width: 9,
                height: 9
              }, {
                name: "PLAYLIST_EXPAND_SELECTED",
                x: 150,
                y: 42,
                width: 9,
                height: 9
              }],
              EQ_EX: [{
                name: "EQ_SHADE_BACKGROUND_SELECTED",
                x: 0,
                y: 0,
                width: 275,
                height: 14
              }, {
                name: "EQ_SHADE_BACKGROUND",
                x: 0,
                y: 15,
                width: 275,
                height: 14
              }, {
                name: "EQ_SHADE_VOLUME_SLIDER_LEFT",
                x: 1,
                y: 30,
                width: 3,
                height: 7
              }, {
                name: "EQ_SHADE_VOLUME_SLIDER_CENTER",
                x: 4,
                y: 30,
                width: 3,
                height: 7
              }, {
                name: "EQ_SHADE_VOLUME_SLIDER_RIGHT",
                x: 7,
                y: 30,
                width: 3,
                height: 7
              }, {
                name: "EQ_SHADE_BALANCE_SLIDER_LEFT",
                x: 11,
                y: 30,
                width: 3,
                height: 7
              }, {
                name: "EQ_SHADE_BALANCE_SLIDER_CENTER",
                x: 14,
                y: 30,
                width: 3,
                height: 7
              }, {
                name: "EQ_SHADE_BALANCE_SLIDER_RIGHT",
                x: 17,
                y: 30,
                width: 3,
                height: 7
              }, {
                name: "EQ_MAXIMIZE_BUTTON_ACTIVE",
                x: 1,
                y: 38,
                width: 9,
                height: 9
              }, {
                name: "EQ_MINIMIZE_BUTTON_ACTIVE",
                x: 1,
                y: 47,
                width: 9,
                height: 9
              }, {
                name: "EQ_SHADE_CLOSE_BUTTON",
                x: 11,
                y: 38,
                width: 9,
                height: 9
              }, {
                name: "EQ_SHADE_CLOSE_BUTTON_ACTIVE",
                x: 11,
                y: 47,
                width: 9,
                height: 9
              }],
              EQMAIN: [
                {
                  name: "EQ_WINDOW_BACKGROUND",
                  x: 0,
                  y: 0,
                  width: 275,
                  height: 116
                },
                {
                  name: "EQ_TITLE_BAR",
                  x: 0,
                  y: 149,
                  width: 275,
                  height: 14
                },
                {
                  name: "EQ_TITLE_BAR_SELECTED",
                  x: 0,
                  y: 134,
                  width: 275,
                  height: 14
                },
                {
                  name: "EQ_SLIDER_BACKGROUND",
                  x: 13,
                  y: 164,
                  width: 209,
                  height: 129
                },
                {
                  name: "EQ_SLIDER_THUMB",
                  x: 0,
                  y: 164,
                  width: 11,
                  height: 11
                },
                {
                  name: "EQ_SLIDER_THUMB_SELECTED",
                  x: 0,
                  y: 176,
                  width: 11,
                  height: 11
                },
                {
                  name: "EQ_CLOSE_BUTTON",
                  x: 0,
                  y: 116,
                  width: 9,
                  height: 9
                },
                {
                  name: "EQ_CLOSE_BUTTON_ACTIVE",
                  x: 0,
                  y: 125,
                  width: 9,
                  height: 9
                },
                // This is technically not a sprite, it's just part of the background.
                // However, we extract it to use it as a fallback for
                // `EQ_MAXIMIZE_BUTTON_ACTIVE`. Without this, skins that don't implement
                // `eq_ex.bmp` would show the default skin's `EQ_MAXIMIZE_BUTTON_ACTIVE`
                // instead of showing no sprite aka, just showing through to this portion of
                // the title bar image.
                {
                  name: "EQ_MAXIMIZE_BUTTON_ACTIVE_FALLBACK",
                  x: 254,
                  y: 152,
                  width: 9,
                  height: 9
                },
                {
                  name: "EQ_ON_BUTTON",
                  x: 10,
                  y: 119,
                  width: 26,
                  height: 12
                },
                {
                  name: "EQ_ON_BUTTON_DEPRESSED",
                  x: 128,
                  y: 119,
                  width: 26,
                  height: 12
                },
                {
                  name: "EQ_ON_BUTTON_SELECTED",
                  x: 69,
                  y: 119,
                  width: 26,
                  height: 12
                },
                {
                  name: "EQ_ON_BUTTON_SELECTED_DEPRESSED",
                  x: 187,
                  y: 119,
                  width: 26,
                  height: 12
                },
                {
                  name: "EQ_AUTO_BUTTON",
                  x: 36,
                  y: 119,
                  width: 32,
                  height: 12
                },
                {
                  name: "EQ_AUTO_BUTTON_DEPRESSED",
                  x: 154,
                  y: 119,
                  width: 32,
                  height: 12
                },
                {
                  name: "EQ_AUTO_BUTTON_SELECTED",
                  x: 95,
                  y: 119,
                  width: 32,
                  height: 12
                },
                {
                  name: "EQ_AUTO_BUTTON_SELECTED_DEPRESSED",
                  x: 213,
                  y: 119,
                  width: 32,
                  height: 12
                },
                {
                  name: "EQ_GRAPH_BACKGROUND",
                  x: 0,
                  y: 294,
                  width: 113,
                  height: 19
                },
                {
                  name: "EQ_GRAPH_LINE_COLORS",
                  x: 115,
                  y: 294,
                  width: 1,
                  height: 19
                },
                {
                  name: "EQ_PRESETS_BUTTON",
                  x: 224,
                  y: 164,
                  width: 44,
                  height: 12
                },
                {
                  name: "EQ_PRESETS_BUTTON_SELECTED",
                  x: 224,
                  y: 176,
                  width: 44,
                  height: 12
                },
                {
                  name: "EQ_PREAMP_LINE",
                  x: 0,
                  y: 314,
                  width: 113,
                  height: 1
                }
              ],
              POSBAR: [{
                name: "MAIN_POSITION_SLIDER_BACKGROUND",
                x: 0,
                y: 0,
                width: 248,
                height: 10
              }, {
                name: "MAIN_POSITION_SLIDER_THUMB",
                x: 248,
                y: 0,
                width: 29,
                height: 10
              }, {
                name: "MAIN_POSITION_SLIDER_THUMB_SELECTED",
                x: 278,
                y: 0,
                width: 29,
                height: 10
              }],
              SHUFREP: [{
                name: "MAIN_SHUFFLE_BUTTON",
                x: 28,
                y: 0,
                width: 47,
                height: 15
              }, {
                name: "MAIN_SHUFFLE_BUTTON_DEPRESSED",
                x: 28,
                y: 15,
                width: 47,
                height: 15
              }, {
                name: "MAIN_SHUFFLE_BUTTON_SELECTED",
                x: 28,
                y: 30,
                width: 47,
                height: 15
              }, {
                name: "MAIN_SHUFFLE_BUTTON_SELECTED_DEPRESSED",
                x: 28,
                y: 45,
                width: 47,
                height: 15
              }, {
                name: "MAIN_REPEAT_BUTTON",
                x: 0,
                y: 0,
                width: 28,
                height: 15
              }, {
                name: "MAIN_REPEAT_BUTTON_DEPRESSED",
                x: 0,
                y: 15,
                width: 28,
                height: 15
              }, {
                name: "MAIN_REPEAT_BUTTON_SELECTED",
                x: 0,
                y: 30,
                width: 28,
                height: 15
              }, {
                name: "MAIN_REPEAT_BUTTON_SELECTED_DEPRESSED",
                x: 0,
                y: 45,
                width: 28,
                height: 15
              }, {
                name: "MAIN_EQ_BUTTON",
                x: 0,
                y: 61,
                width: 23,
                height: 12
              }, {
                name: "MAIN_EQ_BUTTON_SELECTED",
                x: 0,
                y: 73,
                width: 23,
                height: 12
              }, {
                name: "MAIN_EQ_BUTTON_DEPRESSED",
                x: 46,
                y: 61,
                width: 23,
                height: 12
              }, {
                name: "MAIN_EQ_BUTTON_DEPRESSED_SELECTED",
                x: 46,
                y: 73,
                width: 23,
                height: 12
              }, {
                name: "MAIN_PLAYLIST_BUTTON",
                x: 23,
                y: 61,
                width: 23,
                height: 12
              }, {
                name: "MAIN_PLAYLIST_BUTTON_SELECTED",
                x: 23,
                y: 73,
                width: 23,
                height: 12
              }, {
                name: "MAIN_PLAYLIST_BUTTON_DEPRESSED",
                x: 69,
                y: 61,
                width: 23,
                height: 12
              }, {
                name: "MAIN_PLAYLIST_BUTTON_DEPRESSED_SELECTED",
                x: 69,
                y: 73,
                width: 23,
                height: 12
              }],
              TEXT: characterSprites,
              TITLEBAR: [{
                name: "MAIN_TITLE_BAR",
                x: 27,
                y: 15,
                width: 275,
                height: 14
              }, {
                name: "MAIN_TITLE_BAR_SELECTED",
                x: 27,
                y: 0,
                width: 275,
                height: 14
              }, {
                name: "MAIN_EASTER_EGG_TITLE_BAR",
                x: 27,
                y: 72,
                width: 275,
                height: 14
              }, {
                name: "MAIN_EASTER_EGG_TITLE_BAR_SELECTED",
                x: 27,
                y: 57,
                width: 275,
                height: 14
              }, {
                name: "MAIN_OPTIONS_BUTTON",
                x: 0,
                y: 0,
                width: 9,
                height: 9
              }, {
                name: "MAIN_OPTIONS_BUTTON_DEPRESSED",
                x: 0,
                y: 9,
                width: 9,
                height: 9
              }, {
                name: "MAIN_MINIMIZE_BUTTON",
                x: 9,
                y: 0,
                width: 9,
                height: 9
              }, {
                name: "MAIN_MINIMIZE_BUTTON_DEPRESSED",
                x: 9,
                y: 9,
                width: 9,
                height: 9
              }, {
                name: "MAIN_SHADE_BUTTON",
                x: 0,
                y: 18,
                width: 9,
                height: 9
              }, {
                name: "MAIN_SHADE_BUTTON_DEPRESSED",
                x: 9,
                y: 18,
                width: 9,
                height: 9
              }, {
                name: "MAIN_CLOSE_BUTTON",
                x: 18,
                y: 0,
                width: 9,
                height: 9
              }, {
                name: "MAIN_CLOSE_BUTTON_DEPRESSED",
                x: 18,
                y: 9,
                width: 9,
                height: 9
              }, {
                name: "MAIN_CLUTTER_BAR_BACKGROUND",
                x: 304,
                y: 0,
                width: 8,
                height: 43
              }, {
                name: "MAIN_CLUTTER_BAR_BACKGROUND_DISABLED",
                x: 312,
                y: 0,
                width: 8,
                height: 43
              }, {
                name: "MAIN_CLUTTER_BAR_BUTTON_O_SELECTED",
                x: 304,
                y: 47,
                width: 8,
                height: 8
              }, {
                name: "MAIN_CLUTTER_BAR_BUTTON_A_SELECTED",
                x: 312,
                y: 55,
                width: 8,
                height: 7
              }, {
                name: "MAIN_CLUTTER_BAR_BUTTON_I_SELECTED",
                x: 320,
                y: 62,
                width: 8,
                height: 7
              }, {
                name: "MAIN_CLUTTER_BAR_BUTTON_D_SELECTED",
                x: 328,
                y: 69,
                width: 8,
                height: 8
              }, {
                name: "MAIN_CLUTTER_BAR_BUTTON_V_SELECTED",
                x: 336,
                y: 77,
                width: 8,
                height: 7
              }, {
                name: "MAIN_SHADE_BACKGROUND",
                x: 27,
                y: 42,
                width: 275,
                height: 14
              }, {
                name: "MAIN_SHADE_BACKGROUND_SELECTED",
                x: 27,
                y: 29,
                width: 275,
                height: 14
              }, {
                name: "MAIN_SHADE_BUTTON_SELECTED",
                x: 0,
                y: 27,
                width: 9,
                height: 9
              }, {
                name: "MAIN_SHADE_BUTTON_SELECTED_DEPRESSED",
                x: 9,
                y: 27,
                width: 9,
                height: 9
              }, {
                name: "MAIN_SHADE_POSITION_BACKGROUND",
                x: 0,
                y: 36,
                width: 17,
                height: 7
              }, {
                name: "MAIN_SHADE_POSITION_THUMB",
                x: 20,
                y: 36,
                width: 3,
                height: 7
              }, {
                name: "MAIN_SHADE_POSITION_THUMB_LEFT",
                x: 17,
                y: 36,
                width: 3,
                height: 7
              }, {
                name: "MAIN_SHADE_POSITION_THUMB_RIGHT",
                x: 23,
                y: 36,
                width: 3,
                height: 7
              }],
              VOLUME: [{
                name: "MAIN_VOLUME_BACKGROUND",
                x: 0,
                y: 0,
                width: 68,
                height: 420
              }, {
                name: "MAIN_VOLUME_THUMB",
                x: 15,
                y: 422,
                width: 14,
                height: 11
              }, {
                name: "MAIN_VOLUME_THUMB_SELECTED",
                x: 0,
                y: 422,
                width: 14,
                height: 11
              }],
              GEN: [{
                name: "GEN_TOP_LEFT_SELECTED",
                x: 0,
                y: 0,
                width: 25,
                height: 20
              }, {
                name: "GEN_TOP_LEFT_END_SELECTED",
                x: 26,
                y: 0,
                width: 25,
                height: 20
              }, {
                name: "GEN_TOP_CENTER_FILL_SELECTED",
                x: 52,
                y: 0,
                width: 25,
                height: 20
              }, {
                name: "GEN_TOP_RIGHT_END_SELECTED",
                x: 78,
                y: 0,
                width: 25,
                height: 20
              }, {
                name: "GEN_TOP_LEFT_RIGHT_FILL_SELECTED",
                x: 104,
                y: 0,
                width: 25,
                height: 20
              }, {
                name: "GEN_TOP_RIGHT_SELECTED",
                x: 130,
                y: 0,
                width: 25,
                height: 20
              }, {
                name: "GEN_TOP_LEFT",
                x: 0,
                y: 21,
                width: 25,
                height: 20
              }, {
                name: "GEN_TOP_LEFT_END",
                x: 26,
                y: 21,
                width: 25,
                height: 20
              }, {
                name: "GEN_TOP_CENTER_FILL",
                x: 52,
                y: 21,
                width: 25,
                height: 20
              }, {
                name: "GEN_TOP_RIGHT_END",
                x: 78,
                y: 21,
                width: 25,
                height: 20
              }, {
                name: "GEN_TOP_LEFT_RIGHT_FILL",
                x: 104,
                y: 21,
                width: 25,
                height: 20
              }, {
                name: "GEN_TOP_RIGHT",
                x: 130,
                y: 21,
                width: 25,
                height: 20
              }, {
                name: "GEN_BOTTOM_LEFT",
                x: 0,
                y: 42,
                width: 125,
                height: 14
              }, {
                name: "GEN_BOTTOM_RIGHT",
                x: 0,
                y: 57,
                width: 125,
                height: 14
              }, {
                name: "GEN_BOTTOM_FILL",
                x: 127,
                y: 72,
                width: 25,
                height: 14
              }, {
                name: "GEN_MIDDLE_LEFT",
                x: 127,
                y: 42,
                width: 11,
                height: 29
              }, {
                name: "GEN_MIDDLE_LEFT_BOTTOM",
                x: 158,
                y: 42,
                width: 11,
                height: 24
              }, {
                name: "GEN_MIDDLE_RIGHT",
                x: 139,
                y: 42,
                width: 8,
                height: 29
              }, {
                name: "GEN_MIDDLE_RIGHT_BOTTOM",
                x: 170,
                y: 42,
                width: 8,
                height: 24
              }, {
                name: "GEN_CLOSE_SELECTED",
                x: 148,
                y: 42,
                width: 9,
                height: 9
              }]
              /*
               We don't currently support the Media Library, so there are disabled
              GENEX: [
                {
                  name: "GENEX_BUTTON_BACKGROUND_LEFT_UNPRESSED",
                  x: 0,
                  y: 0,
                  height: 15,
                  width: 4,
                },
                {
                  name: "GENEX_BUTTON_BACKGROUND_CENTER_UNPRESSED",
                  x: 4,
                  y: 0,
                  height: 15,
                  width: 39,
                },
                {
                  name: "GENEX_BUTTON_BACKGROUND_RIGHT_UNPRESSED",
                  x: 43,
                  y: 0,
                  height: 15,
                  width: 4,
                },
                {
                  name: "GENEX_BUTTON_BACKGROUND_PRESSED",
                  x: 0,
                  y: 1,
                  height: 15,
                  width: 47,
                },
                { name: "GENEX_SCROLL_UP_UNPRESSED", x: 0, y: 31, height: 14, width: 14 },
                {
                  name: "GENEX_SCROLL_DOWN_UNPRESSED",
                  x: 14,
                  y: 31,
                  height: 14,
                  width: 14,
                },
                { name: "GENEX_SCROLL_UP_PRESSED", x: 28, y: 31, height: 14, width: 14 },
                { name: "GENEX_SCROLL_DOWN_PRESSED", x: 42, y: 31, height: 14, width: 14 },
                { name: "GENEX_SCROLL_LEFT_UNPRESSED", x: 0, y: 45, height: 14, width: 14 },
                {
                  name: "GENEX_SCROLL_RIGHT_UNPRESSED",
                  x: 14,
                  y: 45,
                  height: 14,
                  width: 14,
                },
                { name: "GENEX_SCROLL_LEFT_PRESSED", x: 28, y: 45, height: 14, width: 14 },
                { name: "GENEX_SCROLL_RIGHT_PRESSED", x: 42, y: 45, height: 14, width: 14 },
                {
                  name: "GENEX_VERTICAL_SCROLL_HANDLE_UNPRESSED",
                  x: 56,
                  y: 31,
                  height: 28,
                  width: 14,
                },
                {
                  name: "GENEX_VERTICAL_SCROLL_HANDLE_PRESSED",
                  x: 70,
                  y: 31,
                  height: 28,
                  width: 14,
                },
                {
                  name: "GENEX_HORIZONTAL_SCROLL_HANDLE_UNPRESSED",
                  x: 84,
                  y: 31,
                  height: 14,
                  width: 28,
                },
                {
                  name: "GENEX_HORIZONTAL_SCROLL_HANDLE_PRESSED",
                  x: 84,
                  y: 45,
                  height: 14,
                  width: 28,
                },
              ],
              */
            };
            var skinSprites = skinSprites_sprites;
            function pointPairs(arr) {
              const pairedValues = [];
              for (let i = 0; i < arr.length; i += 2) {
                pairedValues.push(`${arr[i]},${arr[i + 1]}`);
              }
              return pairedValues;
            }
            function regionParser(regionStr) {
              const iniData = parseIni(regionStr);
              const data = {};
              Object.keys(iniData).forEach((section) => {
                const {
                  numpoints,
                  pointlist
                } = iniData[section];
                if (!numpoints || !pointlist) {
                  return;
                }
                const pointCounts = numpoints.split(/\s*,\s*/).filter((val) => val !== "");
                const points = pointPairs(
                  // points can be separated by spaces, or by commas
                  pointlist.split(/\s*[, ]\s*/).filter((val) => val !== "")
                );
                let pointIndex = 0;
                const polygons = pointCounts.map((numStr) => {
                  const num = Number(numStr);
                  if (num < 3) {
                    pointIndex += num;
                    return null;
                  }
                  const polygon = points.slice(pointIndex, pointIndex + num).join(" ");
                  if (!polygon.length) {
                    return null;
                  }
                  pointIndex += num;
                  return polygon;
                });
                const validPolygons = polygons.filter((polygon) => polygon != null);
                if (validPolygons.length) {
                  data[section] = validPolygons;
                }
              });
              return data;
            }
            function skinParserUtils_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function skinParserUtils_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  skinParserUtils_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  skinParserUtils_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            const getFileExtension = (fileName) => {
              const matches = /\.([a-z]{3,4})$/i.exec(fileName);
              return matches ? matches[1].toLowerCase() : null;
            };
            function getFilenameRegex(base, ext) {
              return new RegExp(`^(.*[/\\\\])?${base}.(${ext})$`, "i");
            }
            async function getFileFromZip(zip, fileName, ext, mode) {
              const files = zip.file(getFilenameRegex(fileName, ext));
              if (!files.length) {
                return null;
              }
              const lastFile = files[files.length - 1];
              try {
                const contents = await lastFile.async(mode);
                return {
                  contents,
                  name: lastFile.name
                };
              } catch (e) {
                console.warn(`Failed to extract "${fileName}.${ext}" from the skin archive.`);
                return null;
              }
            }
            function fallbackGetImgFromBlob(blob) {
              return imgFromUrl(URL.createObjectURL(blob));
            }
            async function getImgFromBlob(blob) {
              try {
                return await window.createImageBitmap(blob);
              } catch (e) {
                try {
                  return await fallbackGetImgFromBlob(blob);
                } catch (ee) {
                  return null;
                }
              }
            }
            function getSpriteUrisFromImg(img, sprites) {
              const canvas = document.createElement("canvas");
              const context = canvas.getContext("2d");
              if (context == null) {
                throw new Error("Failed to get canvas context");
              }
              const images = {};
              sprites.forEach((sprite) => {
                canvas.height = sprite.height;
                canvas.width = sprite.width;
                context.drawImage(img, -sprite.x, -sprite.y);
                const image = canvas.toDataURL();
                images[sprite.name] = image;
              });
              return images;
            }
            async function getImgFromFilename(zip, fileName) {
              const file = await getFileFromZip(zip, fileName, "(png|bmp)", "blob");
              if (!file) {
                return null;
              }
              const mimeType = `image/${getFileExtension(file.name) || "*"}`;
              const typedBlob = new Blob([file.contents], {
                type: mimeType
              });
              return getImgFromBlob(typedBlob);
            }
            async function getSpriteUrisFromFilename(zip, fileName) {
              const img = await getImgFromFilename(zip, fileName);
              if (img == null) {
                return {};
              }
              return getSpriteUrisFromImg(img, skinSprites[fileName]);
            }
            const RIFF_MAGIC = "RIFF".split("").map((c) => c.charCodeAt(0));
            function arrayStartsWith(arr, matcher) {
              return matcher.every((item, i) => arr[i] === item);
            }
            async function getCursorFromFilename(zip, fileName) {
              const file = await getFileFromZip(zip, fileName, "CUR", "uint8array");
              if (file == null) {
                return null;
              }
              const contents = file.contents;
              if (arrayStartsWith(contents, RIFF_MAGIC)) {
                return {
                  type: "ani",
                  aniData: contents
                };
              }
              return {
                type: "cur",
                url: curUrlFromByteArray(contents)
              };
            }
            async function getPlaylistStyle(zip) {
              const files = zip.file(getFilenameRegex("PLEDIT", "txt"));
              const file = files[0];
              if (file == null) {
                return DEFAULT_SKIN.playlistStyle;
              }
              const ini = await file.async("text");
              if (ini == null) {
                return DEFAULT_SKIN.playlistStyle;
              }
              const data = ini && parseIni(ini).text;
              if (!data) {
                return DEFAULT_SKIN.playlistStyle;
              }
              ["normal", "current", "normalbg", "selectedbg", "mbFG", "mbBG"].forEach((colorKey) => {
                let color = data[colorKey];
                if (!color) {
                  return;
                }
                if (color[0] !== "#") {
                  color = `#${color}`;
                }
                data[colorKey] = color.slice(0, 7);
              });
              return skinParserUtils_objectSpread(skinParserUtils_objectSpread({}, DEFAULT_SKIN.playlistStyle), data);
            }
            async function getGenExColors(zip) {
              const img = await getImgFromFilename(zip, "GENEX");
              if (img == null) {
                return null;
              }
              const canvas = document.createElement("canvas");
              const context = canvas.getContext("2d");
              if (context == null) {
                return null;
              }
              canvas.width = img.width;
              canvas.height = img.height;
              context.drawImage(img, 0, 0);
              const getColorAt = (x) => `rgb(${context.getImageData(x, 0, 1, 1).data.slice(0, 3).join(",")})`;
              return {
                // (1) x=48: item background (background to edits, listviews, etc.)
                itemBackground: getColorAt(48),
                // (2) x=50: item foreground (text colour of edits, listviews, etc.)
                itemForeground: getColorAt(50),
                // (3) x=52: window background (used to set the bg color for the dialog)
                windowBackground: getColorAt(52),
                // (4) x=54: button text colour
                buttonText: getColorAt(54),
                // (5) x=56: window text colour
                windowText: getColorAt(56),
                // (6) x=58: colour of dividers and sunken borders
                divider: getColorAt(58),
                // (7) x=60: selection colour for entries inside playlists (nothing else yet)
                playlistSelection: getColorAt(60),
                // (8) x=62: listview header background colour
                listHeaderBackground: getColorAt(62),
                // (9) x=64: listview header text colour
                listHeaderText: getColorAt(64),
                // (10) x=66: listview header frame top and left colour
                listHeaderFrameTopAndLeft: getColorAt(66),
                // (11) x=68: listview header frame bottom and right colour
                listHeaderFrameBottomAndRight: getColorAt(68),
                // (12) x=70: listview header frame colour, when pressed
                listHeaderFramePressed: getColorAt(70),
                // (13) x=72: listview header dead area colour
                listHeaderDeadArea: getColorAt(72),
                // (14) x=74: scrollbar colour #1
                scrollbarOne: getColorAt(74),
                // (15) x=76: scrollbar colour #2
                scrollbarTwo: getColorAt(76),
                // (16) x=78: pressed scrollbar colour #1
                pressedScrollbarOne: getColorAt(78),
                // (17) x=80: pressed scrollbar colour #2
                pressedScrollbarTwo: getColorAt(80),
                // (18) x=82: scrollbar dead area colour
                scrollbarDeadArea: getColorAt(82),
                // (19) x=84 List view text colour highlighted
                listTextHighlighted: getColorAt(84),
                // (20) x=86 List view background colour highlighted
                listTextHighlightedBackground: getColorAt(86),
                // (21) x=88 List view text colour selected
                listTextSelected: getColorAt(88),
                // (22) x=90 List view background colour selected
                listTextSelectedBackground: getColorAt(90)
              };
            }
            function skinParser_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function skinParser_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  skinParser_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  skinParser_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            const shallowMerge = (objs) => objs.reduce((prev, img) => Object.assign(prev, img), {});
            const CURSORS = [
              "CLOSE",
              "EQCLOSE",
              "EQNORMAL",
              "EQSLID",
              "EQTITLE",
              "MAINMENU",
              "MMENU",
              "MIN",
              "NORMAL",
              "PCLOSE",
              "PNORMAL",
              "POSBAR",
              "PSIZE",
              "PTBAR",
              "PVSCROLL",
              "PWINBUT",
              "PWSNORM",
              "PWSSIZE",
              "SONGNAME",
              "TITLEBAR",
              "VOLBAL",
              "WINBUT",
              "WSNORMAL",
              "WSPOSBAR"
              /*
               * > There are usually 4 more cursors in the skins: volbar.cur, wsclose.cur,
               * > wswinbut.cur, wsmin.cur, but they are never used, at least in the last
               * > versions of winamp, so there's no need of including them. The cursors
               * > shown when the mouse is over the app-buttons are the same in normal and
               * > winshade mode, except for the main menu button. You can make animated
               * > cursors, but you have to name them with the extension .cur (animated
               * > cursors are usually .ani files).
               *
               * -- Skinners Atlas
               *
               * "VOLBAR",
               * "WSCLOSE",
               * "WSWINBUT",
               * "WSMIN",
               *
               */
            ];
            async function genVizColors(zip) {
              const viscolor = await getFileFromZip(zip, "VISCOLOR", "txt", "text");
              return viscolor ? parseViscolors(viscolor.contents) : DEFAULT_SKIN.colors;
            }
            async function genImages(zip) {
              const imageObjs = await Promise.all(Object.keys(skinSprites).map((fileName) => getSpriteUrisFromFilename(zip, fileName)));
              return shallowMerge(imageObjs);
            }
            async function genCursors(zip) {
              const cursorObjs = await Promise.all(CURSORS.map(async (cursorName) => ({
                [cursorName]: await getCursorFromFilename(zip, cursorName)
              })));
              return shallowMerge(cursorObjs);
            }
            async function genRegion(zip) {
              const region = await getFileFromZip(zip, "REGION", "txt", "text");
              return region ? regionParser(region.contents) : {};
            }
            async function genGenTextSprites(zip) {
              const img = await getImgFromFilename(zip, "GEN");
              if (img == null) {
                return null;
              }
              const canvas = document.createElement("canvas");
              const context = canvas.getContext("2d");
              canvas.width = img.width;
              canvas.height = img.height;
              context.drawImage(img, 0, 0);
              const getLetters = (y, prefix) => {
                const getColorAt = (x2) => context.getImageData(x2, y, 1, 1).data.join(",");
                let x = 1;
                const backgroundColor = getColorAt(0);
                const height = 7;
                return LETTERS.map((letter) => {
                  let nextBackground = x;
                  while (getColorAt(nextBackground) !== backgroundColor && nextBackground < canvas.width) {
                    nextBackground++;
                  }
                  const width = nextBackground - x;
                  const name = `${prefix}_${letter}`;
                  const sprite = {
                    x,
                    y,
                    height,
                    width,
                    name
                  };
                  x = nextBackground + 1;
                  return sprite;
                });
              };
              const letterWidths = {};
              const sprites = [...getLetters(88, "GEN_TEXT_SELECTED"), ...getLetters(96, "GEN_TEXT")];
              sprites.forEach((sprite) => {
                letterWidths[sprite.name] = sprite.width;
              });
              return [letterWidths, getSpriteUrisFromImg(img, sprites)];
            }
            async function skinParser(zipFileBuffer, JSZip) {
              const zip = await JSZip.loadAsync(zipFileBuffer);
              const [colors, playlistStyle, images, cursors, region, genTextSprites, genExColors] = await Promise.all([genVizColors(zip), getPlaylistStyle(zip), genImages(zip), genCursors(zip), genRegion(zip), genGenTextSprites(zip), getGenExColors(zip)]);
              const [genLetterWidths, genTextImages] = genTextSprites || [null, {}];
              return {
                colors,
                playlistStyle,
                images: skinParser_objectSpread(skinParser_objectSpread({}, images), genTextImages),
                genLetterWidths,
                cursors,
                region,
                genExColors
              };
            }
            var js_skinParser = skinParser;
            var tinyqueue = __webpack_require__2(39);
            var tinyqueue_default = __webpack_require__2.n(tinyqueue);
            class loadQueue_LoadQueue {
              constructor({
                threads
              }) {
                this._queue = new tinyqueue_default.a([], (a, b) => a.priority() - b.priority());
                this._availableThreads = threads;
              }
              push(task, priority) {
                const t = {
                  task,
                  priority
                };
                this._queue.push(t);
                setTimeout(() => {
                  this._run();
                }, 0);
                return () => {
                  this._queue = this._queue.filter((t1) => t1 !== t);
                };
              }
              _run() {
                while (this._availableThreads > 0) {
                  if (this._queue.length === 0) {
                    return;
                  }
                  this._availableThreads--;
                  const t = this._queue.pop();
                  const promise = t.task();
                  browser_default()(typeof promise.then === "function", `LoadQueue only supports loading Promises. Got ${promise}`);
                  promise.then(() => {
                    this._availableThreads++;
                    this._run();
                  });
                }
              }
            }
            function cropPlaylist() {
              return (dispatch, getState) => {
                const state = getState();
                if (getSelectedTrackObjects(state).length === 0) {
                  return;
                }
                const selectedTrackIds = getSelectedTrackIds(state);
                const {
                  playlist: {
                    trackOrder
                  }
                } = state;
                dispatch({
                  type: REMOVE_TRACKS,
                  // @ts-ignore The keys are numbers, but TypeScript does not trust us.
                  // https://github.com/Microsoft/TypeScript/pull/12253#issuecomment-263132208
                  ids: trackOrder.filter((id) => !selectedTrackIds.has(id))
                });
              };
            }
            function removeSelectedTracks() {
              return (dispatch, getState) => {
                dispatch({
                  type: REMOVE_TRACKS,
                  // @ts-ignore The keys are numbers, but TypeScript does not trust us.
                  // https://github.com/Microsoft/TypeScript/pull/12253#issuecomment-263132208
                  ids: Array.from(getSelectedTrackIds(getState()))
                });
              };
            }
            function playlist_removeAllTracks() {
              return (dispatch) => {
                dispatch({
                  type: STOP
                });
                dispatch({
                  type: REMOVE_ALL_TRACKS
                });
              };
            }
            function playlist_reverseList() {
              return {
                type: REVERSE_LIST
              };
            }
            function playlist_randomizeList() {
              return {
                type: RANDOMIZE_LIST
              };
            }
            function playlist_sortListByTitle() {
              return (dispatch, getState) => {
                const state = getState();
                const tracks = getTracks(state);
                const trackOrder = sort(getTrackOrder(state), (i) => `${tracks[i].title}`.toLowerCase());
                return dispatch({
                  type: SET_TRACK_ORDER,
                  trackOrder
                });
              };
            }
            function playlist_setPlaylistScrollPosition(position) {
              return {
                type: SET_PLAYLIST_SCROLL_POSITION,
                position
              };
            }
            function scrollNTracks(n) {
              return (dispatch, getState) => {
                const state = getState();
                const overflow = getOverflowTrackCount(state);
                const currentOffset = getScrollOffset(state);
                const position = overflow ? clamp((currentOffset + n) / overflow, 0, 1) : 0;
                return dispatch({
                  type: SET_PLAYLIST_SCROLL_POSITION,
                  position: position * 100
                });
              };
            }
            function playlist_scrollPlaylistByDelta(e) {
              e.preventDefault();
              return (dispatch, getState) => {
                const state = getState();
                if (getOverflowTrackCount(state)) {
                  e.stopPropagation();
                }
                const totalPixelHeight = state.playlist.trackOrder.length * TRACK_HEIGHT;
                const percentDelta = e.deltaY / totalPixelHeight * 100;
                dispatch({
                  type: SET_PLAYLIST_SCROLL_POSITION,
                  position: clamp(state.display.playlistScrollPosition + percentDelta, 0, 100)
                });
              };
            }
            function playlist_scrollUpFourTracks() {
              return scrollNTracks(-4);
            }
            function playlist_scrollDownFourTracks() {
              return scrollNTracks(4);
            }
            function playlist_dragSelected(offset) {
              return (dispatch, getState) => {
                const state = getState();
                const tracks = getTracks(state);
                const trackOrder = getTrackOrder(state);
                const selectedIds = getSelectedTrackIds(state);
                const firstSelected = trackOrder.findIndex((trackId) => tracks[trackId] && selectedIds.has(trackId));
                if (firstSelected === -1) {
                  return;
                }
                const lastSelected = findLastIndex(trackOrder, (trackId) => tracks[trackId] && selectedIds.has(trackId));
                if (lastSelected === -1) {
                  throw new Error("We found a first selected, but not a last selected.");
                }
                const min = -firstSelected;
                const max = trackOrder.length - 1 - lastSelected;
                const normalizedOffset = clamp(offset, min, max);
                if (normalizedOffset !== 0) {
                  dispatch({
                    type: DRAG_SELECTED,
                    offset: normalizedOffset
                  });
                }
              };
            }
            function invertSelection() {
              return {
                type: INVERT_SELECTION
              };
            }
            function playlist_selectZero() {
              return {
                type: SELECT_ZERO
              };
            }
            function selectAll() {
              return {
                type: SELECT_ALL
              };
            }
            const DURATION_VISIBLE_PRIORITY = 5;
            const META_DATA_VISIBLE_PRIORITY = 10;
            const DURATION_PRIORITY = 15;
            const META_DATA_PRIORITY = 20;
            const loadQueue = new loadQueue_LoadQueue({
              threads: 4
            });
            function addTracksFromReferences(fileReferences, loadStyle, atIndex) {
              const tracks = Array.from(fileReferences).map((file) => ({
                blob: file,
                defaultName: file.name
              }));
              return files_loadMediaFiles(tracks, loadStyle, atIndex);
            }
            const SKIN_FILENAME_MATCHER = new RegExp("(wsz|zip)$", "i");
            const EQF_FILENAME_MATCHER = new RegExp("eqf$", "i");
            function loadFilesFromReferences(fileReferences, loadStyle = LOAD_STYLE.PLAY, atIndex = void 0) {
              return (dispatch) => {
                if (fileReferences.length < 1) {
                  return;
                } else if (fileReferences.length === 1) {
                  const fileReference = fileReferences[0];
                  if (SKIN_FILENAME_MATCHER.test(fileReference.name)) {
                    dispatch(setSkinFromBlob(fileReference));
                    return;
                  } else if (EQF_FILENAME_MATCHER.test(fileReference.name)) {
                    dispatch(setEqFromFileReference(fileReference));
                    return;
                  }
                }
                dispatch(addTracksFromReferences(fileReferences, loadStyle, atIndex));
              };
            }
            function setSkinFromBlob(blob) {
              return async (dispatch, getState, {
                requireJSZip
              }) => {
                if (!requireJSZip) {
                  alert("Webamp has not been configured to support custom skins.");
                  return;
                }
                dispatch({
                  type: LOADING
                });
                let JSZip;
                try {
                  JSZip = await requireJSZip();
                } catch (e) {
                  console.error(e);
                  dispatch({
                    type: LOADED
                  });
                  alert("Failed to load the skin parser.");
                  return;
                }
                try {
                  const skinData = await js_skinParser(blob, JSZip);
                  dispatch({
                    type: SET_SKIN_DATA,
                    data: {
                      skinImages: skinData.images,
                      skinColors: skinData.colors,
                      skinPlaylistStyle: skinData.playlistStyle,
                      skinCursors: skinData.cursors,
                      skinRegion: skinData.region,
                      skinGenLetterWidths: skinData.genLetterWidths,
                      skinGenExColors: skinData.genExColors
                    }
                  });
                } catch (e) {
                  console.error(e);
                  dispatch({
                    type: LOADED
                  });
                  alert(`Failed to parse skin`);
                }
              };
            }
            function setSkinFromUrl(url) {
              return async (dispatch) => {
                dispatch({
                  type: LOADING
                });
                try {
                  const response = await fetch(url);
                  if (!response.ok) {
                    throw new Error(response.statusText);
                  }
                  dispatch(setSkinFromBlob(response.blob()));
                } catch (e) {
                  console.error(e);
                  dispatch({
                    type: LOADED
                  });
                  alert(`Failed to download skin from ${url}`);
                }
              };
            }
            function _openFileDialog(accept, expectedType) {
              return async (dispatch) => {
                var _fileReferences$;
                const fileReferences = await promptForFileReferences({
                  accept
                });
                dispatch({
                  type: "OPENED_FILES",
                  expectedType,
                  count: fileReferences.length,
                  firstFileName: (_fileReferences$ = fileReferences[0]) === null || _fileReferences$ === void 0 ? void 0 : _fileReferences$.name
                });
                dispatch(loadFilesFromReferences(fileReferences));
              };
            }
            function files_openEqfFileDialog() {
              return _openFileDialog(".eqf", "EQ");
            }
            function files_openMediaFileDialog() {
              return _openFileDialog(null, "MEDIA");
            }
            function files_openSkinFileDialog() {
              return _openFileDialog(".zip, .wsz", "SKIN");
            }
            function fetchMediaDuration(url, id) {
              return (dispatch, getState) => {
                loadQueue.push(async () => {
                  try {
                    const duration = await genMediaDuration(url);
                    dispatch({
                      type: SET_MEDIA_DURATION,
                      duration,
                      id
                    });
                  } catch (e) {
                  }
                }, () => {
                  const trackIsVisible = getTrackIsVisibleFunction(getState());
                  return trackIsVisible(id) ? DURATION_VISIBLE_PRIORITY : DURATION_PRIORITY;
                });
              };
            }
            function files_loadMedia(e, loadStyle = LOAD_STYLE.NONE, atIndex = 0) {
              const {
                files
              } = e.dataTransfer;
              return async (dispatch, getState, {
                handleTrackDropEvent
              }) => {
                if (handleTrackDropEvent) {
                  const tracks = await handleTrackDropEvent(e);
                  if (tracks != null) {
                    dispatch(files_loadMediaFiles(tracks, loadStyle, atIndex));
                    return;
                  }
                }
                dispatch(loadFilesFromReferences(files, loadStyle, atIndex));
              };
            }
            function files_loadMediaFiles(tracks, loadStyle = LOAD_STYLE.NONE, atIndex = 0) {
              return (dispatch) => {
                if (loadStyle === LOAD_STYLE.PLAY) {
                  dispatch(playlist_removeAllTracks());
                }
                tracks.forEach((track, i) => {
                  const priority = i === 0 ? loadStyle : LOAD_STYLE.NONE;
                  dispatch(loadMediaFile(track, priority, atIndex + i));
                });
              };
            }
            function loadMediaFile(track, priority = LOAD_STYLE.NONE, atIndex = 0) {
              return (dispatch) => {
                const id = uniqueId();
                const {
                  defaultName,
                  metaData,
                  duration
                } = track;
                let canonicalUrl;
                if ("url" in track) {
                  canonicalUrl = track.url.toString();
                } else if ("blob" in track) {
                  canonicalUrl = URL.createObjectURL(track.blob);
                } else {
                  throw new Error("Expected track to have either a blob or a url");
                }
                dispatch({
                  type: ADD_TRACK_FROM_URL,
                  url: canonicalUrl,
                  duration: track.duration,
                  defaultName,
                  id,
                  atIndex
                });
                switch (priority) {
                  case LOAD_STYLE.BUFFER:
                    dispatch({
                      type: BUFFER_TRACK,
                      id
                    });
                    break;
                  case LOAD_STYLE.PLAY:
                    dispatch({
                      type: PLAY_TRACK,
                      id
                    });
                    break;
                  case LOAD_STYLE.NONE:
                  default:
                    if (duration != null) {
                      dispatch({
                        type: SET_MEDIA_DURATION,
                        duration,
                        id
                      });
                    } else {
                      dispatch(fetchMediaDuration(canonicalUrl, id));
                    }
                }
                if (metaData != null) {
                  const {
                    artist,
                    title,
                    album
                  } = metaData;
                  dispatch({
                    type: SET_MEDIA_TAGS,
                    artist,
                    title,
                    album,
                    // For now, we lie about these next three things.
                    // TODO: Ideally we would leave these as null and force a media data
                    // fetch when the user starts playing.
                    sampleRate: 44e3,
                    bitrate: 192e3,
                    numberOfChannels: 2,
                    id
                  });
                } else if ("blob" in track) {
                  dispatch(fetchMediaTags(track.blob, id));
                } else {
                  dispatch(queueFetchingMediaTags(id));
                }
              };
            }
            function queueFetchingMediaTags(id) {
              return (dispatch, getState) => {
                const track = getTracks(getState())[id];
                loadQueue.push(() => dispatch(fetchMediaTags(track.url, id)), () => {
                  const trackIsVisible = getTrackIsVisibleFunction(getState());
                  return trackIsVisible(id) ? META_DATA_VISIBLE_PRIORITY : META_DATA_PRIORITY;
                });
              };
            }
            function fetchMediaTags(file, id) {
              return async (dispatch, getState, {
                requireMusicMetadata
              }) => {
                dispatch({
                  type: MEDIA_TAG_REQUEST_INITIALIZED,
                  id
                });
                try {
                  const metadata = await genMediaTags(file, await requireMusicMetadata());
                  const {
                    artist,
                    title,
                    album,
                    picture
                  } = metadata.common;
                  const {
                    numberOfChannels,
                    bitrate,
                    sampleRate
                  } = metadata.format;
                  let albumArtUrl = null;
                  if (picture && picture.length >= 1) {
                    const byteArray = new Uint8Array(picture[0].data);
                    const blob = new Blob([byteArray], {
                      type: picture[0].format
                    });
                    albumArtUrl = URL.createObjectURL(blob);
                  }
                  dispatch({
                    type: SET_MEDIA_TAGS,
                    artist: artist ? artist : "",
                    title: title ? title : "",
                    album,
                    albumArtUrl,
                    numberOfChannels,
                    bitrate,
                    sampleRate,
                    id
                  });
                } catch (e) {
                  dispatch({
                    type: MEDIA_TAG_REQUEST_FAILED,
                    id
                  });
                }
              };
            }
            function setEqFromFileReference(fileReference) {
              return async (dispatch) => {
                const arrayBuffer = await genArrayBufferFromFileReference(fileReference);
                const eqf = Object(winamp_eqf["parser"])(arrayBuffer);
                const preset = eqf.presets[0];
                dispatch(files_setEqFromObject(preset));
              };
            }
            function files_setEqFromObject(preset) {
              return (dispatch) => {
                dispatch(setPreamp(normalizeEqBand(preset.preamp)));
                BANDS.forEach((band) => {
                  dispatch(setEqBand(band, normalizeEqBand(preset[`hz${band}`])));
                });
              };
            }
            function files_downloadPreset() {
              return (dispatch, getState) => {
                const state = getState();
                const data = getEqfData(state);
                const arrayBuffer = Object(winamp_eqf["creator"])(data);
                const base64 = base64FromArrayBuffer(arrayBuffer);
                const dataURI = `data:application/zip;base64,${base64}`;
                downloadURI(dataURI, "entry.eqf");
              };
            }
            function files_downloadHtmlPlaylist() {
              return (dispatch, getState) => {
                const uri = getPlaylistURL(getState());
                downloadURI(uri, "Winamp Playlist.html");
              };
            }
            let el = document.createElement("input");
            el.type = "file";
            const DIR_SUPPORT = (
              // @ts-ignore
              typeof el.webkitdirectory !== "undefined" || // @ts-ignore
              typeof el.mozdirectory !== "undefined" || // @ts-ignore
              typeof el.directory !== "undefined"
            );
            el = null;
            function files_addFilesAtIndex(nextIndex) {
              return async (dispatch) => {
                const fileReferences = await promptForFileReferences();
                dispatch(addTracksFromReferences(fileReferences, LOAD_STYLE.NONE, nextIndex));
              };
            }
            function files_addDirAtIndex(nextIndex) {
              return async (dispatch) => {
                if (!DIR_SUPPORT) {
                  alert("Not supported in your browser");
                  return;
                }
                const fileReferences = await promptForFileReferences({
                  directory: true
                });
                dispatch(addTracksFromReferences(fileReferences, LOAD_STYLE.NONE, nextIndex));
              };
            }
            function files_addFilesFromUrl(atIndex = 0) {
              return async (dispatch, getState, {
                handleAddUrlEvent
              }) => {
                if (handleAddUrlEvent) {
                  const tracks = await handleAddUrlEvent();
                  if (tracks != null) {
                    dispatch(files_loadMediaFiles(tracks, LOAD_STYLE.NONE, atIndex));
                    return;
                  }
                } else {
                  alert("Not supported in Webamp");
                }
              };
            }
            function files_addFilesFromList() {
              return async (dispatch, getState, {
                handleLoadListEvent
              }) => {
                if (handleLoadListEvent) {
                  const tracks = await handleLoadListEvent();
                  if (tracks != null) {
                    dispatch(playlist_removeAllTracks());
                    dispatch(files_loadMediaFiles(tracks, LOAD_STYLE.NONE, 0));
                    return;
                  }
                } else {
                  alert("Not supported in Webamp");
                }
              };
            }
            function files_saveFilesToList() {
              return (dispatch, getState, {
                handleSaveListEvent
              }) => {
                if (handleSaveListEvent) {
                  handleSaveListEvent(getUserTracks(getState()));
                } else {
                  alert("Not supported in Webamp");
                }
              };
            }
            function files_droppedFiles(e, windowId) {
              return (dispatch) => {
                var _e$dataTransfer$files;
                return dispatch({
                  type: "DROPPED_FILES",
                  count: e.dataTransfer.files.length,
                  firstFileName: (_e$dataTransfer$files = e.dataTransfer.files[0]) === null || _e$dataTransfer$files === void 0 ? void 0 : _e$dataTransfer$files.name,
                  windowId
                });
              };
            }
            function normalizePresetTypes(preset) {
              const {
                name
              } = preset;
              if ("butterchurnPresetObject" in preset) {
                return {
                  type: "RESOLVED",
                  name,
                  preset: preset.butterchurnPresetObject
                };
              } else if ("getButterchrunPresetObject" in preset) {
                return {
                  type: "UNRESOLVED",
                  name,
                  getPreset: preset.getButterchrunPresetObject
                };
              } else if ("butterchurnPresetUrl" in preset) {
                return {
                  type: "UNRESOLVED",
                  name,
                  getPreset: async () => {
                    const resp = await fetch(preset.butterchurnPresetUrl);
                    return resp.json();
                  }
                };
              }
              throw new Error("Invalid preset object");
            }
            function initializePresets(presetOptions) {
              return async (dispatch) => {
                const {
                  getPresets,
                  importButterchurn
                } = presetOptions;
                importButterchurn().then((butterchurn) => {
                  dispatch({
                    type: GOT_BUTTERCHURN,
                    butterchurn: butterchurn.default
                  });
                });
                const presets = await getPresets();
                const normalizePresets = presets.map(normalizePresetTypes);
                dispatch(loadPresets(normalizePresets));
              };
            }
            function loadPresets(presets) {
              return (dispatch, getState) => {
                const state = getState();
                const presetsLength = state.milkdrop.presets.length;
                dispatch({
                  type: GOT_BUTTERCHURN_PRESETS,
                  presets
                });
                if (presetsLength === 0 && getRandomizePresets(state)) {
                  dispatch(selectRandomPreset());
                } else {
                  dispatch(milkdrop_requestPresetAtIndex(presetsLength, TransitionType.IMMEDIATE, true));
                }
              };
            }
            function milkdrop_appendPresetFileList(fileList) {
              return async (dispatch, getState, {
                convertPreset
              }) => {
                const presets = Array.from(fileList).map((file) => {
                  const JSON_EXT = ".json";
                  const MILK_EXT = ".milk";
                  const filename = file.name.toLowerCase();
                  if (filename.endsWith(MILK_EXT)) {
                    if (convertPreset == null) {
                      throw new Error("Invalid type");
                    }
                    return {
                      type: "UNRESOLVED",
                      name: file.name.slice(0, file.name.length - MILK_EXT.length),
                      getPreset: () => convertPreset(file)
                    };
                  } else if (filename.endsWith(JSON_EXT)) {
                    return {
                      type: "UNRESOLVED",
                      name: file.name.slice(0, file.name.length - JSON_EXT.length),
                      getPreset: async () => {
                        const str = await genStringFromFileReference(file);
                        return JSON.parse(str);
                      }
                    };
                  }
                  console.error("Invalid type preset when loading directory");
                  return null;
                }).filter(Boolean);
                dispatch(loadPresets(presets));
              };
            }
            function milkdrop_selectNextPreset(transitionType = TransitionType.DEFAULT) {
              return (dispatch, getState) => {
                const state = getState();
                if (getRandomizePresets(state)) {
                  return dispatch(selectRandomPreset(transitionType));
                }
                const currentPresetIndex = getCurrentPresetIndex(state);
                if (currentPresetIndex == null) {
                  return;
                }
                const nextPresetIndex = currentPresetIndex + 1;
                dispatch(milkdrop_requestPresetAtIndex(nextPresetIndex, transitionType, true));
              };
            }
            function milkdrop_selectPreviousPreset(transitionType = TransitionType.DEFAULT) {
              return (dispatch, getState) => {
                const state = getState();
                const {
                  presetHistory
                } = state.milkdrop;
                if (presetHistory.length < 1) {
                  return;
                }
                const lastPresetIndex = presetHistory[presetHistory.length - 2];
                dispatch(milkdrop_requestPresetAtIndex(lastPresetIndex, transitionType, false));
              };
            }
            function selectRandomPreset(transitionType = TransitionType.DEFAULT) {
              return (dispatch, getState) => {
                const state = getState();
                const randomIndex = Math.floor(Math.random() * state.milkdrop.presets.length);
                dispatch(milkdrop_requestPresetAtIndex(randomIndex, transitionType, true));
              };
            }
            function milkdrop_requestPresetAtIndex(index, transitionType, addToHistory) {
              return async (dispatch, getState) => {
                const state = getState();
                const preset = state.milkdrop.presets[index];
                if (preset == null) {
                  return;
                }
                dispatch({
                  type: PRESET_REQUESTED,
                  index,
                  addToHistory
                });
                switch (preset.type) {
                  case "RESOLVED":
                    dispatch({
                      type: SELECT_PRESET_AT_INDEX,
                      index,
                      transitionType
                    });
                    return;
                  case "UNRESOLVED":
                    const json = await preset.getPreset();
                    dispatch({
                      type: RESOLVE_PRESET_AT_INDEX,
                      index,
                      json
                    });
                    dispatch({
                      type: SELECT_PRESET_AT_INDEX,
                      index,
                      transitionType
                    });
                    return;
                }
              };
            }
            function milkdrop_handlePresetDrop(e) {
              return milkdrop_appendPresetFileList(e.dataTransfer.files);
            }
            function toggleRandomizePresets() {
              return {
                type: TOGGLE_RANDOMIZE_PRESETS
              };
            }
            function togglePresetCycling() {
              return {
                type: TOGGLE_PRESET_CYCLING
              };
            }
            function milkdrop_scheduleMilkdropMessage(message) {
              return {
                type: SCHEDULE_MILKDROP_MESSAGE,
                message
              };
            }
            function actionCreators_close() {
              return (dispatch) => {
                let defaultPrevented = false;
                const cancel = () => {
                  defaultPrevented = true;
                };
                dispatch({
                  type: CLOSE_REQUESTED,
                  cancel
                });
                if (!defaultPrevented) {
                  dispatch({
                    type: STOP
                  });
                  dispatch({
                    type: CLOSE_WINAMP
                  });
                }
              };
            }
            function actionCreators_open() {
              return {
                type: OPEN_WINAMP
              };
            }
            function actionCreators_toggleVisualizerStyle() {
              return {
                type: TOGGLE_VISUALIZER_STYLE
              };
            }
            function actionCreators_minimize() {
              return {
                type: MINIMIZE_WINAMP
              };
            }
            function actionCreators_setFocus(input) {
              return {
                type: SET_FOCUS,
                input
              };
            }
            function actionCreators_unsetFocus() {
              return {
                type: UNSET_FOCUS
              };
            }
            function actionCreators_focusBand(band) {
              return {
                type: SET_BAND_FOCUS,
                input: "eq",
                bandFocused: band
              };
            }
            function loadSerializedState(serializedState) {
              return (dispatch) => {
                dispatch({
                  type: LOAD_SERIALIZED_STATE,
                  serializedState
                });
                dispatch(ensureWindowsAreOnScreen());
              };
            }
            function actionCreators_loadDefaultSkin() {
              return {
                type: LOAD_DEFAULT_SKIN
              };
            }
            function toggleMilkdropDesktop() {
              return (dispatch, getState) => {
                if (getMilkdropDesktopEnabled(getState())) {
                  dispatch({
                    type: SET_MILKDROP_DESKTOP,
                    enabled: false
                  });
                } else {
                  dispatch({
                    type: SET_MILKDROP_DESKTOP,
                    enabled: true
                  });
                }
              };
            }
            function setMilkdropFullscreen(enabled) {
              return {
                type: SET_MILKDROP_FULLSCREEN,
                enabled
              };
            }
            function toggleMilkdropFullscreen() {
              return (dispatch, getState) => {
                dispatch(setMilkdropFullscreen(!getMilkdropFullscreenEnabled(getState())));
              };
            }
            function actionCreators_togglePresetOverlay() {
              return (dispatch, getState) => {
                if (getPresetOverlayOpen(getState())) {
                  dispatch(windows_setFocusedWindow(WINDOWS.MILKDROP));
                }
                dispatch({
                  type: TOGGLE_PRESET_OVERLAY
                });
              };
            }
            function actionCreators_stepMarquee() {
              return {
                type: STEP_MARQUEE
              };
            }
            var mediaMiddleware = (media) => (store) => {
              const {
                media: {
                  volume,
                  balance
                },
                equalizer: {
                  sliders
                }
              } = store.getState();
              media.setVolume(volume);
              media.setBalance(balance);
              media.setPreamp(sliders.preamp);
              media.on("timeupdate", () => {
                store.dispatch({
                  type: UPDATE_TIME_ELAPSED,
                  elapsed: media.timeElapsed()
                });
              });
              media.on("ended", () => {
                store.dispatch(media_next());
              });
              media.on("playing", () => {
                store.dispatch({
                  type: IS_PLAYING
                });
              });
              media.on("waiting", () => {
                store.dispatch({
                  type: START_WORKING
                });
              });
              media.on("stopWaiting", () => {
                store.dispatch({
                  type: STOP_WORKING
                });
              });
              media.on("fileLoaded", () => {
                const id = getCurrentTrackId(store.getState());
                if (id == null) {
                  return;
                }
                store.dispatch({
                  id,
                  type: SET_MEDIA,
                  kbps: "128",
                  khz: "44",
                  channels: 2,
                  length: media.duration()
                });
              });
              return (next) => (action) => {
                const returnValue = next(action);
                const state = store.getState();
                switch (action.type) {
                  case PLAY:
                    media.play();
                    break;
                  case PAUSE:
                    media.pause();
                    break;
                  case STOP:
                    media.stop();
                    break;
                  case SET_VOLUME:
                    media.setVolume(getVolume(state));
                    break;
                  case SET_BALANCE:
                    media.setBalance(getBalance(state));
                    break;
                  case SEEK_TO_PERCENT_COMPLETE:
                    media.seekToPercentComplete(action.percent);
                    break;
                  case PLAY_TRACK: {
                    const url = getTrackUrl(store.getState())(action.id);
                    if (url != null) {
                      media.loadFromUrl(url, true);
                    }
                    break;
                  }
                  case BUFFER_TRACK: {
                    const url = getTrackUrl(store.getState())(action.id);
                    if (url != null) {
                      media.loadFromUrl(url, false);
                    }
                    break;
                  }
                  case SET_BAND_VALUE:
                    if (action.band === "preamp") {
                      media.setPreamp(action.value);
                    } else {
                      media.setEqBand(action.band, action.value);
                    }
                    break;
                  case SET_EQ_OFF:
                    media.disableEq();
                    break;
                  case SET_EQ_ON:
                    media.enableEq();
                    break;
                  case LOAD_SERIALIZED_STATE: {
                    if (getEqualizerEnabled(state)) {
                      media.enableEq();
                    } else {
                      media.disableEq();
                    }
                    media.setVolume(getVolume(state));
                    media.setBalance(getBalance(state));
                    objectForEach(state.equalizer.sliders, (value, slider) => {
                      if (slider === "preamp") {
                        media.setPreamp(value);
                      } else {
                        media.setEqBand(slider, value);
                      }
                    });
                    break;
                  }
                }
                return returnValue;
              };
            };
            const compose = Object(redux_devtools_extension["composeWithDevTools"])({
              actionsBlacklist: [UPDATE_TIME_ELAPSED, STEP_MARQUEE]
            });
            var js_store = function(media, actionEmitter, customMiddlewares = [], stateOverrides, extras) {
              let initialState;
              if (stateOverrides) {
                initialState = merge(reducers(void 0, {
                  type: "@@init"
                }), stateOverrides);
              }
              const emitterMiddleware = () => (next) => (action) => {
                actionEmitter.trigger(action.type, action);
                return next(action);
              };
              const enhancer = compose(Object(redux["applyMiddleware"])(...[es.withExtraArgument(extras), mediaMiddleware(media), emitterMiddleware, ...customMiddlewares].filter(Boolean)));
              const store = initialState ? Object(redux["createStore"])(reducers, initialState, enhancer) : Object(redux["createStore"])(reducers, enhancer);
              return store;
            };
            var fscreen_lib = __webpack_require__2(13);
            var fscreen_lib_default = __webpack_require__2.n(fscreen_lib);
            function leaveFullScreen() {
              if (fscreen_lib_default.a.fullscreenEnabled) {
                fscreen_lib_default.a.exitFullscreen();
              }
            }
            function enterFullScreen(node) {
              if (fscreen_lib_default.a.fullscreenEnabled) {
                fscreen_lib_default.a.requestFullscreen(node);
              }
            }
            function FullScreen(props) {
              const {
                onChange,
                enabled
              } = props;
              const ref = Object(react["useRef"])(null);
              Object(react["useEffect"])(() => {
                function detectFullScreen() {
                  if (onChange) {
                    onChange(fscreen_lib_default.a.fullscreenElement === ref.current);
                  }
                }
                fscreen_lib_default.a.addEventListener("fullscreenchange", detectFullScreen);
                return () => {
                  fscreen_lib_default.a.removeEventListener("fullscreenchange", detectFullScreen);
                };
              }, [onChange]);
              Object(react["useLayoutEffect"])(() => {
                const isEnabled = fscreen_lib_default.a.fullscreenElement === ref.current;
                if (isEnabled && !enabled) {
                  leaveFullScreen();
                } else if (!isEnabled && enabled && ref.current != null) {
                  enterFullScreen(ref.current);
                }
              }, [enabled]);
              return Object(jsx_runtime["jsx"])("div", {
                ref,
                style: props.enabled ? {
                  height: "100%",
                  width: "100%"
                } : void 0,
                children: props.children
              });
            }
            var Fullscreen = FullScreen;
            function useUnmountedRef() {
              const unmountedRef = Object(react["useRef"])(false);
              Object(react["useEffect"])(() => {
                return () => {
                  unmountedRef.current = true;
                };
              }, []);
              return unmountedRef;
            }
            function usePromiseValueOrNull(propValue) {
              const [value, setValue] = Object(react["useState"])(null);
              Object(react["useEffect"])(() => {
                let disposed = false;
                propValue.then((resolvedValue) => {
                  if (disposed) {
                    return;
                  }
                  setValue(resolvedValue);
                });
                return () => {
                  disposed = true;
                };
              }, [propValue]);
              return value;
            }
            function useScreenSize() {
              const [size] = Object(react["useState"])(getScreenSize());
              return size;
            }
            function useWindowSize() {
              const [size, setSize] = Object(react["useState"])(utils_getWindowSize());
              const handler = Object(react["useCallback"])(throttle(() => {
                setSize(utils_getWindowSize());
              }, 100), []);
              Object(react["useEffect"])(() => {
                window.addEventListener("resize", handler);
                return () => {
                  window.removeEventListener("resize", handler);
                };
              }, [handler]);
              return size;
            }
            const cursorPositionRef = {
              current: {
                pageX: 0,
                pageY: 0
              }
            };
            window.document.addEventListener("mousemove", ({
              pageX,
              pageY
            }) => {
              cursorPositionRef.current = {
                pageX,
                pageY
              };
            });
            function useCursorPositionRef() {
              return cursorPositionRef;
            }
            function useIsHovered() {
              const cursorRef = useCursorPositionRef();
              const [hover, setHover] = Object(react["useState"])(false);
              const [node, setNode] = Object(react["useState"])(null);
              Object(react["useLayoutEffect"])(() => {
                if (node == null) {
                  setHover(false);
                  return;
                }
                const domRect = node.getBoundingClientRect();
                const {
                  pageX,
                  pageY
                } = cursorRef.current;
                setHover(pageX >= domRect.left && pageX <= domRect.right && pageY >= domRect.top && pageY <= domRect.bottom);
                const enter = () => setHover(true);
                const leave = () => setHover(false);
                node.addEventListener("mouseenter", enter);
                node.addEventListener("mouseleave", leave);
                return () => {
                  node.removeEventListener("mouseenter", enter);
                  node.removeEventListener("mouseleave", leave);
                };
              }, [node, cursorRef]);
              return {
                ref: setNode,
                hover
              };
            }
            function useOnClickAway(ref, callback) {
              Object(react["useEffect"])(() => {
                if (ref == null || callback == null) {
                  return;
                }
                const handleClickOut = (ee) => {
                  const clickOutTarget = ee.target;
                  if (!(clickOutTarget instanceof Element)) {
                    return;
                  }
                  if (ref.contains(clickOutTarget)) {
                    return;
                  }
                  callback();
                  window.document.removeEventListener("click", handleClickOut, {
                    capture: true
                  });
                };
                window.document.addEventListener("click", handleClickOut, {
                  capture: true
                });
                return () => {
                  window.document.removeEventListener("click", handleClickOut, {
                    capture: true
                  });
                };
              }, [ref, callback]);
            }
            function useTypedSelector(selector) {
              return useSelector_useSelector(selector);
            }
            function useActionCreator(actionCreator) {
              const dispatch = useDispatch();
              return Object(react["useCallback"])((...args) => dispatch(actionCreator(...args)), [dispatch, actionCreator]);
            }
            function useTypedDispatch() {
              return useDispatch();
            }
            var classnames = __webpack_require__2(4);
            var classnames_default = __webpack_require__2.n(classnames);
            var gen_window = __webpack_require__2(68);
            function ResizeTarget_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function ResizeTarget_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  ResizeTarget_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  ResizeTarget_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function ResizeTarget(props) {
              const {
                currentSize,
                setWindowSize,
                widthOnly
              } = props, passThroughProps = objectWithoutProperties_default()(props, ["currentSize", "setWindowSize", "widthOnly"]);
              const [mouseDown, setMouseDown] = Object(react["useState"])(false);
              const [mouseStart, setMouseStart] = Object(react["useState"])(null);
              Object(react["useEffect"])(() => {
                if (mouseDown === false || mouseStart == null) {
                  return;
                }
                const [width, height] = currentSize;
                const handleMove = (ee) => {
                  const x = getX(ee) - mouseStart.x;
                  const y = getY(ee) - mouseStart.y;
                  const newWidth = Math.max(0, width + Math.round(x / WINDOW_RESIZE_SEGMENT_WIDTH));
                  const newHeight = widthOnly ? width : Math.max(0, height + Math.round(y / WINDOW_RESIZE_SEGMENT_HEIGHT));
                  const newSize = [newWidth, newHeight];
                  props.setWindowSize(newSize);
                };
                window.addEventListener("mousemove", handleMove);
                window.addEventListener("touchmove", handleMove);
                const handleMouseUp = () => setMouseDown(false);
                window.addEventListener("mouseup", handleMouseUp);
                window.addEventListener("touchend", handleMouseUp);
                return () => {
                  window.removeEventListener("mousemove", handleMove);
                  window.removeEventListener("touchmove", handleMove);
                  window.removeEventListener("mouseup", handleMouseUp);
                  window.removeEventListener("touchend", handleMouseUp);
                };
              }, [mouseStart, mouseDown]);
              const handleMouseDown = (e) => {
                setMouseStart({
                  x: getX(e),
                  y: getY(e)
                });
                setMouseDown(true);
              };
              return Object(jsx_runtime["jsx"])("div", ResizeTarget_objectSpread({
                onMouseDown: handleMouseDown,
                onTouchStart: handleMouseDown
              }, passThroughProps));
            }
            var components_ResizeTarget = Object(react["memo"])(ResizeTarget);
            function FocusTarget({
              onKeyDown,
              windowId,
              children
            }) {
              const focusedWindowId = useTypedSelector(getFocusedWindow);
              const setFocus = useActionCreator(windows_setFocusedWindow);
              const focusHandler = Object(react["useCallback"])(() => {
                if (windowId !== focusedWindowId) {
                  setFocus(windowId);
                }
              }, [windowId, focusedWindowId, setFocus]);
              const [ref, setRef] = Object(react["useState"])(null);
              Object(react["useEffect"])(() => {
                if (ref == null || onKeyDown == null) {
                  return;
                }
                ref.addEventListener("keydown", onKeyDown);
                return () => ref.removeEventListener("keydown", onKeyDown);
              }, [onKeyDown, windowId, focusedWindowId, ref]);
              Object(react["useEffect"])(() => {
                if (ref == null || windowId !== focusedWindowId) {
                  return;
                }
                const observer = new MutationObserver((mutations) => {
                  if (document.activeElement !== document.body) {
                    return;
                  }
                  if (mutations.some((mutation) => mutation.removedNodes.length > 0)) {
                    ref.focus();
                  }
                });
                observer.observe(ref, {
                  subtree: true,
                  attributes: false,
                  childList: true
                });
                return () => observer.disconnect();
              }, [windowId, focusedWindowId, ref]);
              return Object(jsx_runtime["jsx"])("div", {
                ref: setRef,
                onMouseDown: focusHandler,
                onTouchStart: focusHandler,
                onFocus: focusHandler,
                tabIndex: -1,
                style: {
                  height: "100%",
                  width: "100%"
                },
                children
              });
            }
            var components_FocusTarget = FocusTarget;
            const Text = ({
              children
            }) => {
              const letters = children.split("");
              return Object(jsx_runtime["jsx"])(react["Fragment"], {
                children: letters.map((letter, i) => Object(jsx_runtime["jsx"])("div", {
                  className: `draggable gen-text-letter gen-text-${letter === " " ? "space" : letter.toLowerCase()}`
                }, i))
              });
            };
            const CHROME_WIDTH = 19;
            const CHROME_HEIGHT = 34;
            const GenWindow = ({
              children,
              title,
              windowId,
              onKeyDown
            }) => {
              const setWindowSize = useActionCreator(windows_setWindowSize);
              const closeWindow = useActionCreator(windows_closeWindow);
              const getWindowPixelSize = useTypedSelector(selectors_getWindowPixelSize);
              const focusedWindow = useTypedSelector(getFocusedWindow);
              const getWindowSize = useTypedSelector(selectors_getWindowSize);
              const windowSize = getWindowSize(windowId);
              const selected = focusedWindow === windowId;
              const {
                width,
                height
              } = getWindowPixelSize(windowId);
              return Object(jsx_runtime["jsx"])(components_FocusTarget, {
                windowId,
                onKeyDown,
                children: Object(jsx_runtime["jsxs"])("div", {
                  className: classnames_default()("gen-window", "window", {
                    selected
                  }),
                  style: {
                    width,
                    height
                  },
                  children: [Object(jsx_runtime["jsxs"])("div", {
                    className: "gen-top draggable",
                    children: [Object(jsx_runtime["jsx"])("div", {
                      className: "gen-top-left draggable"
                    }), Object(jsx_runtime["jsx"])("div", {
                      className: "gen-top-left-fill draggable"
                    }), Object(jsx_runtime["jsx"])("div", {
                      className: "gen-top-left-end draggable"
                    }), Object(jsx_runtime["jsx"])("div", {
                      className: "gen-top-title draggable",
                      children: Object(jsx_runtime["jsx"])(Text, {
                        children: title
                      })
                    }), Object(jsx_runtime["jsx"])("div", {
                      className: "gen-top-right-end draggable"
                    }), Object(jsx_runtime["jsx"])("div", {
                      className: "gen-top-right-fill draggable"
                    }), Object(jsx_runtime["jsx"])("div", {
                      className: "gen-top-right draggable",
                      children: Object(jsx_runtime["jsx"])("div", {
                        className: "gen-close selected",
                        onClick: () => closeWindow(windowId)
                      })
                    })]
                  }), Object(jsx_runtime["jsxs"])("div", {
                    className: "gen-middle",
                    children: [Object(jsx_runtime["jsx"])("div", {
                      className: "gen-middle-left draggable",
                      children: Object(jsx_runtime["jsx"])("div", {
                        className: "gen-middle-left-bottom draggable"
                      })
                    }), Object(jsx_runtime["jsx"])("div", {
                      className: "gen-middle-center",
                      children: children({
                        width: width - CHROME_WIDTH,
                        height: height - CHROME_HEIGHT
                      })
                    }), Object(jsx_runtime["jsx"])("div", {
                      className: "gen-middle-right draggable",
                      children: Object(jsx_runtime["jsx"])("div", {
                        className: "gen-middle-right-bottom draggable"
                      })
                    })]
                  }), Object(jsx_runtime["jsxs"])("div", {
                    className: "gen-bottom draggable",
                    children: [Object(jsx_runtime["jsx"])("div", {
                      className: "gen-bottom-left draggable"
                    }), Object(jsx_runtime["jsx"])("div", {
                      className: "gen-bottom-right draggable",
                      children: Object(jsx_runtime["jsx"])(components_ResizeTarget, {
                        currentSize: windowSize,
                        setWindowSize: (size) => setWindowSize(windowId, size),
                        id: "gen-resize-target"
                      })
                    })]
                  })]
                })
              });
            };
            var components_GenWindow = GenWindow;
            const TRANSITION_TYPE_DURATIONS = {
              [TransitionType.DEFAULT]: 2.7,
              [TransitionType.IMMEDIATE]: 0,
              [TransitionType.USER_PRESET]: 5.7
            };
            function Visualizer({
              analyser,
              width,
              height
            }) {
              const visualizerStyle = useTypedSelector(selectors_getVisualizerStyle);
              const playing = useTypedSelector(getMediaIsPlaying);
              const butterchurn = useTypedSelector(getButterchurn);
              const trackTitle = useTypedSelector(getCurrentTrackDisplayName);
              const currentPreset = useTypedSelector(getCurrentPreset);
              const transitionType = useTypedSelector(getPresetTransitionType);
              const message = useTypedSelector(getMilkdropMessage);
              const isEnabledVisualizer = visualizerStyle === VISUALIZERS.MILKDROP;
              const canvasRef = Object(react["useRef"])(null);
              const [visualizer, setVisualizer] = Object(react["useState"])(null);
              Object(react["useEffect"])(() => {
                if (canvasRef.current == null || butterchurn == null) {
                  return;
                }
                if (visualizer != null) {
                  return;
                }
                const _visualizer = butterchurn.createVisualizer(analyser.context, canvasRef.current, {
                  width,
                  height,
                  meshWidth: 32,
                  meshHeight: 24,
                  pixelRatio: window.devicePixelRatio || 1
                });
                _visualizer.connectAudio(analyser);
                setVisualizer(_visualizer);
              }, [butterchurn, analyser, height, width, visualizer]);
              Object(react["useEffect"])(() => {
                if (visualizer == null) {
                  return;
                }
                visualizer.setRendererSize(width, height);
              }, [visualizer, width, height]);
              const hasLoadedPreset = Object(react["useRef"])(false);
              Object(react["useEffect"])(() => {
                if (visualizer == null || currentPreset == null) {
                  return;
                }
                if (hasLoadedPreset.current) {
                  visualizer.loadPreset(currentPreset, TRANSITION_TYPE_DURATIONS[transitionType]);
                } else {
                  visualizer.loadPreset(currentPreset, TRANSITION_TYPE_DURATIONS[TransitionType.IMMEDIATE]);
                  hasLoadedPreset.current = true;
                }
              }, [visualizer, currentPreset]);
              Object(react["useEffect"])(() => {
                if (visualizer == null || !trackTitle) {
                  return;
                }
                visualizer.launchSongTitleAnim(trackTitle);
              }, [visualizer, trackTitle]);
              const lastShownMessage = Object(react["useRef"])(null);
              Object(react["useEffect"])(() => {
                if (visualizer == null || message == null) {
                  return;
                }
                if (lastShownMessage.current == null || message.time > lastShownMessage.current) {
                  lastShownMessage.current = Date.now();
                  visualizer.launchSongTitleAnim(message.text);
                }
              }, [visualizer, message]);
              const shouldAnimate = playing && isEnabledVisualizer;
              Object(react["useEffect"])(() => {
                if (!shouldAnimate || visualizer == null) {
                  return;
                }
                let animationFrameRequest = null;
                const loop = () => {
                  visualizer.render();
                  animationFrameRequest = window.requestAnimationFrame(loop);
                };
                loop();
                return () => {
                  if (animationFrameRequest != null) {
                    window.cancelAnimationFrame(animationFrameRequest);
                  }
                };
              }, [visualizer, shouldAnimate]);
              return Object(jsx_runtime["jsx"])("canvas", {
                height,
                width,
                style: {
                  height: "100%",
                  width: "100%",
                  display: isEnabledVisualizer ? "block" : "none"
                },
                ref: canvasRef
              });
            }
            var MilkdropWindow_Visualizer = Visualizer;
            var milkdrop_window = __webpack_require__2(71);
            const Background = (props) => {
              const {
                innerRef
              } = props;
              return Object(jsx_runtime["jsx"])("div", {
                ref: innerRef,
                className: "draggable",
                style: {
                  // This color will be used until Butterchurn is loaded
                  backgroundColor: "#000",
                  position: "absolute",
                  top: 0,
                  bottom: 0,
                  left: 0,
                  right: 0,
                  height: "100%",
                  width: "100%"
                },
                tabIndex: 0,
                children: props.children
              });
            };
            var MilkdropWindow_Background = Background;
            function PresetOverlay_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function PresetOverlay_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  PresetOverlay_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  PresetOverlay_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            const ENTRY_HEIGHT = 14;
            const HEIGHT_PADDING = 15;
            const WIDTH_PADDING = 20;
            const LOADING_STYLE = {
              position: "absolute",
              top: 0,
              left: 0,
              color: "white",
              background: "rgba(0.33, 0.33, 0.33, 0.33)"
            };
            const OUTER_WRAPPER_STYLE = {
              position: "absolute",
              top: 0,
              left: 0,
              padding: "15px 10px 0 10px"
            };
            const INNER_WRAPPER_STYLE = {
              display: "inline-block",
              whiteSpace: "nowrap",
              overflow: "hidden",
              background: "rgba(0, 0, 0, 0.815)",
              fontSize: "12px"
            };
            function presetIndexFromListIndex(listIndex) {
              return listIndex - 1;
            }
            function listIndexFromPresetIndex(listIndex) {
              return listIndex + 1;
            }
            function PresetOverlay({
              height,
              width
            }) {
              const presetKeys = useTypedSelector(getPresetNames);
              const currentPresetIndex = useTypedSelector(getCurrentPresetIndex);
              const requestPresetAtIndex = useActionCreator(milkdrop_requestPresetAtIndex);
              const togglePresetOverlay = useActionCreator(actionCreators_togglePresetOverlay);
              const appendPresetFileList = useActionCreator(milkdrop_appendPresetFileList);
              const unmountedRef = useUnmountedRef();
              const [selectedListIndex, setSelectedListIndex] = Object(react["useState"])(() => {
                if (currentPresetIndex != null) {
                  return listIndexFromPresetIndex(currentPresetIndex);
                }
                return 0;
              });
              const maxListIndex = presetKeys.length;
              const renderList = Object(react["useCallback"])(() => {
                const maxVisibleRows = Math.floor((height - HEIGHT_PADDING) / ENTRY_HEIGHT);
                const rowsToShow = Math.floor(maxVisibleRows * 0.75);
                const [startIndex, endIndex] = getRangeCenteredOnIndex(
                  maxListIndex + 1,
                  // Add one to convert an index to a length
                  rowsToShow,
                  selectedListIndex
                );
                const presetElms = [];
                for (let i = startIndex; i <= endIndex; i++) {
                  const presetIndex = presetIndexFromListIndex(i);
                  const isSelected = i === selectedListIndex;
                  const isCurrent = presetIndex === currentPresetIndex;
                  let color;
                  if (isSelected) {
                    color = isCurrent ? "#FFCC22" : "#FF5050";
                  } else {
                    color = isCurrent ? "#CCFF03" : "#CCCCCC";
                  }
                  presetElms.push(Object(jsx_runtime["jsx"])("li", {
                    style: {
                      color,
                      lineHeight: `${ENTRY_HEIGHT}px`
                    },
                    children: i === 0 ? "Load Local Directory" : presetKeys[presetIndex]
                  }, i));
                }
                return presetElms;
              }, [currentPresetIndex, height, maxListIndex, presetKeys, selectedListIndex]);
              const loadLocalDir = Object(react["useCallback"])(async () => {
                const fileReferences = await promptForFileReferences({
                  directory: true
                });
                if (unmountedRef.current) {
                  return;
                }
                appendPresetFileList(fileReferences);
              }, [appendPresetFileList, unmountedRef]);
              const handleFocusedKeyboardInput = Object(react["useCallback"])((e) => {
                switch (e.keyCode) {
                  case 38:
                    setSelectedListIndex((value) => Math.max(value - 1, 0));
                    e.stopPropagation();
                    break;
                  case 40:
                    setSelectedListIndex((value) => Math.min(value + 1, maxListIndex));
                    e.stopPropagation();
                    break;
                  case 13:
                    if (selectedListIndex === 0) {
                      loadLocalDir();
                    } else {
                      requestPresetAtIndex(presetIndexFromListIndex(selectedListIndex), TransitionType.DEFAULT, true);
                    }
                    e.stopPropagation();
                    break;
                  case 27:
                    togglePresetOverlay();
                    e.stopPropagation();
                    break;
                }
              }, [loadLocalDir, maxListIndex, requestPresetAtIndex, selectedListIndex, togglePresetOverlay]);
              const handleNode = Object(react["useCallback"])((node) => {
                if (node != null && document.activeElement !== node) {
                  node.focus();
                }
              }, []);
              if (presetKeys == null) {
                return Object(jsx_runtime["jsx"])("div", {
                  style: LOADING_STYLE,
                  children: Object(jsx_runtime["jsx"])("span", {
                    children: "Loading presets"
                  })
                });
              }
              return Object(jsx_runtime["jsx"])("div", {
                ref: handleNode,
                tabIndex: -1,
                style: OUTER_WRAPPER_STYLE,
                onKeyDown: handleFocusedKeyboardInput,
                children: Object(jsx_runtime["jsx"])("div", {
                  style: PresetOverlay_objectSpread(PresetOverlay_objectSpread({}, INNER_WRAPPER_STYLE), {}, {
                    width: width - 20 - WIDTH_PADDING,
                    maxHeight: height - HEIGHT_PADDING
                  }),
                  children: Object(jsx_runtime["jsx"])("ul", {
                    style: {
                      listStyleType: "none",
                      padding: 0,
                      margin: 0
                    },
                    children: renderList()
                  })
                })
              });
            }
            function getRangeCenteredOnIndex(length, maxRangeSize, indexToCenter) {
              const rangeSize = Math.min(length, maxRangeSize);
              const halfRangeSize = Math.floor(rangeSize / 2);
              const idealStartIndex = indexToCenter - halfRangeSize;
              const startIndex = clamp(idealStartIndex, 0, length - rangeSize);
              const endIndex = startIndex + rangeSize - 1;
              return [startIndex, endIndex];
            }
            var MilkdropWindow_PresetOverlay = PresetOverlay;
            function DropTarget_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function DropTarget_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  DropTarget_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  DropTarget_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function supress(e) {
              e.stopPropagation();
              e.preventDefault();
              e.dataTransfer.dropEffect = "link";
              e.dataTransfer.effectAllowed = "link";
            }
            const DropTarget = (props) => {
              const {
                // eslint-disable-next-line no-shadow, no-unused-vars
                handleDrop,
                windowId
              } = props, passThroughProps = objectWithoutProperties_default()(props, ["handleDrop", "windowId"]);
              const droppedFiles = useActionCreator(files_droppedFiles);
              const onDrop = Object(react["useCallback"])((e) => {
                supress(e);
                droppedFiles(e, windowId);
                const {
                  currentTarget
                } = e;
                if (!(currentTarget instanceof Element)) {
                  return;
                }
                const {
                  left: x,
                  top: y
                } = currentTarget.getBoundingClientRect();
                handleDrop(e, {
                  x,
                  y
                });
              }, [handleDrop, droppedFiles, windowId]);
              return Object(jsx_runtime["jsx"])("div", DropTarget_objectSpread(DropTarget_objectSpread({}, passThroughProps), {}, {
                onDragStart: supress,
                onDragEnter: supress,
                onDragOver: supress,
                onDrop
              }));
            };
            var components_DropTarget = DropTarget;
            var context_menu = __webpack_require__2(73);
            function ContextMenu_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function ContextMenu_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  ContextMenu_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  ContextMenu_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            const Portal = (props) => {
              const node = Object(react["useMemo"])(() => {
                const div = document.createElement("div");
                div.id = "webamp-context-menu";
                div.style.position = "absolute";
                div.style.top = "0";
                div.style.left = "0";
                div.style.zIndex = String(props.zIndex + 1);
                return div;
              }, [props.zIndex]);
              Object(react["useEffect"])(() => {
                document.body.appendChild(node);
                return () => {
                  document.body.removeChild(node);
                };
              }, [node]);
              const style = {
                top: props.top,
                left: props.left,
                position: "absolute"
              };
              return Object(react_dom["createPortal"])(Object(jsx_runtime["jsx"])("div", {
                style,
                children: props.children
              }), node);
            };
            const ContextMenu_Hr = () => Object(jsx_runtime["jsx"])("li", {
              className: "hr",
              children: Object(jsx_runtime["jsx"])("hr", {})
            });
            const Parent = ({
              children,
              label
            }) => Object(jsx_runtime["jsxs"])("li", {
              className: "parent",
              children: [Object(jsx_runtime["jsx"])("ul", {
                children
              }), label]
            });
            const LinkNode = (props) => Object(jsx_runtime["jsx"])("li", {
              children: Object(jsx_runtime["jsx"])("a", ContextMenu_objectSpread(ContextMenu_objectSpread({}, props), {}, {
                children: props.label
              }))
            });
            const Node = (props) => {
              const {
                label,
                checked,
                className = ""
              } = props, passThroughProps = objectWithoutProperties_default()(props, ["label", "checked", "className"]);
              return Object(jsx_runtime["jsx"])("li", ContextMenu_objectSpread(ContextMenu_objectSpread({
                className: classnames_default()(className, {
                  checked
                })
              }, passThroughProps), {}, {
                children: label
              }));
            };
            function ContextMenu({
              children,
              offsetTop,
              offsetLeft,
              top,
              bottom,
              selected
            }) {
              const zIndex = useTypedSelector(getZIndex);
              if (!selected) {
                return null;
              }
              return Object(jsx_runtime["jsx"])(Portal, {
                top: offsetTop,
                left: offsetLeft,
                zIndex,
                children: Object(jsx_runtime["jsx"])("ul", {
                  className: classnames_default()("context-menu", {
                    top,
                    bottom
                  }),
                  children
                })
              });
            }
            function ContextMenuWrapper_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function ContextMenuWrapper_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  ContextMenuWrapper_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  ContextMenuWrapper_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function ContextMenuWraper(_ref) {
              var _openPosition$y, _openPosition$x;
              let {
                children,
                renderContents
              } = _ref, passThroughProps = objectWithoutProperties_default()(_ref, ["children", "renderContents"]);
              const [openPosition, setOpenPosition] = Object(react["useState"])(null);
              const closeMenu = Object(react["useCallback"])(() => {
                setOpenPosition(null);
              }, []);
              const handleGlobalClick = Object(react["useCallback"])((e) => {
                if (e.button !== 2) {
                  closeMenu();
                }
              }, [closeMenu]);
              const handleRightClick = Object(react["useCallback"])((e) => {
                const {
                  pageX,
                  pageY
                } = e;
                setOpenPosition({
                  x: pageX,
                  y: pageY
                });
                e.preventDefault();
                e.stopPropagation();
              }, []);
              Object(react["useEffect"])(() => {
                if (openPosition == null) {
                  return;
                }
                document.addEventListener("click", handleGlobalClick);
                document.body.addEventListener("contextmenu", closeMenu);
                return () => {
                  document.removeEventListener("click", handleGlobalClick);
                  document.body.removeEventListener("contextmenu", closeMenu);
                };
              }, [openPosition, closeMenu, handleGlobalClick]);
              return Object(jsx_runtime["jsxs"])("div", ContextMenuWrapper_objectSpread(ContextMenuWrapper_objectSpread({
                onContextMenu: handleRightClick,
                style: {
                  width: "100%",
                  height: "100%"
                }
              }, passThroughProps), {}, {
                children: [Object(jsx_runtime["jsx"])(ContextMenu, {
                  selected: openPosition != null,
                  offsetTop: (_openPosition$y = openPosition === null || openPosition === void 0 ? void 0 : openPosition.y) !== null && _openPosition$y !== void 0 ? _openPosition$y : 0,
                  offsetLeft: (_openPosition$x = openPosition === null || openPosition === void 0 ? void 0 : openPosition.x) !== null && _openPosition$x !== void 0 ? _openPosition$x : 0,
                  children: renderContents()
                }), children]
              }));
            }
            const MilkdropContextMenu = (props) => {
              const desktop = useTypedSelector(getMilkdropDesktopEnabled);
              const closeWindow = useActionCreator(windows_closeWindow);
              const toggleDesktop = useActionCreator(toggleMilkdropDesktop);
              const toggleFullscreen = useActionCreator(toggleMilkdropFullscreen);
              return Object(jsx_runtime["jsx"])(ContextMenuWraper, {
                renderContents: () => {
                  return Object(jsx_runtime["jsxs"])(jsx_runtime["Fragment"], {
                    children: [Object(jsx_runtime["jsx"])(Node, {
                      onClick: toggleFullscreen,
                      label: "Fullscreen",
                      hotkey: "Alt+Enter"
                    }), Object(jsx_runtime["jsx"])(Node, {
                      onClick: toggleDesktop,
                      checked: desktop,
                      label: "Desktop Mode",
                      hotkey: "Alt+D"
                    }), Object(jsx_runtime["jsx"])(ContextMenu_Hr, {}), Object(jsx_runtime["jsx"])(Node, {
                      onClick: () => closeWindow(WINDOWS.MILKDROP),
                      label: "Quit"
                    })]
                  });
                },
                children: props.children
              });
            };
            var MilkdropWindow_MilkdropContextMenu = MilkdropContextMenu;
            const Desktop = react["memo"](({
              children
            }) => {
              const [desktopNode] = react["useState"](() => document.createElement("div"));
              react["useEffect"](() => {
                desktopNode.classList.add("webamp-desktop");
                document.body.appendChild(desktopNode);
                return () => {
                  document.body.removeChild(desktopNode);
                };
              }, [desktopNode]);
              return react_dom_default.a.createPortal(children, desktopNode);
            });
            var MilkdropWindow_Desktop = Desktop;
            function MilkdropWindow_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function MilkdropWindow_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  MilkdropWindow_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  MilkdropWindow_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            const MILLISECONDS_BETWEEN_PRESET_TRANSITIONS = 15e3;
            function useKeyHandler() {
              const trackTitle = useTypedSelector(getCurrentTrackDisplayName);
              const selectNextPreset = useActionCreator(milkdrop_selectNextPreset);
              const selectPreviousPreset = useActionCreator(milkdrop_selectPreviousPreset);
              const toggleRandomize = useActionCreator(toggleRandomizePresets);
              const togglePresetOverlay = useActionCreator(actionCreators_togglePresetOverlay);
              const scheduleMilkdropMessage = useActionCreator(milkdrop_scheduleMilkdropMessage);
              const toggleCycling = useActionCreator(togglePresetCycling);
              return Object(react["useCallback"])((e) => {
                switch (e.keyCode) {
                  case 32:
                    selectNextPreset();
                    break;
                  case 8:
                    selectPreviousPreset(TransitionType.IMMEDIATE);
                    break;
                  case 72:
                    selectNextPreset(TransitionType.IMMEDIATE);
                    break;
                  case 82:
                    toggleRandomize();
                    break;
                  case 76:
                    togglePresetOverlay();
                    e.stopPropagation();
                    break;
                  case 84:
                    if (trackTitle != null) {
                      scheduleMilkdropMessage(trackTitle);
                    }
                    e.stopPropagation();
                    break;
                  case 145:
                  case 125:
                    toggleCycling();
                    break;
                }
              }, [scheduleMilkdropMessage, selectNextPreset, selectPreviousPreset, toggleCycling, togglePresetOverlay, toggleRandomize, trackTitle]);
            }
            function Milkdrop({
              analyser
            }) {
              const desktop = useTypedSelector(getMilkdropDesktopEnabled);
              const fullscreen = useTypedSelector(getMilkdropFullscreenEnabled);
              const overlay = useTypedSelector(getPresetOverlayOpen);
              const presetsAreCycling = useTypedSelector(getPresetsAreCycling);
              const currentPresetIndex = useTypedSelector(getCurrentPresetIndex);
              const mediaIsPlaying = useTypedSelector(getMediaIsPlaying);
              const toggleFullscreen = useActionCreator(toggleMilkdropFullscreen);
              const selectNextPreset = useActionCreator(milkdrop_selectNextPreset);
              const handlePresetDrop = useActionCreator(milkdrop_handlePresetDrop);
              const setFullscreen = useActionCreator(setMilkdropFullscreen);
              const handleKeyDown = useKeyHandler();
              Object(react["useEffect"])(() => {
                if (!presetsAreCycling || !mediaIsPlaying) {
                  return;
                }
                const intervalId = setInterval(selectNextPreset, MILLISECONDS_BETWEEN_PRESET_TRANSITIONS);
                return () => clearInterval(intervalId);
              }, [presetsAreCycling, currentPresetIndex, mediaIsPlaying, selectNextPreset]);
              const screenSize = useScreenSize();
              const windowSize = useWindowSize();
              if (desktop) {
                return Object(jsx_runtime["jsx"])(MilkdropWindow_Desktop, {
                  children: Object(jsx_runtime["jsx"])(MilkdropWindow_MilkdropContextMenu, {
                    children: Object(jsx_runtime["jsx"])(MilkdropWindow_Visualizer, MilkdropWindow_objectSpread(MilkdropWindow_objectSpread({}, windowSize), {}, {
                      analyser
                    }))
                  })
                });
              }
              return Object(jsx_runtime["jsx"])(components_GenWindow, {
                title: "Milkdrop",
                windowId: WINDOWS.MILKDROP,
                onKeyDown: handleKeyDown,
                children: (genWindowSize) => {
                  const size = fullscreen ? screenSize : genWindowSize;
                  return Object(jsx_runtime["jsx"])(MilkdropWindow_MilkdropContextMenu, {
                    children: Object(jsx_runtime["jsx"])(MilkdropWindow_Background, {
                      children: Object(jsx_runtime["jsxs"])(components_DropTarget, {
                        windowId: WINDOWS.MILKDROP,
                        handleDrop: handlePresetDrop,
                        children: [overlay && Object(jsx_runtime["jsx"])(MilkdropWindow_PresetOverlay, MilkdropWindow_objectSpread({}, size)), Object(jsx_runtime["jsx"])(Fullscreen, {
                          enabled: fullscreen,
                          onChange: setFullscreen,
                          children: Object(jsx_runtime["jsx"])("div", {
                            onDoubleClick: toggleFullscreen,
                            children: Object(jsx_runtime["jsx"])(MilkdropWindow_Visualizer, MilkdropWindow_objectSpread(MilkdropWindow_objectSpread({}, size), {}, {
                              analyser
                            }))
                          })
                        })]
                      })
                    })
                  });
                }
              });
            }
            var MilkdropWindow = Milkdrop;
            const PlaybackContextMenu = () => {
              const previous = useActionCreator(media_previous);
              const play = useActionCreator(media_play);
              const pause = useActionCreator(media_pause);
              const stop = useActionCreator(media_stop);
              const next = useActionCreator(media_next);
              const seekForward = useActionCreator(media_seekForward);
              const seekBackward = useActionCreator(media_seekBackward);
              const nextN = useActionCreator(media_nextN);
              return Object(jsx_runtime["jsxs"])(react["Fragment"], {
                children: [Object(jsx_runtime["jsx"])(Node, {
                  label: "Previous",
                  hotkey: "Z",
                  onClick: previous
                }), Object(jsx_runtime["jsx"])(Node, {
                  label: "Play",
                  hotkey: "X",
                  onClick: play
                }), Object(jsx_runtime["jsx"])(Node, {
                  label: "Pause",
                  hotkey: "C",
                  onClick: pause
                }), Object(jsx_runtime["jsx"])(Node, {
                  label: "Stop",
                  hotkey: "V",
                  onClick: stop
                }), Object(jsx_runtime["jsx"])(Node, {
                  label: "Next",
                  hotkey: "B",
                  onClick: next
                }), Object(jsx_runtime["jsx"])(ContextMenu_Hr, {}), Object(jsx_runtime["jsx"])(Node, {
                  label: "Back 5 seconds",
                  hotkey: "Left",
                  onClick: () => seekBackward(5)
                }), Object(jsx_runtime["jsx"])(Node, {
                  label: "Fwd 5 seconds",
                  hotkey: "Right",
                  onClick: () => seekForward(5)
                }), Object(jsx_runtime["jsx"])(Node, {
                  label: "10 tracks back",
                  hotkey: "Num. 1",
                  onClick: () => nextN(-10)
                }), Object(jsx_runtime["jsx"])(Node, {
                  label: "10 tracks fwd",
                  hotkey: "Num. 3",
                  onClick: () => nextN(10)
                })]
              });
            };
            var components_PlaybackContextMenu = PlaybackContextMenu;
            const SkinContextMenu = () => {
              const loadDefaultSkin = useActionCreator(actionCreators_loadDefaultSkin);
              const openSkinFileDialog = useActionCreator(files_openSkinFileDialog);
              const setSkin = useActionCreator(setSkinFromUrl);
              const availableSkins = useTypedSelector(getAvaliableSkins);
              return Object(jsx_runtime["jsxs"])(Parent, {
                label: "Skins",
                children: [Object(jsx_runtime["jsx"])(Node, {
                  onClick: openSkinFileDialog,
                  label: "Load Skin..."
                }), Object(jsx_runtime["jsx"])(ContextMenu_Hr, {}), Object(jsx_runtime["jsx"])(Node, {
                  onClick: loadDefaultSkin,
                  label: "<Base Skin>"
                }), availableSkins.map((skin) => Object(jsx_runtime["jsx"])(Node, {
                  onClick: () => setSkin(skin.url),
                  label: skin.name
                }, skin.url))]
              });
            };
            var SkinsContextMenu = SkinContextMenu;
            const OptionsContextMenu = () => {
              const toggleTimeMode = useActionCreator(media_toggleTimeMode);
              const toggleDoubleSizeMode = useActionCreator(windows_toggleDoubleSizeMode);
              const toggleRepeat = useActionCreator(media_toggleRepeat);
              const toggleShuffle = useActionCreator(media_toggleShuffle);
              const doubled = useTypedSelector(getDoubled);
              const timeMode = useTypedSelector(getTimeMode);
              const repeat = useTypedSelector(getRepeat);
              const shuffle = useTypedSelector(getShuffle);
              return Object(jsx_runtime["jsxs"])(jsx_runtime["Fragment"], {
                children: [Object(jsx_runtime["jsx"])(SkinsContextMenu, {}), Object(jsx_runtime["jsx"])(ContextMenu_Hr, {}), Object(jsx_runtime["jsx"])(Node, {
                  label: "Time elapsed",
                  hotkey: "(Ctrl+T toggles)",
                  onClick: toggleTimeMode,
                  checked: timeMode === TIME_MODE.ELAPSED
                }), Object(jsx_runtime["jsx"])(Node, {
                  label: "Time remaining",
                  hotkey: "(Ctrl+T toggles)",
                  onClick: toggleTimeMode,
                  checked: timeMode === TIME_MODE.REMAINING
                }), Object(jsx_runtime["jsx"])(Node, {
                  label: "Double Size",
                  hotkey: "Ctrl+D",
                  onClick: toggleDoubleSizeMode,
                  checked: doubled
                }), Object(jsx_runtime["jsx"])(ContextMenu_Hr, {}), Object(jsx_runtime["jsx"])(Node, {
                  label: "Repeat",
                  hotkey: "R",
                  onClick: toggleRepeat,
                  checked: repeat
                }), Object(jsx_runtime["jsx"])(Node, {
                  label: "Shuffle",
                  hotkey: "S",
                  onClick: toggleShuffle,
                  checked: shuffle
                })]
              });
            };
            var components_OptionsContextMenu = OptionsContextMenu;
            const MainContextMenu = Object(react["memo"])(({
              filePickers
            }) => {
              const networkConnected = useTypedSelector(getNetworkConnected);
              const genWindows = useTypedSelector(getGenWindows);
              const close = useActionCreator(actionCreators_close);
              const openMediaFileDialog = useActionCreator(files_openMediaFileDialog);
              const loadMediaFiles = useActionCreator(files_loadMediaFiles);
              const toggleWindow = useActionCreator(windows_toggleWindow);
              const menuOpened = useActionCreator(() => ({
                type: "MAIN_CONTEXT_MENU_OPENED"
              }));
              Object(react["useEffect"])(() => {
                menuOpened();
              }, [menuOpened]);
              return Object(jsx_runtime["jsxs"])(react["Fragment"], {
                children: [Object(jsx_runtime["jsx"])(LinkNode, {
                  href: "https://webamp.org/about",
                  target: "_blank",
                  label: "Webamp..."
                }), Object(jsx_runtime["jsx"])(ContextMenu_Hr, {}), Object(jsx_runtime["jsxs"])(Parent, {
                  label: "Play",
                  children: [Object(jsx_runtime["jsx"])(Node, {
                    onClick: openMediaFileDialog,
                    label: "File...",
                    hotkey: "L"
                  }), filePickers != null && filePickers.map((picker, i) => (networkConnected || !picker.requiresNetwork) && Object(jsx_runtime["jsx"])(Node, {
                    onClick: async () => {
                      let files;
                      try {
                        files = await picker.filePicker();
                      } catch (e) {
                        console.error("Error loading from file picker", e);
                      }
                      loadMediaFiles(files || [], LOAD_STYLE.PLAY);
                    },
                    label: picker.contextMenuName
                  }, i))]
                }), Object(jsx_runtime["jsx"])(ContextMenu_Hr, {}), Object.keys(genWindows).map((i) => Object(jsx_runtime["jsx"])(Node, {
                  label: genWindows[i].title,
                  checked: genWindows[i].open,
                  onClick: () => toggleWindow(i),
                  hotkey: genWindows[i].hotkey
                }, i)), Object(jsx_runtime["jsx"])(ContextMenu_Hr, {}), Object(jsx_runtime["jsx"])(SkinsContextMenu, {}), Object(jsx_runtime["jsx"])(ContextMenu_Hr, {}), Object(jsx_runtime["jsx"])(Parent, {
                  label: "Options",
                  children: Object(jsx_runtime["jsx"])(components_OptionsContextMenu, {})
                }), Object(jsx_runtime["jsx"])(Parent, {
                  label: "Playback",
                  children: Object(jsx_runtime["jsx"])(components_PlaybackContextMenu, {})
                }), Object(jsx_runtime["jsx"])(ContextMenu_Hr, {}), Object(jsx_runtime["jsx"])(Node, {
                  onClick: close,
                  label: "Exit"
                })]
              });
            });
            var MainWindow_MainContextMenu = MainContextMenu;
            function WindowManager_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function WindowManager_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  WindowManager_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  WindowManager_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            const abuts = (a, b) => {
              const wouldMoveTo = snap(a, b);
              return wouldMoveTo.x !== void 0 || wouldMoveTo.y !== void 0;
            };
            function useHandleMouseDown(propsWindows) {
              const windowsInfo = useTypedSelector(getWindowsInfo);
              const getWindowHidden = useTypedSelector(selectors_getWindowHidden);
              const browserWindowSize = useTypedSelector(getBrowserWindowSize);
              const updateWindowPositions = useActionCreator(windows_updateWindowPositions);
              const [draggingState, setDraggingState] = Object(react["useState"])(null);
              Object(react["useEffect"])(() => {
                if (draggingState == null) {
                  return;
                }
                const {
                  boundingBox,
                  moving,
                  stationary,
                  mouseStart
                } = draggingState;
                const handleMouseMove = (ee) => {
                  const proposedDiff = {
                    x: getX(ee) - mouseStart.x,
                    y: getY(ee) - mouseStart.y
                  };
                  const proposedWindows = moving.map((node) => WindowManager_objectSpread(WindowManager_objectSpread({}, node), applyDiff(node, proposedDiff)));
                  const proposedBox = WindowManager_objectSpread(WindowManager_objectSpread({}, boundingBox), applyDiff(boundingBox, proposedDiff));
                  const snapDiff = snapDiffManyToMany(proposedWindows, stationary);
                  const withinDiff = snapWithinDiff(proposedBox, browserWindowSize);
                  const finalDiff = applyMultipleDiffs(proposedDiff, snapDiff, withinDiff);
                  const windowPositionDiff = {};
                  moving.forEach((w) => {
                    windowPositionDiff[w.key] = applyDiff(w, finalDiff);
                  });
                  updateWindowPositions(windowPositionDiff, false);
                };
                function handleMouseUp() {
                  setDraggingState(null);
                }
                window.addEventListener("mouseup", handleMouseUp);
                window.addEventListener("touchend", handleMouseUp);
                window.addEventListener("mousemove", handleMouseMove, {
                  passive: false
                });
                window.addEventListener("touchmove", handleMouseMove, {
                  passive: false
                });
                return () => {
                  window.removeEventListener("mousemove", handleMouseMove);
                  window.removeEventListener("touchmove", handleMouseMove);
                  window.removeEventListener("mouseup", handleMouseUp);
                  window.removeEventListener("touchend", handleMouseUp);
                };
              }, [browserWindowSize, draggingState, updateWindowPositions]);
              return Object(react["useCallback"])((key, e) => {
                if (!e.target.classList.contains("draggable")) {
                  return;
                }
                const x = getX(e);
                const y = getY(e);
                if (getWindowHidden(key)) {
                  return;
                }
                const windows = windowsInfo.filter((w) => propsWindows[w.key] != null && !getWindowHidden(w.key));
                const targetNode = windows.find((node) => node.key === key);
                if (targetNode == null) {
                  throw new Error(`Tried to move a node that does not exist: ${key}`);
                }
                let movingSet = /* @__PURE__ */ new Set([targetNode]);
                if (key === "main") {
                  const findAllConnected = traceConnection(abuts);
                  movingSet = findAllConnected(windows, targetNode);
                }
                const stationary = windows.filter((w) => !movingSet.has(w));
                const moving = Array.from(movingSet);
                const mouseStart = {
                  x,
                  y
                };
                const boundingBox = snapUtils_boundingBox(moving);
                setDraggingState({
                  boundingBox,
                  moving,
                  stationary,
                  mouseStart
                });
              }, [getWindowHidden, propsWindows, windowsInfo]);
            }
            function WindowManager({
              windows: propsWindows
            }) {
              const windowsInfo = useTypedSelector(getWindowsInfo);
              const setFocusedWindow = useActionCreator(windows_setFocusedWindow);
              const handleMouseDown = useHandleMouseDown(propsWindows);
              const windows = windowsInfo.filter((w) => propsWindows[w.key]);
              const onBlur = Object(react["useCallback"])(
                // I give up on trying to type things with `relatedTarget`.
                (e) => {
                  const {
                    currentTarget,
                    relatedTarget
                  } = e;
                  if (currentTarget === relatedTarget || currentTarget.contains(relatedTarget)) {
                    return;
                  }
                  setFocusedWindow(null);
                },
                [setFocusedWindow]
              );
              return Object(jsx_runtime["jsx"])(jsx_runtime["Fragment"], {
                children: windows.map((w) => Object(jsx_runtime["jsx"])("div", {
                  onBlur,
                  onMouseDown: (e) => {
                    handleMouseDown(w.key, e);
                  },
                  onTouchStart: (e) => {
                    handleMouseDown(w.key, e);
                  },
                  style: {
                    position: "absolute",
                    top: 0,
                    left: 0,
                    transform: `translate(${w.x}px, ${w.y}px)`,
                    touchAction: "none"
                  },
                  children: propsWindows[w.key]
                }, w.key))
              });
            }
            var deburr = __webpack_require__2(40);
            var deburr_default = __webpack_require__2.n(deburr);
            function Character_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function Character_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  Character_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  Character_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            const characterClassName = (char) => `character-${deburr_default()(char.toString()).toLowerCase().charCodeAt(0)}`;
            const Character = react["memo"]((_ref) => {
              let {
                children: char,
                className
              } = _ref, passThrough = objectWithoutProperties_default()(_ref, ["children", "className"]);
              return Object(jsx_runtime["jsx"])("span", Character_objectSpread(Character_objectSpread({}, passThrough), {}, {
                className: `${className || ""} character ${characterClassName(char)}`,
                children: char
              }));
            });
            var components_Character = Character;
            var mini_time = __webpack_require__2(88);
            const MiniTime_Background = () => Object(jsx_runtime["jsx"])(react["Fragment"], {
              children: [1, 7, 12, 20, 25].map((left, i) => Object(jsx_runtime["jsx"])(components_Character, {
                style: {
                  left
                },
                className: "background-character",
                children: " "
              }, i))
            });
            const MiniTime = () => {
              const status = useTypedSelector(getMediaStatus);
              const duration = useTypedSelector(getDuration);
              const timeElapsed = useTypedSelector(getTimeElapsed);
              const timeMode = useTypedSelector(getTimeMode);
              const toggle = useActionCreator(media_toggleTimeMode);
              let seconds = null;
              if (status !== MEDIA_STATUS.STOPPED && duration != null) {
                seconds = timeMode === TIME_MODE.ELAPSED ? timeElapsed : duration - timeElapsed;
              }
              const timeObj = getTimeObj(seconds);
              const showMinus = timeMode === TIME_MODE.REMAINING && status !== MEDIA_STATUS.STOPPED;
              return Object(jsx_runtime["jsxs"])("div", {
                onClick: toggle,
                className: classnames_default()("mini-time", "countdown", {
                  blinking: status === MEDIA_STATUS.PAUSED
                }),
                children: [Object(jsx_runtime["jsx"])(MiniTime_Background, {}), Object(jsx_runtime["jsx"])(components_Character, {
                  style: {
                    left: 1
                  },
                  children: showMinus ? "-" : " "
                }), Object(jsx_runtime["jsx"])(components_Character, {
                  style: {
                    left: 7
                  },
                  children: timeObj.minutesFirstDigit
                }), Object(jsx_runtime["jsx"])(components_Character, {
                  style: {
                    left: 12
                  },
                  children: timeObj.minutesSecondDigit
                }), Object(jsx_runtime["jsx"])(components_Character, {
                  style: {
                    left: 20
                  },
                  children: timeObj.secondsFirstDigit
                }), Object(jsx_runtime["jsx"])(components_Character, {
                  style: {
                    left: 25
                  },
                  children: timeObj.secondsSecondDigit
                })]
              });
            };
            var components_MiniTime = MiniTime;
            function ClickedDiv_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function ClickedDiv_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  ClickedDiv_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  ClickedDiv_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function ClickedDiv(props) {
              const [clicked, setClicked] = Object(react["useState"])(false);
              function handleMouseDown(e) {
                setClicked(true);
                if (props.onMouseDown) {
                  props.onMouseDown(e);
                }
              }
              return Object(jsx_runtime["jsx"])("div", ClickedDiv_objectSpread(ClickedDiv_objectSpread({}, props), {}, {
                className: classnames_default()(props.className, {
                  clicked
                }),
                onMouseDown: handleMouseDown
              }));
            }
            var components_ClickedDiv = ClickedDiv;
            function ContextMenuTarget_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function ContextMenuTarget_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  ContextMenuTarget_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  ContextMenuTarget_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function getNodeOffset(node) {
              if (node == null) {
                return {
                  top: 0,
                  left: 0
                };
              }
              const rect = node.getBoundingClientRect();
              const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
              const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
              return {
                top: rect.top + scrollTop,
                left: rect.left + scrollLeft
              };
            }
            function ContextMenuTarget(props) {
              const handleNode = Object(react["useRef"])(null);
              const [selected, setSelected] = Object(react["useState"])(false);
              Object(react["useEffect"])(() => {
                if (!selected) {
                  return;
                }
                function handleGlobalClick(e) {
                  if (selected && // Typescript does not believe that these click events are always fired on DOM nodes.
                  e.target instanceof Element && selected && // Not sure how, but it's possible for this to get called when handleNode is null/undefined.
                  // https://sentry.io/share/issue/2066cd79f21e4f279791319f4d2ea35d/
                  handleNode.current && !handleNode.current.contains(e.target)) {
                    setSelected(false);
                  }
                }
                document.addEventListener("click", handleGlobalClick);
                return () => {
                  document.removeEventListener("click", handleGlobalClick);
                };
              }, [selected]);
              const offset = Object(react["useMemo"])(() => {
                return selected ? getNodeOffset(handleNode.current) : (
                  // Kinda awkward. This is a nonsense return value since we only use
                  //this value when we are selected.
                  {
                    top: 0,
                    left: 0
                  }
                );
              }, [selected]);
              const {
                renderMenu,
                children,
                top,
                bottom
              } = props, passThroughProps = objectWithoutProperties_default()(props, ["renderMenu", "children", "top", "bottom"]);
              return Object(jsx_runtime["jsxs"])("div", ContextMenuTarget_objectSpread(ContextMenuTarget_objectSpread({}, passThroughProps), {}, {
                children: [Object(jsx_runtime["jsx"])("div", {
                  className: "handle",
                  style: {
                    width: "100%",
                    height: "100%"
                  },
                  ref: handleNode,
                  onClick: () => setSelected(!selected),
                  children
                }), Object(jsx_runtime["jsx"])(ContextMenu, {
                  selected,
                  offsetTop: offset.top,
                  offsetLeft: offset.left,
                  top,
                  bottom,
                  children: renderMenu()
                })]
              }));
            }
            var components_ContextMenuTarget = ContextMenuTarget;
            const PIXEL_DENSITY = 2;
            function sliceAverage(dataArray, sliceWidth, sliceNumber) {
              const start = sliceWidth * sliceNumber;
              const end = start + sliceWidth;
              let sum2 = 0;
              for (let i = start; i < end; i++) {
                sum2 += dataArray[i];
              }
              return sum2 / sliceWidth;
            }
            function usePaintOscilloscopeFrame({
              analyser,
              height,
              width,
              renderWidth
            }) {
              const colors = useTypedSelector(getSkinColors);
              const bufferLength = analyser.fftSize;
              const dataArray = Object(react["useMemo"])(() => {
                return new Uint8Array(bufferLength);
              }, [bufferLength]);
              return Object(react["useCallback"])((canvasCtx) => {
                analyser.getByteTimeDomainData(dataArray);
                canvasCtx.lineWidth = PIXEL_DENSITY;
                canvasCtx.strokeStyle = colors[18];
                const sliceWidth = Math.floor(bufferLength / width) * PIXEL_DENSITY;
                const h = height;
                canvasCtx.beginPath();
                for (let j = 0; j <= renderWidth; j++) {
                  const amplitude = sliceAverage(dataArray, sliceWidth, j);
                  const percentAmplitude = amplitude / 255;
                  const y = (1 - percentAmplitude) * h;
                  const x = j * PIXEL_DENSITY;
                  if (x === 0) {
                    canvasCtx.moveTo(x, y);
                  } else {
                    canvasCtx.lineTo(x, y);
                  }
                }
                canvasCtx.stroke();
              }, [analyser, bufferLength, colors, dataArray, height, renderWidth, width]);
            }
            const useBarVisualizer_PIXEL_DENSITY = 2;
            const BAR_WIDTH = 3 * useBarVisualizer_PIXEL_DENSITY;
            const GRADIENT_COLOR_COUNT = 16;
            const PEAK_COLOR_INDEX = 23;
            const BAR_PEAK_DROP_RATE = 0.01;
            const NUM_BARS = 20;
            function octaveBucketsForBufferLength(bufferLength) {
              const octaveBuckets = new Array(NUM_BARS).fill(0);
              const minHz = 200;
              const maxHz = 22050;
              const octaveStep = Math.pow(maxHz / minHz, 1 / NUM_BARS);
              octaveBuckets[0] = 0;
              octaveBuckets[1] = minHz;
              for (let i = 2; i < NUM_BARS - 1; i++) {
                octaveBuckets[i] = octaveBuckets[i - 1] * octaveStep;
              }
              octaveBuckets[NUM_BARS - 1] = maxHz;
              for (let i = 0; i < NUM_BARS; i++) {
                const octaveIdx = Math.floor(octaveBuckets[i] / maxHz * bufferLength);
                octaveBuckets[i] = octaveIdx;
              }
              return octaveBuckets;
            }
            function preRenderBar(height, colors, renderHeight) {
              const barCanvas = document.createElement("canvas");
              barCanvas.width = BAR_WIDTH;
              barCanvas.height = height;
              const offset = 2;
              const gradientColors = colors.slice(offset, offset + GRADIENT_COLOR_COUNT);
              const barCanvasCtx = barCanvas.getContext("2d");
              if (barCanvasCtx == null) {
                throw new Error("Could not construct canvas context");
              }
              const multiplier = GRADIENT_COLOR_COUNT / renderHeight;
              for (let i = 0; i < renderHeight; i++) {
                const colorIndex = GRADIENT_COLOR_COUNT - 1 - Math.floor(i * multiplier);
                barCanvasCtx.fillStyle = gradientColors[colorIndex];
                const y = height - i * useBarVisualizer_PIXEL_DENSITY;
                barCanvasCtx.fillRect(0, y, BAR_WIDTH, useBarVisualizer_PIXEL_DENSITY);
              }
              return barCanvas;
            }
            function usePaintBar({
              renderHeight,
              height
            }) {
              const colors = useTypedSelector(getSkinColors);
              const getWindowShade = useTypedSelector(selectors_getWindowShade);
              const windowShade = getWindowShade("main");
              const barCanvas = Object(react["useMemo"])(() => {
                return preRenderBar(height, colors, renderHeight);
              }, [colors, height, renderHeight]);
              return Object(react["useCallback"])((ctx, x, barHeight, peakHeight) => {
                barHeight = Math.ceil(barHeight) * useBarVisualizer_PIXEL_DENSITY;
                peakHeight = Math.ceil(peakHeight) * useBarVisualizer_PIXEL_DENSITY;
                if (barHeight > 0 || peakHeight > 0) {
                  const y = height - barHeight;
                  const b = BAR_WIDTH;
                  if (height > 0) {
                    ctx.drawImage(barCanvas, 0, y, b, height, x, y, b, height);
                  }
                  if (!windowShade) {
                    const peakY = height - peakHeight;
                    ctx.fillStyle = colors[PEAK_COLOR_INDEX];
                    ctx.fillRect(x, peakY, b, useBarVisualizer_PIXEL_DENSITY);
                  }
                }
              }, [barCanvas, colors, height, windowShade]);
            }
            function usePaintBarFrame({
              renderHeight,
              height,
              analyser
            }) {
              const [barPeaks] = Object(react["useState"])(() => new Array(NUM_BARS).fill(0));
              const [barPeakFrames] = Object(react["useState"])(() => new Array(NUM_BARS).fill(0));
              const bufferLength = analyser.frequencyBinCount;
              const octaveBuckets = Object(react["useMemo"])(() => {
                return octaveBucketsForBufferLength(bufferLength);
              }, [bufferLength]);
              const dataArray = Object(react["useMemo"])(() => {
                return new Uint8Array(bufferLength);
              }, [bufferLength]);
              const paintBar = usePaintBar({
                height,
                renderHeight
              });
              return Object(react["useCallback"])((canvasCtx) => {
                analyser.getByteFrequencyData(dataArray);
                const heightMultiplier = renderHeight / 256;
                const xOffset = BAR_WIDTH + useBarVisualizer_PIXEL_DENSITY;
                for (let j = 0; j < NUM_BARS - 1; j++) {
                  const start = octaveBuckets[j];
                  const end = octaveBuckets[j + 1];
                  let amplitude = 0;
                  for (let k = start; k < end; k++) {
                    amplitude += dataArray[k];
                  }
                  amplitude /= end - start;
                  let barPeak = barPeaks[j] - BAR_PEAK_DROP_RATE * Math.pow(barPeakFrames[j], 2);
                  if (barPeak < amplitude) {
                    barPeak = amplitude;
                    barPeakFrames[j] = 0;
                  } else {
                    barPeakFrames[j] += 1;
                  }
                  barPeaks[j] = barPeak;
                  paintBar(canvasCtx, j * xOffset, amplitude * heightMultiplier, barPeak * heightMultiplier);
                }
              }, [analyser, barPeakFrames, barPeaks, dataArray, octaveBuckets, paintBar, renderHeight]);
            }
            const Visualizer_PIXEL_DENSITY = 2;
            function preRenderBg(width, height, bgColor, fgColor, windowShade) {
              const bgCanvas = document.createElement("canvas");
              bgCanvas.width = width;
              bgCanvas.height = height;
              const distance = 2 * Visualizer_PIXEL_DENSITY;
              const bgCanvasCtx = bgCanvas.getContext("2d");
              if (bgCanvasCtx == null) {
                throw new Error("Could not construct canvas context");
              }
              bgCanvasCtx.fillStyle = bgColor;
              bgCanvasCtx.fillRect(0, 0, width, height);
              if (!windowShade) {
                bgCanvasCtx.fillStyle = fgColor;
                for (let x = 0; x < width; x += distance) {
                  for (let y = Visualizer_PIXEL_DENSITY; y < height; y += distance) {
                    bgCanvasCtx.fillRect(x, y, Visualizer_PIXEL_DENSITY, Visualizer_PIXEL_DENSITY);
                  }
                }
              }
              return bgCanvas;
            }
            function Visualizer_Visualizer({
              analyser
            }) {
              Object(react["useLayoutEffect"])(() => {
                analyser.fftSize = 2048;
              }, [analyser.fftSize]);
              const colors = useTypedSelector(getSkinColors);
              const style = useTypedSelector(selectors_getVisualizerStyle);
              const status = useTypedSelector(getMediaStatus);
              const getWindowShade = useTypedSelector(selectors_getWindowShade);
              const dummyVizData = useTypedSelector(getDummyVizData);
              const toggleVisualizerStyle = useActionCreator(actionCreators_toggleVisualizerStyle);
              const windowShade = getWindowShade("main");
              const renderWidth = windowShade ? 38 : 76;
              const renderHeight = windowShade ? 5 : 16;
              const width = renderWidth * Visualizer_PIXEL_DENSITY;
              const height = renderHeight * Visualizer_PIXEL_DENSITY;
              const bgCanvas = Object(react["useMemo"])(() => {
                return preRenderBg(width, height, colors[0], colors[1], Boolean(windowShade));
              }, [colors, height, width, windowShade]);
              const paintOscilloscopeFrame = usePaintOscilloscopeFrame({
                analyser,
                height,
                width,
                renderWidth
              });
              const paintBarFrame = usePaintBarFrame({
                analyser,
                height,
                renderHeight
              });
              const paintBar = usePaintBar({
                height,
                renderHeight
              });
              const paintFrame = Object(react["useCallback"])((canvasCtx) => {
                if (status !== MEDIA_STATUS.PLAYING) {
                  return;
                }
                if (dummyVizData) {
                  canvasCtx.drawImage(bgCanvas, 0, 0);
                  Object.entries(dummyVizData).forEach(([i, value]) => {
                    paintBar(canvasCtx, Number(i), value, -1);
                  });
                  return;
                }
                switch (style) {
                  case VISUALIZERS.OSCILLOSCOPE:
                    canvasCtx.drawImage(bgCanvas, 0, 0);
                    paintOscilloscopeFrame(canvasCtx);
                    break;
                  case VISUALIZERS.BAR:
                    canvasCtx.drawImage(bgCanvas, 0, 0);
                    paintBarFrame(canvasCtx);
                    break;
                  default:
                    canvasCtx.clearRect(0, 0, width, height);
                }
              }, [bgCanvas, dummyVizData, height, paintBar, paintBarFrame, paintOscilloscopeFrame, status, style, width]);
              const [canvas, setCanvas] = Object(react["useState"])(null);
              Object(react["useLayoutEffect"])(() => {
                if (canvas == null) {
                  return;
                }
                const canvasCtx = canvas.getContext("2d");
                if (canvasCtx == null) {
                  return;
                }
                canvasCtx.imageSmoothingEnabled = false;
                let animationRequest = null;
                const loop = () => {
                  paintFrame(canvasCtx);
                  animationRequest = window.requestAnimationFrame(loop);
                };
                loop();
                return () => {
                  if (animationRequest != null) {
                    window.cancelAnimationFrame(animationRequest);
                  }
                };
              }, [canvas, paintFrame]);
              if (status === MEDIA_STATUS.STOPPED) {
                return null;
              }
              return Object(jsx_runtime["jsx"])("canvas", {
                id: "visualizer",
                ref: setCanvas,
                style: {
                  width: renderWidth,
                  height: renderHeight
                },
                width,
                height,
                onClick: toggleVisualizerStyle
              });
            }
            var components_Visualizer = Visualizer_Visualizer;
            const ActionButtons = Object(react["memo"])(() => {
              const previous = useActionCreator(media_previous);
              const play = useActionCreator(media_play);
              const pause = useActionCreator(media_pause);
              const next = useActionCreator(media_next);
              const stop = useActionCreator(media_stop);
              return Object(jsx_runtime["jsxs"])("div", {
                className: "actions",
                children: [Object(jsx_runtime["jsx"])("div", {
                  id: "previous",
                  onClick: previous,
                  title: "Previous Track"
                }), Object(jsx_runtime["jsx"])("div", {
                  id: "play",
                  onClick: play,
                  title: "Play"
                }), Object(jsx_runtime["jsx"])("div", {
                  id: "pause",
                  onClick: pause,
                  title: "Pause"
                }), Object(jsx_runtime["jsx"])("div", {
                  id: "stop",
                  onClick: stop,
                  title: "Stop"
                }), Object(jsx_runtime["jsx"])("div", {
                  id: "next",
                  onClick: next,
                  title: "Next Track"
                })]
              });
            });
            var MainWindow_ActionButtons = ActionButtons;
            function Balance_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function Balance_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  Balance_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  Balance_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function Balance({
              style,
              className,
              id
            }) {
              const balance = useTypedSelector(getBalance);
              const setBalance = useActionCreator(media_setBalance);
              const setFocus = useActionCreator(actionCreators_setFocus);
              const unsetFocus = useActionCreator(actionCreators_unsetFocus);
              return Object(jsx_runtime["jsx"])("input", {
                id,
                className,
                type: "range",
                min: "-100",
                max: "100",
                step: "1",
                value: balance,
                style: Balance_objectSpread(Balance_objectSpread({}, style), {}, {
                  touchAction: "none"
                }),
                onChange: (e) => setBalance(Number(e.target.value)),
                onMouseDown: () => setFocus("balance"),
                onMouseUp: unsetFocus,
                title: "Balance"
              });
            }
            const offsetFromBalance = (balance) => {
              const percent = Math.abs(balance) / 100;
              const sprite = Math.floor(percent * 27);
              const offset = sprite * 15;
              return offset;
            };
            const MainBalance = Object(react["memo"])(() => {
              const balance = useTypedSelector(getBalance);
              return Object(jsx_runtime["jsx"])(Balance, {
                id: "balance",
                style: {
                  backgroundPosition: `0 -${offsetFromBalance(balance)}px`
                }
              });
            });
            var MainWindow_MainBalance = MainBalance;
            const Close = Object(react["memo"])(() => {
              const close = useActionCreator(actionCreators_close);
              return Object(jsx_runtime["jsx"])(components_ClickedDiv, {
                id: "close",
                onClick: close,
                title: "Close"
              });
            });
            var MainWindow_Close = Close;
            function setFocusDouble() {
              return actionCreators_setFocus("double");
            }
            function mouseUp() {
              return (dispatch) => {
                dispatch(windows_toggleDoubleSizeMode());
                dispatch(actionCreators_unsetFocus());
              };
            }
            const ClutterBar = Object(react["memo"])(() => {
              const handleMouseDown = useActionCreator(setFocusDouble);
              const handleMouseUp = useActionCreator(mouseUp);
              const doubled = useTypedSelector(getDoubled);
              return Object(jsx_runtime["jsxs"])("div", {
                id: "clutter-bar",
                children: [Object(jsx_runtime["jsx"])(components_ContextMenuTarget, {
                  bottom: true,
                  renderMenu: () => Object(jsx_runtime["jsx"])(components_OptionsContextMenu, {}),
                  children: Object(jsx_runtime["jsx"])("div", {
                    id: "button-o"
                  })
                }), Object(jsx_runtime["jsx"])("div", {
                  id: "button-a"
                }), Object(jsx_runtime["jsx"])("div", {
                  id: "button-i"
                }), Object(jsx_runtime["jsx"])("div", {
                  title: "Toggle Doublesize Mode",
                  id: "button-d",
                  className: classnames_default()({
                    selected: doubled
                  }),
                  onMouseUp: handleMouseUp,
                  onMouseDown: handleMouseDown
                }), Object(jsx_runtime["jsx"])("div", {
                  id: "button-v"
                })]
              });
            });
            var MainWindow_ClutterBar = ClutterBar;
            const Eject = Object(react["memo"])(() => {
              const openMediaFileDialog = useActionCreator(files_openMediaFileDialog);
              return Object(jsx_runtime["jsx"])("div", {
                id: "eject",
                onClick: openMediaFileDialog,
                title: "Open File(s)"
              });
            });
            var MainWindow_Eject = Eject;
            function toggleEqualizer() {
              return windows_toggleWindow("equalizer");
            }
            const EqToggleButton = Object(react["memo"])(() => {
              const handleClick = useActionCreator(toggleEqualizer);
              const windowOpen = useTypedSelector(selectors_getWindowOpen)("equalizer");
              return Object(jsx_runtime["jsx"])("div", {
                id: "equalizer-button",
                className: classnames_default()({
                  selected: windowOpen
                }),
                onClick: handleClick,
                title: "Toggle Graphical Equalizer"
              });
            });
            var MainWindow_EqToggleButton = EqToggleButton;
            function togglePlaylist() {
              return windows_toggleWindow("playlist");
            }
            const PlaylistToggleButton = Object(react["memo"])(() => {
              const selected = useTypedSelector(selectors_getWindowOpen)("playlist");
              const handleClick = useActionCreator(togglePlaylist);
              return Object(jsx_runtime["jsx"])("div", {
                id: "playlist-button",
                className: classnames_default()({
                  selected
                }),
                onClick: handleClick,
                title: "Toggle Playlist Editor"
              });
            });
            var MainWindow_PlaylistToggleButton = PlaylistToggleButton;
            const CharacterString = Object(react["memo"])((props) => {
              const text = `${props.children}` || "";
              const chars = text.split("");
              return Object(jsx_runtime["jsx"])(react["Fragment"], {
                children: chars.map((character, index) => Object(jsx_runtime["jsx"])(components_Character, {
                  children: character
                }, index + character))
              });
            });
            var components_CharacterString = CharacterString;
            const Kbps = Object(react["memo"])(() => {
              const kbps = useTypedSelector(getKbps);
              return Object(jsx_runtime["jsx"])("div", {
                id: "kbps",
                children: Object(jsx_runtime["jsx"])(components_CharacterString, {
                  children: kbps || ""
                })
              });
            });
            var MainWindow_Kbps = Kbps;
            const Khz = Object(react["memo"])(() => {
              const khz = useTypedSelector(getKhz);
              return Object(jsx_runtime["jsx"])("div", {
                id: "khz",
                children: Object(jsx_runtime["jsx"])(components_CharacterString, {
                  children: khz || ""
                })
              });
            });
            var MainWindow_Khz = Khz;
            const SEPARATOR = "  ***  ";
            const CHAR_WIDTH = 5;
            const MARQUEE_MAX_LENGTH = 31;
            const mod = (n, m) => (n % m + m) % m;
            const isLong = (text) => text.length >= MARQUEE_MAX_LENGTH;
            const stepOffset = (text, step, pixels) => {
              if (!isLong(text)) {
                return 0;
              }
              const stepOffsetWidth = step * CHAR_WIDTH;
              const offset = stepOffsetWidth + pixels;
              const stringLength = (text.length + SEPARATOR.length) * CHAR_WIDTH;
              return mod(offset, stringLength);
            };
            const pixelUnits = (pixels) => `${pixels}px`;
            const loopText = (text) => isLong(text) ? `${text}${SEPARATOR}${text}` : text.padEnd(MARQUEE_MAX_LENGTH, " ");
            function useStepper({
              step,
              dragging
            }) {
              const [stepping, setStepping] = react["useState"](true);
              react["useEffect"](() => {
                if (stepping === false) {
                  return;
                }
                const stepHandle = setInterval(step, 220);
                return () => clearInterval(stepHandle);
              }, [step, stepping]);
              react["useEffect"](() => {
                if (dragging) {
                  setStepping(false);
                  return;
                }
                const steppingTimeout = window.setTimeout(() => {
                  setStepping(true);
                }, 1e3);
                return () => {
                  window.clearTimeout(steppingTimeout);
                };
              }, [dragging]);
            }
            function useDragX() {
              const [mouseDownX, setMouseDownX] = react["useState"](null);
              const [dragOffset, setDragOffset] = react["useState"](0);
              react["useEffect"](() => {
                if (mouseDownX == null) {
                  return;
                }
                const xStart = mouseDownX;
                const handleMouseMove = (ee) => {
                  const diff = getX(ee) - xStart;
                  setDragOffset(-diff);
                };
                let cleanedUp = false;
                const handleMouseUp = () => {
                  if (cleanedUp) {
                    return;
                  }
                  document.removeEventListener("mousemove", handleMouseMove);
                  document.removeEventListener("touchmove", handleMouseMove);
                  document.removeEventListener("mouseup", handleMouseUp);
                  document.removeEventListener("touchend", handleMouseUp);
                  setMouseDownX(null);
                  cleanedUp = true;
                };
                document.addEventListener("mousemove", handleMouseMove);
                document.addEventListener("touchmove", handleMouseMove);
                document.addEventListener("touseup", handleMouseUp);
                document.addEventListener("touchend", handleMouseUp);
                return handleMouseUp;
              }, [mouseDownX]);
              const handleMouseDown = react["useCallback"]((e) => {
                setMouseDownX(getX(e));
              }, []);
              return {
                handleMouseDown,
                dragOffset,
                dragging: mouseDownX != null
              };
            }
            const Marquee = react["memo"](() => {
              const text = useTypedSelector(getMarqueeText);
              const doubled = useTypedSelector(getDoubled);
              const marqueeStep = useTypedSelector(getMarqueeStep);
              const stepMarquee = useActionCreator(actionCreators_stepMarquee);
              const {
                handleMouseDown,
                dragOffset,
                dragging
              } = useDragX();
              const offset = stepOffset(text, marqueeStep, dragOffset);
              const offsetPixels = pixelUnits(-offset);
              useStepper({
                step: stepMarquee,
                dragging
              });
              return Object(jsx_runtime["jsx"])("div", {
                id: "marquee",
                className: "text",
                onMouseDown: handleMouseDown,
                onTouchStart: handleMouseDown,
                title: "Song Title",
                children: Object(jsx_runtime["jsx"])("div", {
                  style: {
                    whiteSpace: "nowrap",
                    willChange: "transform",
                    transform: `translateX(${offsetPixels})`
                  },
                  children: Object(jsx_runtime["jsx"])(components_CharacterString, {
                    children: loopText(text)
                  })
                }, doubled ? "doubled" : "not-doubled")
              });
            });
            var MainWindow_Marquee = Marquee;
            const MonoStereo = Object(react["memo"])(() => {
              const channels = useTypedSelector(getChannels);
              return Object(jsx_runtime["jsxs"])("div", {
                className: "mono-stereo",
                children: [Object(jsx_runtime["jsx"])("div", {
                  id: "stereo",
                  className: classnames_default()({
                    selected: channels === 2
                  })
                }), Object(jsx_runtime["jsx"])("div", {
                  id: "mono",
                  className: classnames_default()({
                    selected: channels === 1
                  })
                })]
              });
            });
            var MainWindow_MonoStereo = MonoStereo;
            function usePosition() {
              const duration = useTypedSelector(getDuration);
              const timeElapsed = useTypedSelector(getTimeElapsed);
              const position = duration ? Math.floor(timeElapsed) / duration * 100 : 0;
              const scrubPosition = useTypedSelector(getUserInputScrubPosition);
              const userInputFocus = useTypedSelector(getUserInputFocus);
              const displayedPosition = userInputFocus === "position" ? scrubPosition : position;
              return [position, displayedPosition];
            }
            const Position = Object(react["memo"])(() => {
              const [position, displayedPosition] = usePosition();
              const dispatch = useTypedDispatch();
              const seekToPercentComplete = Object(react["useCallback"])((e) => {
                dispatch({
                  type: SEEK_TO_PERCENT_COMPLETE,
                  percent: Number(e.target.value)
                });
                dispatch({
                  type: UNSET_FOCUS
                });
              }, [dispatch]);
              const setPosition = Object(react["useCallback"])((e) => {
                dispatch({
                  type: SET_FOCUS,
                  input: "position"
                });
                dispatch({
                  type: SET_SCRUB_POSITION,
                  position: Number(e.target.value)
                });
              }, [dispatch]);
              let className = "";
              if (position <= 33) {
                className = "left";
              } else if (position >= 66) {
                className = "right";
              }
              return Object(jsx_runtime["jsx"])("input", {
                id: "position",
                className,
                type: "range",
                min: "0",
                max: "100",
                step: "1",
                style: {
                  touchAction: "none"
                },
                value: displayedPosition,
                onInput: setPosition,
                onChange: () => {
                },
                onMouseUp: seekToPercentComplete,
                onMouseDown: setPosition,
                title: "Seeking Bar"
              });
            });
            var MainWindow_Position = Position;
            const Repeat = Object(react["memo"])(() => {
              const repeat = useTypedSelector(getRepeat);
              const handleClick = useActionCreator(media_toggleRepeat);
              return Object(jsx_runtime["jsx"])(ContextMenuWraper, {
                renderContents: () => Object(jsx_runtime["jsx"])(Node, {
                  checked: repeat,
                  label: "Repeat",
                  onClick: handleClick,
                  hotkey: "(R)"
                }),
                children: Object(jsx_runtime["jsx"])("div", {
                  id: "repeat",
                  className: classnames_default()({
                    selected: repeat
                  }),
                  onClick: handleClick,
                  title: "Toggle Repeat"
                })
              });
            });
            var MainWindow_Repeat = Repeat;
            const Shade = Object(react["memo"])(() => {
              const handleClick = useActionCreator(windows_toggleMainWindowShadeMode);
              return Object(jsx_runtime["jsx"])(components_ClickedDiv, {
                id: "shade",
                onMouseDown: handleClick,
                onDoubleClick: (e) => e.stopPropagation(),
                title: "Toggle Windowshade Mode"
              });
            });
            var MainWindow_Shade = Shade;
            const Minimize = Object(react["memo"])(() => {
              const minimize = useActionCreator(actionCreators_minimize);
              return Object(jsx_runtime["jsx"])(components_ClickedDiv, {
                id: "minimize",
                title: "Minimize",
                onClick: minimize
              });
            });
            var MainWindow_Minimize = Minimize;
            const Shuffle = Object(react["memo"])(() => {
              const shuffle = useTypedSelector(getShuffle);
              const handleClick = useActionCreator(media_toggleShuffle);
              return Object(jsx_runtime["jsx"])(ContextMenuWraper, {
                renderContents: () => Object(jsx_runtime["jsx"])(Node, {
                  checked: shuffle,
                  label: "Shuffle",
                  onClick: handleClick,
                  hotkey: "(S)"
                }),
                children: Object(jsx_runtime["jsx"])("div", {
                  id: "shuffle",
                  className: classnames_default()({
                    selected: shuffle
                  }),
                  onClick: handleClick,
                  title: "Toggle Shuffle"
                })
              });
            });
            var MainWindow_Shuffle = Shuffle;
            const Time = Object(react["memo"])(() => {
              const toggleTimeMode = useActionCreator(media_toggleTimeMode);
              const timeElapsed = useTypedSelector(getTimeElapsed);
              const duration = useTypedSelector(getDuration) || 0;
              const timeMode = useTypedSelector(getTimeMode);
              const seconds = timeMode === TIME_MODE.ELAPSED ? timeElapsed : duration - timeElapsed;
              const timeObj = getTimeObj(seconds);
              return Object(jsx_runtime["jsxs"])("div", {
                id: "time",
                onClick: toggleTimeMode,
                className: "countdown",
                children: [timeMode === TIME_MODE.REMAINING && Object(jsx_runtime["jsx"])("div", {
                  id: "minus-sign"
                }), Object(jsx_runtime["jsx"])("div", {
                  id: "minute-first-digit",
                  className: `digit digit-${timeObj.minutesFirstDigit}`
                }), Object(jsx_runtime["jsx"])("div", {
                  id: "minute-second-digit",
                  className: `digit digit-${timeObj.minutesSecondDigit}`
                }), Object(jsx_runtime["jsx"])("div", {
                  id: "second-first-digit",
                  className: `digit digit-${timeObj.secondsFirstDigit}`
                }), Object(jsx_runtime["jsx"])("div", {
                  id: "second-second-digit",
                  className: `digit digit-${timeObj.secondsSecondDigit}`
                })]
              });
            });
            var MainWindow_Time = Time;
            function Volume_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function Volume_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  Volume_ownKeys(Object(source), true).forEach(function(key) {
                    defineProperty_default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  Volume_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function Volume({
              id,
              style,
              className
            }) {
              const volume = useTypedSelector(getVolume);
              const setFocus = useActionCreator(actionCreators_setFocus);
              const unsetFocus = useActionCreator(actionCreators_unsetFocus);
              const setVolume = useActionCreator(media_setVolume);
              return Object(jsx_runtime["jsx"])("input", {
                id,
                type: "range",
                min: "0",
                max: "100",
                step: "1",
                value: volume,
                style: Volume_objectSpread(Volume_objectSpread({}, style), {}, {
                  touchAction: "none"
                }),
                className,
                onChange: (e) => setVolume(Number(e.target.value)),
                onMouseDown: () => setFocus("volume"),
                onTouchStart: () => {
                  setFocus("volume");
                },
                onMouseUp: unsetFocus,
                onTouchEnd: unsetFocus,
                title: "Volume Bar"
              });
            }
            const MainVolume = Object(react["memo"])(() => {
              const volume = useTypedSelector(getVolume);
              const percent = volume / 100;
              const sprite = Math.round(percent * 28);
              const offset = (sprite - 1) * 15;
              const style = {
                backgroundPosition: `0 -${offset}px`
              };
              return Object(jsx_runtime["jsx"])("div", {
                id: "volume",
                style,
                children: Object(jsx_runtime["jsx"])(Volume, {})
              });
            });
            var MainWindow_MainVolume = MainVolume;
            var main_window = __webpack_require__2(90);
            function loadMediaAndPlay(e) {
              return files_loadMedia(e, LOAD_STYLE.PLAY);
            }
            const MainWindow = react["memo"](({
              analyser,
              filePickers
            }) => {
              const mainShade = useTypedSelector(selectors_getWindowShade)("main");
              const status = useTypedSelector(getMediaStatus);
              const focused = useTypedSelector(getFocusedWindow);
              const loading = useTypedSelector(getLoading);
              const doubled = useTypedSelector(getDoubled);
              const llama = useTypedSelector(getLlamaMode);
              const working = useTypedSelector(getWorking);
              const className = classnames_default()({
                window: true,
                play: status === MEDIA_STATUS.PLAYING,
                stop: status === MEDIA_STATUS.STOPPED,
                pause: status === MEDIA_STATUS.PAUSED,
                selected: focused === WINDOWS.MAIN,
                shade: mainShade,
                draggable: true,
                loading,
                doubled,
                llama
              });
              const toggleMainWindowShadeMode = useActionCreator(windows_toggleMainWindowShadeMode);
              const scrollVolume = useActionCreator(media_scrollVolume);
              const loadMedia = useActionCreator(loadMediaAndPlay);
              return Object(jsx_runtime["jsx"])(components_DropTarget, {
                id: "main-window",
                windowId: WINDOWS.MAIN,
                className,
                handleDrop: loadMedia,
                onWheel: scrollVolume,
                children: Object(jsx_runtime["jsxs"])(components_FocusTarget, {
                  windowId: WINDOWS.MAIN,
                  children: [Object(jsx_runtime["jsxs"])("div", {
                    id: "title-bar",
                    className: "selected draggable",
                    onDoubleClick: toggleMainWindowShadeMode,
                    children: [Object(jsx_runtime["jsx"])(components_ContextMenuTarget, {
                      id: "option-context",
                      bottom: true,
                      renderMenu: () => Object(jsx_runtime["jsx"])(MainWindow_MainContextMenu, {
                        filePickers
                      }),
                      children: Object(jsx_runtime["jsx"])(components_ClickedDiv, {
                        id: "option",
                        title: "Winamp Menu"
                      })
                    }), mainShade && Object(jsx_runtime["jsx"])(components_MiniTime, {}), Object(jsx_runtime["jsx"])(MainWindow_Minimize, {}), Object(jsx_runtime["jsx"])(MainWindow_Shade, {}), Object(jsx_runtime["jsx"])(MainWindow_Close, {})]
                  }), Object(jsx_runtime["jsxs"])("div", {
                    className: "webamp-status",
                    children: [Object(jsx_runtime["jsx"])(MainWindow_ClutterBar, {}), !working && Object(jsx_runtime["jsx"])("div", {
                      id: "play-pause"
                    }), Object(jsx_runtime["jsx"])("div", {
                      id: "work-indicator",
                      className: classnames_default()({
                        selected: working
                      })
                    }), Object(jsx_runtime["jsx"])(MainWindow_Time, {})]
                  }), Object(jsx_runtime["jsx"])(
                    components_Visualizer,
                    {
                      analyser
                    }
                  ), Object(jsx_runtime["jsxs"])("div", {
                    className: "media-info",
                    children: [Object(jsx_runtime["jsx"])(MainWindow_Marquee, {}), Object(jsx_runtime["jsx"])(MainWindow_Kbps, {}), Object(jsx_runtime["jsx"])(MainWindow_Khz, {}), Object(jsx_runtime["jsx"])(MainWindow_MonoStereo, {})]
                  }), Object(jsx_runtime["jsx"])(MainWindow_MainVolume, {}), Object(jsx_runtime["jsx"])(MainWindow_MainBalance, {}), Object(jsx_runtime["jsxs"])("div", {
                    className: "windows",
                    children: [Object(jsx_runtime["jsx"])(MainWindow_EqToggleButton, {}), Object(jsx_runtime["jsx"])(MainWindow_PlaylistToggleButton, {})]
                  }), Object(jsx_runtime["jsx"])(MainWindow_Position, {}), Object(jsx_runtime["jsx"])(MainWindow_ActionButtons, {}), Object(jsx_runtime["jsx"])(MainWindow_Eject, {}), Object(jsx_runtime["jsxs"])("div", {
                    className: "shuffle-repeat",
                    children: [Object(jsx_runtime["jsx"])(MainWindow_Shuffle, {}), Object(jsx_runtime["jsx"])(MainWindow_Repeat, {})]
                  }), Object(jsx_runtime["jsx"])("a", {
                    id: "about",
                    target: "_blank",
                    href: "https://webamp.org/about",
                    title: "About"
                  })]
                })
              });
            });
            var components_MainWindow = MainWindow;
            function PlaylistResizeTarget({
              widthOnly
            }) {
              const windowSize = useTypedSelector(selectors_getWindowSize);
              const setWindowSize = useActionCreator(windows_setWindowSize);
              const currentSize = windowSize("playlist");
              return Object(jsx_runtime["jsx"])(components_ResizeTarget, {
                currentSize,
                id: "playlist-resize-target",
                setWindowSize: (size) => {
                  setWindowSize("playlist", size);
                },
                widthOnly
              });
            }
            var PlaylistWindow_PlaylistResizeTarget = PlaylistResizeTarget;
            function PlaylistShade() {
              const focused = useTypedSelector(getFocusedWindow);
              const getWindowSize = useTypedSelector(selectors_getWindowSize);
              const playlistSize = getWindowSize("playlist");
              const duration = useTypedSelector(getDuration);
              const name = useTypedSelector(getMinimalMediaText);
              const closeWindow = useActionCreator(windows_closeWindow);
              const toggleShade = useActionCreator(togglePlaylistShadeMode);
              const focusWindow = useActionCreator(windows_setFocusedWindow);
              const addedWidth = playlistSize[0] * WINDOW_RESIZE_SEGMENT_WIDTH;
              const trimmedName = Object(react["useMemo"])(() => {
                if (name == null) {
                  return "[No file]";
                }
                const MIN_NAME_WIDTH = 205;
                const nameLength = (MIN_NAME_WIDTH + addedWidth) / CHARACTER_WIDTH;
                return name.length > nameLength ? name.slice(0, nameLength - 1) + UTF8_ELLIPSIS : name;
              }, [addedWidth, name]);
              const time = Object(react["useMemo"])(() => {
                return name == null ? "" : getTimeStr(duration);
              }, [duration, name]);
              return Object(jsx_runtime["jsx"])("div", {
                id: "playlist-window-shade",
                className: classnames_default()("window", "draggable", {
                  selected: focused === WINDOWS.PLAYLIST
                }),
                style: {
                  width: `${WINDOW_WIDTH + addedWidth}px`
                },
                onMouseDown: () => focusWindow("playlist"),
                onDoubleClick: toggleShade,
                children: Object(jsx_runtime["jsx"])("div", {
                  className: "left",
                  children: Object(jsx_runtime["jsxs"])("div", {
                    className: "right draggable",
                    children: [Object(jsx_runtime["jsx"])("div", {
                      id: "playlist-shade-track-title",
                      children: Object(jsx_runtime["jsx"])(components_CharacterString, {
                        children: trimmedName
                      })
                    }), Object(jsx_runtime["jsx"])("div", {
                      id: "playlist-shade-time",
                      children: Object(jsx_runtime["jsx"])(components_CharacterString, {
                        children: time
                      })
                    }), Object(jsx_runtime["jsx"])(PlaylistWindow_PlaylistResizeTarget, {
                      widthOnly: true
                    }), Object(jsx_runtime["jsx"])("div", {
                      id: "playlist-shade-button",
                      onClick: toggleShade
                    }), Object(jsx_runtime["jsx"])("div", {
                      id: "playlist-close-button",
                      onClick: () => closeWindow("playlist")
                    })]
                  })
                })
              });
            }
            var PlaylistWindow_PlaylistShade = PlaylistShade;
            function PlaylistMenuEntry({
              children
            }) {
              const {
                ref,
                hover
              } = useIsHovered();
              return Object(jsx_runtime["jsx"])("li", {
                ref,
                className: classnames_default()({
                  hover
                }),
                children
              });
            }
            var PlaylistWindow_PlaylistMenuEntry = Object(react["memo"])(PlaylistMenuEntry);
            function PlaylistMenu(props) {
              const [selected, setSelected] = Object(react["useState"])(false);
              const [ref, setRef] = Object(react["useState"])(null);
              const callback = Object(react["useCallback"])(() => {
                setTimeout(() => {
                  setSelected(false);
                }, 0);
              }, []);
              useOnClickAway(ref, selected ? callback : null);
              return Object(jsx_runtime["jsxs"])("div", {
                id: props.id,
                className: classnames_default()("playlist-menu", {
                  selected
                }),
                ref: setRef,
                onClick: () => setSelected((selected_) => !selected_),
                children: [Object(jsx_runtime["jsx"])("div", {
                  className: "bar"
                }), selected && Object(jsx_runtime["jsx"])("ul", {
                  children: react["Children"].map(props.children, (child, i) => Object(jsx_runtime["jsx"])(PlaylistWindow_PlaylistMenuEntry, {
                    children: child
                  }, i))
                })]
              });
            }
            var PlaylistWindow_PlaylistMenu = Object(react["memo"])(PlaylistMenu);
            const AddMenu = () => {
              const nextIndex = useTypedSelector(getTrackCount);
              const addDirAtIndex = useActionCreator(files_addDirAtIndex);
              const addFilesAtIndex = useActionCreator(files_addFilesAtIndex);
              const addFilesFromUrl = useActionCreator(files_addFilesFromUrl);
              return Object(jsx_runtime["jsxs"])(PlaylistWindow_PlaylistMenu, {
                id: "playlist-add-menu",
                children: [Object(jsx_runtime["jsx"])("div", {
                  className: "add-url",
                  onClick: () => addFilesFromUrl(nextIndex)
                }), Object(jsx_runtime["jsx"])("div", {
                  className: "add-dir",
                  onClick: () => addDirAtIndex(nextIndex)
                }), Object(jsx_runtime["jsx"])("div", {
                  className: "add-file",
                  onClick: () => addFilesAtIndex(nextIndex)
                })]
              });
            };
            var PlaylistWindow_AddMenu = AddMenu;
            const RemoveMenu = () => {
              const removeSelected = useActionCreator(removeSelectedTracks);
              const removeAll = useActionCreator(playlist_removeAllTracks);
              const crop = useActionCreator(cropPlaylist);
              return Object(jsx_runtime["jsxs"])(PlaylistWindow_PlaylistMenu, {
                id: "playlist-remove-menu",
                children: [Object(jsx_runtime["jsx"])("div", {
                  className: "remove-misc",
                  onClick: () => alert("Not supported in Webamp")
                }), Object(jsx_runtime["jsx"])("div", {
                  className: "remove-all",
                  onClick: removeAll
                }), Object(jsx_runtime["jsx"])("div", {
                  className: "crop",
                  onClick: crop
                }), Object(jsx_runtime["jsx"])("div", {
                  className: "remove-selected",
                  onClick: removeSelected
                })]
              });
            };
            var PlaylistWindow_RemoveMenu = RemoveMenu;
            function SelectionMenu() {
              const invert = useActionCreator(invertSelection);
              const zero = useActionCreator(playlist_selectZero);
              const all = useActionCreator(selectAll);
              return Object(jsx_runtime["jsxs"])(PlaylistWindow_PlaylistMenu, {
                id: "playlist-selection-menu",
                children: [Object(jsx_runtime["jsx"])("div", {
                  className: "invert-selection",
                  onClick: invert
                }), Object(jsx_runtime["jsx"])("div", {
                  className: "select-zero",
                  onClick: zero
                }), Object(jsx_runtime["jsx"])("div", {
                  className: "select-all",
                  onClick: all
                })]
              });
            }
            function SortContextMenu() {
              const reverseList = useActionCreator(playlist_reverseList);
              const randomizeList = useActionCreator(playlist_randomizeList);
              const sortListByTitle = useActionCreator(playlist_sortListByTitle);
              return Object(jsx_runtime["jsx"])(components_ContextMenuTarget, {
                style: {
                  width: "100%",
                  height: "100%"
                },
                top: true,
                renderMenu: () => Object(jsx_runtime["jsxs"])(jsx_runtime["Fragment"], {
                  children: [Object(jsx_runtime["jsx"])(Node, {
                    label: "Sort list by title",
                    onClick: sortListByTitle
                  }), Object(jsx_runtime["jsx"])(ContextMenu_Hr, {}), Object(jsx_runtime["jsx"])(Node, {
                    label: "Reverse list",
                    onClick: reverseList
                  }), Object(jsx_runtime["jsx"])(Node, {
                    label: "Randomize list",
                    onClick: randomizeList
                  })]
                }),
                children: Object(jsx_runtime["jsx"])("div", {})
              });
            }
            const MiscOptionsContextMenu = () => {
              const downloadHtmlPlaylist = useActionCreator(files_downloadHtmlPlaylist);
              return Object(jsx_runtime["jsx"])(components_ContextMenuTarget, {
                style: {
                  width: "100%",
                  height: "100%"
                },
                top: true,
                renderMenu: () => Object(jsx_runtime["jsx"])(Node, {
                  onClick: downloadHtmlPlaylist,
                  label: "Generate HTML playlist"
                }),
                children: Object(jsx_runtime["jsx"])("div", {})
              });
            };
            var PlaylistWindow_MiscOptionsContextMenu = MiscOptionsContextMenu;
            const MiscMenu = () => Object(jsx_runtime["jsxs"])(PlaylistWindow_PlaylistMenu, {
              id: "playlist-misc-menu",
              children: [Object(jsx_runtime["jsx"])("div", {
                className: "sort-list",
                onClick: (e) => e.stopPropagation(),
                children: Object(jsx_runtime["jsx"])(SortContextMenu, {})
              }), Object(jsx_runtime["jsx"])("div", {
                className: "file-info",
                onClick: () => alert("Not supported in Webamp")
              }), Object(jsx_runtime["jsx"])("div", {
                className: "misc-options",
                onClick: (e) => e.stopPropagation(),
                children: Object(jsx_runtime["jsx"])(PlaylistWindow_MiscOptionsContextMenu, {})
              })]
            });
            var PlaylistWindow_MiscMenu = MiscMenu;
            function ListMenu() {
              const removeAllTracks = useActionCreator(playlist_removeAllTracks);
              const addFilesFromList = useActionCreator(files_addFilesFromList);
              const saveFilesToList = useActionCreator(files_saveFilesToList);
              return Object(jsx_runtime["jsxs"])(PlaylistWindow_PlaylistMenu, {
                id: "playlist-list-menu",
                children: [Object(jsx_runtime["jsx"])("div", {
                  className: "new-list",
                  onClick: removeAllTracks
                }), Object(jsx_runtime["jsx"])("div", {
                  className: "save-list",
                  onClick: saveFilesToList
                }), Object(jsx_runtime["jsx"])("div", {
                  className: "load-list",
                  onClick: addFilesFromList
                })]
              });
            }
            function rightPad(str, len, fillChar) {
              while (str.length < len) {
                str += fillChar;
              }
              return str;
            }
            const RunningTimeDisplay = () => {
              const runningTimeMessage = useTypedSelector(getRunningTimeMessage);
              const text = Object(react["useMemo"])(() => rightPad(runningTimeMessage, 18, " "), [runningTimeMessage]);
              return Object(jsx_runtime["jsx"])("div", {
                className: "playlist-running-time-display draggable",
                children: Object(jsx_runtime["jsx"])("div", {
                  children: Object(jsx_runtime["jsx"])(components_CharacterString, {
                    children: text
                  })
                })
              });
            };
            var PlaylistWindow_RunningTimeDisplay = RunningTimeDisplay;
            const PlaylistWindow = () => {
              const play = useActionCreator(media_play);
              const pause = useActionCreator(media_pause);
              const stop = useActionCreator(media_stop);
              const openMediaFileDialog = useActionCreator(files_openMediaFileDialog);
              const next = useActionCreator(media_next);
              const previous = useActionCreator(media_previous);
              return Object(jsx_runtime["jsxs"])(react["Fragment"], {
                children: [Object(jsx_runtime["jsx"])(PlaylistWindow_RunningTimeDisplay, {}), Object(jsx_runtime["jsxs"])("div", {
                  className: "playlist-action-buttons",
                  children: [Object(jsx_runtime["jsx"])("div", {
                    className: "playlist-previous-button",
                    onClick: previous
                  }), Object(jsx_runtime["jsx"])("div", {
                    className: "playlist-play-button",
                    onClick: play
                  }), Object(jsx_runtime["jsx"])("div", {
                    className: "playlist-pause-button",
                    onClick: pause
                  }), Object(jsx_runtime["jsx"])("div", {
                    className: "playlist-stop-button",
                    onClick: stop
                  }), Object(jsx_runtime["jsx"])("div", {
                    className: "playlist-next-button",
                    onClick: next
                  }), Object(jsx_runtime["jsx"])("div", {
                    className: "playlist-eject-button",
                    onClick: openMediaFileDialog
                  })]
                }), Object(jsx_runtime["jsx"])(components_MiniTime, {})]
              });
            };
            var PlaylistActionArea = PlaylistWindow;
            function TrackCell({
              children,
              handleMoveClick,
              index,
              id
            }) {
              const skinPlaylistStyle = useTypedSelector(getSkinPlaylistStyle);
              const selectedTrackIds = useTypedSelector(getSelectedTrackIds);
              const currentTrackId = useTypedSelector(getCurrentTrackId);
              const selected = selectedTrackIds.has(id);
              const current = currentTrackId === id;
              const dispatch = useTypedDispatch();
              const playTrackNow = useActionCreator(media_playTrackNow);
              const onMouseDown = Object(react["useCallback"])((e) => {
                if (e.shiftKey) {
                  e.preventDefault();
                  dispatch({
                    type: SHIFT_CLICKED_TRACK,
                    index
                  });
                  return;
                } else if (e.metaKey || e.ctrlKey) {
                  e.preventDefault();
                  dispatch({
                    type: CTRL_CLICKED_TRACK,
                    index
                  });
                  return;
                }
                if (!selected) {
                  dispatch({
                    type: CLICKED_TRACK,
                    index
                  });
                }
                handleMoveClick(e);
              }, [dispatch, handleMoveClick, index, selected]);
              const handleTouchStart = Object(react["useCallback"])((e) => {
                if (!selected) {
                  dispatch({
                    type: CLICKED_TRACK,
                    index
                  });
                }
                handleMoveClick(e);
                function handleSecondTap() {
                  playTrackNow(id);
                }
                e.target.addEventListener("touchstart", handleSecondTap);
                setTimeout(() => {
                  e.target.removeEventListener("touchstart", handleSecondTap);
                }, 250);
              }, [dispatch, handleMoveClick, id, index, playTrackNow, selected]);
              const style = {
                backgroundColor: selected ? skinPlaylistStyle.selectedbg : void 0,
                color: current ? skinPlaylistStyle.current : void 0
              };
              return Object(jsx_runtime["jsx"])("div", {
                className: classnames_default()("track-cell", {
                  selected,
                  current
                }),
                style,
                onClick: (e) => e.stopPropagation(),
                onMouseDown,
                onTouchStart: handleTouchStart,
                onContextMenu: (e) => e.preventDefault(),
                onDoubleClick: () => playTrackNow(id),
                children
              });
            }
            var PlaylistWindow_TrackCell = TrackCell;
            const TrackTitle = ({
              id,
              paddedTrackNumber
            }) => {
              const title = useTypedSelector(selectors_getTrackDisplayName)(id);
              return Object(jsx_runtime["jsxs"])("span", {
                children: [paddedTrackNumber, ". ", title]
              });
            };
            var PlaylistWindow_TrackTitle = TrackTitle;
            function getNumberLength(number) {
              return number.toString().length;
            }
            function TrackList() {
              const offset = useTypedSelector(getScrollOffset);
              const trackIds = useTypedSelector(getVisibleTrackIds);
              const tracks = useTypedSelector(getTracks);
              const numberOfTracks = useTypedSelector(getNumberOfTracks);
              const selectZero = useActionCreator(playlist_selectZero);
              const dragSelected = useActionCreator(playlist_dragSelected);
              const scrollPlaylistByDelta = useActionCreator(playlist_scrollPlaylistByDelta);
              const [node, setNode] = Object(react["useState"])(null);
              const [moving, setMoving] = Object(react["useState"])(false);
              const [mouseStartY, setMouseStartY] = Object(react["useState"])(null);
              const _handleMoveClick = (e) => {
                setMoving(true);
                setMouseStartY(getY(e));
              };
              Object(react["useEffect"])(() => {
                if (node == null || mouseStartY == null || moving === false) {
                  return;
                }
                const {
                  top,
                  bottom,
                  left,
                  right
                } = node.getBoundingClientRect();
                let lastDiff = 0;
                const handleMouseMove = (ee) => {
                  const x = getX(ee);
                  const y = getY(ee);
                  if (y < top || y > bottom || x < left || x > right) {
                    return;
                  }
                  const proposedDiff = Math.floor((y - mouseStartY) / TRACK_HEIGHT);
                  if (proposedDiff !== lastDiff) {
                    const diffDiff = proposedDiff - lastDiff;
                    dragSelected(diffDiff);
                    lastDiff = proposedDiff;
                  }
                };
                const handleMouseUp = () => setMoving(false);
                window.addEventListener("mouseup", handleMouseUp);
                window.addEventListener("mousemove", handleMouseMove);
                window.addEventListener("touchend", handleMouseUp);
                window.addEventListener("touchmove", handleMouseMove);
                return () => {
                  window.removeEventListener("mousemove", handleMouseMove);
                  window.removeEventListener("touchmove", handleMouseMove);
                  window.removeEventListener("mouseup", handleMouseUp);
                  window.removeEventListener("touchend", handleMouseUp);
                };
              }, [moving]);
              function _renderTracks(format) {
                return trackIds.map((id, i) => Object(jsx_runtime["jsx"])(PlaylistWindow_TrackCell, {
                  id,
                  index: offset + i,
                  handleMoveClick: _handleMoveClick,
                  children: format(id, i)
                }, id));
              }
              const maxTrackNumberLength = getNumberLength(numberOfTracks);
              const paddedTrackNumForIndex = (i) => (i + 1 + offset).toString().padStart(maxTrackNumberLength, " ");
              Object(react["useEffect"])(() => {
                if (node == null) {
                  return;
                }
                node.addEventListener("wheel", scrollPlaylistByDelta, {
                  passive: false
                });
                return () => {
                  node.removeEventListener("wheel", scrollPlaylistByDelta);
                };
              }, [node, scrollPlaylistByDelta]);
              return Object(jsx_runtime["jsxs"])("div", {
                ref: setNode,
                className: "playlist-tracks",
                style: {
                  height: "100%",
                  userSelect: "none"
                },
                onClick: selectZero,
                children: [Object(jsx_runtime["jsx"])("div", {
                  className: "playlist-track-titles",
                  children: _renderTracks((id, i) => Object(jsx_runtime["jsx"])(PlaylistWindow_TrackTitle, {
                    id,
                    paddedTrackNumber: paddedTrackNumForIndex(i)
                  }))
                }), Object(jsx_runtime["jsx"])("div", {
                  className: "playlist-track-durations",
                  children: _renderTracks((id) => getTimeStr(tracks[id].duration))
                })]
              });
            }
            var PlaylistWindow_TrackList = TrackList;
            function VerticalSlider({
              value,
              height,
              width,
              handle,
              handleHeight,
              onBeforeChange,
              onChange,
              onAfterChange,
              disabled
            }) {
              const ref = Object(react["useRef"])(null);
              const handleRef = Object(react["useRef"])(null);
              function registerMoveListener({
                target,
                clientY,
                touch
              }) {
                const sliderNode = ref.current;
                const handleNode = handleRef.current;
                if (sliderNode == null || handleNode == null) {
                  return null;
                }
                const sliderRect = sliderNode.getBoundingClientRect();
                const handleRect = handleNode.getBoundingClientRect();
                const {
                  top: sliderTop,
                  height: sliderHeight
                } = sliderRect;
                const {
                  top: handleTop,
                  height: realHandleHeight
                } = handleRect;
                const handleOffset = handleNode.contains(target) ? clientY - handleTop : realHandleHeight / 2;
                const baseOffset = sliderTop + handleOffset;
                const spanSize = sliderHeight - realHandleHeight;
                function moveToPosition(y) {
                  const startOffset = y - baseOffset;
                  onChange(clamp(startOffset / spanSize, 0, 1));
                }
                if (touch) {
                  const handleTouchMove = (event) => {
                    if (event.cancelable) {
                      event.preventDefault();
                    }
                    moveToPosition(event.touches[0].clientY);
                  };
                  const handleTouchEnd = () => {
                    if (onAfterChange != null) {
                      onAfterChange();
                    }
                    document.removeEventListener("touchmove", handleTouchMove);
                    document.removeEventListener("touchend", handleTouchEnd);
                  };
                  document.addEventListener("touchmove", handleTouchMove, {
                    passive: false
                  });
                  document.addEventListener("touchend", handleTouchEnd);
                } else {
                  const handleMouseMove = (event) => {
                    event.preventDefault();
                    moveToPosition(event.clientY);
                  };
                  const handleMouseUp = () => {
                    if (onAfterChange != null) {
                      onAfterChange();
                    }
                    document.removeEventListener("mousemove", handleMouseMove);
                    document.removeEventListener("mouseup", handleMouseUp);
                  };
                  document.addEventListener("mousemove", handleMouseMove);
                  document.addEventListener("mouseup", handleMouseUp);
                }
                if (onBeforeChange != null) {
                  onBeforeChange();
                }
                moveToPosition(clientY);
              }
              function handleMouseDown(e) {
                e.preventDefault();
                registerMoveListener({
                  target: e.target,
                  clientY: e.clientY,
                  touch: false
                });
              }
              function handleTouchStart(e) {
                registerMoveListener({
                  target: e.target,
                  clientY: e.touches[0].clientY,
                  touch: true
                });
              }
              const offset = Math.floor((height - handleHeight) * value);
              return Object(jsx_runtime["jsx"])("div", {
                style: {
                  height,
                  width
                },
                onMouseDown: disabled ? void 0 : handleMouseDown,
                onTouchStart: disabled ? void 0 : handleTouchStart,
                ref,
                children: Object(jsx_runtime["jsx"])("div", {
                  style: {
                    transform: `translateY(${offset}px)`
                  },
                  ref: handleRef,
                  children: handle
                })
              });
            }
            const HANDLE_HEIGHT = 18;
            const Handle = () => Object(jsx_runtime["jsx"])("div", {
              className: "playlist-scrollbar-handle",
              style: {
                height: HANDLE_HEIGHT
              }
            });
            function PlaylistScrollBar() {
              const getWindowPixelSize = useTypedSelector(selectors_getWindowPixelSize);
              const playlistHeight = getWindowPixelSize(WINDOWS.PLAYLIST).height;
              const playlistScrollPosition = useTypedSelector(getPlaylistScrollPosition);
              const allTracksAreVisible = useTypedSelector(getAllTracksAreVisible);
              const setPlaylistScrollPosition = useActionCreator(playlist_setPlaylistScrollPosition);
              return Object(jsx_runtime["jsx"])("div", {
                className: "playlist-scrollbar",
                style: {
                  marginLeft: 5
                },
                children: Object(jsx_runtime["jsx"])(VerticalSlider, {
                  height: playlistHeight - 58,
                  handleHeight: HANDLE_HEIGHT,
                  width: 8,
                  value: playlistScrollPosition / 100,
                  onChange: (val) => setPlaylistScrollPosition(val * 100),
                  handle: Object(jsx_runtime["jsx"])(Handle, {}),
                  disabled: allTracksAreVisible
                })
              });
            }
            var playlist_window = __webpack_require__2(92);
            function _maxTrackIndex(state) {
              return state.playlist.trackOrder.length - 1;
            }
            function PlaylistWindow_PlaylistWindow({
              analyser
            }) {
              const offset = useTypedSelector(getScrollOffset);
              const getWindowSize = useTypedSelector(selectors_getWindowSize);
              const selectedWindow = useTypedSelector(getFocusedWindow);
              const getWindowShade = useTypedSelector(selectors_getWindowShade);
              const getWindowOpen = useTypedSelector(selectors_getWindowOpen);
              const maxTrackIndex = useTypedSelector(_maxTrackIndex);
              const skinPlaylistStyle = useTypedSelector(getSkinPlaylistStyle);
              const getWindowPixelSize = useTypedSelector(selectors_getWindowPixelSize);
              const selected = selectedWindow === WINDOWS.PLAYLIST;
              const playlistShade = Boolean(getWindowShade(WINDOWS.PLAYLIST));
              const playlistSize = getWindowSize(WINDOWS.PLAYLIST);
              const playlistWindowPixelSize = getWindowPixelSize(WINDOWS.PLAYLIST);
              const close = useActionCreator(windows_closeWindow);
              const toggleShade = useActionCreator(togglePlaylistShadeMode);
              const scrollUpFourTracks = useActionCreator(playlist_scrollUpFourTracks);
              const scrollDownFourTracks = useActionCreator(playlist_scrollDownFourTracks);
              const scrollVolume = useActionCreator(media_scrollVolume);
              const loadMedia = useActionCreator(files_loadMedia);
              const showVisualizer = playlistSize[0] > 2;
              const activateVisualizer = !getWindowOpen(WINDOWS.MAIN);
              const handleDrop = Object(react["useCallback"])((e, targetCoords) => {
                const top = e.clientY - targetCoords.y;
                const atIndex = clamp(offset + Math.round((top - 23) / TRACK_HEIGHT), 0, maxTrackIndex + 1);
                loadMedia(e, LOAD_STYLE.NONE, atIndex);
              }, [loadMedia, maxTrackIndex, offset]);
              if (playlistShade) {
                return Object(jsx_runtime["jsx"])(PlaylistWindow_PlaylistShade, {});
              }
              const style = {
                color: skinPlaylistStyle.normal,
                backgroundColor: skinPlaylistStyle.normalbg,
                fontFamily: `${skinPlaylistStyle.font}, Arial, sans-serif`,
                height: `${playlistWindowPixelSize.height}px`,
                width: `${playlistWindowPixelSize.width}px`
              };
              const classes = classnames_default()("window", "draggable", {
                selected
              });
              const showSpacers = playlistSize[0] % 2 === 0;
              return Object(jsx_runtime["jsx"])(components_FocusTarget, {
                windowId: WINDOWS.PLAYLIST,
                children: Object(jsx_runtime["jsxs"])(components_DropTarget, {
                  id: "playlist-window",
                  windowId: WINDOWS.PLAYLIST,
                  className: classes,
                  style,
                  handleDrop,
                  onWheel: scrollVolume,
                  children: [Object(jsx_runtime["jsxs"])("div", {
                    className: "playlist-top draggable",
                    onDoubleClick: toggleShade,
                    children: [Object(jsx_runtime["jsx"])("div", {
                      className: "playlist-top-left draggable"
                    }), showSpacers && Object(jsx_runtime["jsx"])("div", {
                      className: "playlist-top-left-spacer draggable"
                    }), Object(jsx_runtime["jsx"])("div", {
                      className: "playlist-top-left-fill draggable"
                    }), Object(jsx_runtime["jsx"])("div", {
                      className: "playlist-top-title draggable"
                    }), showSpacers && Object(jsx_runtime["jsx"])("div", {
                      className: "playlist-top-right-spacer draggable"
                    }), Object(jsx_runtime["jsx"])("div", {
                      className: "playlist-top-right-fill draggable"
                    }), Object(jsx_runtime["jsxs"])("div", {
                      className: "playlist-top-right draggable",
                      children: [Object(jsx_runtime["jsx"])("div", {
                        id: "playlist-shade-button",
                        onClick: toggleShade
                      }), Object(jsx_runtime["jsx"])("div", {
                        id: "playlist-close-button",
                        onClick: () => close(WINDOWS.PLAYLIST)
                      })]
                    })]
                  }), Object(jsx_runtime["jsxs"])("div", {
                    className: "playlist-middle draggable",
                    children: [Object(jsx_runtime["jsx"])("div", {
                      className: "playlist-middle-left draggable"
                    }), Object(jsx_runtime["jsx"])("div", {
                      className: "playlist-middle-center",
                      children: Object(jsx_runtime["jsx"])(PlaylistWindow_TrackList, {})
                    }), Object(jsx_runtime["jsx"])("div", {
                      className: "playlist-middle-right draggable",
                      children: Object(jsx_runtime["jsx"])(PlaylistScrollBar, {})
                    })]
                  }), Object(jsx_runtime["jsxs"])("div", {
                    className: "playlist-bottom draggable",
                    children: [Object(jsx_runtime["jsxs"])("div", {
                      className: "playlist-bottom-left draggable",
                      children: [Object(jsx_runtime["jsx"])(PlaylistWindow_AddMenu, {}), Object(jsx_runtime["jsx"])(PlaylistWindow_RemoveMenu, {}), Object(jsx_runtime["jsx"])(SelectionMenu, {}), Object(jsx_runtime["jsx"])(PlaylistWindow_MiscMenu, {})]
                    }), Object(jsx_runtime["jsx"])("div", {
                      className: "playlist-bottom-center draggable"
                    }), Object(jsx_runtime["jsxs"])("div", {
                      className: "playlist-bottom-right draggable",
                      children: [showVisualizer && Object(jsx_runtime["jsx"])("div", {
                        className: "playlist-visualizer",
                        children: activateVisualizer && Object(jsx_runtime["jsx"])("div", {
                          className: "visualizer-wrapper",
                          children: Object(jsx_runtime["jsx"])(
                            components_Visualizer,
                            {
                              analyser
                            }
                          )
                        })
                      }), Object(jsx_runtime["jsx"])(PlaylistActionArea, {}), Object(jsx_runtime["jsx"])(ListMenu, {}), Object(jsx_runtime["jsx"])("div", {
                        id: "playlist-scroll-up-button",
                        onClick: scrollUpFourTracks
                      }), Object(jsx_runtime["jsx"])("div", {
                        id: "playlist-scroll-down-button",
                        onClick: scrollDownFourTracks
                      }), Object(jsx_runtime["jsx"])(PlaylistWindow_PlaylistResizeTarget, {})]
                    })]
                  })]
                })
              });
            }
            var components_PlaylistWindow = PlaylistWindow_PlaylistWindow;
            const MAX_VALUE = 100;
            const spriteNumber = (value) => {
              const percent = value / MAX_VALUE;
              return Math.round(percent * 27);
            };
            const spriteOffsets = (number) => {
              const x = number % 14;
              const y = Math.floor(number / 14);
              return {
                x,
                y
              };
            };
            const Band_Handle = () => {
              const style = {
                width: 11,
                height: 11,
                marginLeft: 1
              };
              return Object(jsx_runtime["jsx"])("div", {
                style,
                className: "slider-handle"
              });
            };
            function Band({
              id,
              onChange,
              band
            }) {
              const sliders = useTypedSelector(getSliders);
              const value = sliders[band];
              const backgroundPosition = Object(react["useMemo"])(() => {
                const {
                  x,
                  y
                } = spriteOffsets(spriteNumber(value));
                const xOffset = x * 15;
                const yOffset = y * 65;
                return `-${xOffset}px -${yOffset}px`;
              }, [value]);
              const focusBand = useActionCreator(actionCreators_focusBand);
              const usetFocus = useActionCreator(actionCreators_unsetFocus);
              return Object(jsx_runtime["jsx"])("div", {
                id,
                className: "band",
                style: {
                  backgroundPosition,
                  height: 63
                },
                children: Object(jsx_runtime["jsx"])(VerticalSlider, {
                  height: 62,
                  width: 14,
                  handleHeight: 11,
                  value: 1 - value / MAX_VALUE,
                  onBeforeChange: () => focusBand(band),
                  onChange: (val) => onChange((1 - val) * MAX_VALUE),
                  onAfterChange: usetFocus,
                  handle: Object(jsx_runtime["jsx"])(Band_Handle, {})
                })
              });
            }
            const EqOn = () => {
              const toggleEq = useActionCreator(equalizer_toggleEq);
              const on = useTypedSelector(getEqualizerEnabled);
              return Object(jsx_runtime["jsx"])("div", {
                id: "on",
                className: classnames_default()({
                  selected: on
                }),
                onClick: toggleEq
              });
            };
            var EqualizerWindow_EqOn = EqOn;
            const EqAuto = Object(react["memo"])(() => {
              const selected = useTypedSelector((state) => state.equalizer.auto);
              const toggleAuto = useActionCreator(toggleEqAuto);
              return Object(jsx_runtime["jsx"])("div", {
                id: "auto",
                className: classnames_default()({
                  selected
                }),
                onClick: toggleAuto
              });
            });
            var EqualizerWindow_EqAuto = EqAuto;
            function spline(xs, ys) {
              const ks = getNaturalKs(xs, ys);
              const maxX = xs[xs.length - 1];
              const allYs = [];
              let i = 1;
              for (let x = 0; x <= maxX; x++) {
                while (xs[i] < x) i++;
                const t = (x - xs[i - 1]) / (xs[i] - xs[i - 1]);
                const a = ks[i - 1] * (xs[i] - xs[i - 1]) - (ys[i] - ys[i - 1]);
                const b = -ks[i] * (xs[i] - xs[i - 1]) + (ys[i] - ys[i - 1]);
                const q = (1 - t) * ys[i - 1] + t * ys[i] + t * (1 - t) * (a * (1 - t) + b * t);
                allYs.push(q);
              }
              return allYs;
            }
            function getNaturalKs(xs, ys) {
              const ks = xs.map(() => 0);
              const n = xs.length - 1;
              const matrix = zerosMatrix(n + 1, n + 2);
              for (let i = 1; i < n; i++) {
                matrix[i][i - 1] = 1 / (xs[i] - xs[i - 1]);
                matrix[i][i] = 2 * (1 / (xs[i] - xs[i - 1]) + 1 / (xs[i + 1] - xs[i]));
                matrix[i][i + 1] = 1 / (xs[i + 1] - xs[i]);
                matrix[i][n + 1] = 3 * ((ys[i] - ys[i - 1]) / ((xs[i] - xs[i - 1]) * (xs[i] - xs[i - 1])) + (ys[i + 1] - ys[i]) / ((xs[i + 1] - xs[i]) * (xs[i + 1] - xs[i])));
              }
              matrix[0][0] = 2 / (xs[1] - xs[0]);
              matrix[0][1] = 1 / (xs[1] - xs[0]);
              matrix[0][n + 1] = 3 * (ys[1] - ys[0]) / ((xs[1] - xs[0]) * (xs[1] - xs[0]));
              matrix[n][n - 1] = 1 / (xs[n] - xs[n - 1]);
              matrix[n][n] = 2 / (xs[n] - xs[n - 1]);
              matrix[n][n + 1] = 3 * (ys[n] - ys[n - 1]) / ((xs[n] - xs[n - 1]) * (xs[n] - xs[n - 1]));
              return solve(matrix, ks);
            }
            function solve(matrix, ks) {
              const m = matrix.length;
              for (let k = 0; k < m; k++) {
                let iMax = 0;
                let vali = Number.NEGATIVE_INFINITY;
                for (let i = k; i < m; i++) if (matrix[i][k] > vali) {
                  iMax = i;
                  vali = matrix[i][k];
                }
                swapRows(matrix, k, iMax);
                for (let i = k + 1; i < m; i++) {
                  for (let j = k + 1; j < m + 1; j++) matrix[i][j] = matrix[i][j] - matrix[k][j] * (matrix[i][k] / matrix[k][k]);
                  matrix[i][k] = 0;
                }
              }
              for (let i = m - 1; i >= 0; i--) {
                const v = matrix[i][m] / matrix[i][i];
                ks[i] = v;
                for (let j = i - 1; j >= 0; j--) {
                  matrix[j][m] -= matrix[j][i] * v;
                  matrix[j][i] = 0;
                }
              }
              return ks;
            }
            function zerosMatrix(rows, columns) {
              const matrix = [];
              for (let i = 0; i < rows; i++) {
                matrix.push([]);
                for (let j = 0; j < columns; j++) {
                  matrix[i].push(0);
                }
              }
              return matrix;
            }
            function swapRows(m, k, l) {
              const p = m[k];
              m[k] = m[l];
              m[l] = p;
            }
            const GRAPH_HEIGHT = 19;
            const GRAPH_WIDTH = 113;
            function EqGraph() {
              const sliders = useTypedSelector(getSliders);
              const preampLineImagePromise = useTypedSelector(getPreampLineImage);
              const preampLineImage = usePromiseValueOrNull(preampLineImagePromise);
              const [canvasNode, setCanvasNode] = Object(react["useState"])(null);
              const canvasCtx = Object(react["useMemo"])(() => {
                var _canvasNode$getContex;
                return (_canvasNode$getContex = canvasNode === null || canvasNode === void 0 ? void 0 : canvasNode.getContext("2d")) !== null && _canvasNode$getContex !== void 0 ? _canvasNode$getContex : null;
              }, [canvasNode]);
              const colorPattern = useColorPattern(canvasCtx);
              Object(react["useLayoutEffect"])(() => {
                if (canvasCtx == null || canvasNode == null || preampLineImage == null || colorPattern == null) {
                  return;
                }
                const width = Number(canvasNode.width);
                const height = Number(canvasNode.height);
                canvasCtx.clearRect(0, 0, width, height);
                drawEqLine({
                  colorPattern,
                  sliders,
                  canvasCtx,
                  preampLineImage
                });
              }, [canvasCtx, canvasNode, colorPattern, preampLineImage, sliders]);
              return Object(jsx_runtime["jsx"])("canvas", {
                id: "eqGraph",
                ref: setCanvasNode,
                width: GRAPH_WIDTH,
                height: GRAPH_HEIGHT
              });
            }
            function useColorPattern(canvasCtx) {
              const lineColorsImagePromise = useTypedSelector(getLineColorsImage);
              const lineColorsImage = usePromiseValueOrNull(lineColorsImagePromise);
              return Object(react["useMemo"])(() => {
                if (canvasCtx == null || lineColorsImage == null) {
                  return null;
                }
                return canvasCtx.createPattern(lineColorsImage, "repeat-x");
              }, [canvasCtx, lineColorsImage]);
            }
            function drawEqLine({
              colorPattern,
              sliders,
              canvasCtx,
              preampLineImage
            }) {
              const preampValue = percentToRange(sliders.preamp / 100, 0, GRAPH_HEIGHT - 1);
              canvasCtx.drawImage(preampLineImage, 0, preampValue, preampLineImage.width, preampLineImage.height);
              const amplitudes = BANDS.map((band) => sliders[band]);
              canvasCtx.fillStyle = colorPattern;
              const paddingLeft = 2;
              const min = 0;
              const max = GRAPH_HEIGHT - 1;
              const xs = [];
              const ys = [];
              amplitudes.forEach((value, i) => {
                const percent = (100 - value) / 100;
                xs.push(i * 12);
                ys.push(percentToRange(percent, min, max));
              });
              const allYs = spline(xs, ys);
              const maxX = xs[xs.length - 1];
              let lastY = ys[0];
              for (let x = 0; x <= maxX; x++) {
                const y = clamp(Math.round(allYs[x]), 0, GRAPH_HEIGHT - 1);
                const yTop = Math.min(y, lastY);
                const height = 1 + Math.abs(lastY - y);
                canvasCtx.fillRect(paddingLeft + x, yTop, 1, height);
                lastY = y;
              }
            }
            var EqualizerWindow_EqGraph = EqGraph;
            var builtin = __webpack_require__2(41);
            const PresetsContextMenu = () => {
              const openEqfFileDialog = useActionCreator(files_openEqfFileDialog);
              const downloadPreset = useActionCreator(files_downloadPreset);
              const setEqFromObject = useActionCreator(files_setEqFromObject);
              return Object(jsx_runtime["jsx"])(components_ContextMenuTarget, {
                top: true,
                id: "presets-context",
                renderMenu: () => Object(jsx_runtime["jsxs"])(jsx_runtime["Fragment"], {
                  children: [Object(jsx_runtime["jsxs"])(Parent, {
                    label: "Load",
                    children: [builtin.presets.map((preset) => Object(jsx_runtime["jsx"])(Node, {
                      onClick: () => setEqFromObject(preset),
                      label: preset.name
                    }, preset.name)), Object(jsx_runtime["jsx"])(ContextMenu_Hr, {}), Object(jsx_runtime["jsx"])(Node, {
                      onClick: openEqfFileDialog,
                      label: "From Eqf..."
                    })]
                  }), Object(jsx_runtime["jsx"])(Node, {
                    onClick: downloadPreset,
                    label: "Save"
                  })]
                }),
                children: Object(jsx_runtime["jsx"])("div", {
                  id: "presets"
                })
              });
            };
            var EqualizerWindow_PresetsContextMenu = PresetsContextMenu;
            function EqTitleButtons() {
              const focusedWindow = useTypedSelector(getFocusedWindow);
              const selected = focusedWindow === WINDOWS.EQUALIZER;
              const closeWindow = useActionCreator(windows_closeWindow);
              const toggleEqualizerShadeMode = useActionCreator(windows_toggleEqualizerShadeMode);
              return Object(jsx_runtime["jsxs"])(components_ClickedDiv, {
                id: "eq-buttons",
                children: [Object(jsx_runtime["jsx"])("div", {
                  id: "equalizer-shade",
                  onClick: toggleEqualizerShadeMode
                }), Object(jsx_runtime["jsx"])("div", {
                  id: "equalizer-close",
                  onClick: () => closeWindow(WINDOWS.EQUALIZER)
                })]
              }, selected ? "selected" : "unselected");
            }
            const EqualizerShade = () => {
              const volume = useTypedSelector(getVolume);
              const balance = useTypedSelector(getBalance);
              const toggleEqualizerShadeMode = useActionCreator(windows_toggleEqualizerShadeMode);
              const classes = ["left", "center", "right"];
              const eqVolumeClassName = segment(0, 100, volume, classes);
              const eqBalanceClassName = segment(-100, 100, balance, classes);
              return Object(jsx_runtime["jsxs"])("div", {
                className: "draggable",
                onDoubleClick: toggleEqualizerShadeMode,
                style: {
                  width: "100%",
                  height: "100%"
                },
                children: [Object(jsx_runtime["jsx"])(EqTitleButtons, {}), Object(jsx_runtime["jsx"])(Volume, {
                  id: "equalizer-volume",
                  className: eqVolumeClassName
                }), Object(jsx_runtime["jsx"])(Balance, {
                  id: "equalizer-balance",
                  className: eqBalanceClassName
                })]
              });
            };
            var EqualizerWindow_EqualizerShade = EqualizerShade;
            var equalizer_window = __webpack_require__2(94);
            const bandClassName = (band) => `band-${band}`;
            const EqualizerWindow = () => {
              const doubled = useTypedSelector(getDoubled);
              const focusedWindow = useTypedSelector(getFocusedWindow);
              const getWindowShade = useTypedSelector(selectors_getWindowShade);
              const selected = focusedWindow === WINDOWS.EQUALIZER;
              const shade = getWindowShade(WINDOWS.EQUALIZER);
              const setPreampValue = useActionCreator(setPreamp);
              const setEqToMin = useActionCreator(equalizer_setEqToMin);
              const setEqToMid = useActionCreator(equalizer_setEqToMid);
              const setEqToMax = useActionCreator(equalizer_setEqToMax);
              const setHertzValue = useActionCreator(setEqBand);
              const toggleEqualizerShadeMode = useActionCreator(windows_toggleEqualizerShadeMode);
              const className = classnames_default()({
                selected,
                doubled,
                shade,
                window: true,
                draggable: true
              });
              return Object(jsx_runtime["jsx"])("div", {
                id: "equalizer-window",
                className,
                children: Object(jsx_runtime["jsx"])(components_FocusTarget, {
                  windowId: WINDOWS.EQUALIZER,
                  children: shade ? Object(jsx_runtime["jsx"])(EqualizerWindow_EqualizerShade, {}) : Object(jsx_runtime["jsxs"])("div", {
                    children: [Object(jsx_runtime["jsx"])("div", {
                      className: "equalizer-top title-bar draggable",
                      onDoubleClick: toggleEqualizerShadeMode,
                      children: Object(jsx_runtime["jsx"])(EqTitleButtons, {})
                    }), Object(jsx_runtime["jsx"])(EqualizerWindow_EqOn, {}), Object(jsx_runtime["jsx"])(EqualizerWindow_EqAuto, {}), Object(jsx_runtime["jsx"])(EqualizerWindow_EqGraph, {}), Object(jsx_runtime["jsx"])(EqualizerWindow_PresetsContextMenu, {}), Object(jsx_runtime["jsx"])(Band, {
                      id: "preamp",
                      band: "preamp",
                      onChange: setPreampValue
                    }), Object(jsx_runtime["jsx"])("div", {
                      id: "plus12db",
                      onClick: setEqToMax
                    }), Object(jsx_runtime["jsx"])("div", {
                      id: "zerodb",
                      onClick: setEqToMid
                    }), Object(jsx_runtime["jsx"])("div", {
                      id: "minus12db",
                      onClick: setEqToMin
                    }), BANDS.map((hertz) => Object(jsx_runtime["jsx"])(Band, {
                      id: bandClassName(hertz),
                      band: hertz,
                      onChange: (value) => setHertzValue(hertz, value)
                    }, hertz))]
                  })
                })
              });
            };
            var components_EqualizerWindow = EqualizerWindow;
            const imageSelectors = {
              MAIN_BALANCE_BACKGROUND: ["#balance"],
              MAIN_BALANCE_THUMB: ["#balance::-webkit-slider-thumb", "#balance::-moz-range-thumb"],
              MAIN_BALANCE_THUMB_ACTIVE: ["#balance:active::-webkit-slider-thumb", "#balance:active::-moz-range-thumb"],
              MAIN_PREVIOUS_BUTTON: [".actions #previous"],
              MAIN_PREVIOUS_BUTTON_ACTIVE: [".actions #previous:active"],
              MAIN_PLAY_BUTTON: [".actions #play"],
              MAIN_PLAY_BUTTON_ACTIVE: [".actions #play:active"],
              MAIN_PAUSE_BUTTON: [".actions #pause"],
              MAIN_PAUSE_BUTTON_ACTIVE: [".actions #pause:active"],
              MAIN_STOP_BUTTON: [".actions #stop"],
              MAIN_STOP_BUTTON_ACTIVE: [".actions #stop:active"],
              MAIN_NEXT_BUTTON: [".actions #next"],
              MAIN_NEXT_BUTTON_ACTIVE: [".actions #next:active"],
              MAIN_EJECT_BUTTON: ["#eject"],
              MAIN_EJECT_BUTTON_ACTIVE: ["#eject:active"],
              MAIN_WINDOW_BACKGROUND: ["#main-window"],
              MAIN_STEREO: [".media-info #stereo", ".stop .media-info #stereo.selected"],
              MAIN_STEREO_SELECTED: [".media-info #stereo.selected"],
              MAIN_MONO: [".media-info #mono", ".stop .media-info #mono.selected"],
              MAIN_MONO_SELECTED: [".media-info #mono.selected"],
              NO_MINUS_SIGN: ["#time #minus-sign"],
              MINUS_SIGN: ["#time.countdown #minus-sign"],
              DIGIT_0: [".digit-0"],
              DIGIT_1: [".digit-1"],
              DIGIT_2: [".digit-2"],
              DIGIT_3: [".digit-3"],
              DIGIT_4: [".digit-4"],
              DIGIT_5: [".digit-5"],
              DIGIT_6: [".digit-6"],
              DIGIT_7: [".digit-7"],
              DIGIT_8: [".digit-8"],
              DIGIT_9: [".digit-9"],
              NO_MINUS_SIGN_EX: ["#time #minus-sign"],
              MINUS_SIGN_EX: ["#time.countdown #minus-sign"],
              DIGIT_0_EX: [".digit-0"],
              DIGIT_1_EX: [".digit-1"],
              DIGIT_2_EX: [".digit-2"],
              DIGIT_3_EX: [".digit-3"],
              DIGIT_4_EX: [".digit-4"],
              DIGIT_5_EX: [".digit-5"],
              DIGIT_6_EX: [".digit-6"],
              DIGIT_7_EX: [".digit-7"],
              DIGIT_8_EX: [".digit-8"],
              DIGIT_9_EX: [".digit-9"],
              MAIN_PLAYING_INDICATOR: [".play #play-pause"],
              MAIN_PAUSED_INDICATOR: [".pause #play-pause"],
              MAIN_STOPPED_INDICATOR: [".stop #play-pause"],
              MAIN_NOT_WORKING_INDICATOR: ["#work-indicator"],
              MAIN_WORKING_INDICATOR: ["#work-indicator.selected"],
              PLAYLIST_TOP_TILE: [".playlist-top-left-fill", ".playlist-top-left-spacer", ".playlist-top-right-fill", ".playlist-top-right-spacer"],
              PLAYLIST_TOP_LEFT_CORNER: [".playlist-top-left"],
              PLAYLIST_TITLE_BAR: [".playlist-top-title"],
              PLAYLIST_TOP_RIGHT_CORNER: [".playlist-top-right"],
              PLAYLIST_TOP_TILE_SELECTED: [".selected .playlist-top-left-fill", ".selected .playlist-top-left-spacer", ".selected .playlist-top-right-fill", ".selected .playlist-top-right-spacer"],
              PLAYLIST_TOP_LEFT_SELECTED: [".selected .playlist-top-left"],
              PLAYLIST_TITLE_BAR_SELECTED: [".selected .playlist-top-title"],
              PLAYLIST_TOP_RIGHT_CORNER_SELECTED: [".selected .playlist-top-right"],
              PLAYLIST_LEFT_TILE: [".playlist-middle-left"],
              PLAYLIST_RIGHT_TILE: [".playlist-middle-right"],
              PLAYLIST_SCROLL_HANDLE: [".playlist-scrollbar-handle"],
              PLAYLIST_SCROLL_HANDLE_SELECTED: [".playlist-middle-right:active .playlist-scrollbar-handle"],
              PLAYLIST_BOTTOM_TILE: [".playlist-bottom"],
              PLAYLIST_BOTTOM_LEFT_CORNER: [".playlist-bottom-left"],
              PLAYLIST_BOTTOM_RIGHT_CORNER: [".playlist-bottom-right"],
              PLAYLIST_VISUALIZER_BACKGROUND: [".playlist-visualizer"],
              PLAYLIST_SHADE_BACKGROUND: ["#playlist-window-shade"],
              PLAYLIST_SHADE_BACKGROUND_LEFT: ["#playlist-window-shade .left"],
              PLAYLIST_SHADE_BACKGROUND_RIGHT: ["#playlist-window-shade .right"],
              PLAYLIST_SHADE_BACKGROUND_RIGHT_SELECTED: ["#playlist-window-shade.selected .right"],
              PLAYLIST_ADD_MENU_BAR: ["#playlist-add-menu.selected .bar"],
              PLAYLIST_ADD_URL: ["#playlist-add-menu .add-url"],
              PLAYLIST_ADD_URL_SELECTED: ["#playlist-add-menu .hover .add-url"],
              PLAYLIST_ADD_DIR: ["#playlist-add-menu .add-dir"],
              PLAYLIST_ADD_DIR_SELECTED: ["#playlist-add-menu .hover .add-dir"],
              PLAYLIST_ADD_FILE: ["#playlist-add-menu .add-file"],
              PLAYLIST_ADD_FILE_SELECTED: ["#playlist-add-menu .hover .add-file"],
              PLAYLIST_REMOVE_MENU_BAR: ["#playlist-remove-menu.selected .bar"],
              PLAYLIST_REMOVE_ALL: ["#playlist-remove-menu .remove-all"],
              PLAYLIST_REMOVE_ALL_SELECTED: ["#playlist-remove-menu .hover .remove-all"],
              PLAYLIST_CROP: ["#playlist-remove-menu .crop"],
              PLAYLIST_CROP_SELECTED: ["#playlist-remove-menu .hover .crop"],
              PLAYLIST_REMOVE_SELECTED: ["#playlist-remove-menu .remove-selected"],
              PLAYLIST_REMOVE_SELECTED_SELECTED: ["#playlist-remove-menu .hover .remove-selected"],
              PLAYLIST_REMOVE_MISC: ["#playlist-remove-menu .remove-misc"],
              PLAYLIST_REMOVE_MISC_SELECTED: ["#playlist-remove-menu .hover .remove-misc"],
              PLAYLIST_SELECT_MENU_BAR: ["#playlist-selection-menu.selected .bar"],
              PLAYLIST_INVERT_SELECTION: ["#playlist-selection-menu .invert-selection"],
              PLAYLIST_INVERT_SELECTION_SELECTED: ["#playlist-selection-menu .hover .invert-selection"],
              PLAYLIST_SELECT_ZERO: ["#playlist-selection-menu .select-zero"],
              PLAYLIST_SELECT_ZERO_SELECTED: ["#playlist-selection-menu .hover .select-zero"],
              PLAYLIST_SELECT_ALL: ["#playlist-selection-menu .select-all"],
              PLAYLIST_SELECT_ALL_SELECTED: ["#playlist-selection-menu .hover .select-all"],
              PLAYLIST_CLOSE_SELECTED: ["#playlist-close-button:active"],
              PLAYLIST_COLLAPSE_SELECTED: ["#playlist-window #playlist-shade-button:active"],
              PLAYLIST_EXPAND_SELECTED: ["#playlist-window-shade #playlist-shade-button:active"],
              PLAYLIST_MISC_MENU_BAR: ["#playlist-misc-menu.selected .bar"],
              PLAYLIST_MISC_OPTIONS: ["#playlist-misc-menu .misc-options"],
              PLAYLIST_MISC_OPTIONS_SELECTED: ["#playlist-misc-menu .hover .misc-options"],
              PLAYLIST_FILE_INFO: ["#playlist-misc-menu .file-info"],
              PLAYLIST_FILE_INFO_SELECTED: ["#playlist-misc-menu .hover .file-info"],
              PLAYLIST_SORT_LIST: ["#playlist-misc-menu .sort-list"],
              PLAYLIST_SORT_LIST_SELECTED: ["#playlist-misc-menu .hover .sort-list"],
              PLAYLIST_LIST_BAR: ["#playlist-list-menu.selected .bar"],
              PLAYLIST_NEW_LIST: ["#playlist-list-menu .new-list"],
              PLAYLIST_NEW_LIST_SELECTED: ["#playlist-list-menu .hover .new-list"],
              PLAYLIST_LOAD_LIST: ["#playlist-list-menu .load-list"],
              PLAYLIST_LOAD_LIST_SELECTED: ["#playlist-list-menu .hover .load-list"],
              PLAYLIST_SAVE_LIST: ["#playlist-list-menu .save-list"],
              PLAYLIST_SAVE_LIST_SELECTED: ["#playlist-list-menu .hover .save-list"],
              EQ_WINDOW_BACKGROUND: ["#equalizer-window:not(.shade)"],
              EQ_TITLE_BAR: [".equalizer-top"],
              EQ_TITLE_BAR_SELECTED: [".selected .equalizer-top"],
              EQ_SLIDER_BACKGROUND: [".band"],
              EQ_SLIDER_THUMB: [".band .slider-handle"],
              // But the "active" pseudo selector on the parent, since clicking
              // anywhere on the track moves the slider.
              EQ_SLIDER_THUMB_SELECTED: [".band:active .slider-handle"],
              EQ_ON_BUTTON: ["#on"],
              EQ_ON_BUTTON_DEPRESSED: ["#on:active"],
              EQ_ON_BUTTON_SELECTED: ["#on.selected"],
              EQ_ON_BUTTON_SELECTED_DEPRESSED: ["#on.selected:active"],
              EQ_AUTO_BUTTON: ["#auto"],
              EQ_AUTO_BUTTON_DEPRESSED: ["#auto:active"],
              EQ_AUTO_BUTTON_SELECTED: ["#auto.selected"],
              EQ_AUTO_BUTTON_SELECTED_DEPRESSED: ["#auto.selected:active"],
              EQ_GRAPH_BACKGROUND: ["#eqGraph"],
              EQ_PRESETS_BUTTON: ["#presets"],
              EQ_PRESETS_BUTTON_SELECTED: ["#presets:active"],
              EQ_PREAMP_LINE: ["#preamp-line"],
              EQ_SHADE_BACKGROUND: ["#equalizer-window.shade"],
              EQ_SHADE_BACKGROUND_SELECTED: ["#equalizer-window.shade.selected"],
              EQ_SHADE_VOLUME_SLIDER_LEFT: ["#equalizer-volume.left::-webkit-slider-thumb", "#equalizer-volume.left::-moz-range-thumb"],
              EQ_SHADE_VOLUME_SLIDER_CENTER: ["#equalizer-volume.center::-webkit-slider-thumb", "#equalizer-volume.center::-moz-range-thumb"],
              EQ_SHADE_VOLUME_SLIDER_RIGHT: ["#equalizer-volume.right::-webkit-slider-thumb", "#equalizer-volume.right::-moz-range-thumb"],
              EQ_SHADE_BALANCE_SLIDER_LEFT: ["#equalizer-balance.left::-webkit-slider-thumb", "#equalizer-balance.left::-moz-range-thumb"],
              EQ_SHADE_BALANCE_SLIDER_CENTER: ["#equalizer-balance.center::-webkit-slider-thumb", "#equalizer-balance.center::-moz-range-thumb"],
              EQ_SHADE_BALANCE_SLIDER_RIGHT: ["#equalizer-balance.right::-webkit-slider-thumb", "#equalizer-balance.right::-moz-range-thumb"],
              EQ_MAXIMIZE_BUTTON_ACTIVE: ["#equalizer-shade:active"],
              EQ_MINIMIZE_BUTTON_ACTIVE: ["#equalizer-window.shade #equalizer-shade:active"],
              EQ_CLOSE_BUTTON: ["#equalizer-window.selected #eq-buttons.clicked #equalizer-close"],
              EQ_CLOSE_BUTTON_ACTIVE: ["#equalizer-window.selected #eq-buttons.clicked #equalizer-close:active"],
              EQ_SHADE_CLOSE_BUTTON: ["#equalizer-window.shade.selected #eq-buttons.clicked #equalizer-close"],
              EQ_SHADE_CLOSE_BUTTON_ACTIVE: ["#equalizer-window.shade.selected #eq-buttons.clicked #equalizer-close:active"],
              MAIN_POSITION_SLIDER_BACKGROUND: ["#position"],
              MAIN_POSITION_SLIDER_THUMB: ["#position::-webkit-slider-thumb", "#position::-moz-range-thumb"],
              MAIN_POSITION_SLIDER_THUMB_SELECTED: ["#position:active::-webkit-slider-thumb", "#position:active::-moz-range-thumb"],
              MAIN_SHUFFLE_BUTTON: ["#shuffle"],
              MAIN_SHUFFLE_BUTTON_DEPRESSED: ["#shuffle:active"],
              MAIN_SHUFFLE_BUTTON_SELECTED: ["#shuffle.selected"],
              MAIN_SHUFFLE_BUTTON_SELECTED_DEPRESSED: ["#shuffle.selected:active"],
              MAIN_REPEAT_BUTTON: ["#repeat"],
              MAIN_REPEAT_BUTTON_DEPRESSED: ["#repeat:active"],
              MAIN_REPEAT_BUTTON_SELECTED: ["#repeat.selected"],
              MAIN_REPEAT_BUTTON_SELECTED_DEPRESSED: ["#repeat.selected:active"],
              MAIN_EQ_BUTTON: ["#equalizer-button"],
              MAIN_EQ_BUTTON_SELECTED: ["#equalizer-button.selected"],
              MAIN_EQ_BUTTON_DEPRESSED: ["#equalizer-button:active"],
              MAIN_EQ_BUTTON_DEPRESSED_SELECTED: ["#equalizer-button.selected:active"],
              MAIN_PLAYLIST_BUTTON: ["#playlist-button"],
              MAIN_PLAYLIST_BUTTON_SELECTED: ["#playlist-button.selected"],
              MAIN_PLAYLIST_BUTTON_DEPRESSED: ["#playlist-button:active"],
              MAIN_PLAYLIST_BUTTON_DEPRESSED_SELECTED: ["#playlist-button.selected:active"],
              MAIN_TITLE_BAR: ["#title-bar"],
              MAIN_TITLE_BAR_SELECTED: [".selected #title-bar"],
              MAIN_EASTER_EGG_TITLE_BAR: [".llama #title-bar"],
              MAIN_EASTER_EGG_TITLE_BAR_SELECTED: [".llama.selected #title-bar"],
              MAIN_OPTIONS_BUTTON: [".selected #title-bar #option.clicked"],
              MAIN_OPTIONS_BUTTON_DEPRESSED: [".selected #title-bar #option:active", ".selected #title-bar #option.selected"],
              MAIN_MINIMIZE_BUTTON: [".selected #title-bar #minimize.clicked"],
              MAIN_MINIMIZE_BUTTON_DEPRESSED: [".selected #title-bar #minimize:active"],
              MAIN_SHADE_BUTTON: [".selected #title-bar #shade.clicked"],
              MAIN_SHADE_BUTTON_DEPRESSED: [".selected #title-bar #shade:active"],
              MAIN_CLOSE_BUTTON: [".selected #title-bar #close.clicked"],
              MAIN_CLOSE_BUTTON_DEPRESSED: [".selected #title-bar #close:active"],
              MAIN_CLUTTER_BAR_BACKGROUND: ["#clutter-bar"],
              MAIN_CLUTTER_BAR_BACKGROUND_DISABLED: ["#clutter-bar.disabled"],
              MAIN_CLUTTER_BAR_BUTTON_O_SELECTED: ["#button-o:active", "#button-0.selected"],
              MAIN_CLUTTER_BAR_BUTTON_A_SELECTED: ["#button-a:active", "#button-a.selected"],
              MAIN_CLUTTER_BAR_BUTTON_I_SELECTED: ["#button-i:active", "#button-i.selected"],
              MAIN_CLUTTER_BAR_BUTTON_D_SELECTED: ["#button-d:active", "#button-d.selected"],
              MAIN_CLUTTER_BAR_BUTTON_V_SELECTED: ["#button-v:active", "#button-v.selected"],
              MAIN_SHADE_BACKGROUND: [".shade #title-bar"],
              MAIN_SHADE_BACKGROUND_SELECTED: [".shade.selected #title-bar"],
              MAIN_SHADE_BUTTON_SELECTED: [".shade.selected #title-bar #shade"],
              MAIN_SHADE_BUTTON_SELECTED_DEPRESSED: [".shade #title-bar #shade:active"],
              MAIN_SHADE_POSITION_BACKGROUND: [".shade #position"],
              MAIN_SHADE_POSITION_THUMB: [".shade #position::-moz-range-thumb", ".shade #position::-webkit-slider-thumb"],
              MAIN_SHADE_POSITION_THUMB_LEFT: [".shade #position.left::-moz-range-thumb", ".shade #position.left::-webkit-slider-thumb"],
              MAIN_SHADE_POSITION_THUMB_RIGHT: [".shade #position.right::-moz-range-thumb", ".shade #position.right::-webkit-slider-thumb"],
              MAIN_VOLUME_BACKGROUND: ["#volume"],
              MAIN_VOLUME_THUMB: ["#volume input::-webkit-slider-thumb", "#volume input::-moz-range-thumb"],
              MAIN_VOLUME_THUMB_SELECTED: ["#volume input:active::-webkit-slider-thumb", "#volume input:active::-moz-range-thumb"],
              GEN_TOP_CENTER_FILL: [".gen-window .gen-top"],
              GEN_TOP_LEFT: [".gen-window .gen-top-left"],
              GEN_TOP_LEFT_END: [".gen-window .gen-top-left-end"],
              GEN_TOP_RIGHT: [".gen-window .gen-top-right"],
              GEN_TOP_RIGHT_END: [".gen-window .gen-top-right-end"],
              GEN_TOP_LEFT_RIGHT_FILL: [".gen-window .gen-top-left-fill", ".gen-window .gen-top-right-fill"],
              GEN_TOP_CENTER_FILL_SELECTED: [".gen-window.selected .gen-top"],
              GEN_TOP_LEFT_SELECTED: [".gen-window.selected .gen-top-left"],
              GEN_TOP_LEFT_END_SELECTED: [".gen-window.selected .gen-top-left-end"],
              GEN_TOP_RIGHT_SELECTED: [".gen-window.selected .gen-top-right"],
              GEN_TOP_RIGHT_END_SELECTED: [".gen-window.selected .gen-top-right-end"],
              GEN_TOP_LEFT_RIGHT_FILL_SELECTED: [".gen-window.selected .gen-top-left-fill", ".gen-window.selected .gen-top-right-fill"],
              GEN_BOTTOM_LEFT: [".gen-window .gen-bottom-left"],
              GEN_BOTTOM_RIGHT: [".gen-window .gen-bottom-right"],
              GEN_BOTTOM_FILL: [".gen-window .gen-bottom"],
              GEN_MIDDLE_LEFT: [".gen-window .gen-middle-left"],
              GEN_MIDDLE_LEFT_BOTTOM: [".gen-window .gen-middle-left-bottom"],
              GEN_MIDDLE_RIGHT: [".gen-window .gen-middle-right"],
              GEN_MIDDLE_RIGHT_BOTTOM: [".gen-window .gen-middle-right-bottom"],
              GEN_CLOSE_SELECTED: [".gen-window .gen-close:active"]
            };
            Object.keys(FONT_LOOKUP).forEach((character) => {
              const key = imageConstFromChar(character);
              const code = character.charCodeAt(0);
              imageSelectors[key] = [`.character-${code}`];
            });
            LETTERS.forEach((character) => {
              imageSelectors[`GEN_TEXT_${character}`] = [`.gen-text-${character.toLowerCase()}`];
              imageSelectors[`GEN_TEXT_SELECTED_${character}`] = [`.gen-window.selected .gen-text-${character.toLowerCase()}`];
            });
            const cursorSelectors = {
              CLOSE: ["#title-bar #close"],
              // This is not quite right. There are some areas that show this cursor
              // but are not clickable.
              EQSLID: ["#equalizer-window .band"],
              EQNORMAL: ["#equalizer-window"],
              EQCLOSE: ["#equalizer-window #equalizer-close"],
              EQTITLE: ["#equalizer-window .title-bar", "#equalizer-window.shade", "#equalizer-window.shade input"],
              MAINMENU: ["#main-window #option", "#webamp-context-menu .context-menu"],
              MIN: ["#main-window #minimize"],
              NORMAL: [
                // Use this as the default cursor.
                ".window",
                ".window input",
                // Otherwise
                "#main-window",
                "#main-window.shade #title-bar"
              ],
              MMENU: ["#main-window.shade #option"],
              PNORMAL: ["#playlist-window"],
              // TODO: This is should really only apply to the top part of the top.
              // The chrome around the playlist window is larger than others. The
              // cursor only applies to the same height as the other window's chrome.
              PTBAR: ["#playlist-window .playlist-top"],
              PCLOSE: ["#playlist-window #playlist-close-button", "#playlist-window-shade #playlist-close-button"],
              PWINBUT: ["#playlist-window #playlist-shade-button", "#playlist-window-shade #playlist-shade-button"],
              POSBAR: ["#main-window #position"],
              PSIZE: ["#playlist-window #playlist-resize-target"],
              PWSSIZE: ["#playlist-window-shade #playlist-resize-target"],
              PWSNORM: ["#playlist-window-shade"],
              // TODO: The target for this is not quite right.
              PVSCROLL: ["#playlist-window .playlist-scrollbar"],
              SONGNAME: ["#main-window #marquee"],
              TITLEBAR: ["#main-window #title-bar"],
              VOLBAL: ["#volume", "#volume input", "#balance"],
              WINBUT: ["#main-window #shade"],
              WSNORMAL: ["#main-window.shade #title-bar"],
              WSPOSBAR: ["#main-window.shade #position"]
            };
            function Css({
              children,
              id
            }) {
              const style = Object(react["useMemo"])(() => {
                const s = document.createElement("style");
                s.type = "text/css";
                s.id = id;
                return s;
              }, [id]);
              Object(react["useLayoutEffect"])(() => {
                document.head.appendChild(style);
                return () => style.remove();
              }, [style]);
              return Object(react_dom["createPortal"])(children, style);
            }
            function ClipPaths({
              children
            }) {
              const paths = Object(react["useMemo"])(() => {
                return document.createElement("div");
              }, []);
              Object(react["useLayoutEffect"])(() => {
                document.body.appendChild(paths);
                return () => paths.remove();
              }, [paths]);
              return Object(react_dom["createPortal"])(Object(jsx_runtime["jsx"])("svg", {
                height: 0,
                width: 0,
                children: Object(jsx_runtime["jsx"])("defs", {
                  children: Object.keys(children).map((id) => Object(jsx_runtime["jsx"])("clipPath", {
                    id,
                    children: children[id].map((points, i) => Object(jsx_runtime["jsx"])("polygon", {
                      points
                    }, i))
                  }, id))
                })
              }), paths);
            }
            var dist = __webpack_require__2(42);
            const CSS_PREFIX = "#webamp";
            const mapRegionNamesToIds = {
              normal: "mainWindowClipPath",
              windowshade: "shadeMainWindowClipPath",
              equalizer: "equalizerWindowClipPath",
              equalizerws: "shadeEqualizerWindowClipPath"
            };
            const mapRegionNamesToMatcher = {
              normal: "#main-window:not(.shade)",
              windowshade: "#main-window.shade",
              equalizer: "#equalizer-window:not(.shade)",
              equalizerws: "#equalizer-window.shade"
            };
            const numExIsUsed = (skinImages) => Boolean(skinImages.DIGIT_0_EX);
            const FALLBACKS = {
              MAIN_BALANCE_BACKGROUND: "MAIN_VOLUME_BACKGROUND",
              MAIN_BALANCE_THUMB: "MAIN_VOLUME_THUMB",
              MAIN_BALANCE_THUMB_ACTIVE: "MAIN_VOLUME_THUMB_SELECTED",
              EQ_MAXIMIZE_BUTTON_ACTIVE: "EQ_MAXIMIZE_BUTTON_ACTIVE_FALLBACK"
            };
            function normalizeCursorSelector(selector) {
              return `${// TODO: Fix this hack
              // Maybe our CSS name spacing should be based on some other class/id
              // than the one we use for defining the main div.
              // That way it could be shared by both the player and the context menu.
              selector.startsWith("#webamp-context-menu") ? "" : CSS_PREFIX} ${selector}`;
            }
            const getCssRules = Object(lib["createSelector"])(getSkinImages, getSkinCursors, getSkinLetterWidths, getSkinRegion, (skinImages, skinCursors, skinGenLetterWidths, skinRegion) => {
              if (!skinImages || !skinCursors) {
                return null;
              }
              const cssRules = [];
              Object.keys(imageSelectors).forEach((imageName) => {
                const imageUrl = skinImages[imageName] || skinImages[FALLBACKS[imageName]];
                if (imageUrl) {
                  imageSelectors[imageName].forEach((selector) => {
                    cssRules.push(`${CSS_PREFIX} ${selector} {background-image: url(${imageUrl})}`);
                  });
                }
              });
              if (skinGenLetterWidths != null) {
                LETTERS.forEach((letter) => {
                  const width = skinGenLetterWidths[`GEN_TEXT_${letter}`];
                  const selectedWidth = skinGenLetterWidths[`GEN_TEXT_SELECTED_${letter}`];
                  cssRules.push(`${CSS_PREFIX} .gen-text-${letter.toLowerCase()} {width: ${width}px;}`);
                  cssRules.push(`${CSS_PREFIX} .selected .gen-text-${letter.toLowerCase()} {width: ${selectedWidth}px;}`);
                });
              }
              Object.entries(cursorSelectors).forEach(([cursorName, cursorSelector]) => {
                const cursor = skinCursors[cursorName];
                if (cursor == null) {
                  return;
                }
                const cursorRules = cursorSelector.map(normalizeCursorSelector).map((selector) => {
                  switch (cursor.type) {
                    case "cur":
                      return `${selector} {cursor: url(${cursor.url}), auto}`;
                    case "ani": {
                      try {
                        return Object(dist["convertAniBinaryToCSS"])(selector, cursor.aniData);
                      } catch (e) {
                        console.error(e);
                        return null;
                      }
                    }
                  }
                }).filter(Boolean);
                cssRules.push(...cursorRules);
              });
              if (numExIsUsed(skinImages)) {
                cssRules.push(`${CSS_PREFIX} .webamp-status #time #minus-sign { top: 0px; left: -1px; width: 9px; height: 13px; }`);
              }
              for (const [regionName, polygons] of Object.entries(skinRegion)) {
                if (polygons) {
                  const matcher = mapRegionNamesToMatcher[regionName];
                  const id = mapRegionNamesToIds[regionName];
                  cssRules.push(`${CSS_PREFIX} ${matcher} { clip-path: url(#${id}); }`);
                }
              }
              return cssRules.join("\n");
            });
            const getClipPaths = Object(lib["createSelector"])(getSkinRegion, (skinRegion) => {
              const clipPaths = {};
              for (const [regionName, polygons] of Object.entries(skinRegion)) {
                if (polygons) {
                  const id = mapRegionNamesToIds[regionName];
                  clipPaths[id] = polygons;
                }
              }
              return clipPaths;
            });
            function Skin() {
              const cssRules = useTypedSelector(getCssRules);
              const clipPaths = useTypedSelector(getClipPaths);
              if (cssRules == null) {
                return null;
              }
              return Object(jsx_runtime["jsxs"])(jsx_runtime["Fragment"], {
                children: [Object(jsx_runtime["jsx"])(Css, {
                  id: "webamp-skin",
                  children: cssRules
                }), Object(jsx_runtime["jsx"])(ClipPaths, {
                  children: clipPaths
                })]
              });
            }
            var webamp = __webpack_require__2(98);
            function App({
              media,
              filePickers
            }) {
              const closed = useTypedSelector(getClosed);
              const genWindowsInfo = useTypedSelector(getGenWindows);
              const zIndex = useTypedSelector(getZIndex);
              const browserWindowSizeChanged = useActionCreator(windows_browserWindowSizeChanged);
              const setFocusedWindow = useActionCreator(windows_setFocusedWindow);
              const [webampNode] = Object(react["useState"])(() => {
                const node = document.createElement("div");
                node.id = "webamp";
                node.role = "application";
                return node;
              });
              Object(react["useLayoutEffect"])(() => {
                webampNode.style.zIndex = String(zIndex);
              }, [webampNode, zIndex]);
              Object(react["useLayoutEffect"])(() => {
                document.body.appendChild(webampNode);
                return () => {
                  document.body.removeChild(webampNode);
                };
              }, [webampNode]);
              Object(react["useEffect"])(() => {
                const handleWindowResize = () => {
                  if (webampNode == null) {
                    return;
                  }
                  webampNode.style.right = "0";
                  webampNode.style.bottom = "0";
                  webampNode.style.overflow = "hidden";
                  browserWindowSizeChanged(utils_getWindowSize());
                  webampNode.style.right = "auto";
                  webampNode.style.bottom = "auto";
                  webampNode.style.overflow = "visible";
                };
                handleWindowResize();
                window.addEventListener("resize", handleWindowResize);
                return () => {
                  window.removeEventListener("resize", handleWindowResize);
                };
              }, [browserWindowSizeChanged, webampNode]);
              const renderWindows = Object(react["useCallback"])(() => {
                return objectMap(genWindowsInfo, (w, id) => {
                  if (!w.open) {
                    return null;
                  }
                  switch (id) {
                    case WINDOWS.MAIN:
                      return Object(jsx_runtime["jsx"])(components_MainWindow, {
                        analyser: media.getAnalyser(),
                        filePickers
                      });
                    case WINDOWS.EQUALIZER:
                      return Object(jsx_runtime["jsx"])(components_EqualizerWindow, {});
                    case WINDOWS.PLAYLIST:
                      return Object(jsx_runtime["jsx"])(components_PlaylistWindow, {
                        analyser: media.getAnalyser()
                      });
                    case WINDOWS.MILKDROP:
                      return Object(jsx_runtime["jsx"])(MilkdropWindow, {
                        analyser: media.getAnalyser()
                      });
                    default:
                      throw new Error(`Tried to render an unknown window: ${id}`);
                  }
                });
              }, [media, filePickers, genWindowsInfo]);
              const handleBlur = (e) => {
                if (!e.currentTarget.contains(e.relatedTarget)) {
                  setFocusedWindow(null);
                }
              };
              if (closed) {
                return null;
              }
              return react_dom_default.a.createPortal(Object(jsx_runtime["jsx"])(react["StrictMode"], {
                children: Object(jsx_runtime["jsxs"])("div", {
                  onBlur: handleBlur,
                  children: [Object(jsx_runtime["jsx"])(Skin, {}), Object(jsx_runtime["jsx"])(ContextMenuWraper, {
                    renderContents: () => Object(jsx_runtime["jsx"])(MainWindow_MainContextMenu, {
                      filePickers
                    }),
                    children: Object(jsx_runtime["jsx"])(WindowManager, {
                      windows: renderWindows()
                    })
                  })]
                })
              }), webampNode);
            }
            const IGNORE_EVENTS_FROM_TAGS = /* @__PURE__ */ new Set(["input", "textarea", "select"]);
            function bindHotkeys(dispatch) {
              let currentPos = 0;
              const trigger = [
                78,
                // N
                85,
                // U
                76,
                // L
                76,
                // L
                83,
                // S
                79,
                // O
                70,
                // F
                84
                // T
              ];
              const listener = (e) => {
                if (e.target instanceof Element && IGNORE_EVENTS_FROM_TAGS.has(e.target.tagName.toLowerCase())) {
                  return;
                }
                if (e.ctrlKey) {
                  switch (e.keyCode) {
                    case 68:
                      dispatch(windows_toggleDoubleSizeMode());
                      e.preventDefault();
                      break;
                    case 76:
                      break;
                    case 82:
                      dispatch(playlist_reverseList());
                      break;
                    case 84:
                      dispatch({
                        type: TOGGLE_TIME_MODE
                      });
                      break;
                  }
                } else if (e.altKey) {
                  switch (e.keyCode) {
                    case 87:
                      dispatch(windows_toggleWindow("main"));
                      break;
                    case 69:
                      dispatch(windows_toggleWindow("playlist"));
                      break;
                    case 71:
                      dispatch(windows_toggleWindow("equalizer"));
                      break;
                  }
                } else {
                  switch (e.keyCode) {
                    case 37:
                      dispatch(media_seekBackward(5));
                      break;
                    case 38:
                      dispatch(adjustVolume(1));
                      break;
                    case 39:
                      dispatch(media_seekForward(5));
                      break;
                    case 40:
                      dispatch(adjustVolume(-1));
                      break;
                    case 66:
                      dispatch(media_next());
                      break;
                    case 67:
                      dispatch(media_pause());
                      break;
                    case 76:
                      dispatch(files_openMediaFileDialog());
                      break;
                    case 82:
                      dispatch(media_toggleRepeat());
                      break;
                    case 83:
                      dispatch(media_toggleShuffle());
                      break;
                    case 86:
                      dispatch(media_stop());
                      break;
                    case 88:
                      dispatch(media_play());
                      break;
                    case 90:
                      dispatch(media_previous());
                      break;
                    case 96:
                      dispatch(files_openMediaFileDialog());
                      break;
                    case 97:
                      dispatch(media_nextN(-10));
                      break;
                    case 98:
                      dispatch(adjustVolume(-1));
                      break;
                    case 99:
                      dispatch(media_nextN(10));
                      break;
                    case 100:
                      dispatch(media_previous());
                      break;
                    case 101:
                      dispatch(media_play());
                      break;
                    case 102:
                      dispatch(media_next());
                      break;
                    case 103:
                      dispatch(media_seekBackward(5));
                      break;
                    case 104:
                      dispatch(adjustVolume(1));
                      break;
                    case 105:
                      dispatch(media_seekForward(5));
                      break;
                  }
                }
                if (e.keyCode !== 27) {
                  currentPos = e.keyCode === trigger[currentPos] ? currentPos + 1 : 0;
                  if (currentPos === trigger.length) {
                    dispatch({
                      type: TOGGLE_LLAMA_MODE
                    });
                  }
                }
              };
              document.addEventListener("keydown", listener);
              return () => {
                document.removeEventListener("keydown", listener);
              };
            }
            class emitter_Emitter {
              constructor() {
                defineProperty_default()(this, "_listeners", void 0);
                this._listeners = {};
              }
              on(event, callback) {
                const eventListeners = this._listeners[event] || [];
                eventListeners.push(callback);
                this._listeners[event] = eventListeners;
                const unsubscribe = () => {
                  this._listeners[event] = eventListeners.filter((cb) => cb !== callback);
                };
                return unsubscribe;
              }
              trigger(event, ...args) {
                const callbacks = this._listeners[event];
                if (callbacks) {
                  callbacks.forEach((cb) => cb(...args));
                }
              }
              dispose() {
                this._listeners = {};
              }
            }
            function StereoBalanceNode(context, options = {
              balance: 0
            }) {
              let balance = 0;
              const upMixer = context.createGain();
              upMixer.channelCount = 2;
              upMixer.channelCountMode = "explicit";
              upMixer.channelInterpretation = "speakers";
              const splitter = context.createChannelSplitter(2);
              const leftGain = context.createGain();
              const rightGain = context.createGain();
              const merger = context.createChannelMerger(2);
              upMixer.connect(splitter);
              splitter.connect(leftGain, 0);
              splitter.connect(rightGain, 1);
              leftGain.connect(merger, 0, 0);
              rightGain.connect(merger, 0, 1);
              function set(rawValue) {
                const value = Number(rawValue);
                leftGain.gain.value = value > 0 ? 1 - value : 1;
                rightGain.gain.value = value > 0 ? 1 : 1 + value;
                balance = value;
              }
              function get() {
                return balance;
              }
              const audioParam = {};
              Object.defineProperties(audioParam, {
                value: {
                  get,
                  set,
                  enumerable: true,
                  configurable: true
                }
              });
              Object.defineProperties(upMixer, {
                balance: {
                  value: audioParam,
                  enumerable: true,
                  writable: false,
                  configurable: true
                },
                connect: {
                  value: AudioNode.prototype.connect.bind(merger),
                  enumerable: false,
                  writable: false,
                  configurable: true
                },
                disconnect: {
                  value: AudioNode.prototype.disconnect.bind(merger),
                  enumerable: false,
                  writable: false,
                  configurable: true
                }
              });
              if (balance !== options.balance) {
                set(options.balance);
              }
              return upMixer;
            }
            class elementSource_ElementSource {
              on(eventType, cb) {
                return this._emitter.on(eventType, cb);
              }
              constructor(context, destination) {
                defineProperty_default()(this, "_emitter", void 0);
                defineProperty_default()(this, "_context", void 0);
                defineProperty_default()(this, "_source", void 0);
                defineProperty_default()(this, "_destination", void 0);
                defineProperty_default()(this, "_audio", void 0);
                defineProperty_default()(this, "_stalled", void 0);
                defineProperty_default()(this, "_status", void 0);
                this._emitter = new emitter_Emitter();
                this._context = context;
                this._destination = destination;
                this._audio = document.createElement("audio");
                this._audio.crossOrigin = "anonymous";
                this._stalled = false;
                this._status = MEDIA_STATUS.STOPPED;
                this._audio.addEventListener("suspend", () => {
                  this._setStalled(true);
                });
                this._audio.addEventListener("durationchange", () => {
                  this._emitter.trigger("loaded");
                  this._setStalled(false);
                });
                this._audio.addEventListener("ended", () => {
                  this._emitter.trigger("ended");
                  this._setStatus(MEDIA_STATUS.STOPPED);
                });
                this._audio.addEventListener("timeupdate", () => {
                  this._emitter.trigger("positionChange");
                });
                this._audio.addEventListener("error", (e) => {
                  switch (this._audio.error.code) {
                    case 1:
                      console.error("MEDIA_ERR_ABORTED", e);
                      break;
                    case 2:
                      console.error("MEDIA_ERR_NETWORK", e);
                      break;
                    case 3:
                      console.error("PIPELINE_ERROR_DECODE", e);
                      break;
                    case 4:
                      console.error("MEDIA_ERR_SRC_NOT_SUPPORTED", e);
                      break;
                  }
                  this._emitter.trigger("ended");
                  this._setStatus(MEDIA_STATUS.STOPPED);
                });
                this._source = this._context.createMediaElementSource(this._audio);
                this._source.connect(destination);
              }
              _setStalled(stalled) {
                this._stalled = stalled;
                this._emitter.trigger("stallChanged");
              }
              disconnect() {
                this._source.disconnect();
              }
              // Async for now, for compatibility with BufferAudioSource
              // TODO: This does not need to be async
              async loadUrl(url) {
                this._audio.src = url;
              }
              async play() {
                if (this._status !== MEDIA_STATUS.PAUSED) {
                  this.seekToTime(0);
                }
                try {
                  await this._audio.play();
                } catch (err) {
                }
                this._setStatus(MEDIA_STATUS.PLAYING);
              }
              pause() {
                this._audio.pause();
                this._setStatus(MEDIA_STATUS.PAUSED);
              }
              stop() {
                this._audio.pause();
                this._audio.currentTime = 0;
                this._setStatus(MEDIA_STATUS.STOPPED);
              }
              seekToTime(time) {
                this._audio.currentTime = clamp(time, 0, this.getDuration());
                this._emitter.trigger("positionChange");
              }
              getStalled() {
                return this._stalled;
              }
              getStatus() {
                return this._status;
              }
              getDuration() {
                const {
                  duration
                } = this._audio;
                return isNaN(duration) || duration === Infinity ? 0 : duration;
              }
              getTimeElapsed() {
                return this._audio.currentTime;
              }
              _setStatus(status) {
                this._status = status;
                this._emitter.trigger("statusChange");
              }
              dispose() {
                this.stop();
                this._emitter.dispose();
              }
            }
            class media_Media {
              constructor() {
                defineProperty_default()(this, "_emitter", void 0);
                defineProperty_default()(this, "_context", void 0);
                defineProperty_default()(this, "_balance", void 0);
                defineProperty_default()(this, "_staticSource", void 0);
                defineProperty_default()(this, "_preamp", void 0);
                defineProperty_default()(this, "_analyser", void 0);
                defineProperty_default()(this, "_gainNode", void 0);
                defineProperty_default()(this, "_source", void 0);
                defineProperty_default()(this, "_bands", void 0);
                this._emitter = new emitter_Emitter();
                this._context = new (window.AudioContext || window.webkitAudioContext)();
                if (this._context.state === "suspended") {
                  const resume = async () => {
                    await this._context.resume();
                    if (this._context.state === "running") {
                      document.body.removeEventListener("touchend", resume, false);
                      document.body.removeEventListener("click", resume, false);
                      document.body.removeEventListener("keydown", resume, false);
                    }
                  };
                  document.body.addEventListener("touchend", resume, false);
                  document.body.addEventListener("click", resume, false);
                  document.body.addEventListener("keydown", resume, false);
                }
                this._staticSource = this._context.createGain();
                this._balance = new StereoBalanceNode(this._context);
                this._preamp = this._context.createGain();
                this._analyser = this._context.createAnalyser();
                this._analyser.fftSize = 2048;
                this._analyser.smoothingTimeConstant = 0;
                this._gainNode = this._context.createGain();
                this._source = new elementSource_ElementSource(this._context, this._staticSource);
                this._source.on("positionChange", () => {
                  this._emitter.trigger("timeupdate");
                });
                this._source.on("ended", () => {
                  this._emitter.trigger("ended");
                });
                this._source.on("statusChange", () => {
                  switch (this._source.getStatus()) {
                    case MEDIA_STATUS.PLAYING:
                      this._emitter.trigger("playing");
                      break;
                  }
                  this._emitter.trigger("timeupdate");
                });
                this._source.on("loaded", () => {
                  this._emitter.trigger("fileLoaded");
                });
                this._staticSource.connect(this._preamp);
                let output = this._preamp;
                this._bands = {};
                BANDS.forEach((band, i) => {
                  const filter = this._context.createBiquadFilter();
                  this._bands[band] = filter;
                  if (i === 0) {
                    filter.type = "lowshelf";
                  } else if (i === BANDS.length - 1) {
                    filter.type = "highshelf";
                  } else {
                    filter.type = "peaking";
                  }
                  filter.frequency.value = band;
                  filter.gain.value = 0;
                  output.connect(filter);
                  output = filter;
                });
                output.connect(this._balance);
                this._balance.connect(this._gainNode);
                this._balance.connect(this._analyser);
                this._gainNode.connect(this._context.destination);
              }
              getAnalyser() {
                return this._analyser;
              }
              /* Properties */
              duration() {
                return this._source.getDuration();
              }
              timeElapsed() {
                return this._source.getTimeElapsed();
              }
              timeRemaining() {
                return this.duration() - this.timeElapsed();
              }
              percentComplete() {
                return this.timeElapsed() / this.duration() * 100;
              }
              /* Actions */
              async play() {
                await this._source.play();
              }
              pause() {
                this._source.pause();
              }
              stop() {
                this._source.stop();
              }
              /* Actions with arguments */
              seekToPercentComplete(percent) {
                const seekTime = this.duration() * (percent / 100);
                this.seekToTime(seekTime);
              }
              // From 0-1
              setVolume(volume) {
                this._gainNode.gain.value = volume / 100;
              }
              // from 0 to 100
              // The input value here is 0-100 which is kinda wrong, since it represents -12db to 12db.
              // For now, 50 is 0db (no change).
              // Equation used is: 10^((dB)/20) = x, where x (preamp.gain.value) is passed on to gainnode for boosting or attenuation.
              setPreamp(value) {
                const db = value / 100 * 24 - 12;
                this._preamp.gain.value = Math.pow(10, db / 20);
              }
              // From -100 to 100
              setBalance(balance) {
                this._balance.balance.value = balance / 100;
              }
              setEqBand(band, value) {
                const db = value / 100 * 24 - 12;
                this._bands[band].gain.value = db;
              }
              disableEq() {
                this._staticSource.disconnect();
                this._staticSource.connect(this._balance);
              }
              enableEq() {
                this._staticSource.disconnect();
                this._staticSource.connect(this._preamp);
              }
              /* Listeners */
              on(event, callback) {
                this._emitter.on(event, callback);
              }
              seekToTime(time) {
                this._source.seekToTime(time);
              }
              // Used only for the initial load, since it must have a CORS header
              async loadFromUrl(url, autoPlay) {
                this._emitter.trigger("waiting");
                await this._source.loadUrl(url);
                this._emitter.trigger("stopWaiting");
                if (autoPlay) {
                  this.play();
                }
              }
              dispose() {
                this._source.dispose();
                this._emitter.dispose();
              }
            }
            var base_skin = __webpack_require__2(100);
            class Disposable_Disposable {
              constructor() {
                defineProperty_default()(this, "_teardowns", []);
                defineProperty_default()(this, "disposed", void 0);
                this.disposed = false;
              }
              add(...teardowns) {
                if (this.disposed) {
                  throw new Error("Attempted to add a new teardown to a disposed disposable.");
                }
                this._teardowns.push(...teardowns);
              }
              dispose() {
                if (this.disposed) {
                  throw new Error("Attempted to dispose disposable which is already disposed.");
                }
                this._teardowns.forEach((teardown) => {
                  if (typeof teardown === "function") {
                    teardown();
                  } else if (typeof teardown.dispose === "function") {
                    teardown.dispose();
                  }
                });
                this._teardowns = [];
                this.disposed = true;
              }
            }
            const storeHas = (store, predicate) => new Promise((resolve2) => {
              if (predicate(store.getState())) {
                resolve2();
                return;
              }
              const unsubscribe = store.subscribe(() => {
                if (predicate(store.getState())) {
                  resolve2();
                  unsubscribe();
                }
              });
            });
            class webampLazy_Webamp {
              // TODO: Make this _private
              // TODO: Make this _private
              // TODO: Make this _private
              static browserIsSupported() {
                const supportsAudioApi = !!(window.AudioContext || // @ts-ignore
                window.webkitAudioContext);
                const supportsCanvas = !!window.document.createElement("canvas").getContext;
                const supportsPromises = typeof Promise !== "undefined";
                return supportsAudioApi && supportsCanvas && supportsPromises;
              }
              constructor(options) {
                defineProperty_default()(this, "_actionEmitter", void 0);
                defineProperty_default()(this, "_node", void 0);
                defineProperty_default()(this, "_disposable", void 0);
                defineProperty_default()(this, "options", void 0);
                defineProperty_default()(this, "media", void 0);
                defineProperty_default()(this, "store", void 0);
                this._node = null;
                this._disposable = new Disposable_Disposable();
                this._actionEmitter = new emitter_Emitter();
                this.options = options;
                const {
                  initialTracks,
                  initialSkin,
                  avaliableSkins,
                  // Old misspelled name
                  availableSkins,
                  enableHotkeys = false,
                  zIndex,
                  requireJSZip,
                  requireMusicMetadata,
                  handleTrackDropEvent,
                  handleAddUrlEvent,
                  handleLoadListEvent,
                  handleSaveListEvent,
                  __butterchurnOptions,
                  __customMediaClass
                } = this.options;
                let convertPreset = null;
                if (__butterchurnOptions != null) {
                  const {
                    importConvertPreset,
                    presetConverterEndpoint
                  } = __butterchurnOptions;
                  if (importConvertPreset != null && presetConverterEndpoint != null) {
                    convertPreset = async (file) => {
                      const {
                        convertPreset: convert
                      } = await importConvertPreset();
                      return convert(await genStringFromFileReference(file), presetConverterEndpoint);
                    };
                  }
                }
                this.media = new (__customMediaClass || media_Media)();
                this.store = js_store(this.media, this._actionEmitter, this.options.__customMiddlewares, this.options.__initialState, {
                  requireJSZip,
                  requireMusicMetadata,
                  convertPreset,
                  // @ts-ignore Typescript is drunk
                  handleTrackDropEvent,
                  handleAddUrlEvent,
                  handleLoadListEvent,
                  handleSaveListEvent
                });
                if (navigator.onLine) {
                  this.store.dispatch({
                    type: NETWORK_CONNECTED
                  });
                } else {
                  this.store.dispatch({
                    type: NETWORK_DISCONNECTED
                  });
                }
                if (zIndex != null) {
                  this.store.dispatch({
                    type: SET_Z_INDEX,
                    zIndex
                  });
                }
                if (options.__butterchurnOptions) {
                  this.store.dispatch({
                    type: ENABLE_MILKDROP,
                    open: options.__butterchurnOptions.butterchurnOpen
                  });
                  this.store.dispatch(initializePresets(options.__butterchurnOptions));
                }
                const handleOnline = () => this.store.dispatch({
                  type: NETWORK_CONNECTED
                });
                const handleOffline = () => this.store.dispatch({
                  type: NETWORK_DISCONNECTED
                });
                window.addEventListener("online", handleOnline);
                window.addEventListener("offline", handleOffline);
                this._disposable.add(() => {
                  window.removeEventListener("online", handleOnline);
                  window.removeEventListener("offline", handleOffline);
                });
                if (initialSkin) {
                  this.store.dispatch(setSkinFromUrl(initialSkin.url));
                } else {
                  this.store.dispatch({
                    type: LOADED
                  });
                }
                if (initialTracks) {
                  this._bufferTracks(initialTracks);
                }
                if (avaliableSkins != null) {
                  console.warn("The misspelled option `avaliableSkins` is deprecated. Please use `availableSkins` instead.");
                  this.store.dispatch({
                    type: SET_AVAILABLE_SKINS,
                    skins: avaliableSkins
                  });
                } else if (availableSkins != null) {
                  this.store.dispatch({
                    type: SET_AVAILABLE_SKINS,
                    skins: availableSkins
                  });
                }
                const layout = options.__initialWindowLayout;
                if (layout == null) {
                  this.store.dispatch(stackWindows());
                } else {
                  objectForEach(layout, (w, windowId) => {
                    if (w.size != null) {
                      this.store.dispatch(windows_setWindowSize(windowId, w.size));
                    }
                  });
                  this.store.dispatch(windows_updateWindowPositions(objectMap(layout, (w) => w.position), false));
                }
                if (enableHotkeys) {
                  this._disposable.add(bindHotkeys(this.store.dispatch));
                }
              }
              play() {
                this.store.dispatch(media_play());
              }
              pause() {
                this.store.dispatch(media_pause());
              }
              stop() {
                this.store.dispatch(media_stop());
              }
              seekBackward(seconds) {
                this.store.dispatch(media_seekBackward(seconds));
              }
              seekForward(seconds) {
                this.store.dispatch(media_seekForward(seconds));
              }
              seekToTime(seconds) {
                this.store.dispatch(seekToTime(seconds));
              }
              nextTrack() {
                this.store.dispatch(media_next());
              }
              previousTrack() {
                this.store.dispatch(media_previous());
              }
              _bufferTracks(tracks) {
                const nextIndex = getTrackCount(this.store.getState());
                this.store.dispatch(files_loadMediaFiles(tracks, LOAD_STYLE.BUFFER, nextIndex));
              }
              // Append this array of tracks to the end of the current playlist.
              appendTracks(tracks) {
                const nextIndex = getTrackCount(this.store.getState());
                this.store.dispatch(files_loadMediaFiles(tracks, LOAD_STYLE.NONE, nextIndex));
              }
              // Replace any existing tracks with this array of tracks, and begin playing.
              setTracksToPlay(tracks) {
                this.store.dispatch(files_loadMediaFiles(tracks, LOAD_STYLE.PLAY));
              }
              getMediaStatus() {
                return getMediaStatus(this.store.getState());
              }
              onWillClose(cb) {
                return this._actionEmitter.on(CLOSE_REQUESTED, (action) => {
                  cb(action.cancel);
                });
              }
              onClose(cb) {
                return this._actionEmitter.on(CLOSE_WINAMP, cb);
              }
              close() {
                this.store.dispatch(actionCreators_close());
              }
              reopen() {
                this.store.dispatch(actionCreators_open());
              }
              onTrackDidChange(cb) {
                let previousTrackId = null;
                return this.store.subscribe(() => {
                  const state = this.store.getState();
                  const trackId = getCurrentlyPlayingTrackIdIfLoaded(state);
                  if (trackId === previousTrackId) {
                    return;
                  }
                  previousTrackId = trackId;
                  cb(trackId == null ? null : getCurrentTrackInfo(state));
                });
              }
              onMinimize(cb) {
                return this._actionEmitter.on(MINIMIZE_WINAMP, cb);
              }
              setSkinFromUrl(url) {
                this.store.dispatch(setSkinFromUrl(url));
              }
              async skinIsLoaded() {
                await storeHas(this.store, (state) => !state.display.loading);
                await Promise.all([getPreampLineImage(this.store.getState()), getLineColorsImage(this.store.getState())]);
                return;
              }
              __loadSerializedState(serializedState) {
                this.store.dispatch(loadSerializedState(serializedState));
              }
              __getSerializedState() {
                return getSerlializedState(this.store.getState());
              }
              __onStateChange(cb) {
                return this.store.subscribe(cb);
              }
              async renderWhenReady(node) {
                this.store.dispatch(centerWindowsInContainer(node));
                await this.skinIsLoaded();
                if (this._node != null) {
                  throw new Error("Cannot render a Webamp instance twice");
                }
                this._node = node;
                this._disposable.add(() => {
                  if (this._node != null) {
                    react_dom_default.a.unmountComponentAtNode(this._node);
                    this._node = null;
                  }
                });
                react_dom_default.a.render(Object(jsx_runtime["jsx"])(components_Provider, {
                  store: this.store,
                  children: Object(jsx_runtime["jsx"])(App, {
                    media: this.media,
                    filePickers: this.options.filePickers || []
                  })
                }), node);
              }
              dispose() {
                this.media.dispose();
                this._actionEmitter.dispose();
                this._disposable.dispose();
              }
            }
            defineProperty_default()(webampLazy_Webamp, "VERSION", "1.5.0");
            var webampLazy = __webpack_exports__["default"] = webampLazy_Webamp;
          },
          /* 48 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))(function(resolve2, reject2) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function rejected(value) {
                  try {
                    step(generator["throw"](value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function step(result) {
                  result.done ? resolve2(result.value) : new P(function(resolve3) {
                    resolve3(result.value);
                  }).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
              });
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            const initDebug = __webpack_require__2(8);
            const Util_1 = __webpack_require__2(14);
            const Token = __webpack_require__2(6);
            const BasicParser_1 = __webpack_require__2(20);
            const debug = initDebug("music-metadata:parser:ID3v1");
            exports2.Genres = [
              "Blues",
              "Classic Rock",
              "Country",
              "Dance",
              "Disco",
              "Funk",
              "Grunge",
              "Hip-Hop",
              "Jazz",
              "Metal",
              "New Age",
              "Oldies",
              "Other",
              "Pop",
              "R&B",
              "Rap",
              "Reggae",
              "Rock",
              "Techno",
              "Industrial",
              "Alternative",
              "Ska",
              "Death Metal",
              "Pranks",
              "Soundtrack",
              "Euro-Techno",
              "Ambient",
              "Trip-Hop",
              "Vocal",
              "Jazz+Funk",
              "Fusion",
              "Trance",
              "Classical",
              "Instrumental",
              "Acid",
              "House",
              "Game",
              "Sound Clip",
              "Gospel",
              "Noise",
              "Alt. Rock",
              "Bass",
              "Soul",
              "Punk",
              "Space",
              "Meditative",
              "Instrumental Pop",
              "Instrumental Rock",
              "Ethnic",
              "Gothic",
              "Darkwave",
              "Techno-Industrial",
              "Electronic",
              "Pop-Folk",
              "Eurodance",
              "Dream",
              "Southern Rock",
              "Comedy",
              "Cult",
              "Gangsta Rap",
              "Top 40",
              "Christian Rap",
              "Pop/Funk",
              "Jungle",
              "Native American",
              "Cabaret",
              "New Wave",
              "Psychedelic",
              "Rave",
              "Showtunes",
              "Trailer",
              "Lo-Fi",
              "Tribal",
              "Acid Punk",
              "Acid Jazz",
              "Polka",
              "Retro",
              "Musical",
              "Rock & Roll",
              "Hard Rock",
              "Folk",
              "Folk/Rock",
              "National Folk",
              "Swing",
              "Fast-Fusion",
              "Bebob",
              "Latin",
              "Revival",
              "Celtic",
              "Bluegrass",
              "Avantgarde",
              "Gothic Rock",
              "Progressive Rock",
              "Psychedelic Rock",
              "Symphonic Rock",
              "Slow Rock",
              "Big Band",
              "Chorus",
              "Easy Listening",
              "Acoustic",
              "Humour",
              "Speech",
              "Chanson",
              "Opera",
              "Chamber Music",
              "Sonata",
              "Symphony",
              "Booty Bass",
              "Primus",
              "Porn Groove",
              "Satire",
              "Slow Jam",
              "Club",
              "Tango",
              "Samba",
              "Folklore",
              "Ballad",
              "Power Ballad",
              "Rhythmic Soul",
              "Freestyle",
              "Duet",
              "Punk Rock",
              "Drum Solo",
              "A Cappella",
              "Euro-House",
              "Dance Hall",
              "Goa",
              "Drum & Bass",
              "Club-House",
              "Hardcore",
              "Terror",
              "Indie",
              "BritPop",
              "Negerpunk",
              "Polsk Punk",
              "Beat",
              "Christian Gangsta Rap",
              "Heavy Metal",
              "Black Metal",
              "Crossover",
              "Contemporary Christian",
              "Christian Rock",
              "Merengue",
              "Salsa",
              "Thrash Metal",
              "Anime",
              "JPop",
              "Synthpop",
              "Abstract",
              "Art Rock",
              "Baroque",
              "Bhangra",
              "Big Beat",
              "Breakbeat",
              "Chillout",
              "Downtempo",
              "Dub",
              "EBM",
              "Eclectic",
              "Electro",
              "Electroclash",
              "Emo",
              "Experimental",
              "Garage",
              "Global",
              "IDM",
              "Illbient",
              "Industro-Goth",
              "Jam Band",
              "Krautrock",
              "Leftfield",
              "Lounge",
              "Math Rock",
              "New Romantic",
              "Nu-Breakz",
              "Post-Punk",
              "Post-Rock",
              "Psytrance",
              "Shoegaze",
              "Space Rock",
              "Trop Rock",
              "World Music",
              "Neoclassical",
              "Audiobook",
              "Audio Theatre",
              "Neue Deutsche Welle",
              "Podcast",
              "Indie Rock",
              "G-Funk",
              "Dubstep",
              "Garage Rock",
              "Psybient"
            ];
            const Iid3v1Token = {
              len: 128,
              /**
               * @param buf Buffer possibly holding the 128 bytes ID3v1.1 metadata header
               * @param off Offset in buffer in bytes
               * @returns ID3v1.1 header if first 3 bytes equals 'TAG', otherwise null is returned
               */
              get: (buf, off) => {
                const header = new Id3v1StringType(3).get(buf, off);
                return header === "TAG" ? {
                  header,
                  title: new Id3v1StringType(30).get(buf, off + 3),
                  artist: new Id3v1StringType(30).get(buf, off + 33),
                  album: new Id3v1StringType(30).get(buf, off + 63),
                  year: new Id3v1StringType(4).get(buf, off + 93),
                  comment: new Id3v1StringType(28).get(buf, off + 97),
                  // ID3v1.1 separator for track
                  zeroByte: Token.UINT8.get(buf, off + 127),
                  // track: ID3v1.1 field added by Michael Mutschler
                  track: Token.UINT8.get(buf, off + 126),
                  genre: Token.UINT8.get(buf, off + 127)
                } : null;
              }
            };
            class Id3v1StringType extends Token.StringType {
              constructor(len) {
                super(len, "binary");
              }
              get(buf, off) {
                let value = super.get(buf, off);
                value = Util_1.default.trimRightNull(value);
                value = value.trim();
                return value.length > 0 ? value : void 0;
              }
            }
            class ID3v1Parser extends BasicParser_1.BasicParser {
              static getGenre(genreIndex) {
                if (genreIndex < exports2.Genres.length) {
                  return exports2.Genres[genreIndex];
                }
                return void 0;
              }
              parse() {
                return __awaiter(this, void 0, void 0, function* () {
                  if (!this.tokenizer.fileSize) {
                    debug("Skip checking for ID3v1 because the file-size is unknown");
                    return;
                  }
                  const offset = this.tokenizer.fileSize - Iid3v1Token.len;
                  if (this.tokenizer.position > offset) {
                    debug("Already consumed the last 128 bytes");
                    return;
                  }
                  const header = yield this.tokenizer.readToken(Iid3v1Token, offset);
                  if (header) {
                    debug("ID3v1 header found at: pos=%s", this.tokenizer.fileSize - Iid3v1Token.len);
                    for (const id of ["title", "artist", "album", "comment", "track", "year"]) {
                      if (header[id] && header[id] !== "")
                        this.addTag(id, header[id]);
                    }
                    const genre = ID3v1Parser.getGenre(header.genre);
                    if (genre)
                      this.addTag("genre", genre);
                  } else {
                    debug("ID3v1 header not found at: pos=%s", this.tokenizer.fileSize - Iid3v1Token.len);
                  }
                });
              }
              addTag(id, value) {
                this.metadata.addTag("ID3v1", id, value);
              }
            }
            exports2.ID3v1Parser = ID3v1Parser;
          },
          /* 49 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const stream_1 = __webpack_require__2(106);
            class ID3Stream extends stream_1.Readable {
              constructor(buf) {
                super();
                this.buf = buf;
              }
              _read() {
                this.push(this.buf);
                this.push(null);
              }
            }
            exports2.ID3Stream = ID3Stream;
          },
          /* 50 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var R = typeof Reflect === "object" ? Reflect : null;
            var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
              return Function.prototype.apply.call(target, receiver, args);
            };
            var ReflectOwnKeys;
            if (R && typeof R.ownKeys === "function") {
              ReflectOwnKeys = R.ownKeys;
            } else if (Object.getOwnPropertySymbols) {
              ReflectOwnKeys = function ReflectOwnKeys2(target) {
                return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
              };
            } else {
              ReflectOwnKeys = function ReflectOwnKeys2(target) {
                return Object.getOwnPropertyNames(target);
              };
            }
            function ProcessEmitWarning(warning) {
              if (console && console.warn) console.warn(warning);
            }
            var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
              return value !== value;
            };
            function EventEmitter() {
              EventEmitter.init.call(this);
            }
            module2.exports = EventEmitter;
            EventEmitter.EventEmitter = EventEmitter;
            EventEmitter.prototype._events = void 0;
            EventEmitter.prototype._eventsCount = 0;
            EventEmitter.prototype._maxListeners = void 0;
            var defaultMaxListeners = 10;
            function checkListener(listener) {
              if (typeof listener !== "function") {
                throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
              }
            }
            Object.defineProperty(EventEmitter, "defaultMaxListeners", {
              enumerable: true,
              get: function() {
                return defaultMaxListeners;
              },
              set: function(arg) {
                if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
                  throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
                }
                defaultMaxListeners = arg;
              }
            });
            EventEmitter.init = function() {
              if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
                this._events = /* @__PURE__ */ Object.create(null);
                this._eventsCount = 0;
              }
              this._maxListeners = this._maxListeners || void 0;
            };
            EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
              if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
                throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
              }
              this._maxListeners = n;
              return this;
            };
            function _getMaxListeners(that) {
              if (that._maxListeners === void 0)
                return EventEmitter.defaultMaxListeners;
              return that._maxListeners;
            }
            EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
              return _getMaxListeners(this);
            };
            EventEmitter.prototype.emit = function emit(type) {
              var args = [];
              for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
              var doError = type === "error";
              var events = this._events;
              if (events !== void 0)
                doError = doError && events.error === void 0;
              else if (!doError)
                return false;
              if (doError) {
                var er;
                if (args.length > 0)
                  er = args[0];
                if (er instanceof Error) {
                  throw er;
                }
                var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
                err.context = er;
                throw err;
              }
              var handler = events[type];
              if (handler === void 0)
                return false;
              if (typeof handler === "function") {
                ReflectApply(handler, this, args);
              } else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for (var i = 0; i < len; ++i)
                  ReflectApply(listeners[i], this, args);
              }
              return true;
            };
            function _addListener(target, type, listener, prepend) {
              var m;
              var events;
              var existing;
              checkListener(listener);
              events = target._events;
              if (events === void 0) {
                events = target._events = /* @__PURE__ */ Object.create(null);
                target._eventsCount = 0;
              } else {
                if (events.newListener !== void 0) {
                  target.emit(
                    "newListener",
                    type,
                    listener.listener ? listener.listener : listener
                  );
                  events = target._events;
                }
                existing = events[type];
              }
              if (existing === void 0) {
                existing = events[type] = listener;
                ++target._eventsCount;
              } else {
                if (typeof existing === "function") {
                  existing = events[type] = prepend ? [listener, existing] : [existing, listener];
                } else if (prepend) {
                  existing.unshift(listener);
                } else {
                  existing.push(listener);
                }
                m = _getMaxListeners(target);
                if (m > 0 && existing.length > m && !existing.warned) {
                  existing.warned = true;
                  var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                  w.name = "MaxListenersExceededWarning";
                  w.emitter = target;
                  w.type = type;
                  w.count = existing.length;
                  ProcessEmitWarning(w);
                }
              }
              return target;
            }
            EventEmitter.prototype.addListener = function addListener(type, listener) {
              return _addListener(this, type, listener, false);
            };
            EventEmitter.prototype.on = EventEmitter.prototype.addListener;
            EventEmitter.prototype.prependListener = function prependListener(type, listener) {
              return _addListener(this, type, listener, true);
            };
            function onceWrapper() {
              if (!this.fired) {
                this.target.removeListener(this.type, this.wrapFn);
                this.fired = true;
                if (arguments.length === 0)
                  return this.listener.call(this.target);
                return this.listener.apply(this.target, arguments);
              }
            }
            function _onceWrap(target, type, listener) {
              var state = { fired: false, wrapFn: void 0, target, type, listener };
              var wrapped = onceWrapper.bind(state);
              wrapped.listener = listener;
              state.wrapFn = wrapped;
              return wrapped;
            }
            EventEmitter.prototype.once = function once(type, listener) {
              checkListener(listener);
              this.on(type, _onceWrap(this, type, listener));
              return this;
            };
            EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
              checkListener(listener);
              this.prependListener(type, _onceWrap(this, type, listener));
              return this;
            };
            EventEmitter.prototype.removeListener = function removeListener(type, listener) {
              var list, events, position, i, originalListener;
              checkListener(listener);
              events = this._events;
              if (events === void 0)
                return this;
              list = events[type];
              if (list === void 0)
                return this;
              if (list === listener || list.listener === listener) {
                if (--this._eventsCount === 0)
                  this._events = /* @__PURE__ */ Object.create(null);
                else {
                  delete events[type];
                  if (events.removeListener)
                    this.emit("removeListener", type, list.listener || listener);
                }
              } else if (typeof list !== "function") {
                position = -1;
                for (i = list.length - 1; i >= 0; i--) {
                  if (list[i] === listener || list[i].listener === listener) {
                    originalListener = list[i].listener;
                    position = i;
                    break;
                  }
                }
                if (position < 0)
                  return this;
                if (position === 0)
                  list.shift();
                else {
                  spliceOne(list, position);
                }
                if (list.length === 1)
                  events[type] = list[0];
                if (events.removeListener !== void 0)
                  this.emit("removeListener", type, originalListener || listener);
              }
              return this;
            };
            EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
            EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
              var listeners, events, i;
              events = this._events;
              if (events === void 0)
                return this;
              if (events.removeListener === void 0) {
                if (arguments.length === 0) {
                  this._events = /* @__PURE__ */ Object.create(null);
                  this._eventsCount = 0;
                } else if (events[type] !== void 0) {
                  if (--this._eventsCount === 0)
                    this._events = /* @__PURE__ */ Object.create(null);
                  else
                    delete events[type];
                }
                return this;
              }
              if (arguments.length === 0) {
                var keys = Object.keys(events);
                var key;
                for (i = 0; i < keys.length; ++i) {
                  key = keys[i];
                  if (key === "removeListener") continue;
                  this.removeAllListeners(key);
                }
                this.removeAllListeners("removeListener");
                this._events = /* @__PURE__ */ Object.create(null);
                this._eventsCount = 0;
                return this;
              }
              listeners = events[type];
              if (typeof listeners === "function") {
                this.removeListener(type, listeners);
              } else if (listeners !== void 0) {
                for (i = listeners.length - 1; i >= 0; i--) {
                  this.removeListener(type, listeners[i]);
                }
              }
              return this;
            };
            function _listeners(target, type, unwrap) {
              var events = target._events;
              if (events === void 0)
                return [];
              var evlistener = events[type];
              if (evlistener === void 0)
                return [];
              if (typeof evlistener === "function")
                return unwrap ? [evlistener.listener || evlistener] : [evlistener];
              return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
            }
            EventEmitter.prototype.listeners = function listeners(type) {
              return _listeners(this, type, true);
            };
            EventEmitter.prototype.rawListeners = function rawListeners(type) {
              return _listeners(this, type, false);
            };
            EventEmitter.listenerCount = function(emitter, type) {
              if (typeof emitter.listenerCount === "function") {
                return emitter.listenerCount(type);
              } else {
                return listenerCount.call(emitter, type);
              }
            };
            EventEmitter.prototype.listenerCount = listenerCount;
            function listenerCount(type) {
              var events = this._events;
              if (events !== void 0) {
                var evlistener = events[type];
                if (typeof evlistener === "function") {
                  return 1;
                } else if (evlistener !== void 0) {
                  return evlistener.length;
                }
              }
              return 0;
            }
            EventEmitter.prototype.eventNames = function eventNames() {
              return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
            };
            function arrayClone(arr, n) {
              var copy = new Array(n);
              for (var i = 0; i < n; ++i)
                copy[i] = arr[i];
              return copy;
            }
            function spliceOne(list, index) {
              for (; index + 1 < list.length; index++)
                list[index] = list[index + 1];
              list.pop();
            }
            function unwrapListeners(arr) {
              var ret = new Array(arr.length);
              for (var i = 0; i < ret.length; ++i) {
                ret[i] = arr[i].listener || arr[i];
              }
              return ret;
            }
          },
          /* 51 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            exports2 = module2.exports = __webpack_require__2(107);
            exports2.Stream = exports2;
            exports2.Readable = exports2;
            exports2.Writable = __webpack_require__2(53);
            exports2.Duplex = __webpack_require__2(24);
            exports2.Transform = __webpack_require__2(111);
            exports2.PassThrough = __webpack_require__2(154);
          },
          /* 52 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            var buffer = __webpack_require__2(9);
            var Buffer2 = buffer.Buffer;
            function copyProps(src, dst) {
              for (var key in src) {
                dst[key] = src[key];
              }
            }
            if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
              module2.exports = buffer;
            } else {
              copyProps(buffer, exports2);
              exports2.Buffer = SafeBuffer;
            }
            function SafeBuffer(arg, encodingOrOffset, length) {
              return Buffer2(arg, encodingOrOffset, length);
            }
            copyProps(Buffer2, SafeBuffer);
            SafeBuffer.from = function(arg, encodingOrOffset, length) {
              if (typeof arg === "number") {
                throw new TypeError("Argument must not be a number");
              }
              return Buffer2(arg, encodingOrOffset, length);
            };
            SafeBuffer.alloc = function(size, fill, encoding) {
              if (typeof size !== "number") {
                throw new TypeError("Argument must be a number");
              }
              var buf = Buffer2(size);
              if (fill !== void 0) {
                if (typeof encoding === "string") {
                  buf.fill(fill, encoding);
                } else {
                  buf.fill(fill);
                }
              } else {
                buf.fill(0);
              }
              return buf;
            };
            SafeBuffer.allocUnsafe = function(size) {
              if (typeof size !== "number") {
                throw new TypeError("Argument must be a number");
              }
              return Buffer2(size);
            };
            SafeBuffer.allocUnsafeSlow = function(size) {
              if (typeof size !== "number") {
                throw new TypeError("Argument must be a number");
              }
              return buffer.SlowBuffer(size);
            };
          },
          /* 53 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            (function(process, setImmediate, global) {
              var pna = __webpack_require__2(44);
              module2.exports = Writable;
              function WriteReq(chunk, encoding, cb) {
                this.chunk = chunk;
                this.encoding = encoding;
                this.callback = cb;
                this.next = null;
              }
              function CorkedRequest(state) {
                var _this = this;
                this.next = null;
                this.entry = null;
                this.finish = function() {
                  onCorkedFinish(_this, state);
                };
              }
              var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
              var Duplex;
              Writable.WritableState = WritableState;
              var util = Object.create(__webpack_require__2(34));
              util.inherits = __webpack_require__2(31);
              var internalUtil = {
                deprecate: __webpack_require__2(152)
              };
              var Stream = __webpack_require__2(108);
              var Buffer2 = __webpack_require__2(52).Buffer;
              var OurUint8Array = global.Uint8Array || function() {
              };
              function _uint8ArrayToBuffer(chunk) {
                return Buffer2.from(chunk);
              }
              function _isUint8Array(obj) {
                return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
              }
              var destroyImpl = __webpack_require__2(109);
              util.inherits(Writable, Stream);
              function nop() {
              }
              function WritableState(options, stream2) {
                Duplex = Duplex || __webpack_require__2(24);
                options = options || {};
                var isDuplex = stream2 instanceof Duplex;
                this.objectMode = !!options.objectMode;
                if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
                var hwm = options.highWaterMark;
                var writableHwm = options.writableHighWaterMark;
                var defaultHwm = this.objectMode ? 16 : 16 * 1024;
                if (hwm || hwm === 0) this.highWaterMark = hwm;
                else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
                else this.highWaterMark = defaultHwm;
                this.highWaterMark = Math.floor(this.highWaterMark);
                this.finalCalled = false;
                this.needDrain = false;
                this.ending = false;
                this.ended = false;
                this.finished = false;
                this.destroyed = false;
                var noDecode = options.decodeStrings === false;
                this.decodeStrings = !noDecode;
                this.defaultEncoding = options.defaultEncoding || "utf8";
                this.length = 0;
                this.writing = false;
                this.corked = 0;
                this.sync = true;
                this.bufferProcessing = false;
                this.onwrite = function(er) {
                  onwrite(stream2, er);
                };
                this.writecb = null;
                this.writelen = 0;
                this.bufferedRequest = null;
                this.lastBufferedRequest = null;
                this.pendingcb = 0;
                this.prefinished = false;
                this.errorEmitted = false;
                this.bufferedRequestCount = 0;
                this.corkedRequestsFree = new CorkedRequest(this);
              }
              WritableState.prototype.getBuffer = function getBuffer() {
                var current = this.bufferedRequest;
                var out = [];
                while (current) {
                  out.push(current);
                  current = current.next;
                }
                return out;
              };
              (function() {
                try {
                  Object.defineProperty(WritableState.prototype, "buffer", {
                    get: internalUtil.deprecate(function() {
                      return this.getBuffer();
                    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
                  });
                } catch (_) {
                }
              })();
              var realHasInstance;
              if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
                realHasInstance = Function.prototype[Symbol.hasInstance];
                Object.defineProperty(Writable, Symbol.hasInstance, {
                  value: function(object) {
                    if (realHasInstance.call(this, object)) return true;
                    if (this !== Writable) return false;
                    return object && object._writableState instanceof WritableState;
                  }
                });
              } else {
                realHasInstance = function(object) {
                  return object instanceof this;
                };
              }
              function Writable(options) {
                Duplex = Duplex || __webpack_require__2(24);
                if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
                  return new Writable(options);
                }
                this._writableState = new WritableState(options, this);
                this.writable = true;
                if (options) {
                  if (typeof options.write === "function") this._write = options.write;
                  if (typeof options.writev === "function") this._writev = options.writev;
                  if (typeof options.destroy === "function") this._destroy = options.destroy;
                  if (typeof options.final === "function") this._final = options.final;
                }
                Stream.call(this);
              }
              Writable.prototype.pipe = function() {
                this.emit("error", new Error("Cannot pipe, not readable"));
              };
              function writeAfterEnd(stream2, cb) {
                var er = new Error("write after end");
                stream2.emit("error", er);
                pna.nextTick(cb, er);
              }
              function validChunk(stream2, state, chunk, cb) {
                var valid = true;
                var er = false;
                if (chunk === null) {
                  er = new TypeError("May not write null values to stream");
                } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
                  er = new TypeError("Invalid non-string/buffer chunk");
                }
                if (er) {
                  stream2.emit("error", er);
                  pna.nextTick(cb, er);
                  valid = false;
                }
                return valid;
              }
              Writable.prototype.write = function(chunk, encoding, cb) {
                var state = this._writableState;
                var ret = false;
                var isBuf = !state.objectMode && _isUint8Array(chunk);
                if (isBuf && !Buffer2.isBuffer(chunk)) {
                  chunk = _uint8ArrayToBuffer(chunk);
                }
                if (typeof encoding === "function") {
                  cb = encoding;
                  encoding = null;
                }
                if (isBuf) encoding = "buffer";
                else if (!encoding) encoding = state.defaultEncoding;
                if (typeof cb !== "function") cb = nop;
                if (state.ended) writeAfterEnd(this, cb);
                else if (isBuf || validChunk(this, state, chunk, cb)) {
                  state.pendingcb++;
                  ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
                }
                return ret;
              };
              Writable.prototype.cork = function() {
                var state = this._writableState;
                state.corked++;
              };
              Writable.prototype.uncork = function() {
                var state = this._writableState;
                if (state.corked) {
                  state.corked--;
                  if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
                }
              };
              Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
                if (typeof encoding === "string") encoding = encoding.toLowerCase();
                if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
                this._writableState.defaultEncoding = encoding;
                return this;
              };
              function decodeChunk(state, chunk, encoding) {
                if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
                  chunk = Buffer2.from(chunk, encoding);
                }
                return chunk;
              }
              Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function() {
                  return this._writableState.highWaterMark;
                }
              });
              function writeOrBuffer(stream2, state, isBuf, chunk, encoding, cb) {
                if (!isBuf) {
                  var newChunk = decodeChunk(state, chunk, encoding);
                  if (chunk !== newChunk) {
                    isBuf = true;
                    encoding = "buffer";
                    chunk = newChunk;
                  }
                }
                var len = state.objectMode ? 1 : chunk.length;
                state.length += len;
                var ret = state.length < state.highWaterMark;
                if (!ret) state.needDrain = true;
                if (state.writing || state.corked) {
                  var last = state.lastBufferedRequest;
                  state.lastBufferedRequest = {
                    chunk,
                    encoding,
                    isBuf,
                    callback: cb,
                    next: null
                  };
                  if (last) {
                    last.next = state.lastBufferedRequest;
                  } else {
                    state.bufferedRequest = state.lastBufferedRequest;
                  }
                  state.bufferedRequestCount += 1;
                } else {
                  doWrite(stream2, state, false, len, chunk, encoding, cb);
                }
                return ret;
              }
              function doWrite(stream2, state, writev, len, chunk, encoding, cb) {
                state.writelen = len;
                state.writecb = cb;
                state.writing = true;
                state.sync = true;
                if (writev) stream2._writev(chunk, state.onwrite);
                else stream2._write(chunk, encoding, state.onwrite);
                state.sync = false;
              }
              function onwriteError(stream2, state, sync, er, cb) {
                --state.pendingcb;
                if (sync) {
                  pna.nextTick(cb, er);
                  pna.nextTick(finishMaybe, stream2, state);
                  stream2._writableState.errorEmitted = true;
                  stream2.emit("error", er);
                } else {
                  cb(er);
                  stream2._writableState.errorEmitted = true;
                  stream2.emit("error", er);
                  finishMaybe(stream2, state);
                }
              }
              function onwriteStateUpdate(state) {
                state.writing = false;
                state.writecb = null;
                state.length -= state.writelen;
                state.writelen = 0;
              }
              function onwrite(stream2, er) {
                var state = stream2._writableState;
                var sync = state.sync;
                var cb = state.writecb;
                onwriteStateUpdate(state);
                if (er) onwriteError(stream2, state, sync, er, cb);
                else {
                  var finished = needFinish(state);
                  if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                    clearBuffer(stream2, state);
                  }
                  if (sync) {
                    asyncWrite(afterWrite, stream2, state, finished, cb);
                  } else {
                    afterWrite(stream2, state, finished, cb);
                  }
                }
              }
              function afterWrite(stream2, state, finished, cb) {
                if (!finished) onwriteDrain(stream2, state);
                state.pendingcb--;
                cb();
                finishMaybe(stream2, state);
              }
              function onwriteDrain(stream2, state) {
                if (state.length === 0 && state.needDrain) {
                  state.needDrain = false;
                  stream2.emit("drain");
                }
              }
              function clearBuffer(stream2, state) {
                state.bufferProcessing = true;
                var entry = state.bufferedRequest;
                if (stream2._writev && entry && entry.next) {
                  var l = state.bufferedRequestCount;
                  var buffer = new Array(l);
                  var holder = state.corkedRequestsFree;
                  holder.entry = entry;
                  var count = 0;
                  var allBuffers = true;
                  while (entry) {
                    buffer[count] = entry;
                    if (!entry.isBuf) allBuffers = false;
                    entry = entry.next;
                    count += 1;
                  }
                  buffer.allBuffers = allBuffers;
                  doWrite(stream2, state, true, state.length, buffer, "", holder.finish);
                  state.pendingcb++;
                  state.lastBufferedRequest = null;
                  if (holder.next) {
                    state.corkedRequestsFree = holder.next;
                    holder.next = null;
                  } else {
                    state.corkedRequestsFree = new CorkedRequest(state);
                  }
                  state.bufferedRequestCount = 0;
                } else {
                  while (entry) {
                    var chunk = entry.chunk;
                    var encoding = entry.encoding;
                    var cb = entry.callback;
                    var len = state.objectMode ? 1 : chunk.length;
                    doWrite(stream2, state, false, len, chunk, encoding, cb);
                    entry = entry.next;
                    state.bufferedRequestCount--;
                    if (state.writing) {
                      break;
                    }
                  }
                  if (entry === null) state.lastBufferedRequest = null;
                }
                state.bufferedRequest = entry;
                state.bufferProcessing = false;
              }
              Writable.prototype._write = function(chunk, encoding, cb) {
                cb(new Error("_write() is not implemented"));
              };
              Writable.prototype._writev = null;
              Writable.prototype.end = function(chunk, encoding, cb) {
                var state = this._writableState;
                if (typeof chunk === "function") {
                  cb = chunk;
                  chunk = null;
                  encoding = null;
                } else if (typeof encoding === "function") {
                  cb = encoding;
                  encoding = null;
                }
                if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
                if (state.corked) {
                  state.corked = 1;
                  this.uncork();
                }
                if (!state.ending && !state.finished) endWritable(this, state, cb);
              };
              function needFinish(state) {
                return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
              }
              function callFinal(stream2, state) {
                stream2._final(function(err) {
                  state.pendingcb--;
                  if (err) {
                    stream2.emit("error", err);
                  }
                  state.prefinished = true;
                  stream2.emit("prefinish");
                  finishMaybe(stream2, state);
                });
              }
              function prefinish(stream2, state) {
                if (!state.prefinished && !state.finalCalled) {
                  if (typeof stream2._final === "function") {
                    state.pendingcb++;
                    state.finalCalled = true;
                    pna.nextTick(callFinal, stream2, state);
                  } else {
                    state.prefinished = true;
                    stream2.emit("prefinish");
                  }
                }
              }
              function finishMaybe(stream2, state) {
                var need = needFinish(state);
                if (need) {
                  prefinish(stream2, state);
                  if (state.pendingcb === 0) {
                    state.finished = true;
                    stream2.emit("finish");
                  }
                }
                return need;
              }
              function endWritable(stream2, state, cb) {
                state.ending = true;
                finishMaybe(stream2, state);
                if (cb) {
                  if (state.finished) pna.nextTick(cb);
                  else stream2.once("finish", cb);
                }
                state.ended = true;
                stream2.writable = false;
              }
              function onCorkedFinish(corkReq, state, err) {
                var entry = corkReq.entry;
                corkReq.entry = null;
                while (entry) {
                  var cb = entry.callback;
                  state.pendingcb--;
                  cb(err);
                  entry = entry.next;
                }
                if (state.corkedRequestsFree) {
                  state.corkedRequestsFree.next = corkReq;
                } else {
                  state.corkedRequestsFree = corkReq;
                }
              }
              Object.defineProperty(Writable.prototype, "destroyed", {
                get: function() {
                  if (this._writableState === void 0) {
                    return false;
                  }
                  return this._writableState.destroyed;
                },
                set: function(value) {
                  if (!this._writableState) {
                    return;
                  }
                  this._writableState.destroyed = value;
                }
              });
              Writable.prototype.destroy = destroyImpl.destroy;
              Writable.prototype._undestroy = destroyImpl.undestroy;
              Writable.prototype._destroy = function(err, cb) {
                this.end();
                cb(err);
              };
            }).call(this, __webpack_require__2(30), __webpack_require__2(104).setImmediate, __webpack_require__2(17));
          },
          /* 54 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            (function(Buffer2) {
              Object.defineProperty(exports2, "__esModule", { value: true });
              const Token = __webpack_require__2(6);
              const _debug = __webpack_require__2(8);
              const Vorbis = __webpack_require__2(113);
              const debug = _debug("music-metadata:parser:ogg:vorbis1");
              class VorbisParser {
                constructor(metadata, options) {
                  this.metadata = metadata;
                  this.options = options;
                  this.codecName = "Vorbis I";
                  this.pageSegments = [];
                }
                /**
                 * Vorbis 1 parser
                 * @param header Ogg Page Header
                 * @param pageData Page data
                 */
                parsePage(header, pageData) {
                  if (header.headerType.firstPage) {
                    this.parseFirstPage(header, pageData);
                  } else {
                    if (header.headerType.continued) {
                      if (this.pageSegments.length === 0) {
                        throw new Error("Cannot continue on previous page");
                      }
                      this.pageSegments.push(pageData);
                    }
                    if (header.headerType.lastPage || !header.headerType.continued) {
                      if (this.pageSegments.length > 0) {
                        const fullPage = Buffer2.concat(this.pageSegments);
                        this.parseFullPage(fullPage);
                      }
                      this.pageSegments = header.headerType.lastPage ? [] : [pageData];
                    }
                  }
                  if (header.headerType.lastPage) {
                    this.calculateDuration(header);
                  }
                }
                flush() {
                  this.parseFullPage(Buffer2.concat(this.pageSegments));
                }
                /**
                 * Parse first Ogg/Vorbis page
                 * @param {IPageHeader} header
                 * @param {Buffer} pageData
                 */
                parseFirstPage(header, pageData) {
                  debug("Parse first page");
                  const commonHeader = Vorbis.CommonHeader.get(pageData, 0);
                  if (commonHeader.vorbis !== "vorbis")
                    throw new Error("Metadata does not look like Vorbis");
                  if (commonHeader.packetType === 1) {
                    const idHeader = Vorbis.IdentificationHeader.get(pageData, Vorbis.CommonHeader.len);
                    this.metadata.setFormat("sampleRate", idHeader.sampleRate);
                    this.metadata.setFormat("bitrate", idHeader.bitrateNominal);
                    this.metadata.setFormat("numberOfChannels", idHeader.channelMode);
                    debug("sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s", idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);
                  } else
                    throw new Error("First Ogg page should be type 1: the identification header");
                }
                parseFullPage(pageData) {
                  const commonHeader = Vorbis.CommonHeader.get(pageData, 0);
                  debug("Parse full page: type=%s, byteLength=%s", commonHeader.packetType, pageData.byteLength);
                  switch (commonHeader.packetType) {
                    case 3:
                      return this.parseUserCommentList(pageData, Vorbis.CommonHeader.len);
                    case 1:
                    case 5:
                      break;
                  }
                }
                calculateDuration(header) {
                  if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {
                    this.metadata.setFormat("numberOfSamples", header.absoluteGranulePosition);
                    this.metadata.setFormat("duration", this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);
                  }
                }
                /**
                 * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2
                 * @returns {Promise<number>}
                 */
                parseUserCommentList(pageData, offset) {
                  const strLen = Token.UINT32_LE.get(pageData, offset);
                  offset += 4;
                  const vendorString = new Token.StringType(strLen, "utf-8").get(pageData, offset);
                  offset += strLen;
                  let userCommentListLength = Token.UINT32_LE.get(pageData, offset);
                  offset += 4;
                  while (userCommentListLength-- > 0) {
                    offset += this.parseUserComment(pageData, offset);
                  }
                }
                parseUserComment(pageData, offset) {
                  const strLen = Token.UINT32_LE.get(pageData, offset);
                  const v = new Token.StringType(strLen, "utf-8").get(pageData, offset + 4);
                  const idx = v.indexOf("=");
                  const key = v.slice(0, idx).toUpperCase();
                  let value = v.slice(idx + 1);
                  if (key === "METADATA_BLOCK_PICTURE") {
                    value = this.options.skipCovers ? null : Vorbis.VorbisPictureToken.fromBase64(value);
                  }
                  if (value !== null) {
                    debug("Push tag: id=%s, value=%s", key, value);
                    this.metadata.addTag("vorbis", key, value);
                  }
                  return Token.UINT32_LE.len + strLen;
                }
              }
              exports2.VorbisParser = VorbisParser;
            }).call(this, __webpack_require__2(9).Buffer);
          },
          /* 55 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            __webpack_require__2(23);
            var f = __webpack_require__2(1), g = 60103;
            exports2.Fragment = 60107;
            if ("function" === typeof Symbol && Symbol.for) {
              var h = Symbol.for;
              g = h("react.element");
              exports2.Fragment = h("react.fragment");
            }
            var m = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, n = Object.prototype.hasOwnProperty, p = { key: true, ref: true, __self: true, __source: true };
            function q(c, a, k) {
              var b, d = {}, e = null, l = null;
              void 0 !== k && (e = "" + k);
              void 0 !== a.key && (e = "" + a.key);
              void 0 !== a.ref && (l = a.ref);
              for (b in a) n.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
              if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
              return { $$typeof: g, type: c, key: e, ref: l, props: d, _owner: m.current };
            }
            exports2.jsx = q;
            exports2.jsxs = q;
          },
          /* 56 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var l = __webpack_require__2(23), n = 60103, p = 60106;
            exports2.Fragment = 60107;
            exports2.StrictMode = 60108;
            exports2.Profiler = 60114;
            var q = 60109, r = 60110, t = 60112;
            exports2.Suspense = 60113;
            var u = 60115, v = 60116;
            if ("function" === typeof Symbol && Symbol.for) {
              var w = Symbol.for;
              n = w("react.element");
              p = w("react.portal");
              exports2.Fragment = w("react.fragment");
              exports2.StrictMode = w("react.strict_mode");
              exports2.Profiler = w("react.profiler");
              q = w("react.provider");
              r = w("react.context");
              t = w("react.forward_ref");
              exports2.Suspense = w("react.suspense");
              u = w("react.memo");
              v = w("react.lazy");
            }
            var x = "function" === typeof Symbol && Symbol.iterator;
            function y(a) {
              if (null === a || "object" !== typeof a) return null;
              a = x && a[x] || a["@@iterator"];
              return "function" === typeof a ? a : null;
            }
            function z(a) {
              for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
              return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
            }
            var A = { isMounted: function() {
              return false;
            }, enqueueForceUpdate: function() {
            }, enqueueReplaceState: function() {
            }, enqueueSetState: function() {
            } }, B = {};
            function C(a, b, c) {
              this.props = a;
              this.context = b;
              this.refs = B;
              this.updater = c || A;
            }
            C.prototype.isReactComponent = {};
            C.prototype.setState = function(a, b) {
              if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error(z(85));
              this.updater.enqueueSetState(this, a, b, "setState");
            };
            C.prototype.forceUpdate = function(a) {
              this.updater.enqueueForceUpdate(this, a, "forceUpdate");
            };
            function D() {
            }
            D.prototype = C.prototype;
            function E(a, b, c) {
              this.props = a;
              this.context = b;
              this.refs = B;
              this.updater = c || A;
            }
            var F = E.prototype = new D();
            F.constructor = E;
            l(F, C.prototype);
            F.isPureReactComponent = true;
            var G = { current: null }, H = Object.prototype.hasOwnProperty, I = { key: true, ref: true, __self: true, __source: true };
            function J(a, b, c) {
              var e, d = {}, k = null, h = null;
              if (null != b) for (e in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) H.call(b, e) && !I.hasOwnProperty(e) && (d[e] = b[e]);
              var g = arguments.length - 2;
              if (1 === g) d.children = c;
              else if (1 < g) {
                for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
                d.children = f;
              }
              if (a && a.defaultProps) for (e in g = a.defaultProps, g) void 0 === d[e] && (d[e] = g[e]);
              return { $$typeof: n, type: a, key: k, ref: h, props: d, _owner: G.current };
            }
            function K(a, b) {
              return { $$typeof: n, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
            }
            function L(a) {
              return "object" === typeof a && null !== a && a.$$typeof === n;
            }
            function escape(a) {
              var b = { "=": "=0", ":": "=2" };
              return "$" + a.replace(/[=:]/g, function(a2) {
                return b[a2];
              });
            }
            var M = /\/+/g;
            function N(a, b) {
              return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
            }
            function O(a, b, c, e, d) {
              var k = typeof a;
              if ("undefined" === k || "boolean" === k) a = null;
              var h = false;
              if (null === a) h = true;
              else switch (k) {
                case "string":
                case "number":
                  h = true;
                  break;
                case "object":
                  switch (a.$$typeof) {
                    case n:
                    case p:
                      h = true;
                  }
              }
              if (h) return h = a, d = d(h), a = "" === e ? "." + N(h, 0) : e, Array.isArray(d) ? (c = "", null != a && (c = a.replace(M, "$&/") + "/"), O(d, b, c, "", function(a2) {
                return a2;
              })) : null != d && (L(d) && (d = K(d, c + (!d.key || h && h.key === d.key ? "" : ("" + d.key).replace(M, "$&/") + "/") + a)), b.push(d)), 1;
              h = 0;
              e = "" === e ? "." : e + ":";
              if (Array.isArray(a)) for (var g = 0; g < a.length; g++) {
                k = a[g];
                var f = e + N(k, g);
                h += O(k, b, c, f, d);
              }
              else if (f = y(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done; ) k = k.value, f = e + N(k, g++), h += O(k, b, c, f, d);
              else if ("object" === k) throw b = "" + a, Error(z(31, "[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b));
              return h;
            }
            function P(a, b, c) {
              if (null == a) return a;
              var e = [], d = 0;
              O(a, e, "", "", function(a2) {
                return b.call(c, a2, d++);
              });
              return e;
            }
            function Q(a) {
              if (-1 === a._status) {
                var b = a._result;
                b = b();
                a._status = 0;
                a._result = b;
                b.then(function(b2) {
                  0 === a._status && (b2 = b2.default, a._status = 1, a._result = b2);
                }, function(b2) {
                  0 === a._status && (a._status = 2, a._result = b2);
                });
              }
              if (1 === a._status) return a._result;
              throw a._result;
            }
            var R = { current: null };
            function S() {
              var a = R.current;
              if (null === a) throw Error(z(321));
              return a;
            }
            var T = { ReactCurrentDispatcher: R, ReactCurrentBatchConfig: { transition: 0 }, ReactCurrentOwner: G, IsSomeRendererActing: { current: false }, assign: l };
            exports2.Children = { map: P, forEach: function(a, b, c) {
              P(a, function() {
                b.apply(this, arguments);
              }, c);
            }, count: function(a) {
              var b = 0;
              P(a, function() {
                b++;
              });
              return b;
            }, toArray: function(a) {
              return P(a, function(a2) {
                return a2;
              }) || [];
            }, only: function(a) {
              if (!L(a)) throw Error(z(143));
              return a;
            } };
            exports2.Component = C;
            exports2.PureComponent = E;
            exports2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T;
            exports2.cloneElement = function(a, b, c) {
              if (null === a || void 0 === a) throw Error(z(267, a));
              var e = l({}, a.props), d = a.key, k = a.ref, h = a._owner;
              if (null != b) {
                void 0 !== b.ref && (k = b.ref, h = G.current);
                void 0 !== b.key && (d = "" + b.key);
                if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
                for (f in b) H.call(b, f) && !I.hasOwnProperty(f) && (e[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
              }
              var f = arguments.length - 2;
              if (1 === f) e.children = c;
              else if (1 < f) {
                g = Array(f);
                for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
                e.children = g;
              }
              return {
                $$typeof: n,
                type: a.type,
                key: d,
                ref: k,
                props: e,
                _owner: h
              };
            };
            exports2.createContext = function(a, b) {
              void 0 === b && (b = null);
              a = { $$typeof: r, _calculateChangedBits: b, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null };
              a.Provider = { $$typeof: q, _context: a };
              return a.Consumer = a;
            };
            exports2.createElement = J;
            exports2.createFactory = function(a) {
              var b = J.bind(null, a);
              b.type = a;
              return b;
            };
            exports2.createRef = function() {
              return { current: null };
            };
            exports2.forwardRef = function(a) {
              return { $$typeof: t, render: a };
            };
            exports2.isValidElement = L;
            exports2.lazy = function(a) {
              return { $$typeof: v, _payload: { _status: -1, _result: a }, _init: Q };
            };
            exports2.memo = function(a, b) {
              return { $$typeof: u, type: a, compare: void 0 === b ? null : b };
            };
            exports2.useCallback = function(a, b) {
              return S().useCallback(a, b);
            };
            exports2.useContext = function(a, b) {
              return S().useContext(a, b);
            };
            exports2.useDebugValue = function() {
            };
            exports2.useEffect = function(a, b) {
              return S().useEffect(a, b);
            };
            exports2.useImperativeHandle = function(a, b, c) {
              return S().useImperativeHandle(a, b, c);
            };
            exports2.useLayoutEffect = function(a, b) {
              return S().useLayoutEffect(a, b);
            };
            exports2.useMemo = function(a, b) {
              return S().useMemo(a, b);
            };
            exports2.useReducer = function(a, b, c) {
              return S().useReducer(a, b, c);
            };
            exports2.useRef = function(a) {
              return S().useRef(a);
            };
            exports2.useState = function(a) {
              return S().useState(a);
            };
            exports2.version = "17.0.1";
          },
          /* 57 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var aa = __webpack_require__2(1), m = __webpack_require__2(23), r = __webpack_require__2(58);
            function y(a) {
              for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
              return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
            }
            if (!aa) throw Error(y(227));
            var ba = /* @__PURE__ */ new Set(), ca = {};
            function da(a, b) {
              ea(a, b);
              ea(a + "Capture", b);
            }
            function ea(a, b) {
              ca[a] = b;
              for (a = 0; a < b.length; a++) ba.add(b[a]);
            }
            var fa = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, ia = Object.prototype.hasOwnProperty, ja = {}, ka = {};
            function la(a) {
              if (ia.call(ka, a)) return true;
              if (ia.call(ja, a)) return false;
              if (ha.test(a)) return ka[a] = true;
              ja[a] = true;
              return false;
            }
            function ma(a, b, c, d) {
              if (null !== c && 0 === c.type) return false;
              switch (typeof b) {
                case "function":
                case "symbol":
                  return true;
                case "boolean":
                  if (d) return false;
                  if (null !== c) return !c.acceptsBooleans;
                  a = a.toLowerCase().slice(0, 5);
                  return "data-" !== a && "aria-" !== a;
                default:
                  return false;
              }
            }
            function na(a, b, c, d) {
              if (null === b || "undefined" === typeof b || ma(a, b, c, d)) return true;
              if (d) return false;
              if (null !== c) switch (c.type) {
                case 3:
                  return !b;
                case 4:
                  return false === b;
                case 5:
                  return isNaN(b);
                case 6:
                  return isNaN(b) || 1 > b;
              }
              return false;
            }
            function B(a, b, c, d, e, f, g) {
              this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
              this.attributeName = d;
              this.attributeNamespace = e;
              this.mustUseProperty = c;
              this.propertyName = a;
              this.type = b;
              this.sanitizeURL = f;
              this.removeEmptyString = g;
            }
            var D = {};
            "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
              D[a] = new B(a, 0, false, a, null, false, false);
            });
            [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
              var b = a[0];
              D[b] = new B(b, 1, false, a[1], null, false, false);
            });
            ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
              D[a] = new B(a, 2, false, a.toLowerCase(), null, false, false);
            });
            ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
              D[a] = new B(a, 2, false, a, null, false, false);
            });
            "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
              D[a] = new B(a, 3, false, a.toLowerCase(), null, false, false);
            });
            ["checked", "multiple", "muted", "selected"].forEach(function(a) {
              D[a] = new B(a, 3, true, a, null, false, false);
            });
            ["capture", "download"].forEach(function(a) {
              D[a] = new B(a, 4, false, a, null, false, false);
            });
            ["cols", "rows", "size", "span"].forEach(function(a) {
              D[a] = new B(a, 6, false, a, null, false, false);
            });
            ["rowSpan", "start"].forEach(function(a) {
              D[a] = new B(a, 5, false, a.toLowerCase(), null, false, false);
            });
            var oa = /[\-:]([a-z])/g;
            function pa(a) {
              return a[1].toUpperCase();
            }
            "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
              var b = a.replace(
                oa,
                pa
              );
              D[b] = new B(b, 1, false, a, null, false, false);
            });
            "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
              var b = a.replace(oa, pa);
              D[b] = new B(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
            });
            ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
              var b = a.replace(oa, pa);
              D[b] = new B(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
            });
            ["tabIndex", "crossOrigin"].forEach(function(a) {
              D[a] = new B(a, 1, false, a.toLowerCase(), null, false, false);
            });
            D.xlinkHref = new B("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
            ["src", "href", "action", "formAction"].forEach(function(a) {
              D[a] = new B(a, 1, false, a.toLowerCase(), null, true, true);
            });
            function qa(a, b, c, d) {
              var e = D.hasOwnProperty(b) ? D[b] : null;
              var f = null !== e ? 0 === e.type : d ? false : !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1] ? false : true;
              f || (na(b, c, e, d) && (c = null), d || null === e ? la(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c))));
            }
            var ra = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, sa = 60103, ta = 60106, ua = 60107, wa = 60108, xa = 60114, ya = 60109, za = 60110, Aa = 60112, Ba = 60113, Ca = 60120, Da = 60115, Ea = 60116, Fa = 60121, Ga = 60128, Ha = 60129, Ia = 60130, Ja = 60131;
            if ("function" === typeof Symbol && Symbol.for) {
              var E = Symbol.for;
              sa = E("react.element");
              ta = E("react.portal");
              ua = E("react.fragment");
              wa = E("react.strict_mode");
              xa = E("react.profiler");
              ya = E("react.provider");
              za = E("react.context");
              Aa = E("react.forward_ref");
              Ba = E("react.suspense");
              Ca = E("react.suspense_list");
              Da = E("react.memo");
              Ea = E("react.lazy");
              Fa = E("react.block");
              E("react.scope");
              Ga = E("react.opaque.id");
              Ha = E("react.debug_trace_mode");
              Ia = E("react.offscreen");
              Ja = E("react.legacy_hidden");
            }
            var Ka = "function" === typeof Symbol && Symbol.iterator;
            function La(a) {
              if (null === a || "object" !== typeof a) return null;
              a = Ka && a[Ka] || a["@@iterator"];
              return "function" === typeof a ? a : null;
            }
            var Ma;
            function Na(a) {
              if (void 0 === Ma) try {
                throw Error();
              } catch (c) {
                var b = c.stack.trim().match(/\n( *(at )?)/);
                Ma = b && b[1] || "";
              }
              return "\n" + Ma + a;
            }
            var Oa = false;
            function Pa(a, b) {
              if (!a || Oa) return "";
              Oa = true;
              var c = Error.prepareStackTrace;
              Error.prepareStackTrace = void 0;
              try {
                if (b) if (b = function() {
                  throw Error();
                }, Object.defineProperty(b.prototype, "props", { set: function() {
                  throw Error();
                } }), "object" === typeof Reflect && Reflect.construct) {
                  try {
                    Reflect.construct(b, []);
                  } catch (k) {
                    var d = k;
                  }
                  Reflect.construct(a, [], b);
                } else {
                  try {
                    b.call();
                  } catch (k) {
                    d = k;
                  }
                  a.call(b.prototype);
                }
                else {
                  try {
                    throw Error();
                  } catch (k) {
                    d = k;
                  }
                  a();
                }
              } catch (k) {
                if (k && d && "string" === typeof k.stack) {
                  for (var e = k.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; ) h--;
                  for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
                    if (1 !== g || 1 !== h) {
                      do
                        if (g--, h--, 0 > h || e[g] !== f[h]) return "\n" + e[g].replace(" at new ", " at ");
                      while (1 <= g && 0 <= h);
                    }
                    break;
                  }
                }
              } finally {
                Oa = false, Error.prepareStackTrace = c;
              }
              return (a = a ? a.displayName || a.name : "") ? Na(a) : "";
            }
            function Qa(a) {
              switch (a.tag) {
                case 5:
                  return Na(a.type);
                case 16:
                  return Na("Lazy");
                case 13:
                  return Na("Suspense");
                case 19:
                  return Na("SuspenseList");
                case 0:
                case 2:
                case 15:
                  return a = Pa(a.type, false), a;
                case 11:
                  return a = Pa(a.type.render, false), a;
                case 22:
                  return a = Pa(a.type._render, false), a;
                case 1:
                  return a = Pa(a.type, true), a;
                default:
                  return "";
              }
            }
            function Ra(a) {
              if (null == a) return null;
              if ("function" === typeof a) return a.displayName || a.name || null;
              if ("string" === typeof a) return a;
              switch (a) {
                case ua:
                  return "Fragment";
                case ta:
                  return "Portal";
                case xa:
                  return "Profiler";
                case wa:
                  return "StrictMode";
                case Ba:
                  return "Suspense";
                case Ca:
                  return "SuspenseList";
              }
              if ("object" === typeof a) switch (a.$$typeof) {
                case za:
                  return (a.displayName || "Context") + ".Consumer";
                case ya:
                  return (a._context.displayName || "Context") + ".Provider";
                case Aa:
                  var b = a.render;
                  b = b.displayName || b.name || "";
                  return a.displayName || ("" !== b ? "ForwardRef(" + b + ")" : "ForwardRef");
                case Da:
                  return Ra(a.type);
                case Fa:
                  return Ra(a._render);
                case Ea:
                  b = a._payload;
                  a = a._init;
                  try {
                    return Ra(a(b));
                  } catch (c) {
                  }
              }
              return null;
            }
            function Sa(a) {
              switch (typeof a) {
                case "boolean":
                case "number":
                case "object":
                case "string":
                case "undefined":
                  return a;
                default:
                  return "";
              }
            }
            function Ta(a) {
              var b = a.type;
              return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
            }
            function Ua(a) {
              var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
              if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
                var e = c.get, f = c.set;
                Object.defineProperty(a, b, { configurable: true, get: function() {
                  return e.call(this);
                }, set: function(a2) {
                  d = "" + a2;
                  f.call(this, a2);
                } });
                Object.defineProperty(a, b, { enumerable: c.enumerable });
                return { getValue: function() {
                  return d;
                }, setValue: function(a2) {
                  d = "" + a2;
                }, stopTracking: function() {
                  a._valueTracker = null;
                  delete a[b];
                } };
              }
            }
            function Va(a) {
              a._valueTracker || (a._valueTracker = Ua(a));
            }
            function Wa(a) {
              if (!a) return false;
              var b = a._valueTracker;
              if (!b) return true;
              var c = b.getValue();
              var d = "";
              a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
              a = d;
              return a !== c ? (b.setValue(a), true) : false;
            }
            function Xa(a) {
              a = a || ("undefined" !== typeof document ? document : void 0);
              if ("undefined" === typeof a) return null;
              try {
                return a.activeElement || a.body;
              } catch (b) {
                return a.body;
              }
            }
            function Ya(a, b) {
              var c = b.checked;
              return m({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
            }
            function Za(a, b) {
              var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
              c = Sa(null != b.value ? b.value : c);
              a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
            }
            function $a(a, b) {
              b = b.checked;
              null != b && qa(a, "checked", b, false);
            }
            function ab(a, b) {
              $a(a, b);
              var c = Sa(b.value), d = b.type;
              if (null != c) if ("number" === d) {
                if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
              } else a.value !== "" + c && (a.value = "" + c);
              else if ("submit" === d || "reset" === d) {
                a.removeAttribute("value");
                return;
              }
              b.hasOwnProperty("value") ? bb(a, b.type, c) : b.hasOwnProperty("defaultValue") && bb(a, b.type, Sa(b.defaultValue));
              null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
            }
            function cb(a, b, c) {
              if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
                var d = b.type;
                if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
                b = "" + a._wrapperState.initialValue;
                c || b === a.value || (a.value = b);
                a.defaultValue = b;
              }
              c = a.name;
              "" !== c && (a.name = "");
              a.defaultChecked = !!a._wrapperState.initialChecked;
              "" !== c && (a.name = c);
            }
            function bb(a, b, c) {
              if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
            }
            function db(a) {
              var b = "";
              aa.Children.forEach(a, function(a2) {
                null != a2 && (b += a2);
              });
              return b;
            }
            function eb(a, b) {
              a = m({ children: void 0 }, b);
              if (b = db(b.children)) a.children = b;
              return a;
            }
            function fb(a, b, c, d) {
              a = a.options;
              if (b) {
                b = {};
                for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
                for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
              } else {
                c = "" + Sa(c);
                b = null;
                for (e = 0; e < a.length; e++) {
                  if (a[e].value === c) {
                    a[e].selected = true;
                    d && (a[e].defaultSelected = true);
                    return;
                  }
                  null !== b || a[e].disabled || (b = a[e]);
                }
                null !== b && (b.selected = true);
              }
            }
            function gb(a, b) {
              if (null != b.dangerouslySetInnerHTML) throw Error(y(91));
              return m({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
            }
            function hb(a, b) {
              var c = b.value;
              if (null == c) {
                c = b.children;
                b = b.defaultValue;
                if (null != c) {
                  if (null != b) throw Error(y(92));
                  if (Array.isArray(c)) {
                    if (!(1 >= c.length)) throw Error(y(93));
                    c = c[0];
                  }
                  b = c;
                }
                null == b && (b = "");
                c = b;
              }
              a._wrapperState = { initialValue: Sa(c) };
            }
            function ib(a, b) {
              var c = Sa(b.value), d = Sa(b.defaultValue);
              null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
              null != d && (a.defaultValue = "" + d);
            }
            function jb(a) {
              var b = a.textContent;
              b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
            }
            var kb = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
            function lb(a) {
              switch (a) {
                case "svg":
                  return "http://www.w3.org/2000/svg";
                case "math":
                  return "http://www.w3.org/1998/Math/MathML";
                default:
                  return "http://www.w3.org/1999/xhtml";
              }
            }
            function mb(a, b) {
              return null == a || "http://www.w3.org/1999/xhtml" === a ? lb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
            }
            var nb, ob = function(a) {
              return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
                MSApp.execUnsafeLocalFunction(function() {
                  return a(b, c, d, e);
                });
              } : a;
            }(function(a, b) {
              if (a.namespaceURI !== kb.svg || "innerHTML" in a) a.innerHTML = b;
              else {
                nb = nb || document.createElement("div");
                nb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
                for (b = nb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
                for (; b.firstChild; ) a.appendChild(b.firstChild);
              }
            });
            function pb(a, b) {
              if (b) {
                var c = a.firstChild;
                if (c && c === a.lastChild && 3 === c.nodeType) {
                  c.nodeValue = b;
                  return;
                }
              }
              a.textContent = b;
            }
            var qb = {
              animationIterationCount: true,
              borderImageOutset: true,
              borderImageSlice: true,
              borderImageWidth: true,
              boxFlex: true,
              boxFlexGroup: true,
              boxOrdinalGroup: true,
              columnCount: true,
              columns: true,
              flex: true,
              flexGrow: true,
              flexPositive: true,
              flexShrink: true,
              flexNegative: true,
              flexOrder: true,
              gridArea: true,
              gridRow: true,
              gridRowEnd: true,
              gridRowSpan: true,
              gridRowStart: true,
              gridColumn: true,
              gridColumnEnd: true,
              gridColumnSpan: true,
              gridColumnStart: true,
              fontWeight: true,
              lineClamp: true,
              lineHeight: true,
              opacity: true,
              order: true,
              orphans: true,
              tabSize: true,
              widows: true,
              zIndex: true,
              zoom: true,
              fillOpacity: true,
              floodOpacity: true,
              stopOpacity: true,
              strokeDasharray: true,
              strokeDashoffset: true,
              strokeMiterlimit: true,
              strokeOpacity: true,
              strokeWidth: true
            }, rb = ["Webkit", "ms", "Moz", "O"];
            Object.keys(qb).forEach(function(a) {
              rb.forEach(function(b) {
                b = b + a.charAt(0).toUpperCase() + a.substring(1);
                qb[b] = qb[a];
              });
            });
            function sb(a, b, c) {
              return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || qb.hasOwnProperty(a) && qb[a] ? ("" + b).trim() : b + "px";
            }
            function tb(a, b) {
              a = a.style;
              for (var c in b) if (b.hasOwnProperty(c)) {
                var d = 0 === c.indexOf("--"), e = sb(c, b[c], d);
                "float" === c && (c = "cssFloat");
                d ? a.setProperty(c, e) : a[c] = e;
              }
            }
            var ub = m({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
            function vb(a, b) {
              if (b) {
                if (ub[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(y(137, a));
                if (null != b.dangerouslySetInnerHTML) {
                  if (null != b.children) throw Error(y(60));
                  if (!("object" === typeof b.dangerouslySetInnerHTML && "__html" in b.dangerouslySetInnerHTML)) throw Error(y(61));
                }
                if (null != b.style && "object" !== typeof b.style) throw Error(y(62));
              }
            }
            function wb(a, b) {
              if (-1 === a.indexOf("-")) return "string" === typeof b.is;
              switch (a) {
                case "annotation-xml":
                case "color-profile":
                case "font-face":
                case "font-face-src":
                case "font-face-uri":
                case "font-face-format":
                case "font-face-name":
                case "missing-glyph":
                  return false;
                default:
                  return true;
              }
            }
            function xb(a) {
              a = a.target || a.srcElement || window;
              a.correspondingUseElement && (a = a.correspondingUseElement);
              return 3 === a.nodeType ? a.parentNode : a;
            }
            var yb = null, zb = null, Ab = null;
            function Bb(a) {
              if (a = Cb(a)) {
                if ("function" !== typeof yb) throw Error(y(280));
                var b = a.stateNode;
                b && (b = Db(b), yb(a.stateNode, a.type, b));
              }
            }
            function Eb(a) {
              zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
            }
            function Fb() {
              if (zb) {
                var a = zb, b = Ab;
                Ab = zb = null;
                Bb(a);
                if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
              }
            }
            function Gb(a, b) {
              return a(b);
            }
            function Hb(a, b, c, d, e) {
              return a(b, c, d, e);
            }
            function Ib() {
            }
            var Jb = Gb, Kb = false, Lb = false;
            function Mb() {
              if (null !== zb || null !== Ab) Ib(), Fb();
            }
            function Nb(a, b, c) {
              if (Lb) return a(b, c);
              Lb = true;
              try {
                return Jb(a, b, c);
              } finally {
                Lb = false, Mb();
              }
            }
            function Ob(a, b) {
              var c = a.stateNode;
              if (null === c) return null;
              var d = Db(c);
              if (null === d) return null;
              c = d[b];
              a: switch (b) {
                case "onClick":
                case "onClickCapture":
                case "onDoubleClick":
                case "onDoubleClickCapture":
                case "onMouseDown":
                case "onMouseDownCapture":
                case "onMouseMove":
                case "onMouseMoveCapture":
                case "onMouseUp":
                case "onMouseUpCapture":
                case "onMouseEnter":
                  (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
                  a = !d;
                  break a;
                default:
                  a = false;
              }
              if (a) return null;
              if (c && "function" !== typeof c) throw Error(y(231, b, typeof c));
              return c;
            }
            var Pb = false;
            if (fa) try {
              var Qb = {};
              Object.defineProperty(Qb, "passive", { get: function() {
                Pb = true;
              } });
              window.addEventListener("test", Qb, Qb);
              window.removeEventListener("test", Qb, Qb);
            } catch (a) {
              Pb = false;
            }
            function Rb(a, b, c, d, e, f, g, h, k) {
              var l = Array.prototype.slice.call(arguments, 3);
              try {
                b.apply(c, l);
              } catch (n) {
                this.onError(n);
              }
            }
            var Sb = false, Tb = null, Ub = false, Vb = null, Wb = { onError: function(a) {
              Sb = true;
              Tb = a;
            } };
            function Xb(a, b, c, d, e, f, g, h, k) {
              Sb = false;
              Tb = null;
              Rb.apply(Wb, arguments);
            }
            function Yb(a, b, c, d, e, f, g, h, k) {
              Xb.apply(this, arguments);
              if (Sb) {
                if (Sb) {
                  var l = Tb;
                  Sb = false;
                  Tb = null;
                } else throw Error(y(198));
                Ub || (Ub = true, Vb = l);
              }
            }
            function Zb(a) {
              var b = a, c = a;
              if (a.alternate) for (; b.return; ) b = b.return;
              else {
                a = b;
                do
                  b = a, 0 !== (b.flags & 1026) && (c = b.return), a = b.return;
                while (a);
              }
              return 3 === b.tag ? c : null;
            }
            function $b(a) {
              if (13 === a.tag) {
                var b = a.memoizedState;
                null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
                if (null !== b) return b.dehydrated;
              }
              return null;
            }
            function ac(a) {
              if (Zb(a) !== a) throw Error(y(188));
            }
            function bc(a) {
              var b = a.alternate;
              if (!b) {
                b = Zb(a);
                if (null === b) throw Error(y(188));
                return b !== a ? null : a;
              }
              for (var c = a, d = b; ; ) {
                var e = c.return;
                if (null === e) break;
                var f = e.alternate;
                if (null === f) {
                  d = e.return;
                  if (null !== d) {
                    c = d;
                    continue;
                  }
                  break;
                }
                if (e.child === f.child) {
                  for (f = e.child; f; ) {
                    if (f === c) return ac(e), a;
                    if (f === d) return ac(e), b;
                    f = f.sibling;
                  }
                  throw Error(y(188));
                }
                if (c.return !== d.return) c = e, d = f;
                else {
                  for (var g = false, h = e.child; h; ) {
                    if (h === c) {
                      g = true;
                      c = e;
                      d = f;
                      break;
                    }
                    if (h === d) {
                      g = true;
                      d = e;
                      c = f;
                      break;
                    }
                    h = h.sibling;
                  }
                  if (!g) {
                    for (h = f.child; h; ) {
                      if (h === c) {
                        g = true;
                        c = f;
                        d = e;
                        break;
                      }
                      if (h === d) {
                        g = true;
                        d = f;
                        c = e;
                        break;
                      }
                      h = h.sibling;
                    }
                    if (!g) throw Error(y(189));
                  }
                }
                if (c.alternate !== d) throw Error(y(190));
              }
              if (3 !== c.tag) throw Error(y(188));
              return c.stateNode.current === c ? a : b;
            }
            function cc(a) {
              a = bc(a);
              if (!a) return null;
              for (var b = a; ; ) {
                if (5 === b.tag || 6 === b.tag) return b;
                if (b.child) b.child.return = b, b = b.child;
                else {
                  if (b === a) break;
                  for (; !b.sibling; ) {
                    if (!b.return || b.return === a) return null;
                    b = b.return;
                  }
                  b.sibling.return = b.return;
                  b = b.sibling;
                }
              }
              return null;
            }
            function dc(a, b) {
              for (var c = a.alternate; null !== b; ) {
                if (b === a || b === c) return true;
                b = b.return;
              }
              return false;
            }
            var ec, fc, gc, hc, ic = false, jc = [], kc = null, lc = null, mc = null, nc = /* @__PURE__ */ new Map(), oc = /* @__PURE__ */ new Map(), pc = [], qc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
            function rc(a, b, c, d, e) {
              return { blockedOn: a, domEventName: b, eventSystemFlags: c | 16, nativeEvent: e, targetContainers: [d] };
            }
            function sc(a, b) {
              switch (a) {
                case "focusin":
                case "focusout":
                  kc = null;
                  break;
                case "dragenter":
                case "dragleave":
                  lc = null;
                  break;
                case "mouseover":
                case "mouseout":
                  mc = null;
                  break;
                case "pointerover":
                case "pointerout":
                  nc.delete(b.pointerId);
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                  oc.delete(b.pointerId);
              }
            }
            function tc(a, b, c, d, e, f) {
              if (null === a || a.nativeEvent !== f) return a = rc(b, c, d, e, f), null !== b && (b = Cb(b), null !== b && fc(b)), a;
              a.eventSystemFlags |= d;
              b = a.targetContainers;
              null !== e && -1 === b.indexOf(e) && b.push(e);
              return a;
            }
            function uc(a, b, c, d, e) {
              switch (b) {
                case "focusin":
                  return kc = tc(kc, a, b, c, d, e), true;
                case "dragenter":
                  return lc = tc(lc, a, b, c, d, e), true;
                case "mouseover":
                  return mc = tc(mc, a, b, c, d, e), true;
                case "pointerover":
                  var f = e.pointerId;
                  nc.set(f, tc(nc.get(f) || null, a, b, c, d, e));
                  return true;
                case "gotpointercapture":
                  return f = e.pointerId, oc.set(f, tc(oc.get(f) || null, a, b, c, d, e)), true;
              }
              return false;
            }
            function vc(a) {
              var b = wc(a.target);
              if (null !== b) {
                var c = Zb(b);
                if (null !== c) {
                  if (b = c.tag, 13 === b) {
                    if (b = $b(c), null !== b) {
                      a.blockedOn = b;
                      hc(a.lanePriority, function() {
                        r.unstable_runWithPriority(a.priority, function() {
                          gc(c);
                        });
                      });
                      return;
                    }
                  } else if (3 === b && c.stateNode.hydrate) {
                    a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
                    return;
                  }
                }
              }
              a.blockedOn = null;
            }
            function xc(a) {
              if (null !== a.blockedOn) return false;
              for (var b = a.targetContainers; 0 < b.length; ) {
                var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
                if (null !== c) return b = Cb(c), null !== b && fc(b), a.blockedOn = c, false;
                b.shift();
              }
              return true;
            }
            function zc(a, b, c) {
              xc(a) && c.delete(b);
            }
            function Ac() {
              for (ic = false; 0 < jc.length; ) {
                var a = jc[0];
                if (null !== a.blockedOn) {
                  a = Cb(a.blockedOn);
                  null !== a && ec(a);
                  break;
                }
                for (var b = a.targetContainers; 0 < b.length; ) {
                  var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
                  if (null !== c) {
                    a.blockedOn = c;
                    break;
                  }
                  b.shift();
                }
                null === a.blockedOn && jc.shift();
              }
              null !== kc && xc(kc) && (kc = null);
              null !== lc && xc(lc) && (lc = null);
              null !== mc && xc(mc) && (mc = null);
              nc.forEach(zc);
              oc.forEach(zc);
            }
            function Bc(a, b) {
              a.blockedOn === b && (a.blockedOn = null, ic || (ic = true, r.unstable_scheduleCallback(r.unstable_NormalPriority, Ac)));
            }
            function Cc(a) {
              function b(b2) {
                return Bc(b2, a);
              }
              if (0 < jc.length) {
                Bc(jc[0], a);
                for (var c = 1; c < jc.length; c++) {
                  var d = jc[c];
                  d.blockedOn === a && (d.blockedOn = null);
                }
              }
              null !== kc && Bc(kc, a);
              null !== lc && Bc(lc, a);
              null !== mc && Bc(mc, a);
              nc.forEach(b);
              oc.forEach(b);
              for (c = 0; c < pc.length; c++) d = pc[c], d.blockedOn === a && (d.blockedOn = null);
              for (; 0 < pc.length && (c = pc[0], null === c.blockedOn); ) vc(c), null === c.blockedOn && pc.shift();
            }
            function Dc(a, b) {
              var c = {};
              c[a.toLowerCase()] = b.toLowerCase();
              c["Webkit" + a] = "webkit" + b;
              c["Moz" + a] = "moz" + b;
              return c;
            }
            var Ec = { animationend: Dc("Animation", "AnimationEnd"), animationiteration: Dc("Animation", "AnimationIteration"), animationstart: Dc("Animation", "AnimationStart"), transitionend: Dc("Transition", "TransitionEnd") }, Fc = {}, Gc = {};
            fa && (Gc = document.createElement("div").style, "AnimationEvent" in window || (delete Ec.animationend.animation, delete Ec.animationiteration.animation, delete Ec.animationstart.animation), "TransitionEvent" in window || delete Ec.transitionend.transition);
            function Hc(a) {
              if (Fc[a]) return Fc[a];
              if (!Ec[a]) return a;
              var b = Ec[a], c;
              for (c in b) if (b.hasOwnProperty(c) && c in Gc) return Fc[a] = b[c];
              return a;
            }
            var Ic = Hc("animationend"), Jc = Hc("animationiteration"), Kc = Hc("animationstart"), Lc = Hc("transitionend"), Mc = /* @__PURE__ */ new Map(), Nc = /* @__PURE__ */ new Map(), Oc = [
              "abort",
              "abort",
              Ic,
              "animationEnd",
              Jc,
              "animationIteration",
              Kc,
              "animationStart",
              "canplay",
              "canPlay",
              "canplaythrough",
              "canPlayThrough",
              "durationchange",
              "durationChange",
              "emptied",
              "emptied",
              "encrypted",
              "encrypted",
              "ended",
              "ended",
              "error",
              "error",
              "gotpointercapture",
              "gotPointerCapture",
              "load",
              "load",
              "loadeddata",
              "loadedData",
              "loadedmetadata",
              "loadedMetadata",
              "loadstart",
              "loadStart",
              "lostpointercapture",
              "lostPointerCapture",
              "playing",
              "playing",
              "progress",
              "progress",
              "seeking",
              "seeking",
              "stalled",
              "stalled",
              "suspend",
              "suspend",
              "timeupdate",
              "timeUpdate",
              Lc,
              "transitionEnd",
              "waiting",
              "waiting"
            ];
            function Pc(a, b) {
              for (var c = 0; c < a.length; c += 2) {
                var d = a[c], e = a[c + 1];
                e = "on" + (e[0].toUpperCase() + e.slice(1));
                Nc.set(d, b);
                Mc.set(d, e);
                da(e, [d]);
              }
            }
            var Qc = r.unstable_now;
            Qc();
            var F = 8;
            function Rc(a) {
              if (0 !== (1 & a)) return F = 15, 1;
              if (0 !== (2 & a)) return F = 14, 2;
              if (0 !== (4 & a)) return F = 13, 4;
              var b = 24 & a;
              if (0 !== b) return F = 12, b;
              if (0 !== (a & 32)) return F = 11, 32;
              b = 192 & a;
              if (0 !== b) return F = 10, b;
              if (0 !== (a & 256)) return F = 9, 256;
              b = 3584 & a;
              if (0 !== b) return F = 8, b;
              if (0 !== (a & 4096)) return F = 7, 4096;
              b = 4186112 & a;
              if (0 !== b) return F = 6, b;
              b = 62914560 & a;
              if (0 !== b) return F = 5, b;
              if (a & 67108864) return F = 4, 67108864;
              if (0 !== (a & 134217728)) return F = 3, 134217728;
              b = 805306368 & a;
              if (0 !== b) return F = 2, b;
              if (0 !== (1073741824 & a)) return F = 1, 1073741824;
              F = 8;
              return a;
            }
            function Sc(a) {
              switch (a) {
                case 99:
                  return 15;
                case 98:
                  return 10;
                case 97:
                case 96:
                  return 8;
                case 95:
                  return 2;
                default:
                  return 0;
              }
            }
            function Tc(a) {
              switch (a) {
                case 15:
                case 14:
                  return 99;
                case 13:
                case 12:
                case 11:
                case 10:
                  return 98;
                case 9:
                case 8:
                case 7:
                case 6:
                case 4:
                case 5:
                  return 97;
                case 3:
                case 2:
                case 1:
                  return 95;
                case 0:
                  return 90;
                default:
                  throw Error(y(358, a));
              }
            }
            function Uc(a, b) {
              var c = a.pendingLanes;
              if (0 === c) return F = 0;
              var d = 0, e = 0, f = a.expiredLanes, g = a.suspendedLanes, h = a.pingedLanes;
              if (0 !== f) d = f, e = F = 15;
              else if (f = c & 134217727, 0 !== f) {
                var k = f & ~g;
                0 !== k ? (d = Rc(k), e = F) : (h &= f, 0 !== h && (d = Rc(h), e = F));
              } else f = c & ~g, 0 !== f ? (d = Rc(f), e = F) : 0 !== h && (d = Rc(h), e = F);
              if (0 === d) return 0;
              d = 31 - Vc(d);
              d = c & ((0 > d ? 0 : 1 << d) << 1) - 1;
              if (0 !== b && b !== d && 0 === (b & g)) {
                Rc(b);
                if (e <= F) return b;
                F = e;
              }
              b = a.entangledLanes;
              if (0 !== b) for (a = a.entanglements, b &= d; 0 < b; ) c = 31 - Vc(b), e = 1 << c, d |= a[c], b &= ~e;
              return d;
            }
            function Wc(a) {
              a = a.pendingLanes & -1073741825;
              return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
            }
            function Xc(a, b) {
              switch (a) {
                case 15:
                  return 1;
                case 14:
                  return 2;
                case 12:
                  return a = Yc(24 & ~b), 0 === a ? Xc(10, b) : a;
                case 10:
                  return a = Yc(192 & ~b), 0 === a ? Xc(8, b) : a;
                case 8:
                  return a = Yc(3584 & ~b), 0 === a && (a = Yc(4186112 & ~b), 0 === a && (a = 512)), a;
                case 2:
                  return b = Yc(805306368 & ~b), 0 === b && (b = 268435456), b;
              }
              throw Error(y(358, a));
            }
            function Yc(a) {
              return a & -a;
            }
            function Zc(a) {
              for (var b = [], c = 0; 31 > c; c++) b.push(a);
              return b;
            }
            function $c(a, b, c) {
              a.pendingLanes |= b;
              var d = b - 1;
              a.suspendedLanes &= d;
              a.pingedLanes &= d;
              a = a.eventTimes;
              b = 31 - Vc(b);
              a[b] = c;
            }
            var Vc = Math.clz32 ? Math.clz32 : ad, bd = Math.log, cd = Math.LN2;
            function ad(a) {
              return 0 === a ? 32 : 31 - (bd(a) / cd | 0) | 0;
            }
            var dd = r.unstable_UserBlockingPriority, ed = r.unstable_runWithPriority, fd = true;
            function gd(a, b, c, d) {
              Kb || Ib();
              var e = hd, f = Kb;
              Kb = true;
              try {
                Hb(e, a, b, c, d);
              } finally {
                (Kb = f) || Mb();
              }
            }
            function id(a, b, c, d) {
              ed(dd, hd.bind(null, a, b, c, d));
            }
            function hd(a, b, c, d) {
              if (fd) {
                var e;
                if ((e = 0 === (b & 4)) && 0 < jc.length && -1 < qc.indexOf(a)) a = rc(null, a, b, c, d), jc.push(a);
                else {
                  var f = yc(a, b, c, d);
                  if (null === f) e && sc(a, d);
                  else {
                    if (e) {
                      if (-1 < qc.indexOf(a)) {
                        a = rc(f, a, b, c, d);
                        jc.push(a);
                        return;
                      }
                      if (uc(f, a, b, c, d)) return;
                      sc(a, d);
                    }
                    jd(a, b, d, null, c);
                  }
                }
              }
            }
            function yc(a, b, c, d) {
              var e = xb(d);
              e = wc(e);
              if (null !== e) {
                var f = Zb(e);
                if (null === f) e = null;
                else {
                  var g = f.tag;
                  if (13 === g) {
                    e = $b(f);
                    if (null !== e) return e;
                    e = null;
                  } else if (3 === g) {
                    if (f.stateNode.hydrate) return 3 === f.tag ? f.stateNode.containerInfo : null;
                    e = null;
                  } else f !== e && (e = null);
                }
              }
              jd(a, b, d, e, c);
              return null;
            }
            var kd = null, ld = null, md = null;
            function nd() {
              if (md) return md;
              var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
              for (a = 0; a < c && b[a] === e[a]; a++) ;
              var g = c - a;
              for (d = 1; d <= g && b[c - d] === e[f - d]; d++) ;
              return md = e.slice(a, 1 < d ? 1 - d : void 0);
            }
            function od(a) {
              var b = a.keyCode;
              "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
              10 === a && (a = 13);
              return 32 <= a || 13 === a ? a : 0;
            }
            function pd() {
              return true;
            }
            function qd() {
              return false;
            }
            function rd(a) {
              function b(b2, d, e, f, g) {
                this._reactName = b2;
                this._targetInst = e;
                this.type = d;
                this.nativeEvent = f;
                this.target = g;
                this.currentTarget = null;
                for (var c in a) a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
                this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
                this.isPropagationStopped = qd;
                return this;
              }
              m(b.prototype, { preventDefault: function() {
                this.defaultPrevented = true;
                var a2 = this.nativeEvent;
                a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
              }, stopPropagation: function() {
                var a2 = this.nativeEvent;
                a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
              }, persist: function() {
              }, isPersistent: pd });
              return b;
            }
            var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
              return a.timeStamp || Date.now();
            }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = m({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = m({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
              return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
            }, movementX: function(a) {
              if ("movementX" in a) return a.movementX;
              a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
              return wd;
            }, movementY: function(a) {
              return "movementY" in a ? a.movementY : xd;
            } }), Bd = rd(Ad), Cd = m({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = m({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = m({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = m({}, sd, { clipboardData: function(a) {
              return "clipboardData" in a ? a.clipboardData : window.clipboardData;
            } }), Jd = rd(Id), Kd = m({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
              Esc: "Escape",
              Spacebar: " ",
              Left: "ArrowLeft",
              Up: "ArrowUp",
              Right: "ArrowRight",
              Down: "ArrowDown",
              Del: "Delete",
              Win: "OS",
              Menu: "ContextMenu",
              Apps: "ContextMenu",
              Scroll: "ScrollLock",
              MozPrintableKey: "Unidentified"
            }, Nd = {
              8: "Backspace",
              9: "Tab",
              12: "Clear",
              13: "Enter",
              16: "Shift",
              17: "Control",
              18: "Alt",
              19: "Pause",
              20: "CapsLock",
              27: "Escape",
              32: " ",
              33: "PageUp",
              34: "PageDown",
              35: "End",
              36: "Home",
              37: "ArrowLeft",
              38: "ArrowUp",
              39: "ArrowRight",
              40: "ArrowDown",
              45: "Insert",
              46: "Delete",
              112: "F1",
              113: "F2",
              114: "F3",
              115: "F4",
              116: "F5",
              117: "F6",
              118: "F7",
              119: "F8",
              120: "F9",
              121: "F10",
              122: "F11",
              123: "F12",
              144: "NumLock",
              145: "ScrollLock",
              224: "Meta"
            }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
            function Pd(a) {
              var b = this.nativeEvent;
              return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
            }
            function zd() {
              return Pd;
            }
            var Qd = m({}, ud, { key: function(a) {
              if (a.key) {
                var b = Md[a.key] || a.key;
                if ("Unidentified" !== b) return b;
              }
              return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
            }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
              return "keypress" === a.type ? od(a) : 0;
            }, keyCode: function(a) {
              return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
            }, which: function(a) {
              return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
            } }), Rd = rd(Qd), Sd = m({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = m({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = m({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = m({}, Ad, {
              deltaX: function(a) {
                return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
              },
              deltaY: function(a) {
                return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
              },
              deltaZ: 0,
              deltaMode: 0
            }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = fa && "CompositionEvent" in window, be = null;
            fa && "documentMode" in document && (be = document.documentMode);
            var ce = fa && "TextEvent" in window && !be, de = fa && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
            function ge(a, b) {
              switch (a) {
                case "keyup":
                  return -1 !== $d.indexOf(b.keyCode);
                case "keydown":
                  return 229 !== b.keyCode;
                case "keypress":
                case "mousedown":
                case "focusout":
                  return true;
                default:
                  return false;
              }
            }
            function he(a) {
              a = a.detail;
              return "object" === typeof a && "data" in a ? a.data : null;
            }
            var ie = false;
            function je(a, b) {
              switch (a) {
                case "compositionend":
                  return he(b);
                case "keypress":
                  if (32 !== b.which) return null;
                  fe = true;
                  return ee;
                case "textInput":
                  return a = b.data, a === ee && fe ? null : a;
                default:
                  return null;
              }
            }
            function ke(a, b) {
              if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
              switch (a) {
                case "paste":
                  return null;
                case "keypress":
                  if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
                    if (b.char && 1 < b.char.length) return b.char;
                    if (b.which) return String.fromCharCode(b.which);
                  }
                  return null;
                case "compositionend":
                  return de && "ko" !== b.locale ? null : b.data;
                default:
                  return null;
              }
            }
            var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
            function me(a) {
              var b = a && a.nodeName && a.nodeName.toLowerCase();
              return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
            }
            function ne(a, b, c, d) {
              Eb(d);
              b = oe(b, "onChange");
              0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
            }
            var pe = null, qe = null;
            function re(a) {
              se(a, 0);
            }
            function te(a) {
              var b = ue(a);
              if (Wa(b)) return a;
            }
            function ve(a, b) {
              if ("change" === a) return b;
            }
            var we = false;
            if (fa) {
              var xe;
              if (fa) {
                var ye = "oninput" in document;
                if (!ye) {
                  var ze = document.createElement("div");
                  ze.setAttribute("oninput", "return;");
                  ye = "function" === typeof ze.oninput;
                }
                xe = ye;
              } else xe = false;
              we = xe && (!document.documentMode || 9 < document.documentMode);
            }
            function Ae() {
              pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
            }
            function Be(a) {
              if ("value" === a.propertyName && te(qe)) {
                var b = [];
                ne(b, qe, a, xb(a));
                a = re;
                if (Kb) a(b);
                else {
                  Kb = true;
                  try {
                    Gb(a, b);
                  } finally {
                    Kb = false, Mb();
                  }
                }
              }
            }
            function Ce(a, b, c) {
              "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
            }
            function De(a) {
              if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
            }
            function Ee(a, b) {
              if ("click" === a) return te(b);
            }
            function Fe(a, b) {
              if ("input" === a || "change" === a) return te(b);
            }
            function Ge(a, b) {
              return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
            }
            var He = "function" === typeof Object.is ? Object.is : Ge, Ie = Object.prototype.hasOwnProperty;
            function Je(a, b) {
              if (He(a, b)) return true;
              if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return false;
              var c = Object.keys(a), d = Object.keys(b);
              if (c.length !== d.length) return false;
              for (d = 0; d < c.length; d++) if (!Ie.call(b, c[d]) || !He(a[c[d]], b[c[d]])) return false;
              return true;
            }
            function Ke(a) {
              for (; a && a.firstChild; ) a = a.firstChild;
              return a;
            }
            function Le(a, b) {
              var c = Ke(a);
              a = 0;
              for (var d; c; ) {
                if (3 === c.nodeType) {
                  d = a + c.textContent.length;
                  if (a <= b && d >= b) return { node: c, offset: b - a };
                  a = d;
                }
                a: {
                  for (; c; ) {
                    if (c.nextSibling) {
                      c = c.nextSibling;
                      break a;
                    }
                    c = c.parentNode;
                  }
                  c = void 0;
                }
                c = Ke(c);
              }
            }
            function Me(a, b) {
              return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Me(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
            }
            function Ne() {
              for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
                try {
                  var c = "string" === typeof b.contentWindow.location.href;
                } catch (d) {
                  c = false;
                }
                if (c) a = b.contentWindow;
                else break;
                b = Xa(a.document);
              }
              return b;
            }
            function Oe(a) {
              var b = a && a.nodeName && a.nodeName.toLowerCase();
              return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
            }
            var Pe = fa && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
            function Ue(a, b, c) {
              var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
              Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Oe(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Je(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
            }
            Pc(
              "cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
              0
            );
            Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
            Pc(Oc, 2);
            for (var Ve = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), We = 0; We < Ve.length; We++) Nc.set(Ve[We], 0);
            ea("onMouseEnter", ["mouseout", "mouseover"]);
            ea("onMouseLeave", ["mouseout", "mouseover"]);
            ea("onPointerEnter", ["pointerout", "pointerover"]);
            ea("onPointerLeave", ["pointerout", "pointerover"]);
            da("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
            da("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
            da("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
            da("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
            da("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
            da("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
            var Xe = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Ye = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));
            function Ze(a, b, c) {
              var d = a.type || "unknown-event";
              a.currentTarget = c;
              Yb(d, b, void 0, a);
              a.currentTarget = null;
            }
            function se(a, b) {
              b = 0 !== (b & 4);
              for (var c = 0; c < a.length; c++) {
                var d = a[c], e = d.event;
                d = d.listeners;
                a: {
                  var f = void 0;
                  if (b) for (var g = d.length - 1; 0 <= g; g--) {
                    var h = d[g], k = h.instance, l = h.currentTarget;
                    h = h.listener;
                    if (k !== f && e.isPropagationStopped()) break a;
                    Ze(e, h, l);
                    f = k;
                  }
                  else for (g = 0; g < d.length; g++) {
                    h = d[g];
                    k = h.instance;
                    l = h.currentTarget;
                    h = h.listener;
                    if (k !== f && e.isPropagationStopped()) break a;
                    Ze(e, h, l);
                    f = k;
                  }
                }
              }
              if (Ub) throw a = Vb, Ub = false, Vb = null, a;
            }
            function G(a, b) {
              var c = $e(b), d = a + "__bubble";
              c.has(d) || (af(b, a, 2, false), c.add(d));
            }
            var bf = "_reactListening" + Math.random().toString(36).slice(2);
            function cf(a) {
              a[bf] || (a[bf] = true, ba.forEach(function(b) {
                Ye.has(b) || df(b, false, a, null);
                df(b, true, a, null);
              }));
            }
            function df(a, b, c, d) {
              var e = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0, f = c;
              "selectionchange" === a && 9 !== c.nodeType && (f = c.ownerDocument);
              if (null !== d && !b && Ye.has(a)) {
                if ("scroll" !== a) return;
                e |= 2;
                f = d;
              }
              var g = $e(f), h = a + "__" + (b ? "capture" : "bubble");
              g.has(h) || (b && (e |= 4), af(f, a, e, b), g.add(h));
            }
            function af(a, b, c, d) {
              var e = Nc.get(b);
              switch (void 0 === e ? 2 : e) {
                case 0:
                  e = gd;
                  break;
                case 1:
                  e = id;
                  break;
                default:
                  e = hd;
              }
              c = e.bind(null, b, c, a);
              e = void 0;
              !Pb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
              d ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
            }
            function jd(a, b, c, d, e) {
              var f = d;
              if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (; ; ) {
                if (null === d) return;
                var g = d.tag;
                if (3 === g || 4 === g) {
                  var h = d.stateNode.containerInfo;
                  if (h === e || 8 === h.nodeType && h.parentNode === e) break;
                  if (4 === g) for (g = d.return; null !== g; ) {
                    var k = g.tag;
                    if (3 === k || 4 === k) {
                      if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
                    }
                    g = g.return;
                  }
                  for (; null !== h; ) {
                    g = wc(h);
                    if (null === g) return;
                    k = g.tag;
                    if (5 === k || 6 === k) {
                      d = f = g;
                      continue a;
                    }
                    h = h.parentNode;
                  }
                }
                d = d.return;
              }
              Nb(function() {
                var d2 = f, e2 = xb(c), g2 = [];
                a: {
                  var h2 = Mc.get(a);
                  if (void 0 !== h2) {
                    var k2 = td, x = a;
                    switch (a) {
                      case "keypress":
                        if (0 === od(c)) break a;
                      case "keydown":
                      case "keyup":
                        k2 = Rd;
                        break;
                      case "focusin":
                        x = "focus";
                        k2 = Fd;
                        break;
                      case "focusout":
                        x = "blur";
                        k2 = Fd;
                        break;
                      case "beforeblur":
                      case "afterblur":
                        k2 = Fd;
                        break;
                      case "click":
                        if (2 === c.button) break a;
                      case "auxclick":
                      case "dblclick":
                      case "mousedown":
                      case "mousemove":
                      case "mouseup":
                      case "mouseout":
                      case "mouseover":
                      case "contextmenu":
                        k2 = Bd;
                        break;
                      case "drag":
                      case "dragend":
                      case "dragenter":
                      case "dragexit":
                      case "dragleave":
                      case "dragover":
                      case "dragstart":
                      case "drop":
                        k2 = Dd;
                        break;
                      case "touchcancel":
                      case "touchend":
                      case "touchmove":
                      case "touchstart":
                        k2 = Vd;
                        break;
                      case Ic:
                      case Jc:
                      case Kc:
                        k2 = Hd;
                        break;
                      case Lc:
                        k2 = Xd;
                        break;
                      case "scroll":
                        k2 = vd;
                        break;
                      case "wheel":
                        k2 = Zd;
                        break;
                      case "copy":
                      case "cut":
                      case "paste":
                        k2 = Jd;
                        break;
                      case "gotpointercapture":
                      case "lostpointercapture":
                      case "pointercancel":
                      case "pointerdown":
                      case "pointermove":
                      case "pointerout":
                      case "pointerover":
                      case "pointerup":
                        k2 = Td;
                    }
                    var w = 0 !== (b & 4), z = !w && "scroll" === a, u = w ? null !== h2 ? h2 + "Capture" : null : h2;
                    w = [];
                    for (var t = d2, q; null !== t; ) {
                      q = t;
                      var v = q.stateNode;
                      5 === q.tag && null !== v && (q = v, null !== u && (v = Ob(t, u), null != v && w.push(ef(t, v, q))));
                      if (z) break;
                      t = t.return;
                    }
                    0 < w.length && (h2 = new k2(h2, x, null, c, e2), g2.push({ event: h2, listeners: w }));
                  }
                }
                if (0 === (b & 7)) {
                  a: {
                    h2 = "mouseover" === a || "pointerover" === a;
                    k2 = "mouseout" === a || "pointerout" === a;
                    if (h2 && 0 === (b & 16) && (x = c.relatedTarget || c.fromElement) && (wc(x) || x[ff])) break a;
                    if (k2 || h2) {
                      h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
                      if (k2) {
                        if (x = c.relatedTarget || c.toElement, k2 = d2, x = x ? wc(x) : null, null !== x && (z = Zb(x), x !== z || 5 !== x.tag && 6 !== x.tag)) x = null;
                      } else k2 = null, x = d2;
                      if (k2 !== x) {
                        w = Bd;
                        v = "onMouseLeave";
                        u = "onMouseEnter";
                        t = "mouse";
                        if ("pointerout" === a || "pointerover" === a) w = Td, v = "onPointerLeave", u = "onPointerEnter", t = "pointer";
                        z = null == k2 ? h2 : ue(k2);
                        q = null == x ? h2 : ue(x);
                        h2 = new w(v, t + "leave", k2, c, e2);
                        h2.target = z;
                        h2.relatedTarget = q;
                        v = null;
                        wc(e2) === d2 && (w = new w(u, t + "enter", x, c, e2), w.target = q, w.relatedTarget = z, v = w);
                        z = v;
                        if (k2 && x) b: {
                          w = k2;
                          u = x;
                          t = 0;
                          for (q = w; q; q = gf(q)) t++;
                          q = 0;
                          for (v = u; v; v = gf(v)) q++;
                          for (; 0 < t - q; ) w = gf(w), t--;
                          for (; 0 < q - t; ) u = gf(u), q--;
                          for (; t--; ) {
                            if (w === u || null !== u && w === u.alternate) break b;
                            w = gf(w);
                            u = gf(u);
                          }
                          w = null;
                        }
                        else w = null;
                        null !== k2 && hf(g2, h2, k2, w, false);
                        null !== x && null !== z && hf(g2, z, x, w, true);
                      }
                    }
                  }
                  a: {
                    h2 = d2 ? ue(d2) : window;
                    k2 = h2.nodeName && h2.nodeName.toLowerCase();
                    if ("select" === k2 || "input" === k2 && "file" === h2.type) var J = ve;
                    else if (me(h2)) if (we) J = Fe;
                    else {
                      J = De;
                      var K = Ce;
                    }
                    else (k2 = h2.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (J = Ee);
                    if (J && (J = J(a, d2))) {
                      ne(g2, J, c, e2);
                      break a;
                    }
                    K && K(a, h2, d2);
                    "focusout" === a && (K = h2._wrapperState) && K.controlled && "number" === h2.type && bb(h2, "number", h2.value);
                  }
                  K = d2 ? ue(d2) : window;
                  switch (a) {
                    case "focusin":
                      if (me(K) || "true" === K.contentEditable) Qe = K, Re = d2, Se = null;
                      break;
                    case "focusout":
                      Se = Re = Qe = null;
                      break;
                    case "mousedown":
                      Te = true;
                      break;
                    case "contextmenu":
                    case "mouseup":
                    case "dragend":
                      Te = false;
                      Ue(g2, c, e2);
                      break;
                    case "selectionchange":
                      if (Pe) break;
                    case "keydown":
                    case "keyup":
                      Ue(g2, c, e2);
                  }
                  var Q;
                  if (ae) b: {
                    switch (a) {
                      case "compositionstart":
                        var L = "onCompositionStart";
                        break b;
                      case "compositionend":
                        L = "onCompositionEnd";
                        break b;
                      case "compositionupdate":
                        L = "onCompositionUpdate";
                        break b;
                    }
                    L = void 0;
                  }
                  else ie ? ge(a, c) && (L = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (L = "onCompositionStart");
                  L && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== L ? "onCompositionEnd" === L && ie && (Q = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), K = oe(d2, L), 0 < K.length && (L = new Ld(L, a, null, c, e2), g2.push({ event: L, listeners: K }), Q ? L.data = Q : (Q = he(c), null !== Q && (L.data = Q))));
                  if (Q = ce ? je(a, c) : ke(a, c)) d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld(
                    "onBeforeInput",
                    "beforeinput",
                    null,
                    c,
                    e2
                  ), g2.push({ event: e2, listeners: d2 }), e2.data = Q);
                }
                se(g2, b);
              });
            }
            function ef(a, b, c) {
              return { instance: a, listener: b, currentTarget: c };
            }
            function oe(a, b) {
              for (var c = b + "Capture", d = []; null !== a; ) {
                var e = a, f = e.stateNode;
                5 === e.tag && null !== f && (e = f, f = Ob(a, c), null != f && d.unshift(ef(a, f, e)), f = Ob(a, b), null != f && d.push(ef(a, f, e)));
                a = a.return;
              }
              return d;
            }
            function gf(a) {
              if (null === a) return null;
              do
                a = a.return;
              while (a && 5 !== a.tag);
              return a ? a : null;
            }
            function hf(a, b, c, d, e) {
              for (var f = b._reactName, g = []; null !== c && c !== d; ) {
                var h = c, k = h.alternate, l = h.stateNode;
                if (null !== k && k === d) break;
                5 === h.tag && null !== l && (h = l, e ? (k = Ob(c, f), null != k && g.unshift(ef(c, k, h))) : e || (k = Ob(c, f), null != k && g.push(ef(c, k, h))));
                c = c.return;
              }
              0 !== g.length && a.push({ event: b, listeners: g });
            }
            function jf() {
            }
            var kf = null, lf = null;
            function mf(a, b) {
              switch (a) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  return !!b.autoFocus;
              }
              return false;
            }
            function nf(a, b) {
              return "textarea" === a || "option" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
            }
            var of = "function" === typeof setTimeout ? setTimeout : void 0, pf = "function" === typeof clearTimeout ? clearTimeout : void 0;
            function qf(a) {
              1 === a.nodeType ? a.textContent = "" : 9 === a.nodeType && (a = a.body, null != a && (a.textContent = ""));
            }
            function rf(a) {
              for (; null != a; a = a.nextSibling) {
                var b = a.nodeType;
                if (1 === b || 3 === b) break;
              }
              return a;
            }
            function sf(a) {
              a = a.previousSibling;
              for (var b = 0; a; ) {
                if (8 === a.nodeType) {
                  var c = a.data;
                  if ("$" === c || "$!" === c || "$?" === c) {
                    if (0 === b) return a;
                    b--;
                  } else "/$" === c && b++;
                }
                a = a.previousSibling;
              }
              return null;
            }
            var tf = 0;
            function uf(a) {
              return { $$typeof: Ga, toString: a, valueOf: a };
            }
            var vf = Math.random().toString(36).slice(2), wf = "__reactFiber$" + vf, xf = "__reactProps$" + vf, ff = "__reactContainer$" + vf, yf = "__reactEvents$" + vf;
            function wc(a) {
              var b = a[wf];
              if (b) return b;
              for (var c = a.parentNode; c; ) {
                if (b = c[ff] || c[wf]) {
                  c = b.alternate;
                  if (null !== b.child || null !== c && null !== c.child) for (a = sf(a); null !== a; ) {
                    if (c = a[wf]) return c;
                    a = sf(a);
                  }
                  return b;
                }
                a = c;
                c = a.parentNode;
              }
              return null;
            }
            function Cb(a) {
              a = a[wf] || a[ff];
              return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
            }
            function ue(a) {
              if (5 === a.tag || 6 === a.tag) return a.stateNode;
              throw Error(y(33));
            }
            function Db(a) {
              return a[xf] || null;
            }
            function $e(a) {
              var b = a[yf];
              void 0 === b && (b = a[yf] = /* @__PURE__ */ new Set());
              return b;
            }
            var zf = [], Af = -1;
            function Bf(a) {
              return { current: a };
            }
            function H(a) {
              0 > Af || (a.current = zf[Af], zf[Af] = null, Af--);
            }
            function I(a, b) {
              Af++;
              zf[Af] = a.current;
              a.current = b;
            }
            var Cf = {}, M = Bf(Cf), N = Bf(false), Df = Cf;
            function Ef(a, b) {
              var c = a.type.contextTypes;
              if (!c) return Cf;
              var d = a.stateNode;
              if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
              var e = {}, f;
              for (f in c) e[f] = b[f];
              d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
              return e;
            }
            function Ff(a) {
              a = a.childContextTypes;
              return null !== a && void 0 !== a;
            }
            function Gf() {
              H(N);
              H(M);
            }
            function Hf(a, b, c) {
              if (M.current !== Cf) throw Error(y(168));
              I(M, b);
              I(N, c);
            }
            function If(a, b, c) {
              var d = a.stateNode;
              a = b.childContextTypes;
              if ("function" !== typeof d.getChildContext) return c;
              d = d.getChildContext();
              for (var e in d) if (!(e in a)) throw Error(y(108, Ra(b) || "Unknown", e));
              return m({}, c, d);
            }
            function Jf(a) {
              a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Cf;
              Df = M.current;
              I(M, a);
              I(N, N.current);
              return true;
            }
            function Kf(a, b, c) {
              var d = a.stateNode;
              if (!d) throw Error(y(169));
              c ? (a = If(a, b, Df), d.__reactInternalMemoizedMergedChildContext = a, H(N), H(M), I(M, a)) : H(N);
              I(N, c);
            }
            var Lf = null, Mf = null, Nf = r.unstable_runWithPriority, Of = r.unstable_scheduleCallback, Pf = r.unstable_cancelCallback, Qf = r.unstable_shouldYield, Rf = r.unstable_requestPaint, Sf = r.unstable_now, Tf = r.unstable_getCurrentPriorityLevel, Uf = r.unstable_ImmediatePriority, Vf = r.unstable_UserBlockingPriority, Wf = r.unstable_NormalPriority, Xf = r.unstable_LowPriority, Yf = r.unstable_IdlePriority, Zf = {}, $f = void 0 !== Rf ? Rf : function() {
            }, ag = null, bg = null, cg = false, dg = Sf(), O = 1e4 > dg ? Sf : function() {
              return Sf() - dg;
            };
            function eg() {
              switch (Tf()) {
                case Uf:
                  return 99;
                case Vf:
                  return 98;
                case Wf:
                  return 97;
                case Xf:
                  return 96;
                case Yf:
                  return 95;
                default:
                  throw Error(y(332));
              }
            }
            function fg(a) {
              switch (a) {
                case 99:
                  return Uf;
                case 98:
                  return Vf;
                case 97:
                  return Wf;
                case 96:
                  return Xf;
                case 95:
                  return Yf;
                default:
                  throw Error(y(332));
              }
            }
            function gg(a, b) {
              a = fg(a);
              return Nf(a, b);
            }
            function hg(a, b, c) {
              a = fg(a);
              return Of(a, b, c);
            }
            function ig() {
              if (null !== bg) {
                var a = bg;
                bg = null;
                Pf(a);
              }
              jg();
            }
            function jg() {
              if (!cg && null !== ag) {
                cg = true;
                var a = 0;
                try {
                  var b = ag;
                  gg(99, function() {
                    for (; a < b.length; a++) {
                      var c = b[a];
                      do
                        c = c(true);
                      while (null !== c);
                    }
                  });
                  ag = null;
                } catch (c) {
                  throw null !== ag && (ag = ag.slice(a + 1)), Of(Uf, ig), c;
                } finally {
                  cg = false;
                }
              }
            }
            var kg = ra.ReactCurrentBatchConfig;
            function lg(a, b) {
              if (a && a.defaultProps) {
                b = m({}, b);
                a = a.defaultProps;
                for (var c in a) void 0 === b[c] && (b[c] = a[c]);
                return b;
              }
              return b;
            }
            var mg = Bf(null), ng = null, og = null, pg = null;
            function qg() {
              pg = og = ng = null;
            }
            function rg(a) {
              var b = mg.current;
              H(mg);
              a.type._context._currentValue = b;
            }
            function sg(a, b) {
              for (; null !== a; ) {
                var c = a.alternate;
                if ((a.childLanes & b) === b) if (null === c || (c.childLanes & b) === b) break;
                else c.childLanes |= b;
                else a.childLanes |= b, null !== c && (c.childLanes |= b);
                a = a.return;
              }
            }
            function tg(a, b) {
              ng = a;
              pg = og = null;
              a = a.dependencies;
              null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (ug = true), a.firstContext = null);
            }
            function vg(a, b) {
              if (pg !== a && false !== b && 0 !== b) {
                if ("number" !== typeof b || 1073741823 === b) pg = a, b = 1073741823;
                b = { context: a, observedBits: b, next: null };
                if (null === og) {
                  if (null === ng) throw Error(y(308));
                  og = b;
                  ng.dependencies = { lanes: 0, firstContext: b, responders: null };
                } else og = og.next = b;
              }
              return a._currentValue;
            }
            var wg = false;
            function xg(a) {
              a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null }, effects: null };
            }
            function yg(a, b) {
              a = a.updateQueue;
              b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
            }
            function zg(a, b) {
              return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
            }
            function Ag(a, b) {
              a = a.updateQueue;
              if (null !== a) {
                a = a.shared;
                var c = a.pending;
                null === c ? b.next = b : (b.next = c.next, c.next = b);
                a.pending = b;
              }
            }
            function Bg(a, b) {
              var c = a.updateQueue, d = a.alternate;
              if (null !== d && (d = d.updateQueue, c === d)) {
                var e = null, f = null;
                c = c.firstBaseUpdate;
                if (null !== c) {
                  do {
                    var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
                    null === f ? e = f = g : f = f.next = g;
                    c = c.next;
                  } while (null !== c);
                  null === f ? e = f = b : f = f.next = b;
                } else e = f = b;
                c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects };
                a.updateQueue = c;
                return;
              }
              a = c.lastBaseUpdate;
              null === a ? c.firstBaseUpdate = b : a.next = b;
              c.lastBaseUpdate = b;
            }
            function Cg(a, b, c, d) {
              var e = a.updateQueue;
              wg = false;
              var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
              if (null !== h) {
                e.shared.pending = null;
                var k = h, l = k.next;
                k.next = null;
                null === g ? f = l : g.next = l;
                g = k;
                var n = a.alternate;
                if (null !== n) {
                  n = n.updateQueue;
                  var A = n.lastBaseUpdate;
                  A !== g && (null === A ? n.firstBaseUpdate = l : A.next = l, n.lastBaseUpdate = k);
                }
              }
              if (null !== f) {
                A = e.baseState;
                g = 0;
                n = l = k = null;
                do {
                  h = f.lane;
                  var p = f.eventTime;
                  if ((d & h) === h) {
                    null !== n && (n = n.next = {
                      eventTime: p,
                      lane: 0,
                      tag: f.tag,
                      payload: f.payload,
                      callback: f.callback,
                      next: null
                    });
                    a: {
                      var C = a, x = f;
                      h = b;
                      p = c;
                      switch (x.tag) {
                        case 1:
                          C = x.payload;
                          if ("function" === typeof C) {
                            A = C.call(p, A, h);
                            break a;
                          }
                          A = C;
                          break a;
                        case 3:
                          C.flags = C.flags & -4097 | 64;
                        case 0:
                          C = x.payload;
                          h = "function" === typeof C ? C.call(p, A, h) : C;
                          if (null === h || void 0 === h) break a;
                          A = m({}, A, h);
                          break a;
                        case 2:
                          wg = true;
                      }
                    }
                    null !== f.callback && (a.flags |= 32, h = e.effects, null === h ? e.effects = [f] : h.push(f));
                  } else p = { eventTime: p, lane: h, tag: f.tag, payload: f.payload, callback: f.callback, next: null }, null === n ? (l = n = p, k = A) : n = n.next = p, g |= h;
                  f = f.next;
                  if (null === f) if (h = e.shared.pending, null === h) break;
                  else f = h.next, h.next = null, e.lastBaseUpdate = h, e.shared.pending = null;
                } while (1);
                null === n && (k = A);
                e.baseState = k;
                e.firstBaseUpdate = l;
                e.lastBaseUpdate = n;
                Dg |= g;
                a.lanes = g;
                a.memoizedState = A;
              }
            }
            function Eg(a, b, c) {
              a = b.effects;
              b.effects = null;
              if (null !== a) for (b = 0; b < a.length; b++) {
                var d = a[b], e = d.callback;
                if (null !== e) {
                  d.callback = null;
                  d = c;
                  if ("function" !== typeof e) throw Error(y(191, e));
                  e.call(d);
                }
              }
            }
            var Fg = new aa.Component().refs;
            function Gg(a, b, c, d) {
              b = a.memoizedState;
              c = c(d, b);
              c = null === c || void 0 === c ? b : m({}, b, c);
              a.memoizedState = c;
              0 === a.lanes && (a.updateQueue.baseState = c);
            }
            var Kg = { isMounted: function(a) {
              return (a = a._reactInternals) ? Zb(a) === a : false;
            }, enqueueSetState: function(a, b, c) {
              a = a._reactInternals;
              var d = Hg(), e = Ig(a), f = zg(d, e);
              f.payload = b;
              void 0 !== c && null !== c && (f.callback = c);
              Ag(a, f);
              Jg(a, e, d);
            }, enqueueReplaceState: function(a, b, c) {
              a = a._reactInternals;
              var d = Hg(), e = Ig(a), f = zg(d, e);
              f.tag = 1;
              f.payload = b;
              void 0 !== c && null !== c && (f.callback = c);
              Ag(a, f);
              Jg(a, e, d);
            }, enqueueForceUpdate: function(a, b) {
              a = a._reactInternals;
              var c = Hg(), d = Ig(a), e = zg(c, d);
              e.tag = 2;
              void 0 !== b && null !== b && (e.callback = b);
              Ag(a, e);
              Jg(a, d, c);
            } };
            function Lg(a, b, c, d, e, f, g) {
              a = a.stateNode;
              return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Je(c, d) || !Je(e, f) : true;
            }
            function Mg(a, b, c) {
              var d = false, e = Cf;
              var f = b.contextType;
              "object" === typeof f && null !== f ? f = vg(f) : (e = Ff(b) ? Df : M.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Ef(a, e) : Cf);
              b = new b(c, f);
              a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
              b.updater = Kg;
              a.stateNode = b;
              b._reactInternals = a;
              d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
              return b;
            }
            function Ng(a, b, c, d) {
              a = b.state;
              "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
              "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
              b.state !== a && Kg.enqueueReplaceState(b, b.state, null);
            }
            function Og(a, b, c, d) {
              var e = a.stateNode;
              e.props = c;
              e.state = a.memoizedState;
              e.refs = Fg;
              xg(a);
              var f = b.contextType;
              "object" === typeof f && null !== f ? e.context = vg(f) : (f = Ff(b) ? Df : M.current, e.context = Ef(a, f));
              Cg(a, c, e, d);
              e.state = a.memoizedState;
              f = b.getDerivedStateFromProps;
              "function" === typeof f && (Gg(a, b, f, c), e.state = a.memoizedState);
              "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Kg.enqueueReplaceState(e, e.state, null), Cg(a, c, e, d), e.state = a.memoizedState);
              "function" === typeof e.componentDidMount && (a.flags |= 4);
            }
            var Pg = Array.isArray;
            function Qg(a, b, c) {
              a = c.ref;
              if (null !== a && "function" !== typeof a && "object" !== typeof a) {
                if (c._owner) {
                  c = c._owner;
                  if (c) {
                    if (1 !== c.tag) throw Error(y(309));
                    var d = c.stateNode;
                  }
                  if (!d) throw Error(y(147, a));
                  var e = "" + a;
                  if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === e) return b.ref;
                  b = function(a2) {
                    var b2 = d.refs;
                    b2 === Fg && (b2 = d.refs = {});
                    null === a2 ? delete b2[e] : b2[e] = a2;
                  };
                  b._stringRef = e;
                  return b;
                }
                if ("string" !== typeof a) throw Error(y(284));
                if (!c._owner) throw Error(y(290, a));
              }
              return a;
            }
            function Rg(a, b) {
              if ("textarea" !== a.type) throw Error(y(31, "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b));
            }
            function Sg(a) {
              function b(b2, c2) {
                if (a) {
                  var d2 = b2.lastEffect;
                  null !== d2 ? (d2.nextEffect = c2, b2.lastEffect = c2) : b2.firstEffect = b2.lastEffect = c2;
                  c2.nextEffect = null;
                  c2.flags = 8;
                }
              }
              function c(c2, d2) {
                if (!a) return null;
                for (; null !== d2; ) b(c2, d2), d2 = d2.sibling;
                return null;
              }
              function d(a2, b2) {
                for (a2 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
                return a2;
              }
              function e(a2, b2) {
                a2 = Tg(a2, b2);
                a2.index = 0;
                a2.sibling = null;
                return a2;
              }
              function f(b2, c2, d2) {
                b2.index = d2;
                if (!a) return c2;
                d2 = b2.alternate;
                if (null !== d2) return d2 = d2.index, d2 < c2 ? (b2.flags = 2, c2) : d2;
                b2.flags = 2;
                return c2;
              }
              function g(b2) {
                a && null === b2.alternate && (b2.flags = 2);
                return b2;
              }
              function h(a2, b2, c2, d2) {
                if (null === b2 || 6 !== b2.tag) return b2 = Ug(c2, a2.mode, d2), b2.return = a2, b2;
                b2 = e(b2, c2);
                b2.return = a2;
                return b2;
              }
              function k(a2, b2, c2, d2) {
                if (null !== b2 && b2.elementType === c2.type) return d2 = e(b2, c2.props), d2.ref = Qg(a2, b2, c2), d2.return = a2, d2;
                d2 = Vg(c2.type, c2.key, c2.props, null, a2.mode, d2);
                d2.ref = Qg(a2, b2, c2);
                d2.return = a2;
                return d2;
              }
              function l(a2, b2, c2, d2) {
                if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation) return b2 = Wg(c2, a2.mode, d2), b2.return = a2, b2;
                b2 = e(b2, c2.children || []);
                b2.return = a2;
                return b2;
              }
              function n(a2, b2, c2, d2, f2) {
                if (null === b2 || 7 !== b2.tag) return b2 = Xg(c2, a2.mode, d2, f2), b2.return = a2, b2;
                b2 = e(b2, c2);
                b2.return = a2;
                return b2;
              }
              function A(a2, b2, c2) {
                if ("string" === typeof b2 || "number" === typeof b2) return b2 = Ug("" + b2, a2.mode, c2), b2.return = a2, b2;
                if ("object" === typeof b2 && null !== b2) {
                  switch (b2.$$typeof) {
                    case sa:
                      return c2 = Vg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Qg(a2, null, b2), c2.return = a2, c2;
                    case ta:
                      return b2 = Wg(b2, a2.mode, c2), b2.return = a2, b2;
                  }
                  if (Pg(b2) || La(b2)) return b2 = Xg(
                    b2,
                    a2.mode,
                    c2,
                    null
                  ), b2.return = a2, b2;
                  Rg(a2, b2);
                }
                return null;
              }
              function p(a2, b2, c2, d2) {
                var e2 = null !== b2 ? b2.key : null;
                if ("string" === typeof c2 || "number" === typeof c2) return null !== e2 ? null : h(a2, b2, "" + c2, d2);
                if ("object" === typeof c2 && null !== c2) {
                  switch (c2.$$typeof) {
                    case sa:
                      return c2.key === e2 ? c2.type === ua ? n(a2, b2, c2.props.children, d2, e2) : k(a2, b2, c2, d2) : null;
                    case ta:
                      return c2.key === e2 ? l(a2, b2, c2, d2) : null;
                  }
                  if (Pg(c2) || La(c2)) return null !== e2 ? null : n(a2, b2, c2, d2, null);
                  Rg(a2, c2);
                }
                return null;
              }
              function C(a2, b2, c2, d2, e2) {
                if ("string" === typeof d2 || "number" === typeof d2) return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
                if ("object" === typeof d2 && null !== d2) {
                  switch (d2.$$typeof) {
                    case sa:
                      return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, d2.type === ua ? n(b2, a2, d2.props.children, e2, d2.key) : k(b2, a2, d2, e2);
                    case ta:
                      return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l(b2, a2, d2, e2);
                  }
                  if (Pg(d2) || La(d2)) return a2 = a2.get(c2) || null, n(b2, a2, d2, e2, null);
                  Rg(b2, d2);
                }
                return null;
              }
              function x(e2, g2, h2, k2) {
                for (var l2 = null, t = null, u = g2, z = g2 = 0, q = null; null !== u && z < h2.length; z++) {
                  u.index > z ? (q = u, u = null) : q = u.sibling;
                  var n2 = p(e2, u, h2[z], k2);
                  if (null === n2) {
                    null === u && (u = q);
                    break;
                  }
                  a && u && null === n2.alternate && b(e2, u);
                  g2 = f(n2, g2, z);
                  null === t ? l2 = n2 : t.sibling = n2;
                  t = n2;
                  u = q;
                }
                if (z === h2.length) return c(e2, u), l2;
                if (null === u) {
                  for (; z < h2.length; z++) u = A(e2, h2[z], k2), null !== u && (g2 = f(u, g2, z), null === t ? l2 = u : t.sibling = u, t = u);
                  return l2;
                }
                for (u = d(e2, u); z < h2.length; z++) q = C(u, e2, z, h2[z], k2), null !== q && (a && null !== q.alternate && u.delete(null === q.key ? z : q.key), g2 = f(q, g2, z), null === t ? l2 = q : t.sibling = q, t = q);
                a && u.forEach(function(a2) {
                  return b(e2, a2);
                });
                return l2;
              }
              function w(e2, g2, h2, k2) {
                var l2 = La(h2);
                if ("function" !== typeof l2) throw Error(y(150));
                h2 = l2.call(h2);
                if (null == h2) throw Error(y(151));
                for (var t = l2 = null, u = g2, z = g2 = 0, q = null, n2 = h2.next(); null !== u && !n2.done; z++, n2 = h2.next()) {
                  u.index > z ? (q = u, u = null) : q = u.sibling;
                  var w2 = p(e2, u, n2.value, k2);
                  if (null === w2) {
                    null === u && (u = q);
                    break;
                  }
                  a && u && null === w2.alternate && b(e2, u);
                  g2 = f(w2, g2, z);
                  null === t ? l2 = w2 : t.sibling = w2;
                  t = w2;
                  u = q;
                }
                if (n2.done) return c(e2, u), l2;
                if (null === u) {
                  for (; !n2.done; z++, n2 = h2.next()) n2 = A(e2, n2.value, k2), null !== n2 && (g2 = f(n2, g2, z), null === t ? l2 = n2 : t.sibling = n2, t = n2);
                  return l2;
                }
                for (u = d(e2, u); !n2.done; z++, n2 = h2.next()) n2 = C(u, e2, z, n2.value, k2), null !== n2 && (a && null !== n2.alternate && u.delete(null === n2.key ? z : n2.key), g2 = f(n2, g2, z), null === t ? l2 = n2 : t.sibling = n2, t = n2);
                a && u.forEach(function(a2) {
                  return b(e2, a2);
                });
                return l2;
              }
              return function(a2, d2, f2, h2) {
                var k2 = "object" === typeof f2 && null !== f2 && f2.type === ua && null === f2.key;
                k2 && (f2 = f2.props.children);
                var l2 = "object" === typeof f2 && null !== f2;
                if (l2) switch (f2.$$typeof) {
                  case sa:
                    a: {
                      l2 = f2.key;
                      for (k2 = d2; null !== k2; ) {
                        if (k2.key === l2) {
                          switch (k2.tag) {
                            case 7:
                              if (f2.type === ua) {
                                c(a2, k2.sibling);
                                d2 = e(k2, f2.props.children);
                                d2.return = a2;
                                a2 = d2;
                                break a;
                              }
                              break;
                            default:
                              if (k2.elementType === f2.type) {
                                c(a2, k2.sibling);
                                d2 = e(k2, f2.props);
                                d2.ref = Qg(a2, k2, f2);
                                d2.return = a2;
                                a2 = d2;
                                break a;
                              }
                          }
                          c(a2, k2);
                          break;
                        } else b(a2, k2);
                        k2 = k2.sibling;
                      }
                      f2.type === ua ? (d2 = Xg(f2.props.children, a2.mode, h2, f2.key), d2.return = a2, a2 = d2) : (h2 = Vg(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = Qg(a2, d2, f2), h2.return = a2, a2 = h2);
                    }
                    return g(a2);
                  case ta:
                    a: {
                      for (k2 = f2.key; null !== d2; ) {
                        if (d2.key === k2) if (4 === d2.tag && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                          c(a2, d2.sibling);
                          d2 = e(d2, f2.children || []);
                          d2.return = a2;
                          a2 = d2;
                          break a;
                        } else {
                          c(a2, d2);
                          break;
                        }
                        else b(a2, d2);
                        d2 = d2.sibling;
                      }
                      d2 = Wg(f2, a2.mode, h2);
                      d2.return = a2;
                      a2 = d2;
                    }
                    return g(a2);
                }
                if ("string" === typeof f2 || "number" === typeof f2) return f2 = "" + f2, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Ug(f2, a2.mode, h2), d2.return = a2, a2 = d2), g(a2);
                if (Pg(f2)) return x(a2, d2, f2, h2);
                if (La(f2)) return w(a2, d2, f2, h2);
                l2 && Rg(a2, f2);
                if ("undefined" === typeof f2 && !k2) switch (a2.tag) {
                  case 1:
                  case 22:
                  case 0:
                  case 11:
                  case 15:
                    throw Error(y(152, Ra(a2.type) || "Component"));
                }
                return c(a2, d2);
              };
            }
            var Yg = Sg(true), Zg = Sg(false), $g = {}, ah = Bf($g), bh = Bf($g), ch = Bf($g);
            function dh(a) {
              if (a === $g) throw Error(y(174));
              return a;
            }
            function eh(a, b) {
              I(ch, b);
              I(bh, a);
              I(ah, $g);
              a = b.nodeType;
              switch (a) {
                case 9:
                case 11:
                  b = (b = b.documentElement) ? b.namespaceURI : mb(null, "");
                  break;
                default:
                  a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = mb(b, a);
              }
              H(ah);
              I(ah, b);
            }
            function fh() {
              H(ah);
              H(bh);
              H(ch);
            }
            function gh(a) {
              dh(ch.current);
              var b = dh(ah.current);
              var c = mb(b, a.type);
              b !== c && (I(bh, a), I(ah, c));
            }
            function hh(a) {
              bh.current === a && (H(ah), H(bh));
            }
            var P = Bf(0);
            function ih(a) {
              for (var b = a; null !== b; ) {
                if (13 === b.tag) {
                  var c = b.memoizedState;
                  if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
                } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
                  if (0 !== (b.flags & 64)) return b;
                } else if (null !== b.child) {
                  b.child.return = b;
                  b = b.child;
                  continue;
                }
                if (b === a) break;
                for (; null === b.sibling; ) {
                  if (null === b.return || b.return === a) return null;
                  b = b.return;
                }
                b.sibling.return = b.return;
                b = b.sibling;
              }
              return null;
            }
            var jh = null, kh = null, lh = false;
            function mh(a, b) {
              var c = nh(5, null, null, 0);
              c.elementType = "DELETED";
              c.type = "DELETED";
              c.stateNode = b;
              c.return = a;
              c.flags = 8;
              null !== a.lastEffect ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
            }
            function oh(a, b) {
              switch (a.tag) {
                case 5:
                  var c = a.type;
                  b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
                  return null !== b ? (a.stateNode = b, true) : false;
                case 6:
                  return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, true) : false;
                case 13:
                  return false;
                default:
                  return false;
              }
            }
            function ph(a) {
              if (lh) {
                var b = kh;
                if (b) {
                  var c = b;
                  if (!oh(a, b)) {
                    b = rf(c.nextSibling);
                    if (!b || !oh(a, b)) {
                      a.flags = a.flags & -1025 | 2;
                      lh = false;
                      jh = a;
                      return;
                    }
                    mh(jh, c);
                  }
                  jh = a;
                  kh = rf(b.firstChild);
                } else a.flags = a.flags & -1025 | 2, lh = false, jh = a;
              }
            }
            function qh(a) {
              for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
              jh = a;
            }
            function rh(a) {
              if (a !== jh) return false;
              if (!lh) return qh(a), lh = true, false;
              var b = a.type;
              if (5 !== a.tag || "head" !== b && "body" !== b && !nf(b, a.memoizedProps)) for (b = kh; b; ) mh(a, b), b = rf(b.nextSibling);
              qh(a);
              if (13 === a.tag) {
                a = a.memoizedState;
                a = null !== a ? a.dehydrated : null;
                if (!a) throw Error(y(317));
                a: {
                  a = a.nextSibling;
                  for (b = 0; a; ) {
                    if (8 === a.nodeType) {
                      var c = a.data;
                      if ("/$" === c) {
                        if (0 === b) {
                          kh = rf(a.nextSibling);
                          break a;
                        }
                        b--;
                      } else "$" !== c && "$!" !== c && "$?" !== c || b++;
                    }
                    a = a.nextSibling;
                  }
                  kh = null;
                }
              } else kh = jh ? rf(a.stateNode.nextSibling) : null;
              return true;
            }
            function sh() {
              kh = jh = null;
              lh = false;
            }
            var th = [];
            function uh() {
              for (var a = 0; a < th.length; a++) th[a]._workInProgressVersionPrimary = null;
              th.length = 0;
            }
            var vh = ra.ReactCurrentDispatcher, wh = ra.ReactCurrentBatchConfig, xh = 0, R = null, S = null, T = null, yh = false, zh = false;
            function Ah() {
              throw Error(y(321));
            }
            function Bh(a, b) {
              if (null === b) return false;
              for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return false;
              return true;
            }
            function Ch(a, b, c, d, e, f) {
              xh = f;
              R = b;
              b.memoizedState = null;
              b.updateQueue = null;
              b.lanes = 0;
              vh.current = null === a || null === a.memoizedState ? Dh : Eh;
              a = c(d, e);
              if (zh) {
                f = 0;
                do {
                  zh = false;
                  if (!(25 > f)) throw Error(y(301));
                  f += 1;
                  T = S = null;
                  b.updateQueue = null;
                  vh.current = Fh;
                  a = c(d, e);
                } while (zh);
              }
              vh.current = Gh;
              b = null !== S && null !== S.next;
              xh = 0;
              T = S = R = null;
              yh = false;
              if (b) throw Error(y(300));
              return a;
            }
            function Hh() {
              var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
              null === T ? R.memoizedState = T = a : T = T.next = a;
              return T;
            }
            function Ih() {
              if (null === S) {
                var a = R.alternate;
                a = null !== a ? a.memoizedState : null;
              } else a = S.next;
              var b = null === T ? R.memoizedState : T.next;
              if (null !== b) T = b, S = a;
              else {
                if (null === a) throw Error(y(310));
                S = a;
                a = { memoizedState: S.memoizedState, baseState: S.baseState, baseQueue: S.baseQueue, queue: S.queue, next: null };
                null === T ? R.memoizedState = T = a : T = T.next = a;
              }
              return T;
            }
            function Jh(a, b) {
              return "function" === typeof b ? b(a) : b;
            }
            function Kh(a) {
              var b = Ih(), c = b.queue;
              if (null === c) throw Error(y(311));
              c.lastRenderedReducer = a;
              var d = S, e = d.baseQueue, f = c.pending;
              if (null !== f) {
                if (null !== e) {
                  var g = e.next;
                  e.next = f.next;
                  f.next = g;
                }
                d.baseQueue = e = f;
                c.pending = null;
              }
              if (null !== e) {
                e = e.next;
                d = d.baseState;
                var h = g = f = null, k = e;
                do {
                  var l = k.lane;
                  if ((xh & l) === l) null !== h && (h = h.next = { lane: 0, action: k.action, eagerReducer: k.eagerReducer, eagerState: k.eagerState, next: null }), d = k.eagerReducer === a ? k.eagerState : a(d, k.action);
                  else {
                    var n = {
                      lane: l,
                      action: k.action,
                      eagerReducer: k.eagerReducer,
                      eagerState: k.eagerState,
                      next: null
                    };
                    null === h ? (g = h = n, f = d) : h = h.next = n;
                    R.lanes |= l;
                    Dg |= l;
                  }
                  k = k.next;
                } while (null !== k && k !== e);
                null === h ? f = d : h.next = g;
                He(d, b.memoizedState) || (ug = true);
                b.memoizedState = d;
                b.baseState = f;
                b.baseQueue = h;
                c.lastRenderedState = d;
              }
              return [b.memoizedState, c.dispatch];
            }
            function Lh(a) {
              var b = Ih(), c = b.queue;
              if (null === c) throw Error(y(311));
              c.lastRenderedReducer = a;
              var d = c.dispatch, e = c.pending, f = b.memoizedState;
              if (null !== e) {
                c.pending = null;
                var g = e = e.next;
                do
                  f = a(f, g.action), g = g.next;
                while (g !== e);
                He(f, b.memoizedState) || (ug = true);
                b.memoizedState = f;
                null === b.baseQueue && (b.baseState = f);
                c.lastRenderedState = f;
              }
              return [f, d];
            }
            function Mh(a, b, c) {
              var d = b._getVersion;
              d = d(b._source);
              var e = b._workInProgressVersionPrimary;
              if (null !== e) a = e === d;
              else if (a = a.mutableReadLanes, a = (xh & a) === a) b._workInProgressVersionPrimary = d, th.push(b);
              if (a) return c(b._source);
              th.push(b);
              throw Error(y(350));
            }
            function Nh(a, b, c, d) {
              var e = U;
              if (null === e) throw Error(y(349));
              var f = b._getVersion, g = f(b._source), h = vh.current, k = h.useState(function() {
                return Mh(e, b, c);
              }), l = k[1], n = k[0];
              k = T;
              var A = a.memoizedState, p = A.refs, C = p.getSnapshot, x = A.source;
              A = A.subscribe;
              var w = R;
              a.memoizedState = { refs: p, source: b, subscribe: d };
              h.useEffect(function() {
                p.getSnapshot = c;
                p.setSnapshot = l;
                var a2 = f(b._source);
                if (!He(g, a2)) {
                  a2 = c(b._source);
                  He(n, a2) || (l(a2), a2 = Ig(w), e.mutableReadLanes |= a2 & e.pendingLanes);
                  a2 = e.mutableReadLanes;
                  e.entangledLanes |= a2;
                  for (var d2 = e.entanglements, h2 = a2; 0 < h2; ) {
                    var k2 = 31 - Vc(h2), v = 1 << k2;
                    d2[k2] |= a2;
                    h2 &= ~v;
                  }
                }
              }, [c, b, d]);
              h.useEffect(function() {
                return d(b._source, function() {
                  var a2 = p.getSnapshot, c2 = p.setSnapshot;
                  try {
                    c2(a2(b._source));
                    var d2 = Ig(w);
                    e.mutableReadLanes |= d2 & e.pendingLanes;
                  } catch (q) {
                    c2(function() {
                      throw q;
                    });
                  }
                });
              }, [b, d]);
              He(C, c) && He(x, b) && He(A, d) || (a = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: n }, a.dispatch = l = Oh.bind(null, R, a), k.queue = a, k.baseQueue = null, n = Mh(e, b, c), k.memoizedState = k.baseState = n);
              return n;
            }
            function Ph(a, b, c) {
              var d = Ih();
              return Nh(d, a, b, c);
            }
            function Qh(a) {
              var b = Hh();
              "function" === typeof a && (a = a());
              b.memoizedState = b.baseState = a;
              a = b.queue = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: a };
              a = a.dispatch = Oh.bind(null, R, a);
              return [b.memoizedState, a];
            }
            function Rh(a, b, c, d) {
              a = { tag: a, create: b, destroy: c, deps: d, next: null };
              b = R.updateQueue;
              null === b ? (b = { lastEffect: null }, R.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
              return a;
            }
            function Sh(a) {
              var b = Hh();
              a = { current: a };
              return b.memoizedState = a;
            }
            function Th() {
              return Ih().memoizedState;
            }
            function Uh(a, b, c, d) {
              var e = Hh();
              R.flags |= a;
              e.memoizedState = Rh(1 | b, c, void 0, void 0 === d ? null : d);
            }
            function Vh(a, b, c, d) {
              var e = Ih();
              d = void 0 === d ? null : d;
              var f = void 0;
              if (null !== S) {
                var g = S.memoizedState;
                f = g.destroy;
                if (null !== d && Bh(d, g.deps)) {
                  Rh(b, c, f, d);
                  return;
                }
              }
              R.flags |= a;
              e.memoizedState = Rh(1 | b, c, f, d);
            }
            function Wh(a, b) {
              return Uh(516, 4, a, b);
            }
            function Xh(a, b) {
              return Vh(516, 4, a, b);
            }
            function Yh(a, b) {
              return Vh(4, 2, a, b);
            }
            function Zh(a, b) {
              if ("function" === typeof b) return a = a(), b(a), function() {
                b(null);
              };
              if (null !== b && void 0 !== b) return a = a(), b.current = a, function() {
                b.current = null;
              };
            }
            function $h(a, b, c) {
              c = null !== c && void 0 !== c ? c.concat([a]) : null;
              return Vh(4, 2, Zh.bind(null, b, a), c);
            }
            function ai() {
            }
            function bi(a, b) {
              var c = Ih();
              b = void 0 === b ? null : b;
              var d = c.memoizedState;
              if (null !== d && null !== b && Bh(b, d[1])) return d[0];
              c.memoizedState = [a, b];
              return a;
            }
            function ci(a, b) {
              var c = Ih();
              b = void 0 === b ? null : b;
              var d = c.memoizedState;
              if (null !== d && null !== b && Bh(b, d[1])) return d[0];
              a = a();
              c.memoizedState = [a, b];
              return a;
            }
            function di(a, b) {
              var c = eg();
              gg(98 > c ? 98 : c, function() {
                a(true);
              });
              gg(97 < c ? 97 : c, function() {
                var c2 = wh.transition;
                wh.transition = 1;
                try {
                  a(false), b();
                } finally {
                  wh.transition = c2;
                }
              });
            }
            function Oh(a, b, c) {
              var d = Hg(), e = Ig(a), f = { lane: e, action: c, eagerReducer: null, eagerState: null, next: null }, g = b.pending;
              null === g ? f.next = f : (f.next = g.next, g.next = f);
              b.pending = f;
              g = a.alternate;
              if (a === R || null !== g && g === R) zh = yh = true;
              else {
                if (0 === a.lanes && (null === g || 0 === g.lanes) && (g = b.lastRenderedReducer, null !== g)) try {
                  var h = b.lastRenderedState, k = g(h, c);
                  f.eagerReducer = g;
                  f.eagerState = k;
                  if (He(k, h)) return;
                } catch (l) {
                } finally {
                }
                Jg(a, e, d);
              }
            }
            var Gh = { readContext: vg, useCallback: Ah, useContext: Ah, useEffect: Ah, useImperativeHandle: Ah, useLayoutEffect: Ah, useMemo: Ah, useReducer: Ah, useRef: Ah, useState: Ah, useDebugValue: Ah, useDeferredValue: Ah, useTransition: Ah, useMutableSource: Ah, useOpaqueIdentifier: Ah, unstable_isNewReconciler: false }, Dh = { readContext: vg, useCallback: function(a, b) {
              Hh().memoizedState = [a, void 0 === b ? null : b];
              return a;
            }, useContext: vg, useEffect: Wh, useImperativeHandle: function(a, b, c) {
              c = null !== c && void 0 !== c ? c.concat([a]) : null;
              return Uh(4, 2, Zh.bind(
                null,
                b,
                a
              ), c);
            }, useLayoutEffect: function(a, b) {
              return Uh(4, 2, a, b);
            }, useMemo: function(a, b) {
              var c = Hh();
              b = void 0 === b ? null : b;
              a = a();
              c.memoizedState = [a, b];
              return a;
            }, useReducer: function(a, b, c) {
              var d = Hh();
              b = void 0 !== c ? c(b) : b;
              d.memoizedState = d.baseState = b;
              a = d.queue = { pending: null, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
              a = a.dispatch = Oh.bind(null, R, a);
              return [d.memoizedState, a];
            }, useRef: Sh, useState: Qh, useDebugValue: ai, useDeferredValue: function(a) {
              var b = Qh(a), c = b[0], d = b[1];
              Wh(function() {
                var b2 = wh.transition;
                wh.transition = 1;
                try {
                  d(a);
                } finally {
                  wh.transition = b2;
                }
              }, [a]);
              return c;
            }, useTransition: function() {
              var a = Qh(false), b = a[0];
              a = di.bind(null, a[1]);
              Sh(a);
              return [a, b];
            }, useMutableSource: function(a, b, c) {
              var d = Hh();
              d.memoizedState = { refs: { getSnapshot: b, setSnapshot: null }, source: a, subscribe: c };
              return Nh(d, a, b, c);
            }, useOpaqueIdentifier: function() {
              if (lh) {
                var a = false, b = uf(function() {
                  a || (a = true, c("r:" + (tf++).toString(36)));
                  throw Error(y(355));
                }), c = Qh(b)[1];
                0 === (R.mode & 2) && (R.flags |= 516, Rh(
                  5,
                  function() {
                    c("r:" + (tf++).toString(36));
                  },
                  void 0,
                  null
                ));
                return b;
              }
              b = "r:" + (tf++).toString(36);
              Qh(b);
              return b;
            }, unstable_isNewReconciler: false }, Eh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Kh, useRef: Th, useState: function() {
              return Kh(Jh);
            }, useDebugValue: ai, useDeferredValue: function(a) {
              var b = Kh(Jh), c = b[0], d = b[1];
              Xh(function() {
                var b2 = wh.transition;
                wh.transition = 1;
                try {
                  d(a);
                } finally {
                  wh.transition = b2;
                }
              }, [a]);
              return c;
            }, useTransition: function() {
              var a = Kh(Jh)[0];
              return [
                Th().current,
                a
              ];
            }, useMutableSource: Ph, useOpaqueIdentifier: function() {
              return Kh(Jh)[0];
            }, unstable_isNewReconciler: false }, Fh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Lh, useRef: Th, useState: function() {
              return Lh(Jh);
            }, useDebugValue: ai, useDeferredValue: function(a) {
              var b = Lh(Jh), c = b[0], d = b[1];
              Xh(function() {
                var b2 = wh.transition;
                wh.transition = 1;
                try {
                  d(a);
                } finally {
                  wh.transition = b2;
                }
              }, [a]);
              return c;
            }, useTransition: function() {
              var a = Lh(Jh)[0];
              return [
                Th().current,
                a
              ];
            }, useMutableSource: Ph, useOpaqueIdentifier: function() {
              return Lh(Jh)[0];
            }, unstable_isNewReconciler: false }, ei = ra.ReactCurrentOwner, ug = false;
            function fi(a, b, c, d) {
              b.child = null === a ? Zg(b, null, c, d) : Yg(b, a.child, c, d);
            }
            function gi(a, b, c, d, e) {
              c = c.render;
              var f = b.ref;
              tg(b, e);
              d = Ch(a, b, c, d, f, e);
              if (null !== a && !ug) return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);
              b.flags |= 1;
              fi(a, b, d, e);
              return b.child;
            }
            function ii(a, b, c, d, e, f) {
              if (null === a) {
                var g = c.type;
                if ("function" === typeof g && !ji(g) && void 0 === g.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = g, ki(a, b, g, d, e, f);
                a = Vg(c.type, null, d, b, b.mode, f);
                a.ref = b.ref;
                a.return = b;
                return b.child = a;
              }
              g = a.child;
              if (0 === (e & f) && (e = g.memoizedProps, c = c.compare, c = null !== c ? c : Je, c(e, d) && a.ref === b.ref)) return hi(a, b, f);
              b.flags |= 1;
              a = Tg(g, d);
              a.ref = b.ref;
              a.return = b;
              return b.child = a;
            }
            function ki(a, b, c, d, e, f) {
              if (null !== a && Je(a.memoizedProps, d) && a.ref === b.ref) if (ug = false, 0 !== (f & e)) 0 !== (a.flags & 16384) && (ug = true);
              else return b.lanes = a.lanes, hi(a, b, f);
              return li(a, b, c, d, f);
            }
            function mi(a, b, c) {
              var d = b.pendingProps, e = d.children, f = null !== a ? a.memoizedState : null;
              if ("hidden" === d.mode || "unstable-defer-without-hiding" === d.mode) if (0 === (b.mode & 4)) b.memoizedState = { baseLanes: 0 }, ni(b, c);
              else if (0 !== (c & 1073741824)) b.memoizedState = { baseLanes: 0 }, ni(b, null !== f ? f.baseLanes : c);
              else return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a }, ni(b, a), null;
              else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, ni(b, d);
              fi(a, b, e, c);
              return b.child;
            }
            function oi(a, b) {
              var c = b.ref;
              if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 128;
            }
            function li(a, b, c, d, e) {
              var f = Ff(c) ? Df : M.current;
              f = Ef(b, f);
              tg(b, e);
              c = Ch(a, b, c, d, f, e);
              if (null !== a && !ug) return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);
              b.flags |= 1;
              fi(a, b, c, e);
              return b.child;
            }
            function pi(a, b, c, d, e) {
              if (Ff(c)) {
                var f = true;
                Jf(b);
              } else f = false;
              tg(b, e);
              if (null === b.stateNode) null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2), Mg(b, c, d), Og(b, c, d, e), d = true;
              else if (null === a) {
                var g = b.stateNode, h = b.memoizedProps;
                g.props = h;
                var k = g.context, l = c.contextType;
                "object" === typeof l && null !== l ? l = vg(l) : (l = Ff(c) ? Df : M.current, l = Ef(b, l));
                var n = c.getDerivedStateFromProps, A = "function" === typeof n || "function" === typeof g.getSnapshotBeforeUpdate;
                A || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && Ng(b, g, d, l);
                wg = false;
                var p = b.memoizedState;
                g.state = p;
                Cg(b, d, g, e);
                k = b.memoizedState;
                h !== d || p !== k || N.current || wg ? ("function" === typeof n && (Gg(b, c, n, d), k = b.memoizedState), (h = wg || Lg(b, c, h, d, p, k, l)) ? (A || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4)) : ("function" === typeof g.componentDidMount && (b.flags |= 4), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4), d = false);
              } else {
                g = b.stateNode;
                yg(a, b);
                h = b.memoizedProps;
                l = b.type === b.elementType ? h : lg(b.type, h);
                g.props = l;
                A = b.pendingProps;
                p = g.context;
                k = c.contextType;
                "object" === typeof k && null !== k ? k = vg(k) : (k = Ff(c) ? Df : M.current, k = Ef(b, k));
                var C = c.getDerivedStateFromProps;
                (n = "function" === typeof C || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== A || p !== k) && Ng(b, g, d, k);
                wg = false;
                p = b.memoizedState;
                g.state = p;
                Cg(b, d, g, e);
                var x = b.memoizedState;
                h !== A || p !== x || N.current || wg ? ("function" === typeof C && (Gg(b, c, C, d), x = b.memoizedState), (l = wg || Lg(b, c, l, d, p, x, k)) ? (n || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(
                  d,
                  x,
                  k
                ), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, x, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 256)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 256), b.memoizedProps = d, b.memoizedState = x), g.props = d, g.state = x, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 256), d = false);
              }
              return qi(a, b, c, d, f, e);
            }
            function qi(a, b, c, d, e, f) {
              oi(a, b);
              var g = 0 !== (b.flags & 64);
              if (!d && !g) return e && Kf(b, c, false), hi(a, b, f);
              d = b.stateNode;
              ei.current = b;
              var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
              b.flags |= 1;
              null !== a && g ? (b.child = Yg(b, a.child, null, f), b.child = Yg(b, null, h, f)) : fi(a, b, h, f);
              b.memoizedState = d.state;
              e && Kf(b, c, true);
              return b.child;
            }
            function ri(a) {
              var b = a.stateNode;
              b.pendingContext ? Hf(a, b.pendingContext, b.pendingContext !== b.context) : b.context && Hf(a, b.context, false);
              eh(a, b.containerInfo);
            }
            var si = { dehydrated: null, retryLane: 0 };
            function ti(a, b, c) {
              var d = b.pendingProps, e = P.current, f = false, g;
              (g = 0 !== (b.flags & 64)) || (g = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
              g ? (f = true, b.flags &= -65) : null !== a && null === a.memoizedState || void 0 === d.fallback || true === d.unstable_avoidThisFallback || (e |= 1);
              I(P, e & 1);
              if (null === a) {
                void 0 !== d.fallback && ph(b);
                a = d.children;
                e = d.fallback;
                if (f) return a = ui(b, a, e, c), b.child.memoizedState = { baseLanes: c }, b.memoizedState = si, a;
                if ("number" === typeof d.unstable_expectedLoadTime) return a = ui(b, a, e, c), b.child.memoizedState = { baseLanes: c }, b.memoizedState = si, b.lanes = 33554432, a;
                c = vi({ mode: "visible", children: a }, b.mode, c, null);
                c.return = b;
                return b.child = c;
              }
              if (null !== a.memoizedState) {
                if (f) return d = wi(a, b, d.children, d.fallback, c), f = b.child, e = a.child.memoizedState, f.memoizedState = null === e ? { baseLanes: c } : { baseLanes: e.baseLanes | c }, f.childLanes = a.childLanes & ~c, b.memoizedState = si, d;
                c = xi(a, b, d.children, c);
                b.memoizedState = null;
                return c;
              }
              if (f) return d = wi(a, b, d.children, d.fallback, c), f = b.child, e = a.child.memoizedState, f.memoizedState = null === e ? { baseLanes: c } : { baseLanes: e.baseLanes | c }, f.childLanes = a.childLanes & ~c, b.memoizedState = si, d;
              c = xi(a, b, d.children, c);
              b.memoizedState = null;
              return c;
            }
            function ui(a, b, c, d) {
              var e = a.mode, f = a.child;
              b = { mode: "hidden", children: b };
              0 === (e & 2) && null !== f ? (f.childLanes = 0, f.pendingProps = b) : f = vi(b, e, 0, null);
              c = Xg(c, e, d, null);
              f.return = a;
              c.return = a;
              f.sibling = c;
              a.child = f;
              return c;
            }
            function xi(a, b, c, d) {
              var e = a.child;
              a = e.sibling;
              c = Tg(e, { mode: "visible", children: c });
              0 === (b.mode & 2) && (c.lanes = d);
              c.return = b;
              c.sibling = null;
              null !== a && (a.nextEffect = null, a.flags = 8, b.firstEffect = b.lastEffect = a);
              return b.child = c;
            }
            function wi(a, b, c, d, e) {
              var f = b.mode, g = a.child;
              a = g.sibling;
              var h = { mode: "hidden", children: c };
              0 === (f & 2) && b.child !== g ? (c = b.child, c.childLanes = 0, c.pendingProps = h, g = c.lastEffect, null !== g ? (b.firstEffect = c.firstEffect, b.lastEffect = g, g.nextEffect = null) : b.firstEffect = b.lastEffect = null) : c = Tg(g, h);
              null !== a ? d = Tg(a, d) : (d = Xg(d, f, e, null), d.flags |= 2);
              d.return = b;
              c.return = b;
              c.sibling = d;
              b.child = c;
              return d;
            }
            function yi(a, b) {
              a.lanes |= b;
              var c = a.alternate;
              null !== c && (c.lanes |= b);
              sg(a.return, b);
            }
            function zi(a, b, c, d, e, f) {
              var g = a.memoizedState;
              null === g ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e, lastEffect: f } : (g.isBackwards = b, g.rendering = null, g.renderingStartTime = 0, g.last = d, g.tail = c, g.tailMode = e, g.lastEffect = f);
            }
            function Ai(a, b, c) {
              var d = b.pendingProps, e = d.revealOrder, f = d.tail;
              fi(a, b, d.children, c);
              d = P.current;
              if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 64;
              else {
                if (null !== a && 0 !== (a.flags & 64)) a: for (a = b.child; null !== a; ) {
                  if (13 === a.tag) null !== a.memoizedState && yi(a, c);
                  else if (19 === a.tag) yi(a, c);
                  else if (null !== a.child) {
                    a.child.return = a;
                    a = a.child;
                    continue;
                  }
                  if (a === b) break a;
                  for (; null === a.sibling; ) {
                    if (null === a.return || a.return === b) break a;
                    a = a.return;
                  }
                  a.sibling.return = a.return;
                  a = a.sibling;
                }
                d &= 1;
              }
              I(P, d);
              if (0 === (b.mode & 2)) b.memoizedState = null;
              else switch (e) {
                case "forwards":
                  c = b.child;
                  for (e = null; null !== c; ) a = c.alternate, null !== a && null === ih(a) && (e = c), c = c.sibling;
                  c = e;
                  null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
                  zi(b, false, e, c, f, b.lastEffect);
                  break;
                case "backwards":
                  c = null;
                  e = b.child;
                  for (b.child = null; null !== e; ) {
                    a = e.alternate;
                    if (null !== a && null === ih(a)) {
                      b.child = e;
                      break;
                    }
                    a = e.sibling;
                    e.sibling = c;
                    c = e;
                    e = a;
                  }
                  zi(b, true, c, null, f, b.lastEffect);
                  break;
                case "together":
                  zi(b, false, null, null, void 0, b.lastEffect);
                  break;
                default:
                  b.memoizedState = null;
              }
              return b.child;
            }
            function hi(a, b, c) {
              null !== a && (b.dependencies = a.dependencies);
              Dg |= b.lanes;
              if (0 !== (c & b.childLanes)) {
                if (null !== a && b.child !== a.child) throw Error(y(153));
                if (null !== b.child) {
                  a = b.child;
                  c = Tg(a, a.pendingProps);
                  b.child = c;
                  for (c.return = b; null !== a.sibling; ) a = a.sibling, c = c.sibling = Tg(a, a.pendingProps), c.return = b;
                  c.sibling = null;
                }
                return b.child;
              }
              return null;
            }
            var Bi, Ci, Di, Ei;
            Bi = function(a, b) {
              for (var c = b.child; null !== c; ) {
                if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);
                else if (4 !== c.tag && null !== c.child) {
                  c.child.return = c;
                  c = c.child;
                  continue;
                }
                if (c === b) break;
                for (; null === c.sibling; ) {
                  if (null === c.return || c.return === b) return;
                  c = c.return;
                }
                c.sibling.return = c.return;
                c = c.sibling;
              }
            };
            Ci = function() {
            };
            Di = function(a, b, c, d) {
              var e = a.memoizedProps;
              if (e !== d) {
                a = b.stateNode;
                dh(ah.current);
                var f = null;
                switch (c) {
                  case "input":
                    e = Ya(a, e);
                    d = Ya(a, d);
                    f = [];
                    break;
                  case "option":
                    e = eb(a, e);
                    d = eb(a, d);
                    f = [];
                    break;
                  case "select":
                    e = m({}, e, { value: void 0 });
                    d = m({}, d, { value: void 0 });
                    f = [];
                    break;
                  case "textarea":
                    e = gb(a, e);
                    d = gb(a, d);
                    f = [];
                    break;
                  default:
                    "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = jf);
                }
                vb(c, d);
                var g;
                c = null;
                for (l in e) if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
                  var h = e[l];
                  for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
                } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ca.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
                for (l in d) {
                  var k = d[l];
                  h = null != e ? e[l] : void 0;
                  if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) if (h) {
                    for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
                    for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
                  } else c || (f || (f = []), f.push(l, c)), c = k;
                  else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ca.hasOwnProperty(l) ? (null != k && "onScroll" === l && G("scroll", a), f || h === k || (f = [])) : "object" === typeof k && null !== k && k.$$typeof === Ga ? k.toString() : (f = f || []).push(l, k));
                }
                c && (f = f || []).push(
                  "style",
                  c
                );
                var l = f;
                if (b.updateQueue = l) b.flags |= 4;
              }
            };
            Ei = function(a, b, c, d) {
              c !== d && (b.flags |= 4);
            };
            function Fi(a, b) {
              if (!lh) switch (a.tailMode) {
                case "hidden":
                  b = a.tail;
                  for (var c = null; null !== b; ) null !== b.alternate && (c = b), b = b.sibling;
                  null === c ? a.tail = null : c.sibling = null;
                  break;
                case "collapsed":
                  c = a.tail;
                  for (var d = null; null !== c; ) null !== c.alternate && (d = c), c = c.sibling;
                  null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
              }
            }
            function Gi(a, b, c) {
              var d = b.pendingProps;
              switch (b.tag) {
                case 2:
                case 16:
                case 15:
                case 0:
                case 11:
                case 7:
                case 8:
                case 12:
                case 9:
                case 14:
                  return null;
                case 1:
                  return Ff(b.type) && Gf(), null;
                case 3:
                  fh();
                  H(N);
                  H(M);
                  uh();
                  d = b.stateNode;
                  d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
                  if (null === a || null === a.child) rh(b) ? b.flags |= 4 : d.hydrate || (b.flags |= 256);
                  Ci(b);
                  return null;
                case 5:
                  hh(b);
                  var e = dh(ch.current);
                  c = b.type;
                  if (null !== a && null != b.stateNode) Di(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 128);
                  else {
                    if (!d) {
                      if (null === b.stateNode) throw Error(y(166));
                      return null;
                    }
                    a = dh(ah.current);
                    if (rh(b)) {
                      d = b.stateNode;
                      c = b.type;
                      var f = b.memoizedProps;
                      d[wf] = b;
                      d[xf] = f;
                      switch (c) {
                        case "dialog":
                          G("cancel", d);
                          G("close", d);
                          break;
                        case "iframe":
                        case "object":
                        case "embed":
                          G("load", d);
                          break;
                        case "video":
                        case "audio":
                          for (a = 0; a < Xe.length; a++) G(Xe[a], d);
                          break;
                        case "source":
                          G("error", d);
                          break;
                        case "img":
                        case "image":
                        case "link":
                          G("error", d);
                          G("load", d);
                          break;
                        case "details":
                          G("toggle", d);
                          break;
                        case "input":
                          Za(d, f);
                          G("invalid", d);
                          break;
                        case "select":
                          d._wrapperState = { wasMultiple: !!f.multiple };
                          G("invalid", d);
                          break;
                        case "textarea":
                          hb(d, f), G("invalid", d);
                      }
                      vb(c, f);
                      a = null;
                      for (var g in f) f.hasOwnProperty(g) && (e = f[g], "children" === g ? "string" === typeof e ? d.textContent !== e && (a = ["children", e]) : "number" === typeof e && d.textContent !== "" + e && (a = ["children", "" + e]) : ca.hasOwnProperty(g) && null != e && "onScroll" === g && G("scroll", d));
                      switch (c) {
                        case "input":
                          Va(d);
                          cb(d, f, true);
                          break;
                        case "textarea":
                          Va(d);
                          jb(d);
                          break;
                        case "select":
                        case "option":
                          break;
                        default:
                          "function" === typeof f.onClick && (d.onclick = jf);
                      }
                      d = a;
                      b.updateQueue = d;
                      null !== d && (b.flags |= 4);
                    } else {
                      g = 9 === e.nodeType ? e : e.ownerDocument;
                      a === kb.html && (a = lb(c));
                      a === kb.html ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
                      a[wf] = b;
                      a[xf] = d;
                      Bi(a, b, false, false);
                      b.stateNode = a;
                      g = wb(c, d);
                      switch (c) {
                        case "dialog":
                          G("cancel", a);
                          G("close", a);
                          e = d;
                          break;
                        case "iframe":
                        case "object":
                        case "embed":
                          G("load", a);
                          e = d;
                          break;
                        case "video":
                        case "audio":
                          for (e = 0; e < Xe.length; e++) G(Xe[e], a);
                          e = d;
                          break;
                        case "source":
                          G("error", a);
                          e = d;
                          break;
                        case "img":
                        case "image":
                        case "link":
                          G("error", a);
                          G("load", a);
                          e = d;
                          break;
                        case "details":
                          G("toggle", a);
                          e = d;
                          break;
                        case "input":
                          Za(a, d);
                          e = Ya(a, d);
                          G("invalid", a);
                          break;
                        case "option":
                          e = eb(a, d);
                          break;
                        case "select":
                          a._wrapperState = { wasMultiple: !!d.multiple };
                          e = m({}, d, { value: void 0 });
                          G("invalid", a);
                          break;
                        case "textarea":
                          hb(a, d);
                          e = gb(a, d);
                          G("invalid", a);
                          break;
                        default:
                          e = d;
                      }
                      vb(c, e);
                      var h = e;
                      for (f in h) if (h.hasOwnProperty(f)) {
                        var k = h[f];
                        "style" === f ? tb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && ob(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && pb(a, k) : "number" === typeof k && pb(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ca.hasOwnProperty(f) ? null != k && "onScroll" === f && G("scroll", a) : null != k && qa(a, f, k, g));
                      }
                      switch (c) {
                        case "input":
                          Va(a);
                          cb(a, d, false);
                          break;
                        case "textarea":
                          Va(a);
                          jb(a);
                          break;
                        case "option":
                          null != d.value && a.setAttribute("value", "" + Sa(d.value));
                          break;
                        case "select":
                          a.multiple = !!d.multiple;
                          f = d.value;
                          null != f ? fb(a, !!d.multiple, f, false) : null != d.defaultValue && fb(a, !!d.multiple, d.defaultValue, true);
                          break;
                        default:
                          "function" === typeof e.onClick && (a.onclick = jf);
                      }
                      mf(c, d) && (b.flags |= 4);
                    }
                    null !== b.ref && (b.flags |= 128);
                  }
                  return null;
                case 6:
                  if (a && null != b.stateNode) Ei(a, b, a.memoizedProps, d);
                  else {
                    if ("string" !== typeof d && null === b.stateNode) throw Error(y(166));
                    c = dh(ch.current);
                    dh(ah.current);
                    rh(b) ? (d = b.stateNode, c = b.memoizedProps, d[wf] = b, d.nodeValue !== c && (b.flags |= 4)) : (d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[wf] = b, b.stateNode = d);
                  }
                  return null;
                case 13:
                  H(P);
                  d = b.memoizedState;
                  if (0 !== (b.flags & 64)) return b.lanes = c, b;
                  d = null !== d;
                  c = false;
                  null === a ? void 0 !== b.memoizedProps.fallback && rh(b) : c = null !== a.memoizedState;
                  if (d && !c && 0 !== (b.mode & 2)) if (null === a && true !== b.memoizedProps.unstable_avoidThisFallback || 0 !== (P.current & 1)) 0 === V && (V = 3);
                  else {
                    if (0 === V || 3 === V) V = 4;
                    null === U || 0 === (Dg & 134217727) && 0 === (Hi & 134217727) || Ii(U, W);
                  }
                  if (d || c) b.flags |= 4;
                  return null;
                case 4:
                  return fh(), Ci(b), null === a && cf(b.stateNode.containerInfo), null;
                case 10:
                  return rg(b), null;
                case 17:
                  return Ff(b.type) && Gf(), null;
                case 19:
                  H(P);
                  d = b.memoizedState;
                  if (null === d) return null;
                  f = 0 !== (b.flags & 64);
                  g = d.rendering;
                  if (null === g) if (f) Fi(d, false);
                  else {
                    if (0 !== V || null !== a && 0 !== (a.flags & 64)) for (a = b.child; null !== a; ) {
                      g = ih(a);
                      if (null !== g) {
                        b.flags |= 64;
                        Fi(d, false);
                        f = g.updateQueue;
                        null !== f && (b.updateQueue = f, b.flags |= 4);
                        null === d.lastEffect && (b.firstEffect = null);
                        b.lastEffect = d.lastEffect;
                        d = c;
                        for (c = b.child; null !== c; ) f = c, a = d, f.flags &= 2, f.nextEffect = null, f.firstEffect = null, f.lastEffect = null, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                        I(P, P.current & 1 | 2);
                        return b.child;
                      }
                      a = a.sibling;
                    }
                    null !== d.tail && O() > Ji && (b.flags |= 64, f = true, Fi(d, false), b.lanes = 33554432);
                  }
                  else {
                    if (!f) if (a = ih(g), null !== a) {
                      if (b.flags |= 64, f = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Fi(d, true), null === d.tail && "hidden" === d.tailMode && !g.alternate && !lh) return b = b.lastEffect = d.lastEffect, null !== b && (b.nextEffect = null), null;
                    } else 2 * O() - d.renderingStartTime > Ji && 1073741824 !== c && (b.flags |= 64, f = true, Fi(d, false), b.lanes = 33554432);
                    d.isBackwards ? (g.sibling = b.child, b.child = g) : (c = d.last, null !== c ? c.sibling = g : b.child = g, d.last = g);
                  }
                  return null !== d.tail ? (c = d.tail, d.rendering = c, d.tail = c.sibling, d.lastEffect = b.lastEffect, d.renderingStartTime = O(), c.sibling = null, b = P.current, I(P, f ? b & 1 | 2 : b & 1), c) : null;
                case 23:
                case 24:
                  return Ki(), null !== a && null !== a.memoizedState !== (null !== b.memoizedState) && "unstable-defer-without-hiding" !== d.mode && (b.flags |= 4), null;
              }
              throw Error(y(156, b.tag));
            }
            function Li(a) {
              switch (a.tag) {
                case 1:
                  Ff(a.type) && Gf();
                  var b = a.flags;
                  return b & 4096 ? (a.flags = b & -4097 | 64, a) : null;
                case 3:
                  fh();
                  H(N);
                  H(M);
                  uh();
                  b = a.flags;
                  if (0 !== (b & 64)) throw Error(y(285));
                  a.flags = b & -4097 | 64;
                  return a;
                case 5:
                  return hh(a), null;
                case 13:
                  return H(P), b = a.flags, b & 4096 ? (a.flags = b & -4097 | 64, a) : null;
                case 19:
                  return H(P), null;
                case 4:
                  return fh(), null;
                case 10:
                  return rg(a), null;
                case 23:
                case 24:
                  return Ki(), null;
                default:
                  return null;
              }
            }
            function Mi(a, b) {
              try {
                var c = "", d = b;
                do
                  c += Qa(d), d = d.return;
                while (d);
                var e = c;
              } catch (f) {
                e = "\nError generating stack: " + f.message + "\n" + f.stack;
              }
              return { value: a, source: b, stack: e };
            }
            function Ni(a, b) {
              try {
                console.error(b.value);
              } catch (c) {
                setTimeout(function() {
                  throw c;
                });
              }
            }
            var Oi = "function" === typeof WeakMap ? WeakMap : Map;
            function Pi(a, b, c) {
              c = zg(-1, c);
              c.tag = 3;
              c.payload = { element: null };
              var d = b.value;
              c.callback = function() {
                Qi || (Qi = true, Ri = d);
                Ni(a, b);
              };
              return c;
            }
            function Si(a, b, c) {
              c = zg(-1, c);
              c.tag = 3;
              var d = a.type.getDerivedStateFromError;
              if ("function" === typeof d) {
                var e = b.value;
                c.payload = function() {
                  Ni(a, b);
                  return d(e);
                };
              }
              var f = a.stateNode;
              null !== f && "function" === typeof f.componentDidCatch && (c.callback = function() {
                "function" !== typeof d && (null === Ti ? Ti = /* @__PURE__ */ new Set([this]) : Ti.add(this), Ni(a, b));
                var c2 = b.stack;
                this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
              });
              return c;
            }
            var Ui = "function" === typeof WeakSet ? WeakSet : Set;
            function Vi(a) {
              var b = a.ref;
              if (null !== b) if ("function" === typeof b) try {
                b(null);
              } catch (c) {
                Wi(a, c);
              }
              else b.current = null;
            }
            function Xi(a, b) {
              switch (b.tag) {
                case 0:
                case 11:
                case 15:
                case 22:
                  return;
                case 1:
                  if (b.flags & 256 && null !== a) {
                    var c = a.memoizedProps, d = a.memoizedState;
                    a = b.stateNode;
                    b = a.getSnapshotBeforeUpdate(b.elementType === b.type ? c : lg(b.type, c), d);
                    a.__reactInternalSnapshotBeforeUpdate = b;
                  }
                  return;
                case 3:
                  b.flags & 256 && qf(b.stateNode.containerInfo);
                  return;
                case 5:
                case 6:
                case 4:
                case 17:
                  return;
              }
              throw Error(y(163));
            }
            function Yi(a, b, c) {
              switch (c.tag) {
                case 0:
                case 11:
                case 15:
                case 22:
                  b = c.updateQueue;
                  b = null !== b ? b.lastEffect : null;
                  if (null !== b) {
                    a = b = b.next;
                    do {
                      if (3 === (a.tag & 3)) {
                        var d = a.create;
                        a.destroy = d();
                      }
                      a = a.next;
                    } while (a !== b);
                  }
                  b = c.updateQueue;
                  b = null !== b ? b.lastEffect : null;
                  if (null !== b) {
                    a = b = b.next;
                    do {
                      var e = a;
                      d = e.next;
                      e = e.tag;
                      0 !== (e & 4) && 0 !== (e & 1) && (Zi(c, a), $i(c, a));
                      a = d;
                    } while (a !== b);
                  }
                  return;
                case 1:
                  a = c.stateNode;
                  c.flags & 4 && (null === b ? a.componentDidMount() : (d = c.elementType === c.type ? b.memoizedProps : lg(c.type, b.memoizedProps), a.componentDidUpdate(
                    d,
                    b.memoizedState,
                    a.__reactInternalSnapshotBeforeUpdate
                  )));
                  b = c.updateQueue;
                  null !== b && Eg(c, b, a);
                  return;
                case 3:
                  b = c.updateQueue;
                  if (null !== b) {
                    a = null;
                    if (null !== c.child) switch (c.child.tag) {
                      case 5:
                        a = c.child.stateNode;
                        break;
                      case 1:
                        a = c.child.stateNode;
                    }
                    Eg(c, b, a);
                  }
                  return;
                case 5:
                  a = c.stateNode;
                  null === b && c.flags & 4 && mf(c.type, c.memoizedProps) && a.focus();
                  return;
                case 6:
                  return;
                case 4:
                  return;
                case 12:
                  return;
                case 13:
                  null === c.memoizedState && (c = c.alternate, null !== c && (c = c.memoizedState, null !== c && (c = c.dehydrated, null !== c && Cc(c))));
                  return;
                case 19:
                case 17:
                case 20:
                case 21:
                case 23:
                case 24:
                  return;
              }
              throw Error(y(163));
            }
            function aj(a, b) {
              for (var c = a; ; ) {
                if (5 === c.tag) {
                  var d = c.stateNode;
                  if (b) d = d.style, "function" === typeof d.setProperty ? d.setProperty("display", "none", "important") : d.display = "none";
                  else {
                    d = c.stateNode;
                    var e = c.memoizedProps.style;
                    e = void 0 !== e && null !== e && e.hasOwnProperty("display") ? e.display : null;
                    d.style.display = sb("display", e);
                  }
                } else if (6 === c.tag) c.stateNode.nodeValue = b ? "" : c.memoizedProps;
                else if ((23 !== c.tag && 24 !== c.tag || null === c.memoizedState || c === a) && null !== c.child) {
                  c.child.return = c;
                  c = c.child;
                  continue;
                }
                if (c === a) break;
                for (; null === c.sibling; ) {
                  if (null === c.return || c.return === a) return;
                  c = c.return;
                }
                c.sibling.return = c.return;
                c = c.sibling;
              }
            }
            function bj(a, b) {
              if (Mf && "function" === typeof Mf.onCommitFiberUnmount) try {
                Mf.onCommitFiberUnmount(Lf, b);
              } catch (f) {
              }
              switch (b.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                case 22:
                  a = b.updateQueue;
                  if (null !== a && (a = a.lastEffect, null !== a)) {
                    var c = a = a.next;
                    do {
                      var d = c, e = d.destroy;
                      d = d.tag;
                      if (void 0 !== e) if (0 !== (d & 4)) Zi(b, c);
                      else {
                        d = b;
                        try {
                          e();
                        } catch (f) {
                          Wi(d, f);
                        }
                      }
                      c = c.next;
                    } while (c !== a);
                  }
                  break;
                case 1:
                  Vi(b);
                  a = b.stateNode;
                  if ("function" === typeof a.componentWillUnmount) try {
                    a.props = b.memoizedProps, a.state = b.memoizedState, a.componentWillUnmount();
                  } catch (f) {
                    Wi(
                      b,
                      f
                    );
                  }
                  break;
                case 5:
                  Vi(b);
                  break;
                case 4:
                  cj(a, b);
              }
            }
            function dj(a) {
              a.alternate = null;
              a.child = null;
              a.dependencies = null;
              a.firstEffect = null;
              a.lastEffect = null;
              a.memoizedProps = null;
              a.memoizedState = null;
              a.pendingProps = null;
              a.return = null;
              a.updateQueue = null;
            }
            function ej(a) {
              return 5 === a.tag || 3 === a.tag || 4 === a.tag;
            }
            function fj(a) {
              a: {
                for (var b = a.return; null !== b; ) {
                  if (ej(b)) break a;
                  b = b.return;
                }
                throw Error(y(160));
              }
              var c = b;
              b = c.stateNode;
              switch (c.tag) {
                case 5:
                  var d = false;
                  break;
                case 3:
                  b = b.containerInfo;
                  d = true;
                  break;
                case 4:
                  b = b.containerInfo;
                  d = true;
                  break;
                default:
                  throw Error(y(161));
              }
              c.flags & 16 && (pb(b, ""), c.flags &= -17);
              a: b: for (c = a; ; ) {
                for (; null === c.sibling; ) {
                  if (null === c.return || ej(c.return)) {
                    c = null;
                    break a;
                  }
                  c = c.return;
                }
                c.sibling.return = c.return;
                for (c = c.sibling; 5 !== c.tag && 6 !== c.tag && 18 !== c.tag; ) {
                  if (c.flags & 2) continue b;
                  if (null === c.child || 4 === c.tag) continue b;
                  else c.child.return = c, c = c.child;
                }
                if (!(c.flags & 2)) {
                  c = c.stateNode;
                  break a;
                }
              }
              d ? gj(a, c, b) : hj(a, c, b);
            }
            function gj(a, b, c) {
              var d = a.tag, e = 5 === d || 6 === d;
              if (e) a = e ? a.stateNode : a.stateNode.instance, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = jf));
              else if (4 !== d && (a = a.child, null !== a)) for (gj(a, b, c), a = a.sibling; null !== a; ) gj(a, b, c), a = a.sibling;
            }
            function hj(a, b, c) {
              var d = a.tag, e = 5 === d || 6 === d;
              if (e) a = e ? a.stateNode : a.stateNode.instance, b ? c.insertBefore(a, b) : c.appendChild(a);
              else if (4 !== d && (a = a.child, null !== a)) for (hj(a, b, c), a = a.sibling; null !== a; ) hj(a, b, c), a = a.sibling;
            }
            function cj(a, b) {
              for (var c = b, d = false, e, f; ; ) {
                if (!d) {
                  d = c.return;
                  a: for (; ; ) {
                    if (null === d) throw Error(y(160));
                    e = d.stateNode;
                    switch (d.tag) {
                      case 5:
                        f = false;
                        break a;
                      case 3:
                        e = e.containerInfo;
                        f = true;
                        break a;
                      case 4:
                        e = e.containerInfo;
                        f = true;
                        break a;
                    }
                    d = d.return;
                  }
                  d = true;
                }
                if (5 === c.tag || 6 === c.tag) {
                  a: for (var g = a, h = c, k = h; ; ) if (bj(g, k), null !== k.child && 4 !== k.tag) k.child.return = k, k = k.child;
                  else {
                    if (k === h) break a;
                    for (; null === k.sibling; ) {
                      if (null === k.return || k.return === h) break a;
                      k = k.return;
                    }
                    k.sibling.return = k.return;
                    k = k.sibling;
                  }
                  f ? (g = e, h = c.stateNode, 8 === g.nodeType ? g.parentNode.removeChild(h) : g.removeChild(h)) : e.removeChild(c.stateNode);
                } else if (4 === c.tag) {
                  if (null !== c.child) {
                    e = c.stateNode.containerInfo;
                    f = true;
                    c.child.return = c;
                    c = c.child;
                    continue;
                  }
                } else if (bj(a, c), null !== c.child) {
                  c.child.return = c;
                  c = c.child;
                  continue;
                }
                if (c === b) break;
                for (; null === c.sibling; ) {
                  if (null === c.return || c.return === b) return;
                  c = c.return;
                  4 === c.tag && (d = false);
                }
                c.sibling.return = c.return;
                c = c.sibling;
              }
            }
            function ij(a, b) {
              switch (b.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                case 22:
                  var c = b.updateQueue;
                  c = null !== c ? c.lastEffect : null;
                  if (null !== c) {
                    var d = c = c.next;
                    do
                      3 === (d.tag & 3) && (a = d.destroy, d.destroy = void 0, void 0 !== a && a()), d = d.next;
                    while (d !== c);
                  }
                  return;
                case 1:
                  return;
                case 5:
                  c = b.stateNode;
                  if (null != c) {
                    d = b.memoizedProps;
                    var e = null !== a ? a.memoizedProps : d;
                    a = b.type;
                    var f = b.updateQueue;
                    b.updateQueue = null;
                    if (null !== f) {
                      c[xf] = d;
                      "input" === a && "radio" === d.type && null != d.name && $a(c, d);
                      wb(a, e);
                      b = wb(a, d);
                      for (e = 0; e < f.length; e += 2) {
                        var g = f[e], h = f[e + 1];
                        "style" === g ? tb(c, h) : "dangerouslySetInnerHTML" === g ? ob(c, h) : "children" === g ? pb(c, h) : qa(c, g, h, b);
                      }
                      switch (a) {
                        case "input":
                          ab(c, d);
                          break;
                        case "textarea":
                          ib(c, d);
                          break;
                        case "select":
                          a = c._wrapperState.wasMultiple, c._wrapperState.wasMultiple = !!d.multiple, f = d.value, null != f ? fb(c, !!d.multiple, f, false) : a !== !!d.multiple && (null != d.defaultValue ? fb(c, !!d.multiple, d.defaultValue, true) : fb(c, !!d.multiple, d.multiple ? [] : "", false));
                      }
                    }
                  }
                  return;
                case 6:
                  if (null === b.stateNode) throw Error(y(162));
                  b.stateNode.nodeValue = b.memoizedProps;
                  return;
                case 3:
                  c = b.stateNode;
                  c.hydrate && (c.hydrate = false, Cc(c.containerInfo));
                  return;
                case 12:
                  return;
                case 13:
                  null !== b.memoizedState && (jj = O(), aj(b.child, true));
                  kj(b);
                  return;
                case 19:
                  kj(b);
                  return;
                case 17:
                  return;
                case 23:
                case 24:
                  aj(b, null !== b.memoizedState);
                  return;
              }
              throw Error(y(163));
            }
            function kj(a) {
              var b = a.updateQueue;
              if (null !== b) {
                a.updateQueue = null;
                var c = a.stateNode;
                null === c && (c = a.stateNode = new Ui());
                b.forEach(function(b2) {
                  var d = lj.bind(null, a, b2);
                  c.has(b2) || (c.add(b2), b2.then(d, d));
                });
              }
            }
            function mj(a, b) {
              return null !== a && (a = a.memoizedState, null === a || null !== a.dehydrated) ? (b = b.memoizedState, null !== b && null === b.dehydrated) : false;
            }
            var nj = Math.ceil, oj = ra.ReactCurrentDispatcher, pj = ra.ReactCurrentOwner, X = 0, U = null, Y = null, W = 0, qj = 0, rj = Bf(0), V = 0, sj = null, tj = 0, Dg = 0, Hi = 0, uj = 0, vj = null, jj = 0, Ji = Infinity;
            function wj() {
              Ji = O() + 500;
            }
            var Z = null, Qi = false, Ri = null, Ti = null, xj = false, yj = null, zj = 90, Aj = [], Bj = [], Cj = null, Dj = 0, Ej = null, Fj = -1, Gj = 0, Hj = 0, Ij = null, Jj = false;
            function Hg() {
              return 0 !== (X & 48) ? O() : -1 !== Fj ? Fj : Fj = O();
            }
            function Ig(a) {
              a = a.mode;
              if (0 === (a & 2)) return 1;
              if (0 === (a & 4)) return 99 === eg() ? 1 : 2;
              0 === Gj && (Gj = tj);
              if (0 !== kg.transition) {
                0 !== Hj && (Hj = null !== vj ? vj.pendingLanes : 0);
                a = Gj;
                var b = 4186112 & ~Hj;
                b &= -b;
                0 === b && (a = 4186112 & ~a, b = a & -a, 0 === b && (b = 8192));
                return b;
              }
              a = eg();
              0 !== (X & 4) && 98 === a ? a = Xc(12, Gj) : (a = Sc(a), a = Xc(a, Gj));
              return a;
            }
            function Jg(a, b, c) {
              if (50 < Dj) throw Dj = 0, Ej = null, Error(y(185));
              a = Kj(a, b);
              if (null === a) return null;
              $c(a, b, c);
              a === U && (Hi |= b, 4 === V && Ii(a, W));
              var d = eg();
              1 === b ? 0 !== (X & 8) && 0 === (X & 48) ? Lj(a) : (Mj(a, c), 0 === X && (wj(), ig())) : (0 === (X & 4) || 98 !== d && 99 !== d || (null === Cj ? Cj = /* @__PURE__ */ new Set([a]) : Cj.add(a)), Mj(a, c));
              vj = a;
            }
            function Kj(a, b) {
              a.lanes |= b;
              var c = a.alternate;
              null !== c && (c.lanes |= b);
              c = a;
              for (a = a.return; null !== a; ) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
              return 3 === c.tag ? c.stateNode : null;
            }
            function Mj(a, b) {
              for (var c = a.callbackNode, d = a.suspendedLanes, e = a.pingedLanes, f = a.expirationTimes, g = a.pendingLanes; 0 < g; ) {
                var h = 31 - Vc(g), k = 1 << h, l = f[h];
                if (-1 === l) {
                  if (0 === (k & d) || 0 !== (k & e)) {
                    l = b;
                    Rc(k);
                    var n = F;
                    f[h] = 10 <= n ? l + 250 : 6 <= n ? l + 5e3 : -1;
                  }
                } else l <= b && (a.expiredLanes |= k);
                g &= ~k;
              }
              d = Uc(a, a === U ? W : 0);
              b = F;
              if (0 === d) null !== c && (c !== Zf && Pf(c), a.callbackNode = null, a.callbackPriority = 0);
              else {
                if (null !== c) {
                  if (a.callbackPriority === b) return;
                  c !== Zf && Pf(c);
                }
                15 === b ? (c = Lj.bind(null, a), null === ag ? (ag = [c], bg = Of(Uf, jg)) : ag.push(c), c = Zf) : 14 === b ? c = hg(99, Lj.bind(null, a)) : (c = Tc(b), c = hg(c, Nj.bind(null, a)));
                a.callbackPriority = b;
                a.callbackNode = c;
              }
            }
            function Nj(a) {
              Fj = -1;
              Hj = Gj = 0;
              if (0 !== (X & 48)) throw Error(y(327));
              var b = a.callbackNode;
              if (Oj() && a.callbackNode !== b) return null;
              var c = Uc(a, a === U ? W : 0);
              if (0 === c) return null;
              var d = c;
              var e = X;
              X |= 16;
              var f = Pj();
              if (U !== a || W !== d) wj(), Qj(a, d);
              do
                try {
                  Rj();
                  break;
                } catch (h) {
                  Sj(a, h);
                }
              while (1);
              qg();
              oj.current = f;
              X = e;
              null !== Y ? d = 0 : (U = null, W = 0, d = V);
              if (0 !== (tj & Hi)) Qj(a, 0);
              else if (0 !== d) {
                2 === d && (X |= 64, a.hydrate && (a.hydrate = false, qf(a.containerInfo)), c = Wc(a), 0 !== c && (d = Tj(a, c)));
                if (1 === d) throw b = sj, Qj(a, 0), Ii(a, c), Mj(a, O()), b;
                a.finishedWork = a.current.alternate;
                a.finishedLanes = c;
                switch (d) {
                  case 0:
                  case 1:
                    throw Error(y(345));
                  case 2:
                    Uj(a);
                    break;
                  case 3:
                    Ii(a, c);
                    if ((c & 62914560) === c && (d = jj + 500 - O(), 10 < d)) {
                      if (0 !== Uc(a, 0)) break;
                      e = a.suspendedLanes;
                      if ((e & c) !== c) {
                        Hg();
                        a.pingedLanes |= a.suspendedLanes & e;
                        break;
                      }
                      a.timeoutHandle = of(Uj.bind(null, a), d);
                      break;
                    }
                    Uj(a);
                    break;
                  case 4:
                    Ii(a, c);
                    if ((c & 4186112) === c) break;
                    d = a.eventTimes;
                    for (e = -1; 0 < c; ) {
                      var g = 31 - Vc(c);
                      f = 1 << g;
                      g = d[g];
                      g > e && (e = g);
                      c &= ~f;
                    }
                    c = e;
                    c = O() - c;
                    c = (120 > c ? 120 : 480 > c ? 480 : 1080 > c ? 1080 : 1920 > c ? 1920 : 3e3 > c ? 3e3 : 4320 > c ? 4320 : 1960 * nj(c / 1960)) - c;
                    if (10 < c) {
                      a.timeoutHandle = of(Uj.bind(null, a), c);
                      break;
                    }
                    Uj(a);
                    break;
                  case 5:
                    Uj(a);
                    break;
                  default:
                    throw Error(y(329));
                }
              }
              Mj(a, O());
              return a.callbackNode === b ? Nj.bind(null, a) : null;
            }
            function Ii(a, b) {
              b &= ~uj;
              b &= ~Hi;
              a.suspendedLanes |= b;
              a.pingedLanes &= ~b;
              for (a = a.expirationTimes; 0 < b; ) {
                var c = 31 - Vc(b), d = 1 << c;
                a[c] = -1;
                b &= ~d;
              }
            }
            function Lj(a) {
              if (0 !== (X & 48)) throw Error(y(327));
              Oj();
              if (a === U && 0 !== (a.expiredLanes & W)) {
                var b = W;
                var c = Tj(a, b);
                0 !== (tj & Hi) && (b = Uc(a, b), c = Tj(a, b));
              } else b = Uc(a, 0), c = Tj(a, b);
              0 !== a.tag && 2 === c && (X |= 64, a.hydrate && (a.hydrate = false, qf(a.containerInfo)), b = Wc(a), 0 !== b && (c = Tj(a, b)));
              if (1 === c) throw c = sj, Qj(a, 0), Ii(a, b), Mj(a, O()), c;
              a.finishedWork = a.current.alternate;
              a.finishedLanes = b;
              Uj(a);
              Mj(a, O());
              return null;
            }
            function Vj() {
              if (null !== Cj) {
                var a = Cj;
                Cj = null;
                a.forEach(function(a2) {
                  a2.expiredLanes |= 24 & a2.pendingLanes;
                  Mj(a2, O());
                });
              }
              ig();
            }
            function Wj(a, b) {
              var c = X;
              X |= 1;
              try {
                return a(b);
              } finally {
                X = c, 0 === X && (wj(), ig());
              }
            }
            function Xj(a, b) {
              var c = X;
              X &= -2;
              X |= 8;
              try {
                return a(b);
              } finally {
                X = c, 0 === X && (wj(), ig());
              }
            }
            function ni(a, b) {
              I(rj, qj);
              qj |= b;
              tj |= b;
            }
            function Ki() {
              qj = rj.current;
              H(rj);
            }
            function Qj(a, b) {
              a.finishedWork = null;
              a.finishedLanes = 0;
              var c = a.timeoutHandle;
              -1 !== c && (a.timeoutHandle = -1, pf(c));
              if (null !== Y) for (c = Y.return; null !== c; ) {
                var d = c;
                switch (d.tag) {
                  case 1:
                    d = d.type.childContextTypes;
                    null !== d && void 0 !== d && Gf();
                    break;
                  case 3:
                    fh();
                    H(N);
                    H(M);
                    uh();
                    break;
                  case 5:
                    hh(d);
                    break;
                  case 4:
                    fh();
                    break;
                  case 13:
                    H(P);
                    break;
                  case 19:
                    H(P);
                    break;
                  case 10:
                    rg(d);
                    break;
                  case 23:
                  case 24:
                    Ki();
                }
                c = c.return;
              }
              U = a;
              Y = Tg(a.current, null);
              W = qj = tj = b;
              V = 0;
              sj = null;
              uj = Hi = Dg = 0;
            }
            function Sj(a, b) {
              do {
                var c = Y;
                try {
                  qg();
                  vh.current = Gh;
                  if (yh) {
                    for (var d = R.memoizedState; null !== d; ) {
                      var e = d.queue;
                      null !== e && (e.pending = null);
                      d = d.next;
                    }
                    yh = false;
                  }
                  xh = 0;
                  T = S = R = null;
                  zh = false;
                  pj.current = null;
                  if (null === c || null === c.return) {
                    V = 1;
                    sj = b;
                    Y = null;
                    break;
                  }
                  a: {
                    var f = a, g = c.return, h = c, k = b;
                    b = W;
                    h.flags |= 2048;
                    h.firstEffect = h.lastEffect = null;
                    if (null !== k && "object" === typeof k && "function" === typeof k.then) {
                      var l = k;
                      if (0 === (h.mode & 2)) {
                        var n = h.alternate;
                        n ? (h.updateQueue = n.updateQueue, h.memoizedState = n.memoizedState, h.lanes = n.lanes) : (h.updateQueue = null, h.memoizedState = null);
                      }
                      var A = 0 !== (P.current & 1), p = g;
                      do {
                        var C;
                        if (C = 13 === p.tag) {
                          var x = p.memoizedState;
                          if (null !== x) C = null !== x.dehydrated ? true : false;
                          else {
                            var w = p.memoizedProps;
                            C = void 0 === w.fallback ? false : true !== w.unstable_avoidThisFallback ? true : A ? false : true;
                          }
                        }
                        if (C) {
                          var z = p.updateQueue;
                          if (null === z) {
                            var u = /* @__PURE__ */ new Set();
                            u.add(l);
                            p.updateQueue = u;
                          } else z.add(l);
                          if (0 === (p.mode & 2)) {
                            p.flags |= 64;
                            h.flags |= 16384;
                            h.flags &= -2981;
                            if (1 === h.tag) if (null === h.alternate) h.tag = 17;
                            else {
                              var t = zg(-1, 1);
                              t.tag = 2;
                              Ag(h, t);
                            }
                            h.lanes |= 1;
                            break a;
                          }
                          k = void 0;
                          h = b;
                          var q = f.pingCache;
                          null === q ? (q = f.pingCache = new Oi(), k = /* @__PURE__ */ new Set(), q.set(l, k)) : (k = q.get(l), void 0 === k && (k = /* @__PURE__ */ new Set(), q.set(l, k)));
                          if (!k.has(h)) {
                            k.add(h);
                            var v = Yj.bind(null, f, l, h);
                            l.then(v, v);
                          }
                          p.flags |= 4096;
                          p.lanes = b;
                          break a;
                        }
                        p = p.return;
                      } while (null !== p);
                      k = Error((Ra(h.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
                    }
                    5 !== V && (V = 2);
                    k = Mi(k, h);
                    p = g;
                    do {
                      switch (p.tag) {
                        case 3:
                          f = k;
                          p.flags |= 4096;
                          b &= -b;
                          p.lanes |= b;
                          var J = Pi(p, f, b);
                          Bg(p, J);
                          break a;
                        case 1:
                          f = k;
                          var K = p.type, Q = p.stateNode;
                          if (0 === (p.flags & 64) && ("function" === typeof K.getDerivedStateFromError || null !== Q && "function" === typeof Q.componentDidCatch && (null === Ti || !Ti.has(Q)))) {
                            p.flags |= 4096;
                            b &= -b;
                            p.lanes |= b;
                            var L = Si(p, f, b);
                            Bg(p, L);
                            break a;
                          }
                      }
                      p = p.return;
                    } while (null !== p);
                  }
                  Zj(c);
                } catch (va) {
                  b = va;
                  Y === c && null !== c && (Y = c = c.return);
                  continue;
                }
                break;
              } while (1);
            }
            function Pj() {
              var a = oj.current;
              oj.current = Gh;
              return null === a ? Gh : a;
            }
            function Tj(a, b) {
              var c = X;
              X |= 16;
              var d = Pj();
              U === a && W === b || Qj(a, b);
              do
                try {
                  ak();
                  break;
                } catch (e) {
                  Sj(a, e);
                }
              while (1);
              qg();
              X = c;
              oj.current = d;
              if (null !== Y) throw Error(y(261));
              U = null;
              W = 0;
              return V;
            }
            function ak() {
              for (; null !== Y; ) bk(Y);
            }
            function Rj() {
              for (; null !== Y && !Qf(); ) bk(Y);
            }
            function bk(a) {
              var b = ck(a.alternate, a, qj);
              a.memoizedProps = a.pendingProps;
              null === b ? Zj(a) : Y = b;
              pj.current = null;
            }
            function Zj(a) {
              var b = a;
              do {
                var c = b.alternate;
                a = b.return;
                if (0 === (b.flags & 2048)) {
                  c = Gi(c, b, qj);
                  if (null !== c) {
                    Y = c;
                    return;
                  }
                  c = b;
                  if (24 !== c.tag && 23 !== c.tag || null === c.memoizedState || 0 !== (qj & 1073741824) || 0 === (c.mode & 4)) {
                    for (var d = 0, e = c.child; null !== e; ) d |= e.lanes | e.childLanes, e = e.sibling;
                    c.childLanes = d;
                  }
                  null !== a && 0 === (a.flags & 2048) && (null === a.firstEffect && (a.firstEffect = b.firstEffect), null !== b.lastEffect && (null !== a.lastEffect && (a.lastEffect.nextEffect = b.firstEffect), a.lastEffect = b.lastEffect), 1 < b.flags && (null !== a.lastEffect ? a.lastEffect.nextEffect = b : a.firstEffect = b, a.lastEffect = b));
                } else {
                  c = Li(b);
                  if (null !== c) {
                    c.flags &= 2047;
                    Y = c;
                    return;
                  }
                  null !== a && (a.firstEffect = a.lastEffect = null, a.flags |= 2048);
                }
                b = b.sibling;
                if (null !== b) {
                  Y = b;
                  return;
                }
                Y = b = a;
              } while (null !== b);
              0 === V && (V = 5);
            }
            function Uj(a) {
              var b = eg();
              gg(99, dk.bind(null, a, b));
              return null;
            }
            function dk(a, b) {
              do
                Oj();
              while (null !== yj);
              if (0 !== (X & 48)) throw Error(y(327));
              var c = a.finishedWork;
              if (null === c) return null;
              a.finishedWork = null;
              a.finishedLanes = 0;
              if (c === a.current) throw Error(y(177));
              a.callbackNode = null;
              var d = c.lanes | c.childLanes, e = d, f = a.pendingLanes & ~e;
              a.pendingLanes = e;
              a.suspendedLanes = 0;
              a.pingedLanes = 0;
              a.expiredLanes &= e;
              a.mutableReadLanes &= e;
              a.entangledLanes &= e;
              e = a.entanglements;
              for (var g = a.eventTimes, h = a.expirationTimes; 0 < f; ) {
                var k = 31 - Vc(f), l = 1 << k;
                e[k] = 0;
                g[k] = -1;
                h[k] = -1;
                f &= ~l;
              }
              null !== Cj && 0 === (d & 24) && Cj.has(a) && Cj.delete(a);
              a === U && (Y = U = null, W = 0);
              1 < c.flags ? null !== c.lastEffect ? (c.lastEffect.nextEffect = c, d = c.firstEffect) : d = c : d = c.firstEffect;
              if (null !== d) {
                e = X;
                X |= 32;
                pj.current = null;
                kf = fd;
                g = Ne();
                if (Oe(g)) {
                  if ("selectionStart" in g) h = { start: g.selectionStart, end: g.selectionEnd };
                  else a: if (h = (h = g.ownerDocument) && h.defaultView || window, (l = h.getSelection && h.getSelection()) && 0 !== l.rangeCount) {
                    h = l.anchorNode;
                    f = l.anchorOffset;
                    k = l.focusNode;
                    l = l.focusOffset;
                    try {
                      h.nodeType, k.nodeType;
                    } catch (va) {
                      h = null;
                      break a;
                    }
                    var n = 0, A = -1, p = -1, C = 0, x = 0, w = g, z = null;
                    b: for (; ; ) {
                      for (var u; ; ) {
                        w !== h || 0 !== f && 3 !== w.nodeType || (A = n + f);
                        w !== k || 0 !== l && 3 !== w.nodeType || (p = n + l);
                        3 === w.nodeType && (n += w.nodeValue.length);
                        if (null === (u = w.firstChild)) break;
                        z = w;
                        w = u;
                      }
                      for (; ; ) {
                        if (w === g) break b;
                        z === h && ++C === f && (A = n);
                        z === k && ++x === l && (p = n);
                        if (null !== (u = w.nextSibling)) break;
                        w = z;
                        z = w.parentNode;
                      }
                      w = u;
                    }
                    h = -1 === A || -1 === p ? null : { start: A, end: p };
                  } else h = null;
                  h = h || { start: 0, end: 0 };
                } else h = null;
                lf = { focusedElem: g, selectionRange: h };
                fd = false;
                Ij = null;
                Jj = false;
                Z = d;
                do
                  try {
                    ek();
                  } catch (va) {
                    if (null === Z) throw Error(y(330));
                    Wi(Z, va);
                    Z = Z.nextEffect;
                  }
                while (null !== Z);
                Ij = null;
                Z = d;
                do
                  try {
                    for (g = a; null !== Z; ) {
                      var t = Z.flags;
                      t & 16 && pb(Z.stateNode, "");
                      if (t & 128) {
                        var q = Z.alternate;
                        if (null !== q) {
                          var v = q.ref;
                          null !== v && ("function" === typeof v ? v(null) : v.current = null);
                        }
                      }
                      switch (t & 1038) {
                        case 2:
                          fj(Z);
                          Z.flags &= -3;
                          break;
                        case 6:
                          fj(Z);
                          Z.flags &= -3;
                          ij(Z.alternate, Z);
                          break;
                        case 1024:
                          Z.flags &= -1025;
                          break;
                        case 1028:
                          Z.flags &= -1025;
                          ij(Z.alternate, Z);
                          break;
                        case 4:
                          ij(Z.alternate, Z);
                          break;
                        case 8:
                          h = Z;
                          cj(g, h);
                          var J = h.alternate;
                          dj(h);
                          null !== J && dj(J);
                      }
                      Z = Z.nextEffect;
                    }
                  } catch (va) {
                    if (null === Z) throw Error(y(330));
                    Wi(Z, va);
                    Z = Z.nextEffect;
                  }
                while (null !== Z);
                v = lf;
                q = Ne();
                t = v.focusedElem;
                g = v.selectionRange;
                if (q !== t && t && t.ownerDocument && Me(t.ownerDocument.documentElement, t)) {
                  null !== g && Oe(t) && (q = g.start, v = g.end, void 0 === v && (v = q), "selectionStart" in t ? (t.selectionStart = q, t.selectionEnd = Math.min(v, t.value.length)) : (v = (q = t.ownerDocument || document) && q.defaultView || window, v.getSelection && (v = v.getSelection(), h = t.textContent.length, J = Math.min(g.start, h), g = void 0 === g.end ? J : Math.min(g.end, h), !v.extend && J > g && (h = g, g = J, J = h), h = Le(t, J), f = Le(t, g), h && f && (1 !== v.rangeCount || v.anchorNode !== h.node || v.anchorOffset !== h.offset || v.focusNode !== f.node || v.focusOffset !== f.offset) && (q = q.createRange(), q.setStart(h.node, h.offset), v.removeAllRanges(), J > g ? (v.addRange(q), v.extend(f.node, f.offset)) : (q.setEnd(f.node, f.offset), v.addRange(q))))));
                  q = [];
                  for (v = t; v = v.parentNode; ) 1 === v.nodeType && q.push({ element: v, left: v.scrollLeft, top: v.scrollTop });
                  "function" === typeof t.focus && t.focus();
                  for (t = 0; t < q.length; t++) v = q[t], v.element.scrollLeft = v.left, v.element.scrollTop = v.top;
                }
                fd = !!kf;
                lf = kf = null;
                a.current = c;
                Z = d;
                do
                  try {
                    for (t = a; null !== Z; ) {
                      var K = Z.flags;
                      K & 36 && Yi(t, Z.alternate, Z);
                      if (K & 128) {
                        q = void 0;
                        var Q = Z.ref;
                        if (null !== Q) {
                          var L = Z.stateNode;
                          switch (Z.tag) {
                            case 5:
                              q = L;
                              break;
                            default:
                              q = L;
                          }
                          "function" === typeof Q ? Q(q) : Q.current = q;
                        }
                      }
                      Z = Z.nextEffect;
                    }
                  } catch (va) {
                    if (null === Z) throw Error(y(330));
                    Wi(Z, va);
                    Z = Z.nextEffect;
                  }
                while (null !== Z);
                Z = null;
                $f();
                X = e;
              } else a.current = c;
              if (xj) xj = false, yj = a, zj = b;
              else for (Z = d; null !== Z; ) b = Z.nextEffect, Z.nextEffect = null, Z.flags & 8 && (K = Z, K.sibling = null, K.stateNode = null), Z = b;
              d = a.pendingLanes;
              0 === d && (Ti = null);
              1 === d ? a === Ej ? Dj++ : (Dj = 0, Ej = a) : Dj = 0;
              c = c.stateNode;
              if (Mf && "function" === typeof Mf.onCommitFiberRoot) try {
                Mf.onCommitFiberRoot(Lf, c, void 0, 64 === (c.current.flags & 64));
              } catch (va) {
              }
              Mj(a, O());
              if (Qi) throw Qi = false, a = Ri, Ri = null, a;
              if (0 !== (X & 8)) return null;
              ig();
              return null;
            }
            function ek() {
              for (; null !== Z; ) {
                var a = Z.alternate;
                Jj || null === Ij || (0 !== (Z.flags & 8) ? dc(Z, Ij) && (Jj = true) : 13 === Z.tag && mj(a, Z) && dc(Z, Ij) && (Jj = true));
                var b = Z.flags;
                0 !== (b & 256) && Xi(a, Z);
                0 === (b & 512) || xj || (xj = true, hg(97, function() {
                  Oj();
                  return null;
                }));
                Z = Z.nextEffect;
              }
            }
            function Oj() {
              if (90 !== zj) {
                var a = 97 < zj ? 97 : zj;
                zj = 90;
                return gg(a, fk);
              }
              return false;
            }
            function $i(a, b) {
              Aj.push(b, a);
              xj || (xj = true, hg(97, function() {
                Oj();
                return null;
              }));
            }
            function Zi(a, b) {
              Bj.push(b, a);
              xj || (xj = true, hg(97, function() {
                Oj();
                return null;
              }));
            }
            function fk() {
              if (null === yj) return false;
              var a = yj;
              yj = null;
              if (0 !== (X & 48)) throw Error(y(331));
              var b = X;
              X |= 32;
              var c = Bj;
              Bj = [];
              for (var d = 0; d < c.length; d += 2) {
                var e = c[d], f = c[d + 1], g = e.destroy;
                e.destroy = void 0;
                if ("function" === typeof g) try {
                  g();
                } catch (k) {
                  if (null === f) throw Error(y(330));
                  Wi(f, k);
                }
              }
              c = Aj;
              Aj = [];
              for (d = 0; d < c.length; d += 2) {
                e = c[d];
                f = c[d + 1];
                try {
                  var h = e.create;
                  e.destroy = h();
                } catch (k) {
                  if (null === f) throw Error(y(330));
                  Wi(f, k);
                }
              }
              for (h = a.current.firstEffect; null !== h; ) a = h.nextEffect, h.nextEffect = null, h.flags & 8 && (h.sibling = null, h.stateNode = null), h = a;
              X = b;
              ig();
              return true;
            }
            function gk(a, b, c) {
              b = Mi(c, b);
              b = Pi(a, b, 1);
              Ag(a, b);
              b = Hg();
              a = Kj(a, 1);
              null !== a && ($c(a, 1, b), Mj(a, b));
            }
            function Wi(a, b) {
              if (3 === a.tag) gk(a, a, b);
              else for (var c = a.return; null !== c; ) {
                if (3 === c.tag) {
                  gk(c, a, b);
                  break;
                } else if (1 === c.tag) {
                  var d = c.stateNode;
                  if ("function" === typeof c.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ti || !Ti.has(d))) {
                    a = Mi(b, a);
                    var e = Si(c, a, 1);
                    Ag(c, e);
                    e = Hg();
                    c = Kj(c, 1);
                    if (null !== c) $c(c, 1, e), Mj(c, e);
                    else if ("function" === typeof d.componentDidCatch && (null === Ti || !Ti.has(d))) try {
                      d.componentDidCatch(b, a);
                    } catch (f) {
                    }
                    break;
                  }
                }
                c = c.return;
              }
            }
            function Yj(a, b, c) {
              var d = a.pingCache;
              null !== d && d.delete(b);
              b = Hg();
              a.pingedLanes |= a.suspendedLanes & c;
              U === a && (W & c) === c && (4 === V || 3 === V && (W & 62914560) === W && 500 > O() - jj ? Qj(a, 0) : uj |= c);
              Mj(a, b);
            }
            function lj(a, b) {
              var c = a.stateNode;
              null !== c && c.delete(b);
              b = 0;
              0 === b && (b = a.mode, 0 === (b & 2) ? b = 1 : 0 === (b & 4) ? b = 99 === eg() ? 1 : 2 : (0 === Gj && (Gj = tj), b = Yc(62914560 & ~Gj), 0 === b && (b = 4194304)));
              c = Hg();
              a = Kj(a, b);
              null !== a && ($c(a, b, c), Mj(a, c));
            }
            var ck;
            ck = function(a, b, c) {
              var d = b.lanes;
              if (null !== a) if (a.memoizedProps !== b.pendingProps || N.current) ug = true;
              else if (0 !== (c & d)) ug = 0 !== (a.flags & 16384) ? true : false;
              else {
                ug = false;
                switch (b.tag) {
                  case 3:
                    ri(b);
                    sh();
                    break;
                  case 5:
                    gh(b);
                    break;
                  case 1:
                    Ff(b.type) && Jf(b);
                    break;
                  case 4:
                    eh(b, b.stateNode.containerInfo);
                    break;
                  case 10:
                    d = b.memoizedProps.value;
                    var e = b.type._context;
                    I(mg, e._currentValue);
                    e._currentValue = d;
                    break;
                  case 13:
                    if (null !== b.memoizedState) {
                      if (0 !== (c & b.child.childLanes)) return ti(a, b, c);
                      I(P, P.current & 1);
                      b = hi(a, b, c);
                      return null !== b ? b.sibling : null;
                    }
                    I(P, P.current & 1);
                    break;
                  case 19:
                    d = 0 !== (c & b.childLanes);
                    if (0 !== (a.flags & 64)) {
                      if (d) return Ai(a, b, c);
                      b.flags |= 64;
                    }
                    e = b.memoizedState;
                    null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
                    I(P, P.current);
                    if (d) break;
                    else return null;
                  case 23:
                  case 24:
                    return b.lanes = 0, mi(a, b, c);
                }
                return hi(a, b, c);
              }
              else ug = false;
              b.lanes = 0;
              switch (b.tag) {
                case 2:
                  d = b.type;
                  null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
                  a = b.pendingProps;
                  e = Ef(b, M.current);
                  tg(b, c);
                  e = Ch(null, b, d, a, e, c);
                  b.flags |= 1;
                  if ("object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof) {
                    b.tag = 1;
                    b.memoizedState = null;
                    b.updateQueue = null;
                    if (Ff(d)) {
                      var f = true;
                      Jf(b);
                    } else f = false;
                    b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null;
                    xg(b);
                    var g = d.getDerivedStateFromProps;
                    "function" === typeof g && Gg(b, d, g, a);
                    e.updater = Kg;
                    b.stateNode = e;
                    e._reactInternals = b;
                    Og(b, d, a, c);
                    b = qi(null, b, d, true, f, c);
                  } else b.tag = 0, fi(null, b, e, c), b = b.child;
                  return b;
                case 16:
                  e = b.elementType;
                  a: {
                    null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
                    a = b.pendingProps;
                    f = e._init;
                    e = f(e._payload);
                    b.type = e;
                    f = b.tag = hk(e);
                    a = lg(e, a);
                    switch (f) {
                      case 0:
                        b = li(null, b, e, a, c);
                        break a;
                      case 1:
                        b = pi(null, b, e, a, c);
                        break a;
                      case 11:
                        b = gi(null, b, e, a, c);
                        break a;
                      case 14:
                        b = ii(null, b, e, lg(e.type, a), d, c);
                        break a;
                    }
                    throw Error(y(306, e, ""));
                  }
                  return b;
                case 0:
                  return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), li(a, b, d, e, c);
                case 1:
                  return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), pi(a, b, d, e, c);
                case 3:
                  ri(b);
                  d = b.updateQueue;
                  if (null === a || null === d) throw Error(y(282));
                  d = b.pendingProps;
                  e = b.memoizedState;
                  e = null !== e ? e.element : null;
                  yg(a, b);
                  Cg(b, d, null, c);
                  d = b.memoizedState.element;
                  if (d === e) sh(), b = hi(a, b, c);
                  else {
                    e = b.stateNode;
                    if (f = e.hydrate) kh = rf(b.stateNode.containerInfo.firstChild), jh = b, f = lh = true;
                    if (f) {
                      a = e.mutableSourceEagerHydrationData;
                      if (null != a) for (e = 0; e < a.length; e += 2) f = a[e], f._workInProgressVersionPrimary = a[e + 1], th.push(f);
                      c = Zg(b, null, d, c);
                      for (b.child = c; c; ) c.flags = c.flags & -3 | 1024, c = c.sibling;
                    } else fi(a, b, d, c), sh();
                    b = b.child;
                  }
                  return b;
                case 5:
                  return gh(b), null === a && ph(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, nf(d, e) ? g = null : null !== f && nf(d, f) && (b.flags |= 16), oi(a, b), fi(a, b, g, c), b.child;
                case 6:
                  return null === a && ph(b), null;
                case 13:
                  return ti(a, b, c);
                case 4:
                  return eh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Yg(b, null, d, c) : fi(a, b, d, c), b.child;
                case 11:
                  return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), gi(a, b, d, e, c);
                case 7:
                  return fi(a, b, b.pendingProps, c), b.child;
                case 8:
                  return fi(
                    a,
                    b,
                    b.pendingProps.children,
                    c
                  ), b.child;
                case 12:
                  return fi(a, b, b.pendingProps.children, c), b.child;
                case 10:
                  a: {
                    d = b.type._context;
                    e = b.pendingProps;
                    g = b.memoizedProps;
                    f = e.value;
                    var h = b.type._context;
                    I(mg, h._currentValue);
                    h._currentValue = f;
                    if (null !== g) if (h = g.value, f = He(h, f) ? 0 : ("function" === typeof d._calculateChangedBits ? d._calculateChangedBits(h, f) : 1073741823) | 0, 0 === f) {
                      if (g.children === e.children && !N.current) {
                        b = hi(a, b, c);
                        break a;
                      }
                    } else for (h = b.child, null !== h && (h.return = b); null !== h; ) {
                      var k = h.dependencies;
                      if (null !== k) {
                        g = h.child;
                        for (var l = k.firstContext; null !== l; ) {
                          if (l.context === d && 0 !== (l.observedBits & f)) {
                            1 === h.tag && (l = zg(-1, c & -c), l.tag = 2, Ag(h, l));
                            h.lanes |= c;
                            l = h.alternate;
                            null !== l && (l.lanes |= c);
                            sg(h.return, c);
                            k.lanes |= c;
                            break;
                          }
                          l = l.next;
                        }
                      } else g = 10 === h.tag ? h.type === b.type ? null : h.child : h.child;
                      if (null !== g) g.return = h;
                      else for (g = h; null !== g; ) {
                        if (g === b) {
                          g = null;
                          break;
                        }
                        h = g.sibling;
                        if (null !== h) {
                          h.return = g.return;
                          g = h;
                          break;
                        }
                        g = g.return;
                      }
                      h = g;
                    }
                    fi(a, b, e.children, c);
                    b = b.child;
                  }
                  return b;
                case 9:
                  return e = b.type, f = b.pendingProps, d = f.children, tg(b, c), e = vg(
                    e,
                    f.unstable_observedBits
                  ), d = d(e), b.flags |= 1, fi(a, b, d, c), b.child;
                case 14:
                  return e = b.type, f = lg(e, b.pendingProps), f = lg(e.type, f), ii(a, b, e, f, d, c);
                case 15:
                  return ki(a, b, b.type, b.pendingProps, d, c);
                case 17:
                  return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2), b.tag = 1, Ff(d) ? (a = true, Jf(b)) : a = false, tg(b, c), Mg(b, d, e), Og(b, d, e, c), qi(null, b, d, true, a, c);
                case 19:
                  return Ai(a, b, c);
                case 23:
                  return mi(a, b, c);
                case 24:
                  return mi(a, b, c);
              }
              throw Error(y(156, b.tag));
            };
            function ik(a, b, c, d) {
              this.tag = a;
              this.key = c;
              this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
              this.index = 0;
              this.ref = null;
              this.pendingProps = b;
              this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
              this.mode = d;
              this.flags = 0;
              this.lastEffect = this.firstEffect = this.nextEffect = null;
              this.childLanes = this.lanes = 0;
              this.alternate = null;
            }
            function nh(a, b, c, d) {
              return new ik(a, b, c, d);
            }
            function ji(a) {
              a = a.prototype;
              return !(!a || !a.isReactComponent);
            }
            function hk(a) {
              if ("function" === typeof a) return ji(a) ? 1 : 0;
              if (void 0 !== a && null !== a) {
                a = a.$$typeof;
                if (a === Aa) return 11;
                if (a === Da) return 14;
              }
              return 2;
            }
            function Tg(a, b) {
              var c = a.alternate;
              null === c ? (c = nh(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.nextEffect = null, c.firstEffect = null, c.lastEffect = null);
              c.childLanes = a.childLanes;
              c.lanes = a.lanes;
              c.child = a.child;
              c.memoizedProps = a.memoizedProps;
              c.memoizedState = a.memoizedState;
              c.updateQueue = a.updateQueue;
              b = a.dependencies;
              c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
              c.sibling = a.sibling;
              c.index = a.index;
              c.ref = a.ref;
              return c;
            }
            function Vg(a, b, c, d, e, f) {
              var g = 2;
              d = a;
              if ("function" === typeof a) ji(a) && (g = 1);
              else if ("string" === typeof a) g = 5;
              else a: switch (a) {
                case ua:
                  return Xg(c.children, e, f, b);
                case Ha:
                  g = 8;
                  e |= 16;
                  break;
                case wa:
                  g = 8;
                  e |= 1;
                  break;
                case xa:
                  return a = nh(12, c, b, e | 8), a.elementType = xa, a.type = xa, a.lanes = f, a;
                case Ba:
                  return a = nh(13, c, b, e), a.type = Ba, a.elementType = Ba, a.lanes = f, a;
                case Ca:
                  return a = nh(19, c, b, e), a.elementType = Ca, a.lanes = f, a;
                case Ia:
                  return vi(c, e, f, b);
                case Ja:
                  return a = nh(24, c, b, e), a.elementType = Ja, a.lanes = f, a;
                default:
                  if ("object" === typeof a && null !== a) switch (a.$$typeof) {
                    case ya:
                      g = 10;
                      break a;
                    case za:
                      g = 9;
                      break a;
                    case Aa:
                      g = 11;
                      break a;
                    case Da:
                      g = 14;
                      break a;
                    case Ea:
                      g = 16;
                      d = null;
                      break a;
                    case Fa:
                      g = 22;
                      break a;
                  }
                  throw Error(y(130, null == a ? a : typeof a, ""));
              }
              b = nh(g, c, b, e);
              b.elementType = a;
              b.type = d;
              b.lanes = f;
              return b;
            }
            function Xg(a, b, c, d) {
              a = nh(7, a, d, b);
              a.lanes = c;
              return a;
            }
            function vi(a, b, c, d) {
              a = nh(23, a, d, b);
              a.elementType = Ia;
              a.lanes = c;
              return a;
            }
            function Ug(a, b, c) {
              a = nh(6, a, null, b);
              a.lanes = c;
              return a;
            }
            function Wg(a, b, c) {
              b = nh(4, null !== a.children ? a.children : [], a.key, b);
              b.lanes = c;
              b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
              return b;
            }
            function jk(a, b, c) {
              this.tag = b;
              this.containerInfo = a;
              this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
              this.timeoutHandle = -1;
              this.pendingContext = this.context = null;
              this.hydrate = c;
              this.callbackNode = null;
              this.callbackPriority = 0;
              this.eventTimes = Zc(0);
              this.expirationTimes = Zc(-1);
              this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
              this.entanglements = Zc(0);
              this.mutableSourceEagerHydrationData = null;
            }
            function kk(a, b, c) {
              var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
              return { $$typeof: ta, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
            }
            function lk(a, b, c, d) {
              var e = b.current, f = Hg(), g = Ig(e);
              a: if (c) {
                c = c._reactInternals;
                b: {
                  if (Zb(c) !== c || 1 !== c.tag) throw Error(y(170));
                  var h = c;
                  do {
                    switch (h.tag) {
                      case 3:
                        h = h.stateNode.context;
                        break b;
                      case 1:
                        if (Ff(h.type)) {
                          h = h.stateNode.__reactInternalMemoizedMergedChildContext;
                          break b;
                        }
                    }
                    h = h.return;
                  } while (null !== h);
                  throw Error(y(171));
                }
                if (1 === c.tag) {
                  var k = c.type;
                  if (Ff(k)) {
                    c = If(c, k, h);
                    break a;
                  }
                }
                c = h;
              } else c = Cf;
              null === b.context ? b.context = c : b.pendingContext = c;
              b = zg(f, g);
              b.payload = { element: a };
              d = void 0 === d ? null : d;
              null !== d && (b.callback = d);
              Ag(e, b);
              Jg(e, g, f);
              return g;
            }
            function mk(a) {
              a = a.current;
              if (!a.child) return null;
              switch (a.child.tag) {
                case 5:
                  return a.child.stateNode;
                default:
                  return a.child.stateNode;
              }
            }
            function nk(a, b) {
              a = a.memoizedState;
              if (null !== a && null !== a.dehydrated) {
                var c = a.retryLane;
                a.retryLane = 0 !== c && c < b ? c : b;
              }
            }
            function ok(a, b) {
              nk(a, b);
              (a = a.alternate) && nk(a, b);
            }
            function pk() {
              return null;
            }
            function qk(a, b, c) {
              var d = null != c && null != c.hydrationOptions && c.hydrationOptions.mutableSources || null;
              c = new jk(a, b, null != c && true === c.hydrate);
              b = nh(3, null, null, 2 === b ? 7 : 1 === b ? 3 : 0);
              c.current = b;
              b.stateNode = c;
              xg(b);
              a[ff] = c.current;
              cf(8 === a.nodeType ? a.parentNode : a);
              if (d) for (a = 0; a < d.length; a++) {
                b = d[a];
                var e = b._getVersion;
                e = e(b._source);
                null == c.mutableSourceEagerHydrationData ? c.mutableSourceEagerHydrationData = [b, e] : c.mutableSourceEagerHydrationData.push(b, e);
              }
              this._internalRoot = c;
            }
            qk.prototype.render = function(a) {
              lk(a, this._internalRoot, null, null);
            };
            qk.prototype.unmount = function() {
              var a = this._internalRoot, b = a.containerInfo;
              lk(null, a, null, function() {
                b[ff] = null;
              });
            };
            function rk(a) {
              return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
            }
            function sk(a, b) {
              b || (b = a ? 9 === a.nodeType ? a.documentElement : a.firstChild : null, b = !(!b || 1 !== b.nodeType || !b.hasAttribute("data-reactroot")));
              if (!b) for (var c; c = a.lastChild; ) a.removeChild(c);
              return new qk(a, 0, b ? { hydrate: true } : void 0);
            }
            function tk(a, b, c, d, e) {
              var f = c._reactRootContainer;
              if (f) {
                var g = f._internalRoot;
                if ("function" === typeof e) {
                  var h = e;
                  e = function() {
                    var a2 = mk(g);
                    h.call(a2);
                  };
                }
                lk(b, g, a, e);
              } else {
                f = c._reactRootContainer = sk(c, d);
                g = f._internalRoot;
                if ("function" === typeof e) {
                  var k = e;
                  e = function() {
                    var a2 = mk(g);
                    k.call(a2);
                  };
                }
                Xj(function() {
                  lk(b, g, a, e);
                });
              }
              return mk(g);
            }
            ec = function(a) {
              if (13 === a.tag) {
                var b = Hg();
                Jg(a, 4, b);
                ok(a, 4);
              }
            };
            fc = function(a) {
              if (13 === a.tag) {
                var b = Hg();
                Jg(a, 67108864, b);
                ok(a, 67108864);
              }
            };
            gc = function(a) {
              if (13 === a.tag) {
                var b = Hg(), c = Ig(a);
                Jg(a, c, b);
                ok(a, c);
              }
            };
            hc = function(a, b) {
              return b();
            };
            yb = function(a, b, c) {
              switch (b) {
                case "input":
                  ab(a, c);
                  b = c.name;
                  if ("radio" === c.type && null != b) {
                    for (c = a; c.parentNode; ) c = c.parentNode;
                    c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
                    for (b = 0; b < c.length; b++) {
                      var d = c[b];
                      if (d !== a && d.form === a.form) {
                        var e = Db(d);
                        if (!e) throw Error(y(90));
                        Wa(d);
                        ab(d, e);
                      }
                    }
                  }
                  break;
                case "textarea":
                  ib(a, c);
                  break;
                case "select":
                  b = c.value, null != b && fb(a, !!c.multiple, b, false);
              }
            };
            Gb = Wj;
            Hb = function(a, b, c, d, e) {
              var f = X;
              X |= 4;
              try {
                return gg(98, a.bind(null, b, c, d, e));
              } finally {
                X = f, 0 === X && (wj(), ig());
              }
            };
            Ib = function() {
              0 === (X & 49) && (Vj(), Oj());
            };
            Jb = function(a, b) {
              var c = X;
              X |= 2;
              try {
                return a(b);
              } finally {
                X = c, 0 === X && (wj(), ig());
              }
            };
            function uk(a, b) {
              var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
              if (!rk(b)) throw Error(y(200));
              return kk(a, b, null, c);
            }
            var vk = { Events: [Cb, ue, Db, Eb, Fb, Oj, { current: false }] }, wk = { findFiberByHostInstance: wc, bundleType: 0, version: "17.0.1", rendererPackageName: "react-dom" };
            var xk = { bundleType: wk.bundleType, version: wk.version, rendererPackageName: wk.rendererPackageName, rendererConfig: wk.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ra.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
              a = cc(a);
              return null === a ? null : a.stateNode;
            }, findFiberByHostInstance: wk.findFiberByHostInstance || pk, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null };
            if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
              var yk = __REACT_DEVTOOLS_GLOBAL_HOOK__;
              if (!yk.isDisabled && yk.supportsFiber) try {
                Lf = yk.inject(xk), Mf = yk;
              } catch (a) {
              }
            }
            exports2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk;
            exports2.createPortal = uk;
            exports2.findDOMNode = function(a) {
              if (null == a) return null;
              if (1 === a.nodeType) return a;
              var b = a._reactInternals;
              if (void 0 === b) {
                if ("function" === typeof a.render) throw Error(y(188));
                throw Error(y(268, Object.keys(a)));
              }
              a = cc(b);
              a = null === a ? null : a.stateNode;
              return a;
            };
            exports2.flushSync = function(a, b) {
              var c = X;
              if (0 !== (c & 48)) return a(b);
              X |= 1;
              try {
                if (a) return gg(99, a.bind(null, b));
              } finally {
                X = c, ig();
              }
            };
            exports2.hydrate = function(a, b, c) {
              if (!rk(b)) throw Error(y(200));
              return tk(null, a, b, true, c);
            };
            exports2.render = function(a, b, c) {
              if (!rk(b)) throw Error(y(200));
              return tk(null, a, b, false, c);
            };
            exports2.unmountComponentAtNode = function(a) {
              if (!rk(a)) throw Error(y(40));
              return a._reactRootContainer ? (Xj(function() {
                tk(null, null, a, false, function() {
                  a._reactRootContainer = null;
                  a[ff] = null;
                });
              }), true) : false;
            };
            exports2.unstable_batchedUpdates = Wj;
            exports2.unstable_createPortal = function(a, b) {
              return uk(a, b, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null);
            };
            exports2.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
              if (!rk(c)) throw Error(y(200));
              if (null == a || void 0 === a._reactInternals) throw Error(y(38));
              return tk(a, b, c, false, d);
            };
            exports2.version = "17.0.1";
          },
          /* 58 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            if (true) {
              module2.exports = __webpack_require__2(59);
            } else {
            }
          },
          /* 59 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var f, g, h, k;
            if ("object" === typeof performance && "function" === typeof performance.now) {
              var l = performance;
              exports2.unstable_now = function() {
                return l.now();
              };
            } else {
              var p = Date, q = p.now();
              exports2.unstable_now = function() {
                return p.now() - q;
              };
            }
            if ("undefined" === typeof window || "function" !== typeof MessageChannel) {
              var t = null, u = null, w = function() {
                if (null !== t) try {
                  var a = exports2.unstable_now();
                  t(true, a);
                  t = null;
                } catch (b) {
                  throw setTimeout(w, 0), b;
                }
              };
              f = function(a) {
                null !== t ? setTimeout(f, 0, a) : (t = a, setTimeout(w, 0));
              };
              g = function(a, b) {
                u = setTimeout(a, b);
              };
              h = function() {
                clearTimeout(u);
              };
              exports2.unstable_shouldYield = function() {
                return false;
              };
              k = exports2.unstable_forceFrameRate = function() {
              };
            } else {
              var x = window.setTimeout, y = window.clearTimeout;
              if ("undefined" !== typeof console) {
                var z = window.cancelAnimationFrame;
                "function" !== typeof window.requestAnimationFrame && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
                "function" !== typeof z && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
              }
              var A = false, B = null, C = -1, D = 5, E = 0;
              exports2.unstable_shouldYield = function() {
                return exports2.unstable_now() >= E;
              };
              k = function() {
              };
              exports2.unstable_forceFrameRate = function(a) {
                0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D = 0 < a ? Math.floor(1e3 / a) : 5;
              };
              var F = new MessageChannel(), G = F.port2;
              F.port1.onmessage = function() {
                if (null !== B) {
                  var a = exports2.unstable_now();
                  E = a + D;
                  try {
                    B(true, a) ? G.postMessage(null) : (A = false, B = null);
                  } catch (b) {
                    throw G.postMessage(null), b;
                  }
                } else A = false;
              };
              f = function(a) {
                B = a;
                A || (A = true, G.postMessage(null));
              };
              g = function(a, b) {
                C = x(function() {
                  a(exports2.unstable_now());
                }, b);
              };
              h = function() {
                y(C);
                C = -1;
              };
            }
            function H(a, b) {
              var c = a.length;
              a.push(b);
              a: for (; ; ) {
                var d = c - 1 >>> 1, e = a[d];
                if (void 0 !== e && 0 < I(e, b)) a[d] = b, a[c] = e, c = d;
                else break a;
              }
            }
            function J(a) {
              a = a[0];
              return void 0 === a ? null : a;
            }
            function K(a) {
              var b = a[0];
              if (void 0 !== b) {
                var c = a.pop();
                if (c !== b) {
                  a[0] = c;
                  a: for (var d = 0, e = a.length; d < e; ) {
                    var m = 2 * (d + 1) - 1, n = a[m], v = m + 1, r = a[v];
                    if (void 0 !== n && 0 > I(n, c)) void 0 !== r && 0 > I(r, n) ? (a[d] = r, a[v] = c, d = v) : (a[d] = n, a[m] = c, d = m);
                    else if (void 0 !== r && 0 > I(r, c)) a[d] = r, a[v] = c, d = v;
                    else break a;
                  }
                }
                return b;
              }
              return null;
            }
            function I(a, b) {
              var c = a.sortIndex - b.sortIndex;
              return 0 !== c ? c : a.id - b.id;
            }
            var L = [], M = [], N = 1, O = null, P = 3, Q = false, R = false, S = false;
            function T(a) {
              for (var b = J(M); null !== b; ) {
                if (null === b.callback) K(M);
                else if (b.startTime <= a) K(M), b.sortIndex = b.expirationTime, H(L, b);
                else break;
                b = J(M);
              }
            }
            function U(a) {
              S = false;
              T(a);
              if (!R) if (null !== J(L)) R = true, f(V);
              else {
                var b = J(M);
                null !== b && g(U, b.startTime - a);
              }
            }
            function V(a, b) {
              R = false;
              S && (S = false, h());
              Q = true;
              var c = P;
              try {
                T(b);
                for (O = J(L); null !== O && (!(O.expirationTime > b) || a && !exports2.unstable_shouldYield()); ) {
                  var d = O.callback;
                  if ("function" === typeof d) {
                    O.callback = null;
                    P = O.priorityLevel;
                    var e = d(O.expirationTime <= b);
                    b = exports2.unstable_now();
                    "function" === typeof e ? O.callback = e : O === J(L) && K(L);
                    T(b);
                  } else K(L);
                  O = J(L);
                }
                if (null !== O) var m = true;
                else {
                  var n = J(M);
                  null !== n && g(U, n.startTime - b);
                  m = false;
                }
                return m;
              } finally {
                O = null, P = c, Q = false;
              }
            }
            var W = k;
            exports2.unstable_IdlePriority = 5;
            exports2.unstable_ImmediatePriority = 1;
            exports2.unstable_LowPriority = 4;
            exports2.unstable_NormalPriority = 3;
            exports2.unstable_Profiling = null;
            exports2.unstable_UserBlockingPriority = 2;
            exports2.unstable_cancelCallback = function(a) {
              a.callback = null;
            };
            exports2.unstable_continueExecution = function() {
              R || Q || (R = true, f(V));
            };
            exports2.unstable_getCurrentPriorityLevel = function() {
              return P;
            };
            exports2.unstable_getFirstCallbackNode = function() {
              return J(L);
            };
            exports2.unstable_next = function(a) {
              switch (P) {
                case 1:
                case 2:
                case 3:
                  var b = 3;
                  break;
                default:
                  b = P;
              }
              var c = P;
              P = b;
              try {
                return a();
              } finally {
                P = c;
              }
            };
            exports2.unstable_pauseExecution = function() {
            };
            exports2.unstable_requestPaint = W;
            exports2.unstable_runWithPriority = function(a, b) {
              switch (a) {
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                  break;
                default:
                  a = 3;
              }
              var c = P;
              P = a;
              try {
                return b();
              } finally {
                P = c;
              }
            };
            exports2.unstable_scheduleCallback = function(a, b, c) {
              var d = exports2.unstable_now();
              "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
              switch (a) {
                case 1:
                  var e = -1;
                  break;
                case 2:
                  e = 250;
                  break;
                case 5:
                  e = 1073741823;
                  break;
                case 4:
                  e = 1e4;
                  break;
                default:
                  e = 5e3;
              }
              e = c + e;
              a = { id: N++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
              c > d ? (a.sortIndex = c, H(M, a), null === J(L) && a === J(M) && (S ? h() : S = true, g(U, c - d))) : (a.sortIndex = e, H(L, a), R || Q || (R = true, f(V)));
              return a;
            };
            exports2.unstable_wrapCallback = function(a) {
              var b = P;
              return function() {
                var c = P;
                P = b;
                try {
                  return a.apply(this, arguments);
                } finally {
                  P = c;
                }
              };
            };
          },
          /* 60 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            if (false) {
              var throwOnDirectAccess, ReactIs;
            } else {
              module2.exports = __webpack_require__2(61)();
            }
          },
          /* 61 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var ReactPropTypesSecret = __webpack_require__2(62);
            function emptyFunction() {
            }
            function emptyFunctionWithReset() {
            }
            emptyFunctionWithReset.resetWarningCache = emptyFunction;
            module2.exports = function() {
              function shim(props, propName, componentName, location, propFullName, secret) {
                if (secret === ReactPropTypesSecret) {
                  return;
                }
                var err = new Error(
                  "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
                );
                err.name = "Invariant Violation";
                throw err;
              }
              ;
              shim.isRequired = shim;
              function getShim() {
                return shim;
              }
              ;
              var ReactPropTypes = {
                array: shim,
                bool: shim,
                func: shim,
                number: shim,
                object: shim,
                string: shim,
                symbol: shim,
                any: shim,
                arrayOf: getShim,
                element: shim,
                elementType: shim,
                instanceOf: getShim,
                node: shim,
                objectOf: getShim,
                oneOf: getShim,
                oneOfType: getShim,
                shape: getShim,
                exact: getShim,
                checkPropTypes: emptyFunctionWithReset,
                resetWarningCache: emptyFunction
              };
              ReactPropTypes.PropTypes = ReactPropTypes;
              return ReactPropTypes;
            };
          },
          /* 62 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
            module2.exports = ReactPropTypesSecret;
          },
          /* 63 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var b = "function" === typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
            function z(a) {
              if ("object" === typeof a && null !== a) {
                var u = a.$$typeof;
                switch (u) {
                  case c:
                    switch (a = a.type, a) {
                      case l:
                      case m:
                      case e:
                      case g:
                      case f:
                      case p:
                        return a;
                      default:
                        switch (a = a && a.$$typeof, a) {
                          case k:
                          case n:
                          case t:
                          case r:
                          case h:
                            return a;
                          default:
                            return u;
                        }
                    }
                  case d:
                    return u;
                }
              }
            }
            function A(a) {
              return z(a) === m;
            }
            exports2.AsyncMode = l;
            exports2.ConcurrentMode = m;
            exports2.ContextConsumer = k;
            exports2.ContextProvider = h;
            exports2.Element = c;
            exports2.ForwardRef = n;
            exports2.Fragment = e;
            exports2.Lazy = t;
            exports2.Memo = r;
            exports2.Portal = d;
            exports2.Profiler = g;
            exports2.StrictMode = f;
            exports2.Suspense = p;
            exports2.isAsyncMode = function(a) {
              return A(a) || z(a) === l;
            };
            exports2.isConcurrentMode = A;
            exports2.isContextConsumer = function(a) {
              return z(a) === k;
            };
            exports2.isContextProvider = function(a) {
              return z(a) === h;
            };
            exports2.isElement = function(a) {
              return "object" === typeof a && null !== a && a.$$typeof === c;
            };
            exports2.isForwardRef = function(a) {
              return z(a) === n;
            };
            exports2.isFragment = function(a) {
              return z(a) === e;
            };
            exports2.isLazy = function(a) {
              return z(a) === t;
            };
            exports2.isMemo = function(a) {
              return z(a) === r;
            };
            exports2.isPortal = function(a) {
              return z(a) === d;
            };
            exports2.isProfiler = function(a) {
              return z(a) === g;
            };
            exports2.isStrictMode = function(a) {
              return z(a) === f;
            };
            exports2.isSuspense = function(a) {
              return z(a) === p;
            };
            exports2.isValidElementType = function(a) {
              return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
            };
            exports2.typeOf = z;
          },
          /* 64 */
          /***/
          function(module2, exports2) {
            module2.exports = function(originalModule) {
              if (!originalModule.webpackPolyfill) {
                var module3 = Object.create(originalModule);
                if (!module3.children) module3.children = [];
                Object.defineProperty(module3, "loaded", {
                  enumerable: true,
                  get: function() {
                    return module3.l;
                  }
                });
                Object.defineProperty(module3, "id", {
                  enumerable: true,
                  get: function() {
                    return module3.i;
                  }
                });
                Object.defineProperty(module3, "exports", {
                  enumerable: true
                });
                module3.webpackPolyfill = 1;
              }
              return module3;
            };
          },
          /* 65 */
          /***/
          function(module2, exports2) {
            function _objectWithoutPropertiesLoose(source, excluded) {
              if (source == null) return {};
              var target = {};
              var sourceKeys = Object.keys(source);
              var key, i;
              for (i = 0; i < sourceKeys.length; i++) {
                key = sourceKeys[i];
                if (excluded.indexOf(key) >= 0) continue;
                target[key] = source[key];
              }
              return target;
            }
            module2.exports = _objectWithoutPropertiesLoose;
          },
          /* 66 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            var CONSTANTS = __webpack_require__2(35);
            function parser(arrayBuffer) {
              var data = {};
              var i = 0;
              var arr = new Int8Array(arrayBuffer);
              data.type = String.fromCharCode.apply(null, arr.slice(i, CONSTANTS.HEADER.length));
              if (data.type !== CONSTANTS.HEADER) {
                throw new Error("Invalid .eqf file.");
              }
              i += CONSTANTS.HEADER.length;
              i += 4;
              data.presets = [];
              while (i < arr.length) {
                var preset = {};
                var nameStart = i;
                var nameEnd = nameStart + 257;
                while (arr[i] !== 0 && i <= nameEnd) {
                  i++;
                }
                preset.name = String.fromCharCode.apply(null, arr.slice(nameStart, i));
                i = nameEnd;
                CONSTANTS.PRESET_VALUES.forEach(function(valueName) {
                  preset[valueName] = 64 - arr[i++];
                });
                data.presets.push(preset);
              }
              return data;
            }
            module2.exports = parser;
          },
          /* 67 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            var CONSTANTS = __webpack_require__2(35);
            var FILL_SIZE = 4;
            var PRESET_LENGTH = 257;
            function creator(data) {
              var buffer = [];
              for (var i = 0; i < CONSTANTS.HEADER.length; i++) {
                buffer.push(CONSTANTS.HEADER.charCodeAt(i));
              }
              buffer.push(26);
              var ending = "!--";
              for (var i = 0; i < ending.length; i++) {
                buffer.push(ending.charCodeAt(i));
              }
              if (!data.presets) {
                throw new Error("Eqf data is missing presets");
              }
              data.presets.forEach(function(preset) {
                var k = 0;
                for (; k < preset.name.length; k++) {
                  buffer.push(preset.name.charCodeAt(k));
                }
                for (; k < PRESET_LENGTH; k++) {
                  buffer.push(0);
                }
                CONSTANTS.PRESET_VALUES.forEach(function(valueName) {
                  buffer.push(64 - preset[valueName]);
                });
              });
              return new Uint8Array(buffer).buffer;
            }
            module2.exports = creator;
          },
          /* 68 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            var content = __webpack_require__2(69);
            if (typeof content === "string") content = [[module2.i, content, ""]];
            var transform;
            var insertInto;
            var options = { "hmr": true };
            options.transform = transform;
            options.insertInto = void 0;
            var update = __webpack_require__2(11)(content, options);
            if (content.locals) module2.exports = content.locals;
            if (false) {
            }
          },
          /* 69 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            exports2 = module2.exports = __webpack_require__2(10)(false);
            exports2.push([module2.i, "#webamp .gen-text-space{width:5px}#webamp .gen-text-letter{height:7px;display:inline-block}#webamp .gen-window{width:275px;height:116px;display:flex;flex-direction:column}#webamp .gen-top{height:20px;display:flex;flex-direction:row}#webamp .gen-top-left{width:25px;height:20px}#webamp .gen-top-title{line-height:7px;margin-top:2px;padding:0 3px 0 4px}#webamp .gen-top-left-fill{flex-grow:1;height:20px;background-position:0}#webamp .gen-top-right-fill{flex-grow:1;height:20px;background-position:100%}#webamp .gen-top-left-end,#webamp .gen-top-right,#webamp .gen-top-right-end{width:25px;height:20px}#webamp .gen-close{width:9px;height:9px;position:absolute;right:2px;top:3px}#webamp .gen-middle{flex-grow:1;display:flex;flex-direction:row;position:relative}#webamp .gen-middle-left{width:11px}#webamp .gen-middle-left-bottom{width:11px;height:24px;bottom:0;position:absolute}#webamp .gen-middle-center{flex-grow:1;position:relative}#webamp .gen-middle-right{width:8px}#webamp .gen-middle-right-bottom{width:8px;height:24px;bottom:0;position:absolute}#webamp .gen-bottom{height:14px;background-repeat:repeat-x}#webamp .gen-bottom-left{position:absolute;left:0;width:125px;height:14px}#webamp .gen-bottom-right{position:absolute;right:0;width:125px;height:14px}#webamp .gen-bottom-right #gen-resize-target{position:absolute;right:0;bottom:0;height:20px;width:20px}", ""]);
          },
          /* 70 */
          /***/
          function(module2, exports2) {
            module2.exports = function(css) {
              var location = typeof window !== "undefined" && window.location;
              if (!location) {
                throw new Error("fixUrls requires window.location");
              }
              if (!css || typeof css !== "string") {
                return css;
              }
              var baseUrl = location.protocol + "//" + location.host;
              var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");
              var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
                var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function(o, $1) {
                  return $1;
                }).replace(/^'(.*)'$/, function(o, $1) {
                  return $1;
                });
                if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
                  return fullMatch;
                }
                var newUrl;
                if (unquotedOrigUrl.indexOf("//") === 0) {
                  newUrl = unquotedOrigUrl;
                } else if (unquotedOrigUrl.indexOf("/") === 0) {
                  newUrl = baseUrl + unquotedOrigUrl;
                } else {
                  newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, "");
                }
                return "url(" + JSON.stringify(newUrl) + ")";
              });
              return fixedCss;
            };
          },
          /* 71 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            var content = __webpack_require__2(72);
            if (typeof content === "string") content = [[module2.i, content, ""]];
            var transform;
            var insertInto;
            var options = { "hmr": true };
            options.transform = transform;
            options.insertInto = void 0;
            var update = __webpack_require__2(11)(content, options);
            if (content.locals) module2.exports = content.locals;
            if (false) {
            }
          },
          /* 72 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            exports2 = module2.exports = __webpack_require__2(10)(false);
            exports2.push([module2.i, ".webamp-desktop{position:absolute;top:0;left:0;right:0;bottom:0;z-index:-1}", ""]);
          },
          /* 73 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            var content = __webpack_require__2(74);
            if (typeof content === "string") content = [[module2.i, content, ""]];
            var transform;
            var insertInto;
            var options = { "hmr": true };
            options.transform = transform;
            options.insertInto = void 0;
            var update = __webpack_require__2(11)(content, options);
            if (content.locals) module2.exports = content.locals;
            if (false) {
            }
          },
          /* 74 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            exports2 = module2.exports = __webpack_require__2(10)(false);
            exports2.push([module2.i, '#webamp-context-menu .context-menu{left:0;-webkit-user-select:none;-moz-user-select:none;user-select:none;cursor:default}#webamp-context-menu .context-menu.bottom{top:12px}#webamp-context-menu .context-menu.top{top:0}#webamp-context-menu .context-menu,#webamp-context-menu .context-menu ul{z-index:50;background-color:#fff;position:absolute;list-style:none;padding:0;margin:0;border:1px solid #a7a394;box-shadow:2px 2px 4px rgba(0,0,0,.5)}#webamp-context-menu .context-menu li{position:relative;font-family:Tahoma;font-size:11px;color:#000;white-space:nowrap;margin:2px;padding:1px 18px 3px;display:block}#webamp-context-menu .context-menu li.checked:before{float:left;content:"\\2713";margin-left:-12px}#webamp-context-menu .context-menu li.parent:after{float:right;content:"\\25B8";margin-right:-12px}#webamp-context-menu .context-menu li a{text-decoration:none;color:#000;cursor:default}#webamp-context-menu .context-menu li:hover,#webamp-context-menu .context-menu li:hover a{background-color:#224eb7;color:#fff}#webamp-context-menu .context-menu li.hr{padding:2px 0}#webamp-context-menu .context-menu li.hr:hover{background-color:#fff}#webamp-context-menu .context-menu li.hr hr{border:none;height:1px;background-color:#a7a394;margin:0;padding:0}#webamp-context-menu .context-menu ul{display:none;left:100%;margin-left:-3px}#webamp-context-menu .context-menu li:hover>ul{display:block}', ""]);
          },
          /* 75 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            var basePropertyOf = __webpack_require__2(76);
            var deburredLetters = {
              // Latin-1 Supplement block.
              "À": "A",
              "Á": "A",
              "Â": "A",
              "Ã": "A",
              "Ä": "A",
              "Å": "A",
              "à": "a",
              "á": "a",
              "â": "a",
              "ã": "a",
              "ä": "a",
              "å": "a",
              "Ç": "C",
              "ç": "c",
              "Ð": "D",
              "ð": "d",
              "È": "E",
              "É": "E",
              "Ê": "E",
              "Ë": "E",
              "è": "e",
              "é": "e",
              "ê": "e",
              "ë": "e",
              "Ì": "I",
              "Í": "I",
              "Î": "I",
              "Ï": "I",
              "ì": "i",
              "í": "i",
              "î": "i",
              "ï": "i",
              "Ñ": "N",
              "ñ": "n",
              "Ò": "O",
              "Ó": "O",
              "Ô": "O",
              "Õ": "O",
              "Ö": "O",
              "Ø": "O",
              "ò": "o",
              "ó": "o",
              "ô": "o",
              "õ": "o",
              "ö": "o",
              "ø": "o",
              "Ù": "U",
              "Ú": "U",
              "Û": "U",
              "Ü": "U",
              "ù": "u",
              "ú": "u",
              "û": "u",
              "ü": "u",
              "Ý": "Y",
              "ý": "y",
              "ÿ": "y",
              "Æ": "Ae",
              "æ": "ae",
              "Þ": "Th",
              "þ": "th",
              "ß": "ss",
              // Latin Extended-A block.
              "Ā": "A",
              "Ă": "A",
              "Ą": "A",
              "ā": "a",
              "ă": "a",
              "ą": "a",
              "Ć": "C",
              "Ĉ": "C",
              "Ċ": "C",
              "Č": "C",
              "ć": "c",
              "ĉ": "c",
              "ċ": "c",
              "č": "c",
              "Ď": "D",
              "Đ": "D",
              "ď": "d",
              "đ": "d",
              "Ē": "E",
              "Ĕ": "E",
              "Ė": "E",
              "Ę": "E",
              "Ě": "E",
              "ē": "e",
              "ĕ": "e",
              "ė": "e",
              "ę": "e",
              "ě": "e",
              "Ĝ": "G",
              "Ğ": "G",
              "Ġ": "G",
              "Ģ": "G",
              "ĝ": "g",
              "ğ": "g",
              "ġ": "g",
              "ģ": "g",
              "Ĥ": "H",
              "Ħ": "H",
              "ĥ": "h",
              "ħ": "h",
              "Ĩ": "I",
              "Ī": "I",
              "Ĭ": "I",
              "Į": "I",
              "İ": "I",
              "ĩ": "i",
              "ī": "i",
              "ĭ": "i",
              "į": "i",
              "ı": "i",
              "Ĵ": "J",
              "ĵ": "j",
              "Ķ": "K",
              "ķ": "k",
              "ĸ": "k",
              "Ĺ": "L",
              "Ļ": "L",
              "Ľ": "L",
              "Ŀ": "L",
              "Ł": "L",
              "ĺ": "l",
              "ļ": "l",
              "ľ": "l",
              "ŀ": "l",
              "ł": "l",
              "Ń": "N",
              "Ņ": "N",
              "Ň": "N",
              "Ŋ": "N",
              "ń": "n",
              "ņ": "n",
              "ň": "n",
              "ŋ": "n",
              "Ō": "O",
              "Ŏ": "O",
              "Ő": "O",
              "ō": "o",
              "ŏ": "o",
              "ő": "o",
              "Ŕ": "R",
              "Ŗ": "R",
              "Ř": "R",
              "ŕ": "r",
              "ŗ": "r",
              "ř": "r",
              "Ś": "S",
              "Ŝ": "S",
              "Ş": "S",
              "Š": "S",
              "ś": "s",
              "ŝ": "s",
              "ş": "s",
              "š": "s",
              "Ţ": "T",
              "Ť": "T",
              "Ŧ": "T",
              "ţ": "t",
              "ť": "t",
              "ŧ": "t",
              "Ũ": "U",
              "Ū": "U",
              "Ŭ": "U",
              "Ů": "U",
              "Ű": "U",
              "Ų": "U",
              "ũ": "u",
              "ū": "u",
              "ŭ": "u",
              "ů": "u",
              "ű": "u",
              "ų": "u",
              "Ŵ": "W",
              "ŵ": "w",
              "Ŷ": "Y",
              "ŷ": "y",
              "Ÿ": "Y",
              "Ź": "Z",
              "Ż": "Z",
              "Ž": "Z",
              "ź": "z",
              "ż": "z",
              "ž": "z",
              "Ĳ": "IJ",
              "ĳ": "ij",
              "Œ": "Oe",
              "œ": "oe",
              "ŉ": "'n",
              "ſ": "s"
            };
            var deburrLetter = basePropertyOf(deburredLetters);
            module2.exports = deburrLetter;
          },
          /* 76 */
          /***/
          function(module2, exports2) {
            function basePropertyOf(object) {
              return function(key) {
                return object == null ? void 0 : object[key];
              };
            }
            module2.exports = basePropertyOf;
          },
          /* 77 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            var baseToString = __webpack_require__2(78);
            function toString(value) {
              return value == null ? "" : baseToString(value);
            }
            module2.exports = toString;
          },
          /* 78 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            var Symbol2 = __webpack_require__2(25), arrayMap = __webpack_require__2(81), isArray = __webpack_require__2(82), isSymbol = __webpack_require__2(83);
            var INFINITY = 1 / 0;
            var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
            function baseToString(value) {
              if (typeof value == "string") {
                return value;
              }
              if (isArray(value)) {
                return arrayMap(value, baseToString) + "";
              }
              if (isSymbol(value)) {
                return symbolToString ? symbolToString.call(value) : "";
              }
              var result = value + "";
              return result == "0" && 1 / value == -INFINITY ? "-0" : result;
            }
            module2.exports = baseToString;
          },
          /* 79 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            var freeGlobal = __webpack_require__2(80);
            var freeSelf = typeof self == "object" && self && self.Object === Object && self;
            var root = freeGlobal || freeSelf || Function("return this")();
            module2.exports = root;
          },
          /* 80 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            (function(global) {
              var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
              module2.exports = freeGlobal;
            }).call(this, __webpack_require__2(17));
          },
          /* 81 */
          /***/
          function(module2, exports2) {
            function arrayMap(array, iteratee) {
              var index = -1, length = array == null ? 0 : array.length, result = Array(length);
              while (++index < length) {
                result[index] = iteratee(array[index], index, array);
              }
              return result;
            }
            module2.exports = arrayMap;
          },
          /* 82 */
          /***/
          function(module2, exports2) {
            var isArray = Array.isArray;
            module2.exports = isArray;
          },
          /* 83 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            var baseGetTag = __webpack_require__2(84), isObjectLike = __webpack_require__2(87);
            var symbolTag = "[object Symbol]";
            function isSymbol(value) {
              return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
            }
            module2.exports = isSymbol;
          },
          /* 84 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            var Symbol2 = __webpack_require__2(25), getRawTag = __webpack_require__2(85), objectToString = __webpack_require__2(86);
            var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
            var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
            function baseGetTag(value) {
              if (value == null) {
                return value === void 0 ? undefinedTag : nullTag;
              }
              return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
            }
            module2.exports = baseGetTag;
          },
          /* 85 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            var Symbol2 = __webpack_require__2(25);
            var objectProto = Object.prototype;
            var hasOwnProperty = objectProto.hasOwnProperty;
            var nativeObjectToString = objectProto.toString;
            var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
            function getRawTag(value) {
              var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
              try {
                value[symToStringTag] = void 0;
                var unmasked = true;
              } catch (e) {
              }
              var result = nativeObjectToString.call(value);
              if (unmasked) {
                if (isOwn) {
                  value[symToStringTag] = tag;
                } else {
                  delete value[symToStringTag];
                }
              }
              return result;
            }
            module2.exports = getRawTag;
          },
          /* 86 */
          /***/
          function(module2, exports2) {
            var objectProto = Object.prototype;
            var nativeObjectToString = objectProto.toString;
            function objectToString(value) {
              return nativeObjectToString.call(value);
            }
            module2.exports = objectToString;
          },
          /* 87 */
          /***/
          function(module2, exports2) {
            function isObjectLike(value) {
              return value != null && typeof value == "object";
            }
            module2.exports = isObjectLike;
          },
          /* 88 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            var content = __webpack_require__2(89);
            if (typeof content === "string") content = [[module2.i, content, ""]];
            var transform;
            var insertInto;
            var options = { "hmr": true };
            options.transform = transform;
            options.insertInto = void 0;
            var update = __webpack_require__2(11)(content, options);
            if (content.locals) module2.exports = content.locals;
            if (false) {
            }
          },
          /* 89 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            exports2 = module2.exports = __webpack_require__2(10)(false);
            exports2.push([module2.i, "#webamp .mini-time{display:block;height:6px;width:25px}#webamp .mini-time.blinking .character:not(.background-character){animation:blink 2s step-start 1s infinite;-webkit-animation:blink 2s step-start 1s infinite}#webamp .mini-time .background-character{z-index:1}#webamp .mini-time .character{position:absolute;top:0;z-index:2}", ""]);
          },
          /* 90 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            var content = __webpack_require__2(91);
            if (typeof content === "string") content = [[module2.i, content, ""]];
            var transform;
            var insertInto;
            var options = { "hmr": true };
            options.transform = transform;
            options.insertInto = void 0;
            var update = __webpack_require__2(11)(content, options);
            if (content.locals) module2.exports = content.locals;
            if (false) {
            }
          },
          /* 91 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            exports2 = module2.exports = __webpack_require__2(10)(false);
            exports2.push([module2.i, "#webamp #main-window{position:absolute;height:116px;width:275px;image-rendering:-moz-crisp-edges;image-rendering:-o-crisp-edges;image-rendering:-webkit-optimize-contrast;image-rendering:pixelated;-ms-interpolation-mode:nearest-neighbor}#webamp #title-bar{position:absolute;top:0;left:0;height:14px;width:275px}#webamp #close,#webamp #minimize,#webamp #option-context,#webamp #shade{position:absolute;height:9px;width:9px;top:3px}#webamp #title-bar #option{width:100%;height:100%}#webamp #title-bar #option-context{left:6px}#webamp #title-bar #minimize{left:244px}#webamp #title-bar #shade{left:254px}#webamp #title-bar #close{left:264px}#webamp #clutter-bar{position:absolute;top:22px;left:10px;height:43px;width:8px}#webamp #clutter-bar div{position:absolute;height:7px;width:8px;left:0}#webamp #clutter-bar #button-o{top:3px;height:8px}#webamp #clutter-bar #button-a{top:11px}#webamp #clutter-bar #button-i{top:18px}#webamp #clutter-bar #button-d{top:25px;height:8px}#webamp #clutter-bar #button-v{top:33px}#webamp #play-pause{position:absolute;top:28px;left:26px;height:9px;width:9px;background-repeat:no-repeat}#webamp #work-indicator.selected,#webamp .play #work-indicator{position:absolute;top:28px;left:24px;height:9px;width:3px}#webamp .webamp-status #time{position:absolute;left:39px;top:26px;height:13px;width:59px}#webamp .stop .webamp-status #time{display:none}#webamp .pause .webamp-status #time{animation:blink 2s step-start 1s infinite;-webkit-animation:blink 2s step-start 1s infinite}#webamp .webamp-status #time #minus-sign{position:absolute;top:6px;left:-1px;width:5px;height:1px}#webamp .webamp-status #time #minute-first-digit{position:absolute;pointer-events:none;left:9px;height:13px;width:9px}#webamp .webamp-status #time #minute-second-digit{position:absolute;pointer-events:none;left:21px;height:13px;width:9px}#webamp .webamp-status #time #second-first-digit{position:absolute;pointer-events:none;left:39px;height:13px;width:9px}#webamp .webamp-status #time #second-second-digit{position:absolute;pointer-events:none;left:51px;height:13px;width:9px}#webamp #main-window #visualizer{position:absolute;top:43px;left:24px}#webamp #main-window.shade #visualizer{top:5px;left:79px}#webamp .text{display:none}#webamp #marquee{top:24px;width:154px;display:block;padding:3px 0}#webamp #marquee,#webamp .media-info #kbps{position:absolute;left:111px;height:6px;overflow:hidden}#webamp .media-info #kbps{top:43px;width:15px}#webamp .stop .media-info #kbps{display:none}#webamp .media-info #khz{position:absolute;left:156px;top:43px;width:10px;height:6px;overflow:hidden}#webamp .stop .media-info #khz{display:none}#webamp .media-info .mono-stereo{position:absolute;left:212px;top:41px;width:57px;height:12px}#webamp .media-info .mono-stereo div{position:absolute;height:12px}#webamp .media-info .mono-stereo #mono{width:27px}#webamp .media-info .mono-stereo #stereo{left:27px;width:29px}#webamp #volume{position:absolute;left:107px;top:57px;height:13px;width:68px;background-position:0 0}#webamp #volume input{height:13px;width:65px;display:block}#webamp #volume input::-webkit-slider-thumb{top:1px;height:11px;width:14px}#webamp #volume input::-moz-range-thumb{top:1px;height:11px;width:14px}#webamp #balance{position:absolute;left:177px;top:57px;height:13px;width:38px;background-position:0 0}#webamp #balance::-webkit-slider-thumb{top:1px;height:11px;width:14px}#webamp #balance::-moz-range-thumb{top:1px;height:11px;width:14px}#webamp .windows{position:absolute;left:219px;top:58px;width:46px;height:12px}#webamp .windows div{position:absolute;width:23px;height:12px}#webamp .windows #equalizer-button{left:0}#webamp .windows #playlist-button{left:23px}#webamp #position{position:absolute;left:16px;top:72px;width:248px;height:10px}#webamp #position::-webkit-slider-thumb{height:10px;width:29px;-webkit-box-sizing:border-box;position:relative}#webamp #position::-moz-range-thumb{height:10px;width:29px}#webamp .stop #position::-webkit-slider-thumb{visibility:hidden}#webamp .stop #position::-moz-range-thumb{visibility:hidden}#webamp .play #position::-webkit-slider-thumb{visibility:visible}#webamp .actions div{height:18px;width:23px;position:absolute}#webamp .actions #previous{top:88px;left:16px}#webamp .actions #play{top:88px;left:39px}#webamp .actions #pause{top:88px;left:62px}#webamp .actions #stop{top:88px;left:85px}#webamp .actions #next{top:88px;left:108px;width:22px}#webamp #eject{position:absolute;top:89px;left:136px;height:16px;width:22px}#webamp .shuffle-repeat{position:absolute;top:89px;left:164px;width:74px}#webamp .shuffle-repeat div{position:absolute;height:15px}#webamp .shuffle-repeat #shuffle{width:47px}#webamp .shuffle-repeat #repeat{left:46px;width:28px}#webamp #about{position:absolute;top:91px;left:253px;height:15px;width:13px}#webamp .digit{position:absolute;display:inline-block;width:9px;height:13px;background-repeat:no-repeat;text-indent:-9999px}#webamp #main-window.shade{height:14px}#webamp .shade #balance,#webamp .shade #volume,#webamp .shade .media-info,#webamp .shade .shuffle-repeat,#webamp .shade .webamp-status,#webamp .shade .windows{display:none}#webamp .shade .actions div{position:absolute}#webamp .shade .actions #previous,#webamp .shade .actions #previous:active{background:none;height:10px;width:7px;top:2px;left:169px}#webamp .shade .actions #play,#webamp .shade .actions #play:active{background:none;height:10px;width:10px;top:2px;left:176px}#webamp .shade .actions #pause,#webamp .shade .actions #pause:active{background:none;height:10px;width:9px;top:2px;left:186px}#webamp .shade .actions #stop,#webamp .shade .actions #stop:active{background:none;height:10px;width:9px;top:2px;left:195px}#webamp .shade .actions #next,#webamp .shade .actions #next:active{background:none;height:10px;width:10px;top:2px;left:204px}#webamp .shade #eject,#webamp .shade #eject:active{height:10px;width:10px;top:2px;left:215px;background:none}#webamp .shade #position{position:absolute;left:226px;top:4px;width:17px;height:7px}#webamp .shade #position::-webkit-slider-thumb{height:7px;width:3px;background:none}#webamp .shade #position::-moz-range-thumb{height:7px;width:3px;background:none}#webamp #main-window .mini-time{position:absolute;top:4px;left:127px}", ""]);
          },
          /* 92 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            var content = __webpack_require__2(93);
            if (typeof content === "string") content = [[module2.i, content, ""]];
            var transform;
            var insertInto;
            var options = { "hmr": true };
            options.transform = transform;
            options.insertInto = void 0;
            var update = __webpack_require__2(11)(content, options);
            if (content.locals) module2.exports = content.locals;
            if (false) {
            }
          },
          /* 93 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            exports2 = module2.exports = __webpack_require__2(10)(false);
            exports2.push([module2.i, "#webamp #playlist-window{display:flex;flex-direction:column}#webamp .playlist-top{width:100%;min-height:20px;max-height:20px;position:relative;display:flex}#webamp .playlist-top-left{width:25px}#webamp .playlist-top-left-spacer{width:12px}#webamp .playlist-top-left-fill{flex-grow:1;background-position:100%}#webamp .playlist-top-right-spacer{width:13px}#webamp .playlist-top-right-fill{flex-grow:1;background-position:100%}#webamp .playlist-top-title{width:100px}#webamp .playlist-top-right{width:25px}#webamp .playlist-middle{flex-grow:1;display:flex;flex-direction:row;overflow:hidden}#webamp .playlist-middle-left{background-repeat:repeat-y;width:12px;min-width:12px}#webamp .playlist-middle-center{flex-grow:1;padding:3px 0;min-width:0}#webamp .playlist-tracks{display:flex;flex:1 0 auto}#webamp .playlist-tracks .track-cell{height:13px;line-height:13px;font-size:9px;letter-spacing:.5px;-webkit-user-select:none;-moz-user-select:none;user-select:none}#webamp .playlist-track-durations>div{padding-right:3px;text-align:right}#webamp .playlist-track-titles{flex:1 1 auto;overflow:hidden}#webamp .playlist-track-titles>div{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}#webamp .playlist-middle-right{background-repeat:repeat-y;background-position:100% 0;width:20px;min-width:20px;position:relative;padding-bottom:18px}#webamp .playlist-bottom{width:100%;height:38px;min-height:38px;max-height:38px;position:relative}#webamp .playlist-bottom-left{width:125px;height:100%;position:absolute}#webamp .playlist-menu li{list-style:none;display:none;width:22px;height:18px;padding:0;margin:0}#webamp .playlist-menu li>div{height:100%}#webamp .playlist-menu ul{padding:0;margin:0;position:absolute;bottom:0}#webamp .playlist-menu.selected li{display:block}#webamp .playlist-menu .bar{position:absolute;bottom:0;left:-3px;width:3px;height:54px}#webamp #playlist-add-menu{position:absolute;bottom:12px;left:14px;width:22px;height:18px}#webamp #playlist-remove-menu.playlist-menu .bar{height:72px}#webamp #playlist-remove-menu{position:absolute;bottom:12px;left:43px;width:22px;height:18px}#webamp #playlist-selection-menu{position:absolute;bottom:12px;left:72px;width:22px;height:18px}#webamp #playlist-misc-menu{position:absolute;bottom:12px;left:101px;width:22px;height:18px}#webamp #playlist-list-menu{position:absolute;bottom:12px;right:22px;width:22px;height:18px}#webamp .playlist-bottom-right{width:150px;height:100%;position:absolute;right:0}#webamp .playlist-running-time-display{position:absolute;top:10px;left:7px;height:10px}#webamp .playlist-action-buttons{position:absolute;top:22px;left:3px;display:flex}#webamp .playlist-action-buttons>div{height:10px;width:10px}#webamp #playlist-window .playlist-visualizer{width:75px;height:100%;position:absolute;right:150px}#webamp #playlist-window .mini-time{position:absolute;top:23px;left:66px}#webamp #playlist-window #playlist-resize-target{position:absolute;right:0;bottom:0;height:20px;width:20px}#webamp #playlist-close-button{position:absolute;right:2px;height:9px;width:9px;top:3px}#webamp #playlist-shade-button{position:absolute;right:12px;height:9px;width:9px;top:3px}#webamp #playlist-window-shade{height:14px}#webamp #playlist-window-shade .left,#webamp #playlist-window-shade .right{height:14px;background-repeat:no-repeat}#webamp #playlist-window-shade .right{background-position-x:right}#webamp #playlist-window #playlist-scroll-down-button,#webamp #playlist-window #playlist-scroll-up-button{position:absolute;width:8px;height:5px;right:7px}#webamp #playlist-window #playlist-scroll-up-button{top:2px}#webamp #playlist-window #playlist-scroll-down-button{top:8px}#webamp #playlist-window-shade #playlist-resize-target{position:absolute;right:20px;top:3px;height:9px;width:9px}#webamp #playlist-shade-track-title{position:absolute;top:4px;left:5px}#webamp #playlist-shade-time{position:absolute;top:4px;right:30px}#webamp #playlist-window .visualizer-wrapper{position:absolute;top:12px;left:2px;width:72px;overflow:hidden}", ""]);
          },
          /* 94 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            var content = __webpack_require__2(95);
            if (typeof content === "string") content = [[module2.i, content, ""]];
            var transform;
            var insertInto;
            var options = { "hmr": true };
            options.transform = transform;
            options.insertInto = void 0;
            var update = __webpack_require__2(11)(content, options);
            if (content.locals) module2.exports = content.locals;
            if (false) {
            }
          },
          /* 95 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            exports2 = module2.exports = __webpack_require__2(10)(false);
            exports2.push([module2.i, "#webamp #equalizer-window{height:116px;width:275px}#webamp #equalizer-window.shade{height:14px}#webamp #equalizer-volume{position:absolute;left:61px;top:4px;height:6px;width:97px;background-position:0 0}#webamp #equalizer-volume::-webkit-slider-thumb{height:7px;width:3px}#webamp #equalizer-volume::-moz-range-thumb{height:7px;width:3px}#webamp #equalizer-balance{position:absolute;left:164px;top:4px;height:6px;width:43px;background-position:0 0}#webamp #equalizer-balance::-webkit-slider-thumb{height:7px;width:3px}#webamp #equalizer-balance::-moz-range-thumb{height:7px;width:3px}#webamp .equalizer-top{height:14px;width:275px;position:relative}#webamp #equalizer-close{position:absolute;height:9px;width:9px;left:264px;top:3px}#webamp #equalizer-shade{position:absolute;height:9px;width:9px;left:254px;top:3px}#webamp #on{width:26px;left:14px}#webamp #auto,#webamp #on{position:absolute;height:12px;top:18px}#webamp #auto{width:32px;left:40px}#webamp #presets-context{position:absolute;width:44px;height:12px;top:18px;left:217px}#webamp #presets{width:100%;height:100%}#webamp #eqGraph{position:absolute;width:113px;height:19px;top:17px;left:86px}#webamp #preamp{position:absolute;left:21px;top:38px}#webamp #plus12db{top:36px}#webamp #plus12db,#webamp #zerodb{position:absolute;left:45px;width:22px;height:8px}#webamp #zerodb{top:64px}#webamp #minus12db{position:absolute;left:45px;top:95px;width:22px;height:8px}#webamp #band-60{position:absolute;left:78px;top:38px}#webamp #band-170{position:absolute;left:96px;top:38px}#webamp #band-310{position:absolute;left:114px;top:38px}#webamp #band-600{position:absolute;left:132px;top:38px}#webamp #band-1000{position:absolute;left:150px;top:38px}#webamp #band-3000{position:absolute;left:168px;top:38px}#webamp #band-6000{position:absolute;left:186px;top:38px}#webamp #band-12000{position:absolute;left:204px;top:38px}#webamp #band-14000{position:absolute;left:222px;top:38px}#webamp #band-16000{position:absolute;left:240px;top:38px}", ""]);
          },
          /* 96 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.parseAni = void 0;
            var riff_file_1 = __webpack_require__2(97);
            var byte_data_1 = __webpack_require__2(16);
            var DWORD = { bits: 32, be: false, signed: false, fp: false };
            function parseAni(arr) {
              var riff = new riff_file_1.RIFFFile();
              riff.setSignature(arr);
              var signature = riff.signature;
              if (signature.format !== "ACON") {
                throw new Error('Expected format. Expected "ACON", got "' + signature.format + '"');
              }
              function mapChunk(chunkId, mapper) {
                var chunk = riff.findChunk(chunkId);
                return chunk == null ? null : mapper(chunk);
              }
              var metadata = mapChunk("anih", function(c) {
                var words = byte_data_1.unpackArray(arr, DWORD, c.chunkData.start, c.chunkData.end);
                return {
                  cbSize: words[0],
                  nFrames: words[1],
                  nSteps: words[2],
                  iWidth: words[3],
                  iHeight: words[4],
                  iBitCount: words[5],
                  nPlanes: words[6],
                  iDispRate: words[7],
                  bfAttributes: words[8]
                };
              });
              if (metadata == null) {
                throw new Error("Did not find anih");
              }
              var rate = mapChunk("rate", function(c) {
                return byte_data_1.unpackArray(arr, DWORD, c.chunkData.start, c.chunkData.end);
              });
              var seq = mapChunk("seq ", function(c) {
                return byte_data_1.unpackArray(arr, DWORD, c.chunkData.start, c.chunkData.end);
              });
              var lists = riff.findChunk("LIST", true);
              var imageChunk = lists === null || lists === void 0 ? void 0 : lists.find(function(c) {
                return c.format === "fram";
              });
              if (imageChunk == null) {
                throw new Error("Did not find fram LIST");
              }
              var images = imageChunk.subChunks.slice(0, metadata.nFrames).map(function(c) {
                if (c.chunkId !== "icon") {
                  throw new Error("Unexpected chunk type in fram: " + c.chunkId);
                }
                return arr.slice(c.chunkData.start, c.chunkData.end);
              });
              var title = null;
              var artist = null;
              var infoChunk = lists === null || lists === void 0 ? void 0 : lists.find(function(c) {
                return c.format === "INFO";
              });
              if (infoChunk != null) {
                infoChunk.subChunks.forEach(function(c) {
                  switch (c.chunkId) {
                    case "INAM":
                      title = byte_data_1.unpackString(arr, c.chunkData.start, c.chunkData.end);
                      break;
                    case "IART":
                      artist = byte_data_1.unpackString(arr, c.chunkData.start, c.chunkData.end);
                      break;
                    default:
                  }
                });
              }
              return { images, rate, seq, metadata, artist, title };
            }
            exports2.parseAni = parseAni;
          },
          /* 97 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__2) {
            "use strict";
            __webpack_require__2.r(__webpack_exports__);
            __webpack_require__2.d(__webpack_exports__, "RIFFFile", function() {
              return RIFFFile;
            });
            var byte_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(16);
            class RIFFFile {
              constructor() {
                this.container = "";
                this.chunkSize = 0;
                this.format = "";
                this.signature = null;
                this.head = 0;
                this.uInt32 = { bits: 32, be: false, signed: false, fp: false };
                this.supported_containers = ["RIFF", "RIFX"];
              }
              /**
               * Read the signature of the chunks in a RIFF/RIFX file.
               * @param {!Uint8Array} buffer The file bytes.
               * @protected
               */
              setSignature(buffer) {
                this.head = 0;
                this.container = this.readString(buffer, 4);
                if (this.supported_containers.indexOf(this.container) === -1) {
                  throw Error("Not a supported format.");
                }
                this.uInt32.be = this.container === "RIFX";
                this.chunkSize = this.readUInt32(buffer);
                this.format = this.readString(buffer, 4);
                this.signature = {
                  chunkId: this.container,
                  chunkSize: this.chunkSize,
                  format: this.format,
                  subChunks: this.getSubChunksIndex_(buffer),
                  chunkData: { start: 0, end: this.chunkSize }
                };
              }
              /**
                * Find a chunk by its fourCC_ in a array of RIFF chunks.
                * @param {string} chunkId The chunk fourCC_.
                * @param {boolean} multiple True if there may be multiple chunks
                *    with the same chunkId.
                * @return {Object}
                * @protected
                */
              findChunk(chunkId, multiple = false) {
                let chunks = this.signature.subChunks;
                let chunk = [];
                for (let i = 0; i < chunks.length; i++) {
                  if (chunks[i].chunkId == chunkId) {
                    if (multiple) {
                      chunk.push(chunks[i]);
                    } else {
                      return chunks[i];
                    }
                  }
                }
                if (chunkId == "LIST") {
                  return chunk.length ? chunk : null;
                }
                return null;
              }
              /**
               * Read bytes as a string from a RIFF chunk.
               * @param {!Uint8Array} bytes The bytes.
               * @param {number} maxSize the max size of the string.
               * @return {string} The string.
               * @protected
               */
              readString(bytes, maxSize) {
                let str = "";
                str = Object(byte_data__WEBPACK_IMPORTED_MODULE_0__["unpackString"])(bytes, this.head, this.head + maxSize);
                this.head += maxSize;
                return str;
              }
              /**
               * Read a number from a chunk.
               * @param {!Uint8Array} bytes The chunk bytes.
               * @return {number} The number.
               * @protected
               */
              readUInt32(bytes) {
                let value = Object(byte_data__WEBPACK_IMPORTED_MODULE_0__["unpack"])(bytes, this.uInt32, this.head);
                this.head += 4;
                return value;
              }
              /**
               * Return the sub chunks of a RIFF file.
               * @param {!Uint8Array} buffer the RIFF file bytes.
               * @return {!Array<Object>} The subchunks of a RIFF/RIFX or LIST chunk.
               * @private
               */
              getSubChunksIndex_(buffer) {
                let chunks = [];
                let i = this.head;
                while (i <= buffer.length - 8) {
                  chunks.push(this.getSubChunkIndex_(buffer, i));
                  i += 8 + chunks[chunks.length - 1].chunkSize;
                  i = i % 2 ? i + 1 : i;
                }
                return chunks;
              }
              /**
               * Return a sub chunk from a RIFF file.
               * @param {!Uint8Array} buffer the RIFF file bytes.
               * @param {number} index The start index of the chunk.
               * @return {!Object} A subchunk of a RIFF/RIFX or LIST chunk.
               * @private
               */
              getSubChunkIndex_(buffer, index) {
                let chunk = {
                  chunkId: this.getChunkId_(buffer, index),
                  chunkSize: this.getChunkSize_(buffer, index)
                };
                if (chunk.chunkId == "LIST") {
                  chunk.format = Object(byte_data__WEBPACK_IMPORTED_MODULE_0__["unpackString"])(buffer, index + 8, index + 12);
                  this.head += 4;
                  chunk.subChunks = this.getSubChunksIndex_(buffer);
                } else {
                  let realChunkSize = chunk.chunkSize % 2 ? chunk.chunkSize + 1 : chunk.chunkSize;
                  this.head = index + 8 + realChunkSize;
                  chunk.chunkData = {
                    start: index + 8,
                    end: this.head
                  };
                }
                return chunk;
              }
              /**
               * Return the fourCC_ of a chunk.
               * @param {!Uint8Array} buffer the RIFF file bytes.
               * @param {number} index The start index of the chunk.
               * @return {string} The id of the chunk.
               * @private
               */
              getChunkId_(buffer, index) {
                this.head += 4;
                return Object(byte_data__WEBPACK_IMPORTED_MODULE_0__["unpackString"])(buffer, index, index + 4);
              }
              /**
               * Return the size of a chunk.
               * @param {!Uint8Array} buffer the RIFF file bytes.
               * @param {number} index The start index of the chunk.
               * @return {number} The size of the chunk without the id and size fields.
               * @private
               */
              getChunkSize_(buffer, index) {
                this.head += 4;
                return Object(byte_data__WEBPACK_IMPORTED_MODULE_0__["unpack"])(buffer, this.uInt32, index + 4);
              }
            }
          },
          /* 98 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            var content = __webpack_require__2(99);
            if (typeof content === "string") content = [[module2.i, content, ""]];
            var transform;
            var insertInto;
            var options = { "hmr": true };
            options.transform = transform;
            options.insertInto = void 0;
            var update = __webpack_require__2(11)(content, options);
            if (content.locals) module2.exports = content.locals;
            if (false) {
            }
          },
          /* 99 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            exports2 = module2.exports = __webpack_require__2(10)(false);
            exports2.push([module2.i, "#webamp{position:absolute;top:0;left:0}#webamp canvas{-webkit-user-select:none;-moz-user-select:none;user-select:none}#webamp *{box-sizing:content-box;-webkit-box-sizing:content-box}#webamp :focus{outline:0}#webamp input[type=range]{-webkit-appearance:none;margin:0;padding:0;background:none;border:none}#webamp input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;border:none;border-radius:0;background:none}#webamp input[type=range]::-moz-range-thumb{border:none;border-radius:0;background:none}#webamp input[type=range]::-moz-range-track{border:none;background:none}#webamp input[type=range]:focus{outline:none}#webamp input[type=range]::-moz-focus-outer{border:0}#webamp a:focus{outline:none}@keyframes blink{0%{opacity:1}50%{opacity:0}to{opacity:1}}@-webkit-keyframes blink{0%{opacity:1}50%{opacity:0}to{opacity:1}}#webamp .character{display:inline-block;vertical-align:top;width:5px;height:6px;text-indent:-9999px}#webamp .window{position:absolute;image-rendering:-moz-crisp-edges;image-rendering:-o-crisp-edges;image-rendering:-webkit-optimize-contrast;image-rendering:pixelated;-ms-interpolation-mode:nearest-neighbor;-webkit-transform:translateZ(0)}#webamp .window.doubled{-moz-transform:translateZ(0) scale(2);-moz-transform-origin:top left;-webkit-transform:translateZ(0) scale(2);-webkit-transform-origin:top left}", ""]);
          },
          /* 100 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            var content = __webpack_require__2(101);
            if (typeof content === "string") content = [[module2.i, content, ""]];
            var transform;
            var insertInto;
            var options = { "hmr": true };
            options.transform = transform;
            options.insertInto = void 0;
            var update = __webpack_require__2(11)(content, options);
            if (content.locals) module2.exports = content.locals;
            if (false) {
            }
          },
          /* 101 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            exports2 = module2.exports = __webpack_require__2(10)(false);
            exports2.push([module2.i, "#webamp #balance{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAGkCAMAAABq7Kf7AAACvlBMVEUVfwoWFiMXFyQXGCUYFyUYGCYYkgsZLhwbGyschRIeaRYfHzIjIzgomRwpOCEujhYunBIvL0QvL0kvgBwxMU0xMU4yMU4yMk8zM1AzNFEzNFI0M1E0M1I0NFE0NFM0shU1NVQ1NlM1NlQ2NVM2NVQ2NlU2NlY2NyE3N1c3OFc3OFg4Jh04N1c4N1g4OFc4OFk5Gh05LSA5OVo7TkFCtiZHhidIcy1JSWNMi0BMlSVPU0RPpCNRQkBRmyxSMT5TUm9WqypauihbgTZcmyxcwCpixDFlvjdnoCxnsStp2TBrpU1rwCpuboRuj0Nw1T5xci5yxypz3D50QiR0xzF3JSJ3VCl3oDF3tCt30zB62jB7epB8e458fJB9fZB9fZJ+fpJ/1T6BxyqC3D6Eq1WEtDGEwF2F4jeGi0KGoYiHh5iIoDGJVi6KKSiKRC2KYzaKxDCLfjiLi5yLmCyMjJyNmiyOWxeOjp6OmyyQxzGRODmRTT2RWj2RbkKS4TCTk6KUyjiXXCGXrI+XtDGawmCa4z6bXSGbaSebfieb2jmeYhKeayaeriufFhufKhufPiGfSSGfVyGfbCefgSefkCyfmyygaTqho1Cj4Tik20Wk4jimNDemxzGpfEqprI+p40atkouuV0auag2uwCqwYh+xv16yERayKBayRx6ydiWynCqyriuyxDG3RUu94Ti/bRu/dRC/uyq/0zDAhFPB4kbCb1PCk1fCs1zDciPD1T7FDBLFJxLFQxvFURvFZRvFgCPFnCPFsSrFwCrF2TDGeA/G2jDIxdPI2z7JVyLJgSDJhSnJoCnJtDHJxDHJ3D7Zbx7ZfB/ZjifZlDfZrCfZsTfZwzDZxj7bhC/b1jXfsSjgDhXgHybgLBXgPCbgTB7gWC7gXB7gZy7gch7gfC7gkijgsijgyTDg2zfhmTfhtjfhzD7A/9hgAAAEC0lEQVRo3u3U+VeUZRTA8VeyQtQgKd6XZnGEmXEcmxkLG8YlBdTUCaRGSFFTA02zFBPTssUFF1zac4UKQkXUUrNUIHBLzX0PK3et9L/ouc8z2g+ec2/HX/I93u+ZMz/d877n3Ps5rxYI+J4O+AI+n88Dud0ut8vldDpSUlPtVrvdarNZDEPXAiIx4/V7/Z5Ocs7tcrqcDpGYs1qTYczQ5JDI740+DR7nTEnpYE+1i4dZbRaLoRvaY60fbCl6AP5axoifqEVMi9vFxLZpZ9O11g/HUT2abmixcRpVMFvX2sS1egivVWiarrVLS2yLFxpfomvuQO/sYaNUI0eNhEbcarjo5dc+KEnXNR+s1uv3dZL7cLlgt05HqgO2a7Ulwzp0PUmD1Xr9fo/nSbk0OAGs1gFLs1mSxWoNPUmMyRvAkJjyiCmXw5HSAcasVssTcAFdjkXv6Zc3UC8VQ/KVNptxawyO5fdFXymnHE71SnFPiwXunvR4krbvP6Xd45AS8eLSJKT4BLx4CSkxoT1egoIU6ooXZkhmg/RI8Bm8oIQU7NYDr1sIIAUzMvEywgrSc3jh2QzJdJCexYtCysjsi5WZISGF+g3E66cghQe9iDVoLEMyH6Q+eFFIA57HG5ADkLIGDy3AGjq4SEEaXYg1miGZEVJ/rH8hvYB1G1LBq1gFClL3cCE6VsiQTANJSjIAUn+irLR0LTZryCtEQ3KyBaTi94mKi6YBpLK5aGWls0tISCDpzXSGdI9AynqJSEEaU/w2WvEYgJQzs2z5SqTlZTMlpKIVX6GtKP2SITEkhnQfQuqYO4Eot7uAlDunnGjOOIBU/i1R+TKAtGwr0WqGZDpIU6ZOR5o6RUFa/A3RYoA0bsOWPT8j7dmyQUHasf8o0v4dDIkhMSSGxJAYEkNiSP8zpC+IFKT1m3ejbV4PkCYfaW7+C6m5+YiChE6JuW0MyXSQPifK7QmQancR1UpIh8/8iXbmsIJ09ibaWYbEkBgSQ2JIDOluIT2Vv+AztAVRSDuJaicDpEOnzl1HOnfqkIRUcfoG2mmGZD5I8xd9irRofj5Ayl/XRLTuPQFp0sET19BOHKwQkHpWnPwb7eSPXzMkhsSQ7kNInSOz5qHNUpCqvyOqniQgvb79ONF2CWnpr0TfMyTTQXqLKAKQIguriBYCpPyqTXvRNlUpSE2/oDVVMCTTQfqESH6RItWNRNXvwhep8dgVtGONCtJVIv4imQ/Sx0SRXgCp5ieiGoA08cAlogMSUuVloh8Ykskgdcn7iCgKqYGoZgZAarhA1FApIPWqvEjEkMwH6UOiPICUt7aeaO07AtIb9X8Q1UtIq84TVTIk00FaQqQgrakjWiMh1f1GVLdRQvqdaCNDuqN/AItpcu8L5wnUAAAAAElFTkSuQmCC)}#webamp #balance::-webkit-slider-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAALBAMAAAC9q6FRAAAAFVBMVEUAAAALDxYvL0RKWmt7hJStvMTa5+opTTwbAAAAMUlEQVQI12NQFAQBIQaxNBBIZGALBYIQAyAtKiqKlwapM2RgcwEBQwZhYxAwZICaBwCdgQ6Jd297uQAAAABJRU5ErkJggg==)}#webamp #balance::-moz-range-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAALBAMAAAC9q6FRAAAAFVBMVEUAAAALDxYvL0RKWmt7hJStvMTa5+opTTwbAAAAMUlEQVQI12NQFAQBIQaxNBBIZGALBYIQAyAtKiqKlwapM2RgcwEBQwZhYxAwZICaBwCdgQ6Jd297uQAAAABJRU5ErkJggg==)}#webamp #balance:active::-webkit-slider-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAALBAMAAAC9q6FRAAAAFVBMVEUAAAALDxYZICovL0RKWmva5+r///+U4Y9MAAAAMUlEQVQI12MwFAQBYQbRUBAQZGBlAAIWBiQ6ISEBKw2SV4TTIi4gIMhgJKQopCgoDAB2aAh/NddRQgAAAABJRU5ErkJggg==)}#webamp #balance:active::-moz-range-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAALBAMAAAC9q6FRAAAAFVBMVEUAAAALDxYZICovL0RKWmva5+r///+U4Y9MAAAAMUlEQVQI12MwFAQBYQbRUBAQZGBlAAIWBiQ6ISEBKw2SV4TTIi4gIMhgJKQopCgoDAB2aAh/NddRQgAAAABJRU5ErkJggg==)}#webamp .actions #previous{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAASCAMAAACHObUhAAAASFBMVEUfHzEgHzIgIDMhITQiITMiITQiIjUjIzYjJDgkIzckIzgkJDklJTolJjsmJTsmJjtKWmtSY3N7hJSElKWXqLmttca9ztbv//8qmLzOAAAAcklEQVQY022QMQ7DMAwDj7KQvqD/f2UXD2YGN43cWAuNo0wI1JvNjE8SGzwiwf/Ywwr2k1M6HFMPwDgvvxnoU2DN6fl7xh7X/YJx4a/yte67FaPmV2O5pxi5ZN/Gt5+rI998DD/ridxiLAQiHBKEJYGaT1TOJE+BDpf2AAAAAElFTkSuQmCC)}#webamp .actions #previous:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAASBAMAAABCyVggAAAAElBMVEUICBBKWmtSa3Nje4R7jJytvcYAUCbCAAAAS0lEQVQI12NgwA1MXKDACMhxDYWCEBAHJuOChcPAAsQwDmOIi4MoEocRieMgiMRhROYEInNckTkugcgcVzgnNASIwRxTZOcoIHwDAI4lI4lOrG7eAAAAAElFTkSuQmCC)}#webamp .actions #play{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAASCAMAAACHObUhAAAARVBMVEUmJTsmJTwnJz0nKD4oJz4oKD8pKUAqKUEqKUIqKkMrK0QrLEQsK0MsK0QsK0ZKWmtSY3N7hJSElKWXqLmttca9ztbv//93JWkaAAAAcElEQVQY022QQQ7FIAhEHzJpL/Dvf8y/MBG70VZbYEPeAIGxH0nEX5QEB4L+xj26CnkMXus2QJv92hXXrETluHnT07MqrnV6UbSfcY6rY+N+/1KUUTBl9Nl/vtxow5+PRyKif+1xpZhmmIEZMxFh+AXgtiNLLYv6agAAAABJRU5ErkJggg==)}#webamp .actions #play:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAASBAMAAABCyVggAAAAElBMVEUICBBKWmtSa3Nje4R7jJytvcYAUCbCAAAARUlEQVQI12NgwA1MXKDACMhxDYWCEBAHJuOChcOAzGFkQOYIMiBzwDw4B8RDcEKROKFIykKRDAhFMjoUbqkpsnMUEL4BAGRUIvLymjxCAAAAAElFTkSuQmCC)}#webamp .actions #pause{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAASCAMAAACHObUhAAAARVBMVEUsLEUsLEYtLUctLkguLUguLkkvL0ovMEswL0swL0wwMEsxMU0xMU4xMk0yMU5KWmtSY3N7hJSElKWXqLmttca9ztbv//90IK75AAAAY0lEQVQYGW3BwQ3DQAwDwRVPsBtI/3UGfpCBDfiT00x9GPjbiI2dhvAnjsSsuV3AARdwAMHNo1kBmhVuEjMxEyOLkcRMzMRIze3kcfJyQyA8wqsaO2zSdtitogqqqEoJIgTLP/lyHlITiB2JAAAAAElFTkSuQmCC)}#webamp .actions #pause:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAASBAMAAABCyVggAAAAElBMVEUICBBKWmtSa3Nje4R7jJytvcYAUCbCAAAAOUlEQVQI12NgwA1MXKDACMhxDYWCEBAHJuOCyXFgYAEyYBzBEBdGUdpzXENDXEJDwRxTZOcoIHwDAEquItl9JSARAAAAAElFTkSuQmCC)}#webamp .actions #stop{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAASCAMAAACHObUhAAAAP1BMVEUyMU4yMk8zM1AzNFE0M1E0M1I0NFE0NFM1NVQ1NlQ2NVM2NVQ2NlVKWmtSY3N7hJSElKWXqLmttca9ztbv//8mgTHJAAAAXElEQVQYGW3BQQ7DMAwDwRUttPf+/6FFD2SBBLnYmqkPA38bcbBpCJs4ErPm8uPxAgLNrbmtcBGjiFHETIyWGFmMIkarubzZNAQIm8YOB7cdTqsooERWkEXJheoPfCIcRKB1vkQAAAAASUVORK5CYII=)}#webamp .actions #stop:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAASBAMAAABCyVggAAAAElBMVEUICBBKWmtSa3Nje4R7jJytvcYAUCbCAAAAMklEQVQI12NgwA1MXKDACMhxDYWCEBAHJuOChQPWC+MwCgoKitKBA3YamGOK7BwFhG8A34IfFkPmwnYAAAAASUVORK5CYII=)}#webamp .actions #next{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAASBAMAAABCyVggAAAALVBMVEUICBA2NlU2NlY3N1c4N1g4OFk4OFpKWmtSY3N7hJSElKWXqLmttca9ztbv//8TuYuxAAAAaUlEQVQI12M4AwenDjCcewcDJ4Ccu1BwZzkmp/zu3evld+9MB3Oqa+9e3wfnbEfm7K5F5mxH5uxD5rxF4uxDNuAtEufd3bv33kE4cFcDOWdWzoSC6QkMK8rhgIFB0MjY2NjFxSU0NJQBAK7vnSRnYMknAAAAAElFTkSuQmCC)}#webamp .actions #next:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAElBMVEUICBBKWmtSa3Nje4R7jJytvcYAUCbCAAAATElEQVQI12NgwAVMXCDAWYGBwTUUChyAbKi4CyabAcSAshlZXBxEYWwBJLYgCxJbAIktisQOQbBFkfSGINihLi6uoSC2KZIbFOCuBwDE5iIH3QcLbQAAAABJRU5ErkJggg==)}#webamp #eject{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAQBAMAAADgw5IVAAAAIVBMVEU4OFk4OFo5OVpKWmtSY3N7hJSElKWXqLmttca9ztbv//8Mnk1wAAAAVUlEQVQI12PogIM2hq5VMNDC0DUTCmYEQ9iWCPbkYgTbvNwSxp5cXl4MY5uXlwMlwOxZYBPh5sDNnGwMAlA2UHl5FYZ6uNuCGTpSQ6EgmEGISQkKmAB+iFckwoyJQwAAAABJRU5ErkJggg==)}#webamp #eject:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAQBAMAAADgw5IVAAAAElBMVEUICBBKWmtSa3Nje4R7jJytvcYAUCbCAAAATUlEQVQI12NgwAVMXCDAWYGBwTUUChyAbJAgCxBD2Q4CCDajIAuM7SAoKABjMwoKAiXAbIhJMPVgAGY7gO2EsoHKBUXR1ZsiqVeAuxIAu8seNVNafDwAAAAASUVORK5CYII=)}#webamp #main-window{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARMAAAB0CAMAAACR8SbcAAACEFBMVEUAAAAAUoQAarID9gUNDRQPDxcQEBkRERsTEh0TFB0UEx4UFBQUFBsUFB8VFSAVFSIVFiEVFiIWFSEWFSIWFiEWFiIXFyIXFyQXGCQYFyQYGCUYGCkZGSYZGicZGigaGScaGSgaGicaGikbGyobHCsbHCwcGyscGywcHCscHCwdHS0dHS4dHi0dHi4eHS0eHS4eHi0eHi8fHzAfHzIfIDEgHzEgIDEgIDMhITQhIjMhIjQiITMiITQiIjMiIjUjIzYjIzgjJDcjJDgkIzckIzgkJDckJDklHAolJTolJTwlJjslJjwmJTsmJTwmJjsmJz0nJz4nKD4oJz0oJz4oKD8pKUApKUIpKkEpKkIqKUEqKUIqKkEqKkMrK0QrLEQsK0MsK0QsLEUsLUUtLUYtLUgtLkctLkguLUcuLUguLkcuLkkvL0ovMCUvMEswL0swMEswMEwxMU0xMU4xMk0xMk4yMU0yMU4yMk0yMk8zM1AzM1IzNFE0M1E0NFE0NFM1NVQ1NlQ2LRE2NVM2NVQ2NlU2NlY3N1c3N1g3OFg4N1c4N1g4OFc4OFk4OFo5OVpCQThISEhORj1ZQxxcXGNelepfX2hiYm1lW0JlZXJmZnVoaHZpaXhra3ttbX9vb4NxcYZzc4hzc4p0c4p0dIt1dYx3d3d6h4mHd02PkJKhoK2jlGumhTGnZB+njlatr7X////Zgun4AAAl/ElEQVR42tWdz6+ta1LXP/Xj3VGjA6IRELykww/p7gQJhgkOhLED/wETHRtmRjstbRva295E06djggNDQhwQ0BjEaIJOHECHCFFQsH/Rl+4b7m0aaAINGgPu9VSVg6rnXWufs8/tNs1Orvvk3n32WWuvtd7nrafqW9/6Vj3izJfAc3+V2x8U6x/rmL+hoPPoISWACgapKv1rAq5S868oeOCpOg+KIaDzah51l5ooIP3NwiARFMKpBx8TKCnIskBJysIIIDUFWJ4sSACSAlZJAcnyZQtYIgEUrH5G4XyUx770hX+Rt3nO7SLKS9f40ZeRx344v5fM/4WSQqBe/BwlfaHULNK5WlAPnsjLfrr5ez1z+LtCeRgCTjpaImgpisWRWgrCASJwoAgm4fgScEXLEUVT76gj8DYB7goFS0wUHEQFDOk/FuogbXTpAOKBhcvVONukFJRUSH3k9iWa/Z3Si+ZcYhUsg20pUVIkGRRFSlBkpnEPoZkWSS2o0n6B2LfemdvR725LeklkcTVzSIPl5oCUF6CoLsAsou90ColhLmQ6Iv05o++LrHmxAFUHcFYhLrXvm9FLkpCpj1pvPTA1LdLoCwDwiLUgUwgokkoKpIj+1b6mQixy3nXp2KoB+FopogJS2Z9Xk0QwVaRQnd0p8zlc56dMUC0NUk0AvBKsn65KRmoyhoJgx3gyE0nAcXzvG5lH9HnbqOdNRCgkx5SIZQTSdhJrLTMAleoL1IxCqOqPtUKUlWCRJMnyKrxfy8ZrOoqkACYomKaq9uKAUAtVgaLACVXB51ZDimChMrZvwpGYXE3QtkW23c3FZ6+/R8xl770jGYBmKqpK5gveSClEE1hk5hKvvpIqxA5s4Q4IEUBmClVI9dNU17pPpZK2Ixa3N0GkbVj6n2YzpbaZkCICdYCASQkecpcUy8N74VwqsaIQ3LUOQs+7XpK3/rHvVPvBdGAtWC5+NQcpvOMRZGapPuJKzhVPUNfMoKo3T1w8hLVog23T69+o2VxqqGQJWnRwg0qFWTTgPkNKAZG5vSqo7EVEj1QKquMkCxDHJElcKZSssd3kopbj8e7YO8VF2pB0KQiEnfvX49w9hSF13Sqq8vzGGf+S28EClW2EFIj7sprb3c4i1wQkrSgyaWPNkNzrSjsIIWa57/R8kd5SVD/xmM2fEylKYEkHhUWUprJ0O8Z5IzDQRPpNVOdiBwVw10+3NkzHItrO22+GlG1koZoJ/ckfmEk/CCgZSRw2Owfqsix6M1S1C1EPkJJqq0i0n1toZpvqTSBZAvjavvNq5JoKXLIjtSZSs2Y+ocnj6JdRkcPQ6MfF0YBUKt1z4oNvV6G0d7AiE5ww4ML1nkjleM5bs8jnzUSFbA9vimbMK1DhhOGwqt9LV4ZCVQ2A075HhSR6gENR0ZgRHPDlY54lp5mkSmGHAixDKTFQ3JGlIK5H+567XvK0Xtf+/Gp9H2NMZA0SU3NHKIuOXcsNKN+fE0ywiSdK5nYm+tBKZr+oZpISG691cMXw1Y7YKFAqbqJXMpunSiMvlVRR2LxH+7o7EUFB5o1jY/CcWLGd2lycJ+JcUvWE5whRhbsKx2FZfZF55JilCJRUzK2KWUFfROB9F0XAKg1tb5F8WaidqmSJBUghwqWWyewGhXgIWtualkBCCGEgLGlg4wCXCw/A9HMgW6Tzjs5ezquffXbMHpTxJSoTa+7WxqmJM7B3X4r4cmG5Xi9vHqt9sRYWRja2kCJVbvd1SUlleYUUCmEBqQlSstDM1NwrVlxOJJiZ/dcFaC/P/Ti6+tv/kQkgb5vbiFRDnsLzcr2GrAfurtr9pGxkfb+dR3+yNe6yX9KXC3mzJO6ZV4swjDCMpISIDDbSuX42KVEiTEQbMU8yUIKqquuJNDJS/BrC2HhVNQDy/ooGk5hnPnvb/E/ezmzlxRz6JTnf26R/p33WTf43qLsffTH363+ZTE8e5H985enfg031DErMwQL4gbvsiJnaMdRAq/fE0b4EuQMxCWt84cCBhqLqCh7Wu0ScsjqgVLQQT+sX8lQBQXyTBVbaLj4s6xgCAbC+WxvaP5r+JXqmf6mUZvSWKkouvqydSFZSUiy9AFWpFVDcH8lKotAg28EVCKF0FPT78RCqqqAZEIKKcKzB5p4IUQbuhoMIUop30oAhGIIvrAiygqw22vEyWQhiq6OjQbVXWoT5NY0ixFiQ13D8IohV3dsgcUQuzYP0hcksSeZONXT1R1ACKtMbwand7KhKdsiF8XY1IGZCfynVzo9CRbUjhwCxkWMHJ9eqS9AmtCBVDRED9esmSVGhqPTsfNxokBjSXFBVW6SChr4Yd5+3lF4zlBW15Dj3Y13mViNak54tbehWi6pEQptFKA3L9LVOwkqvPMFN4gNY58BCh1HpDKVMKHyhrgiOTDhP4bDcGQGSubHPIuc5PpzTURPcg0YMXqT7qg0KKJGSnX+SiuajxMkZq1WTuoyTEdax3UQggdRmaK67syqdcRwB6/RlcdqJnu+ag09ykF7qxvraXkxYVOc6S4XMxFU7JvdH8YLDQAXB4TKpOSLItkkBE8Sb/yvqGPgKYJW34DXRRwGKnpRSzSaQhFpy8Q5066SY9BKMmXRaZGtlboNQh+F2cuNYMk0GdF1BtO7EqQrLMaEARFOhzPOiqoou/EL7S9wx1cgM6aTWvS+pfTN3xRoIWDvLay6rZHvewYvayYVqPpIAjtvVTEC14sym3CT6Vls1h5u5pINYeaev0i5BB0jk5i4vV5L5bhLeMRKzKzhVREQUpDApBzehrUc9AU8tDiSG4ViVZgqdy+zrtmry4v7gTqkqIzueisUA5c7h4wgj89wYGxI+smk6/YPV9tXkT03aT4kSVKGN2xk4X1ALIHIi4LqBBT7Wmmn6ew845oeEvTTftN2v7KSmPYg20tV17BTPd0zNDhz+nYSHilCdCAtWiIEvj7TFMZhDsLjo0PxnwEl9PvdrbiebqL1JXqVYEIYvJMdjgN8jTaz0VipvbJhCY8WCJKDEN/ZxQe55sq8f+QUL/ptufOaNfa4oFjS1pAYfhfW+rs7o0x5AthIKKSnCCgiLvvJOx6aEMXaUKbAa1SVkYos10aWAXIPr392+tfxmb9Y3/PqT/SlQ0Z/hHfz1wz81+0SOZz/AH/DsH4jy+09qJ2r84jt8TeqT8b5/Lx/f29QE5Rue8A9ZxTv8a4LwtpMfFJ7aTlTe6XYiH4/3/Vv9+Di4DhdPaSeu73QraWCtetrJh0C/9JR28t+13ul28h/4Jd737/SXt53w1dqJmb3t4/VI8fud9hXAusfPpFPg17+KP8Hb/76+85eEbGZYTzORr85OvpfvfdvH80qOvFO/Nistx7MfzP/Fsw+B/85T+pNfEuQX3uH+JD7O+/4Nn1a47/RS60n9yf8HX1Fd83DQxYgwntKfvPO/zmLHxiYlKE+Y7zTJ/SMv0vfyOIWvqfWoYGx/fKlCqsmBekDCn/T9Seh/GcJ+s/12aeJIjmc/KL/Hs1eBJ8Unvywl4l2ERzVrK3B8NY8q1eU/PwkCqeep6dRUSkjtelaSaNRkylRJhTbDVpsBSIavl86DM5R7zcrSIImEqhDhInw83/+TfEph5dZVPGm+UyLeLEgZJU3nu0hsnYHAEWlXgqRQ8gE9rc0E3hK0KtXL1+nUMmI9kAEscSikibjMYSSlJLjWgTcpO3byofp9+cirWvK7/+dJ7QQ5JBUpsdiFaifx0tEmWXg1sZKo0jbxOIw4/xJGaLSNdDg1FoTWDT1SU+MuuFdhkRRRCcWiilAii0/F+3+CT/pZYhGe1J+A8HO+C2lbxuH8Jb8cNUW1kFbCpKL8jG3mSAC+58rz9LbRhNRlTTS347j48tV14BrPsuZvXSHIqSRAlpKSJ+l4OUqaozY5nn2I3+cjr6LyO09pJ/8D5L++iE/+xVvrGGmRAEemeFOw//knbp/3o1+89Sm7Op5AZbU7KS7HaqXdIre08R7JNpMKQrOmqhMUKUsXRYUVF1l8kvf/RL5+1bNxi0/kj96f7PrO86DgFMYAXMp0ahTxNiRHW0q2gqSDUBX4KnCnl6QpVu8lyVpBaa4ujYzyBj0LzqGk927UHYwEuUETXx1W+X/BJ+a8F+U9NZq7XWC8Zqbn17seVvAVqDjmjop06c9GZ0OsJmC7kqbSirMjp0RjwZZrtbqjlt6ju5YkMhqw6139oSewk+ORy7zBG42SzvLaS+zkXfCuJDsMJ9RKo06NgfVVchaJm50WqqIkcnIa2Uvi16iN916U9M3tU7c49PufwE4u9jiRA/KeT/FuPmXfxqft2/gsu6rz4oq8AaDvAj6LpmJBRUdioTwKX7uuNC616zqyEJS05Tvyau7iDh11uqJ4rTmWPMiLn8CfyPFSM3nPp+CTn3p38OlvT17fup3Hl+Rd7yI/9wafnVLDVERPj9R6h2rJAiN4kJpSa6b6yiS6j8PWaokkYS09lr2TdBdFn9if5NulGtIlKH39W6fYGY8jkzfeQOtdn81RPp1Fd4paxd4781Cani9fkUkulJp62qW1s5XkZc2nE9tUT2+pJ/Un+uhuoIBPvqd497s/Bd/6Ot8KmqjmIzvtjW/ushV887fOfl9BTdV5BWZNkpW00jE1kqKIxm+q86gSuf2oioI4SYaQIMezV/kSH/lHAk+KTz7u6f/lP72ITz5/ohOVb/sVnaYU4Gd/8jF8klPen+/rRr516S2zqNRuRSEvQkq74yJZtkjNfk6N2C+ESEIX+Zn6e//yxCf6HB/7R+9PfL2MuFeRQjDJ14VTrKX6EnQyXSvJFjoMCMaZsCMyMXhxVMnofLp8LmiyVNEshTGyFJmukHKQ49mH9Et89MOgv/2UdvJJhV/46y+yBL9eMsnFUdceHU1+7q898LNfZAP60ZxoZtk6zaSWFLZ8jZAhqMwckdKCkqCNgcmCl66t9bog3EN+kr//Y7yusoUtT+xPFPS7P/OZz3z2c5/73BtvvPXWW2+98cbn3/r8588lkQjjKq7Q7/mt3/7tL16/2kqmOaPzZbWwM+iEGywfyXwElTodACM5IEcwHlZxAV+TS0fMkmz4eveRV/mSPPuwwtPaSbNXNr0z3gp/kdpKx6rqpiE0X7bN5oGlja5YtRODWoyZLHbX472vU8zW7qRIJRca5JLOdSo7Yi9Yr/P+f71eV66Sqyf1J3lCVd0xT3xde9eibCPKfGnU1gEZsziXQScyipvV8nqwtoC9JLX6VQ9HMxHCUqQFjJF6iYJFLgjWGXc++mH0ae3k09qqLAH1hROOXA5oD4vYOkJvFbHPxWwhtWq8q5Jha4MTClbtVIcYO8lLb49uIsrUYpG1OwNP5uQidWm66dP5wR+vX1Vp0ZE+tT+ZlEpBWRABi5Y1iYCxvFpq6dNn8UIOoJSqJunanVstYk+KqpKd/ZV0r1emRhWC9lN1bdXO2RXamsMWSU50r/Yn+rs8+7Biv/m0diIlNlvHlxMc1VqvlvIKqZpo6iNE7Aljz7bZtLDLpttLagG2gBidNGtHnQYrSyfqZJ1mQmgBa7UtXX6FD/54/apybVx9Un+iglgN/7kc3C9yICVSDeVTSbybZR5HJyp9N1uTybkkIhUiHZlpkTCZWsegl4BMFe1WiQLbPKy2PNZ7pftdS+4+8mH5XZ69xhPbyWd2QlOtr0esM/pO8w8q7JYbeVns2XayXC7Y2gTbBWw5a1lTCCRk9CZpdyLZLSkNcOXeN097oTTvIbN+hQ/+GK/rpprM5IE/EX4I/SP7b+qAvSStUJ3O6Al5WTftfqqP7J1uZTnt5KiLWEw15yiH8LWw1OyUOFcgVE6vd5Zyr9pZYcpwOZMvr6WadLPmSrn76D/U3+HZa4b+xh8+oZ283msybV0h13KbgKVXjYvVlxhJDrhMlCS0ru6EivJazmr4xm7Cl6JSomiP4veEplwYvp6q6ShdSVL5K3zwx9ZnlanuRD6tTqnq7Ery3vV1BhSLLVZO3d4/n2cXdAMXJaFCLlP067kEu3ErdpDKDecCac0sC4wKRdAWgAo29nljm3L30Vfld3j2j1PlN5/STj4zvSkGeMAxQnIpadFHFyn08Yhz/VqekEjV7nouKoaRprrW08M8Lmeu090DiyQ0yi7d0NhAL4pcZJLCp/jgj/L65r7CRPhnj/Jbt1D7tk9Qbsq7zz38SFlYwChNfFNBtSsvUIacXCD50mXpYJyp2RilZJvbTDMpxQIpMutSUFUW1U1g3bUUcKFknWXilFzcVA7X2fBLSfy5jyCWHEgJd9WTOcrAs7wnE5Si2l0MasOW3y1DsRwx9DnAYz+OKTqTTMa1WeyJJr114gjZTkRnqMdzJcBrbx/aLvbMSgpbXdU5S+qp6EVKQrT7MGbJ0qI69AELgyWrt2tq7y/b3CMm0WMnyqFE5XL2iw+rULtAB7rK1WQaDLYy3gHuutelwKbAKId2I7rFzEFxsksxcztiQkm2HcxHkhf7q7cdZVpfUPVbrEWwejdE0F3YC6RsW8OBk61szFy9c6aPqgcisM0lT5lZzh0MA5Gt3NTCcB8kRfowiEYYJSqIdA/7LgAv1+kei9JCipr3krBKYS0PjJrGldmEcq13dpWinst5JhJPIV3jYgQzGuFsn6dy9xiEVVURE4QqWd2cce2OEkzjAqyVHWSGntzv6z284aBnJWS6inQb7boOJCpS4Y7AosfeFHonre2v4cZ6YopYz2qQu+5nQW2nxBVxTAvPLstkN/elzofqTu2HZtIWlNPpEcd0+YJ7NQHRTdezO3cTXUe0Xuzph/PcntlOZcGaj5KB1n7+fBub3hJfF3dqKSIHAp6Q6lyse4QEDTjOcThnU3VN63dd2HNLtHtmlpiVHGzHP01AOxDfNuY8WJTJ1HRGy1w2OT2vCkiWWUsJYorIARIgumaluu432pe4COseyLPJ2izH0runTtAuwkzVw6qKta5TDZZmzxc4IHZHdU/HiTghRj+9nQii01kd4w9ciBVXBgArRONs23oUxJLZDkazFST99s0ySFA+xbuIKtQnQx6XmCw8i0jVgCDnzmevT0KlepNuqE4rvEHKOe5CtZn+HoNiu1s9HRRd1binDamEbYIlaM4LbmlUk6wFWuEKPS2HSy+YdNdT95ADKrs49Twg0J2i3dbXRYpLWU1JNGboxvW3R6MmxlJBKyPpHqHuJ0NSp4+fBZHYOmv9Uj2yIj9X8iIU2XfOttzKSfErcrHzOX7NLwejAhLH8ttJZXcPwHurtmazf0Vi51s5Wi4fXNb3+TrnZ48nUKjY/HZstmHJ7LgCoj764y9E/dIUgfSXSMCzwyvXmv8NG6Yb/jzsQZVZkplDUhtP6MMi6V6Sr2xF4mTWrp9t3VQ0ejRUnG2IE262y95Jg+5CYz9mcu3EwCGP6+oo1Nci+DTSWrqUCC66oVhZu+68kxIc6fg84j0DCQfBExWOwEidUG8WGJoCylT6jEIpLdmVzkfuyh5LV0KlLhtYT062EuX3UwHTZgfkYlOqSI1k+YhxBogU3BusdfbADbxe3OQX3SopCOa9JKM3kFle6dUYDKh3lJSrXIueEzDC244VhUv2AKHZ8JjRw1syx7pCVHJShLeRf8qeO1WUDoq6mYOR9zfQLukJclXEtMt6beve4/0WxDppJDiBVKOr89pvtk5j0Wy29sgzH4g93QVA1h744VQMypwBbIkVehDj8nxHTKqsk+Tuzm/zFUoQEXnJotTwICU6/Z11K5Lv1t3dpqrnDjeKSFi51gJdbSbCfY9v6I0mMzjrxAC9r0zgaEcY63QH3gMMylHE9sJ0M4cMXJltiyeqkeNKXae611HL7fyYPZJKO5CGykK7PDqqtJe0yM0aSKXYucPWOKxRN8WN91vRlqk9lUZ9Inq1X71r48+bnDWvA296sl7N91lz5TrJTkTWjr1l7SAbc3heNWq1lMRsZMyrEcklIME6AdAAzEN7Zxagy6dqtWOHPKrcmSl2WZJnoSvxTc7FdSkvCSldOlqaEXDTKVMnA230PLQudFCsVefe2S3xMW3haO31y+4OFx/fimancbrlTZ0fuJ+m2kMu3Zsxm+mG2xYbm/THmr5tHyXM5D9Sj+kxtrRRrbCZFEUoXDSJAZBxnYEzw27Ks8xuRvRlyokB18PgTnYFrR4gxnFcoicyGuuo4Cw4Kh4nsF1am+zYDHMPZmG1rerMKXNjhsGCHA90v4nsGSV1OyfnoZXUZoCkRAykJMk9fYBdDDj3mc6ELzQ2jUuiGO2MdeHdjn0ijPaNNSGyNqeuBbz/uVrk870CUi+OCPrKJgRdhwtdX2IM5CqJeNzB7nGwhTxsOSh52SDYL9dycNO1MLSUkDkceg/0sXQK+Rb756iAp0HDDzl/wDVtJntKHVlHcfRoEcXR8NQpUgh45R1IiZVIeJOOTpicYy459h58Met70Hqwg31gaZd9QSUVZQtfRdXwuK0brv55dDiwNPsfmvSpgKxBLLUomlWZsY+6RbOrE9+Z6SjRxKlSLdVQcO0pqpkiJaoSaKRG9VAPFBUh5tYtvSOlhMiaJTGW+HrQR1SjcVS9FvleLJ3vEgaWemmWoAauBL6QEJkl0fFMM+KxJahLqtC+4B6VmiP8yyWz68x7FbeQWLAeKr1cT8Fdjx6E8jhQkpVoHaA2cv52onse6hBzvoearMyunKu0nVnApSdYSDEOeNLyzcY+ZiznpDUsewxSCVJVlFsD1JEtKhXV0zOts912pt6kyIxmK7AOJJlI9l1yrvlRnuUohLse7GoTl0NVER8uAbT27BERdxS14TGvnSRWM5nTvD2ATRa9CMG9B/VNsDsaBGrXzfVFK8mHPmILv3cnkzTtEEVGj1vWVl7URKeBEBVFanUhvVkdWTd6bFg1pIBcsX2H8GWuHdYEPHZi1A/qXXJs4SVoJBaaM1MpK1v6P5fbgUjEwnqEri9KYrWUQAqktNJ6z8g54PMFAVvtYeaZWNlVMSPBaoH9FiRles1It00Nrug9Ynu6dcfDaGIPCEaFfoqJrzekpBOephb0pj6bO5FAuSiihgidLEiZCemOlqMl2Ay8mbzTwqrKwRcm1DH6iJ5Ndpb9quuU+agQJ6+fIQbWl9QqW1a1Fu4nOXAZ45RoBxJu55ww4b7bMCSiRx9qptiJiXvpLidvr93KMHMuTQocX2qCI01pzuyonmTlHqhOwVbXYBtphNoXrEqX4QadSWBOhzIBqknQ4YpEH5sllVPVS7RHOdkpePK1iNYr5gw308Wl25sCIRNRVk9MK7JwihITS5Vce2cWZJp724npbpdKLxUO74HT0vXc5S2kkcoZv8vNwOODtNC2NlfZ+u2uZSHl7dGsZiM2nrxQcjPXMXfmlY9q7FPJmrmfGLG2+YnUcjdbLCo7W22GsvHMhpB7nF709LopnMdplfpzP/9c2WSI8q0KY7X/tlXCYruT7Elpdz1mtGeIzRaz7BF9K1N61s9g9rs6UlVEjNIdx9xjteakUZJJj81KeElVVK+7pyn3M76VWMTJ6k4lZ8/urasuQ6SKSFOF+wVEFiYzEZifffXVn6+6/8xvjCqdUhVSQEyREvcpI5iDx4zePkd2KWimXecxHGTn/M4ecbdnwy1jTxCT0ygEjvNDm44gTa9j7HmZnmA+gOyOyFaA1sCsPdZWOwmozkSSLFb12OUgIx2kRJRAGu787GuvvPLqL771V//p38TPzqFqYU9YN+XtKlw73OxA3LSEk4rZuXW0NCzbRpcTpggMXyai604nAqTia4lxOW6m6QUe4usqSdLHQH2zGppJKuu4nDkhCyzw1QFhxs3VFazX7lHOLB0KfpO2e5N87LVX4M/+na/5hrpOI1suPZTUSgRn3SEzB9BXG+pyKTv7xC6HUEKJSykG4UjeTQHxrK4LsTFQoQGrT5+4yEl7Wkp6XfnsR92JjLvJ1NRoR7QzHN8nP9QmgZL07Cl1a3PIZFdKLHc1VQu7yD1+nx977RXuf1Pfo/WJf/Wn9obzMYn2BbmmrpGIL9kcyYynTgo9suuD7dECk5jTD5ql36qb49Bz0ywbhUvZYejQf1Eq67ZYoY+ptHQLTpLcqKTdUS2f4xtk19e04aNcWfxuTWkU4ppUg7wL3LH42GuvXH79i9/49Vqf+CdfM85o97E0kyNdyCnKRcBt3SvSgv0ZCaKNzqQcSThM0jQ1ax9tEchUmjadYKU+wLlcLvscAhANtbxdCX3EvY4yqccX7h1fYwvrxLaDdi/VErU4z/+YwYdEsjib/1RI+Nhrr/zBb3391xf1iW959ZdAZWZETtlWSprbFGmV3CL0jplAvRLImunxlCxPQYOwah/USSm2O/ouJFKYRi//AkPqaN/Y4j5bcZanNOsx+XTebqtYhwwb1bpyY+FblCGZuPRpGA05VrKULCIxcueeOYnPT7/2yq/9z68vlHrvF1959RNUDE152xXlrk1RWUedhkvVxXH1xpApLX1C6fl6qq5TOO/ZhEhP8i8hppSOD59PzaoZ4LZrBiPVfBGd1HWeIiKXjq5Z03LfSZQ2NaBMsVvmtJgNMhKNy8k5iXIB9KdfewX7M7NH/hivvPqJPiEpb6Zt77mutjvrtF95jjtgdVqiBrjeKZhpBCRLRzPYfl+g1PeA8qvIJELO9Nmic2vtCaNdJtMXAZtkaxkystSPaS4XymvDN8uNvxnhfXRs3PqAATmTQEjE7UzLshKafMtx1QocZ81GkZ4VDJFr14xzH65xWEWfC7G6h17cQdu8WtY0DlT2IShNkLmDSVmd9aE41j7aIdkNRi8Ak+rd36ccSLY2qaBYFx/d9ClsU1bte1CVibA2kQdS43661Jbrr7z/TeILJVV84a2v5c0PfHtGQUYpcJn46QNOSnA38abbah9aAoFYdvVvHxjQvqImzYl2TnqsMTJbje9Wa7vkSszXHOs1pUp5FMJKZZOpmVE5PYK7WLi7cXZhdnpAz5m0AU4RK4k8weQMDM7kL7//Tf06FeQT/k13b37gPdqC/Y473co9MWWEs0RT87uWf9fP6IqwpxdEECXa0qeumY3Dy9iThLEzt7GZTdyGYtFHZuijYfi6efSUFdQuiWaXjVadtdDZhTFMbxMdqwc0FFZhIyyqCoiSXGjqd//qN2rxhbf+wtfx5gfeXZPKNm9/sXOoiPTAh+nJLiFzSuJeGKVTaoi53EFpW563Bu3UNRtTP4s9HLKZjwNrGdW1G+IFniDJMxnqDqTrYJOqJTPUo2TnwMO/9dbRGUguEnARz24WMiKrJXV/+B3fV8gn/vQ33fHmB96rFTFnmWiLjDjRSnQNZtI/p3Ufvk69x4QRneOdkppTUvD05opKnmOdXYKQqJIbXd+pGLyZ+PxY+jcNgktG5duFv2k5SJGuruoWXEyltdtDkyozdM35ATnhdkF++vuSL/yNb//j8OYH3ltL5oSn1YRAME0sLY4oIbSH9BM66XwdsE+iSi2xCIk5+2rcyVBg45ik6aVUX76cKG+fWwJcRJadmd3LBbHdvJKE+Sqpm7CFhe8azpC70QOWptkpdPn9DD7poR571EtP11VKfvjX5Dde4c0PvLdLZnXdqGBwadRlPQbY9DwBo03A5TJ0Qmd/hIm4SborqSolJ3o8+wCMKvXlENHnau2S1lFlyaYU+yY+lhbXGItNhbCnNVygKqxxfEVLGzvJbrFjzcl0MAcbWWvJQ+AibTbJJ/7W//7a7/rAm7Mk11E6jtg6myF2JF7emk6qb+ZddvVuBpO3RhRCSxc+E6ZtxzmZcf3NnCwWYhEYlA51Us7tCQc5p9w8LxFOvXYH7sE3JeW1x+FcDWr5ZQizObWutjpUw+qq7b80zk34jp96N/BdH+AvrvMAPCbD61H0xmoQUeJLcKXE+z71ZCOgqzQsBw3TND1PmUEIb5kFl6OHnA+p6wsLbsJoo6xTS57PTSV/mOzME08NSCGsQ5btzH+qwdrdCDlEWlbpNO5Y5oY/mqJULdCV8iejivzOSQWiZAQV+2blugb75cicP+ab8ikup9DACzXLFKnEddAptkdndEp8CrKWe7isae/slHhNoNWXtqaQuQ87ShRZslPiQi6j6gvJHmiRulYhUj0xXSftG4ghXT6uxUz5GkXQboIbgf0chXHeInNNEaxE/KZQ10IVvaFGOhYRqEwuLBuyTqHk2EPtt5xtOlQpEZXW4fjsidwHO7xY5L1FLZGbeioozImF+1RpG+3edTmgJwWxyLnouGTNG2gfXZB3J5ztetiKyhhWtjYy4319hNmWHu9tr9a5iA2rssfX+7pDejx9h+qhkPasdj+zpBMD7zOYspVR1nE0LexR/VoDmaBJ8JnVvhMbzeXrbIPLvNIlsBrxLz1FKWs/HppdHYOUsLaj3BvufvxqoXvkBT7dTXml5g+6irE11X7exB5hZnF73FZeyRji9Fmpc5roHLimW5cRSYnlllzXbeE/5FT7jUw0bkSa0/ByTq2zs3NGt1Z6PSIhIFeHxpZ5xW56OhVbPrOXXIE///0vI3au2oq3P4LpK1FY3CajcqO4ePQMJuQWjlwVyI9qKr78SMfb1XnhFKd87pM3XP0hLwexUgFH1l0DNlemhnE0eEFQL8X2cAFPv7TgRrIftkmR+3xIXx7gzBS2lsNV6fUk5x7imC+vnPeZLJ3r9AJN0CFLRsapa9qMm4ZclqtThiKy9H4PsOAi3LeqoLFIrsJX9RCm6n5CvZZCZYt/Y3nDej8FXEdQ2uNkNDVtXIk7XndaQ+r3vR/C1YiC5T2n5bj2Q8qSHFGe7mD7SC/+hiiLXIH0rD4Eak1hZ805oPhWx03h/D4TTyEIgtW0bwVwkbx2vtSojVcTlussIv2JAeQu1wzlPNvb5yDvfcpdX5efXGtuMYHFNGQMk/Ag4XHy6onUYuulqrDUMKTC6zwctesCS1qQQOom5edUHFKXr7OJMtAYA1rT+tgutoHL/Xn8dYw4cLT1ucm0fqXL/GrA/wXAZHzoHrq/wAAAAABJRU5ErkJggg==)}#webamp .media-info #stereo,#webamp .stop .media-info #stereo.selected{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAMCAMAAACpx0YDAAAAk1BMVEUlJTklJTolJjsmJTsmJjsnJz0nJz4oJz4oKD8pKUApKkEqKUEqKUIqKkEqKkIrK0MrK0QsK0QsLEUtLUYtLUguLUcuLUguLkcvL0U8PFNDQ1hJSWFQUGNaWm9lZXZpaXpvcH5wcX9xcYF3d4Z5eYh8e4x+fpCBgY+Dg5KKipaLi5mMi5mRkZ2bmqaioqypqbKqqrTexa8FAAAAvUlEQVQYGQXBQW4aURAFwOrPIJCjEY5Hytq73P9giCj2YBTy+7mqfkUTiURmtUiqRY8eJBJRFAGULIemEipBQySka0xQL+9Bz4FEwbBUj9PP+ffF22P1cXbc1+fnsv7br5ExRr9mz911M99Op+d2P1+22/yRitHttr9eUPP5cH+w/3ftQ4cFx9VX93a7nD+ObufVn/nbdSRqk4qWSCfERHS1USq6ggwkKTCMLBERpCuoVAQdYyAl4dASNJjKN1/Kh0LDHtt2AAAAAElFTkSuQmCC)}#webamp .media-info #stereo.selected{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAMCAMAAACpx0YDAAABXFBMVEUA/wAD+AQG7gkG8QkH4wwI6A0K2g8K3xAL2xIL4hIM2RMN2BUN3RUOxRYO1RUQ0xkSxh0SzBwS0RwTuR0VvCEVxSEapCkbnyscrSwfczAgpzIhkzQinDUlJTklJTolJjslJzklKDolLjslkzomJjsmKTsmKzsmLDomMjsmMjwmNjsmOjsmRjsmWjwmdzsmiDwnJz0nKT0nLT0nNT0nOj0nQjwnTj0nYj0oKz4oLT8oND4oOT8oRz4oSz4oZT8pL0ApO0ApTEApTkApZkApZ0EqMEIqMkMqPEEqTEMqT0IqUEIqZUIqZkMqa0IrLkIrL0UrNEQrPEQrPUQrQEMrSkUrYkQrfUQsMUQsNkUsQkQsS0MsTkYsVEQsWEUsYEYsZ0UtLkUtLkctL0gtMEYtM0YtM0gtNEgtNUctNkctOUYtP0YtQkctR0YtS0Yti0cuLUguLkcuMUcuM0cuN0c2LFEQAAABDklEQVQYGQXBvVHDQBCA0W/3TrJkBBhmPAQkBATUQA+0QEROT9RBwtADCQQkDMaBLIOk8+nnlvfkUfYq0HKgtzIMMIBBxNpR/+Qsy+pcxLnj46iFiKrquJeuw/xp51QvayeuxkSikk+YHuFmxLdetRH//HXnCIuoxiSxpzS1hFfRlw+/DrxWO1YdqdgXV9vd4mrZmWgl9UdaUnD/LX4bo9ue9O8/N/lnkFG0g+tquwGSy5dUR1BlABio2fmmoVzL00XfZMluV027WL3tK8DkIWtUJRBMJGCMQKQve5vT4C2tRDd5LSaS2wEDcjqz2cbZM0l7Nh/KHiPCCERIKfjR8EmnEApqAGMASDD9uiHBP3bmjPqWVRjwAAAAAElFTkSuQmCC)}#webamp .media-info #mono,#webamp .stop .media-info #mono.selected{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABsAAAAMCAMAAACk2TZEAAAAclBMVEUtLUguLkcuLkgvL0ovMEswL0swMEsxMU0xMU4xMk0xMk4yMU4yMk8zM1AzNFE0M1E0M1I0NFE0NFI0NVM3N1E8PFNJSWFQUGdSUmtaWm9gYHZuboJ2dol8e4x+fpCGhpeOjp2VlaOdnaqlpbKsrLetrbnuzsEEAAAAp0lEQVQYGQXBQU4bURQEwOrvkcA4iRS4/+VYwI6VEyTPzGuq8ppyrjHKIVPQsSnnGpReZkQnQzfImKJUU8saWUEWQZyV0g7dqs6X349tf7qfN3uf6t/N/imLDL7WY1/Xx8d1m/+X6+P9+U1XSADNH8Xkr9aqmTW7fY5+r9v9OHp859f9i7z2vJwZpUdUjWpqSZQytlYJUrOpWaR1FhhgbcLQRiEFTH4AmtR0pKKbMGAAAAAASUVORK5CYII=)}#webamp .media-info #mono.selected{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABsAAAAMCAMAAACk2TZEAAABJlBMVEUA/wAD9wUG8QkI6A0J5g4L4hIM2RMM3xMN2BUN3RUP2hgQ0xkSzBwS0RwVvCEVxSEWySIZwicZwigcrSwgpzIhkzQkpzkmdzsmiDwnmD0olD8qa0IrfUQtL0gtMUgtQkcti0cuLkcuMEguMUcuNkguOkkuR0ovL0ovMEsvM0ovNEkvNEovNkovOkovPUovUUkvXEovZkswMEswM0swNUswNkwwP0swQkowTEswT0swUEwwVkswZkswaksxNU0xN04xP04xRE0xZk4xbk0yNU8yNk4yNlAyOE8yQ00yTk4yU04yVk4yY04yaU8ybE8yek4zNFEzOVEzPVAzQ1EzRlEzTFEzU1AzXlE0M1E0NFE0NFI0NVM0NlE0NlI0OlE0PlI0QVI0RlJbMtAUAAAA50lEQVQYGQXBTW7CMBCA0W9mrJKEAKr4WXXTu3TXG3Dc7nuOIiohKLHjGJzpe3IUreZ6BxJkIIHjnlxxbDBVs7EXaVV1u1UtpehDAdloNB3Xo6p1XbF7CN2kj0YFEYmasmUz05yb3KjmfW5LcBnEvk7L1N8P4UwvN+HwS/c+iqIrAT68XTyvq7frZNt6W33+nUAFHADAHAyw+ZsA6tXx0AxtaHTz/Nm9dGGxqef9bkKOntdRUh8BIFGIOD42KSBLn6WtFQAWN7zBL68plYDXQVwYASABGTy6h4DMOHEOyATMOHWmJh7hH8HfcsJFco7ZAAAAAElFTkSuQmCC)}#webamp #time #minus-sign{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAABCAYAAAAW/mTzAAAAF0lEQVQYV2OUUNT8/+L+dQYJRU0GGA0AVz4HY4h207oAAAAASUVORK5CYII=)}#webamp #time.countdown #minus-sign{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAABCAYAAAAW/mTzAAAAEElEQVQYV2Nk+MHwnwENAAAjgQH5sdp7TQAAAABJRU5ErkJggg==)}#webamp .digit-0{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANAgMAAAAGbqyVAAAACVBMVEUAAAAA+AAYISknP40bAAAAFklEQVQI12OYGtrA4ACEHh0ORNFA9QAiPQsl393R7gAAAABJRU5ErkJggg==)}#webamp .digit-1{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANAgMAAAAGbqyVAAAACVBMVEUAAAAA+AAYISknP40bAAAAE0lEQVQI12PsYNjBwMDgwEgCDQAItwpIh/66WgAAAABJRU5ErkJggg==)}#webamp .digit-2{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANAgMAAAAGbqyVAAAACVBMVEUAAAAA+AAYISknP40bAAAAH0lEQVQI12OYGtrAwMDgwNDR4YBCg8RBLI8OVBooDgAebgr//9NFIgAAAABJRU5ErkJggg==)}#webamp .digit-3{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANAgMAAAAGbqyVAAAACVBMVEUAAAAA+AAYISknP40bAAAAGElEQVQI12OYGtrAwMDgwNDR4YBC4xEHAB3uCv9NUBWtAAAAAElFTkSuQmCC)}#webamp .digit-4{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANAgMAAAAGbqyVAAAACVBMVEUAAAAA+AAYISknP40bAAAAGklEQVQI12Pw6HBgAEF0emqoAwMDkO7owKABD8wKi451feQAAAAASUVORK5CYII=)}#webamp .digit-5{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANAgMAAAAGbqyVAAAACVBMVEUAAAAA+AAYISknP40bAAAAIElEQVQI12OYGtrA4MDAwODRgUqDxBmArI4OBxQaKA4AHm4K/5vyk78AAAAASUVORK5CYII=)}#webamp .digit-6{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANAgMAAAAGbqyVAAAACVBMVEUAAAAA+AAYISknP40bAAAAH0lEQVQI12OYGtrA4MDAwODRgUqHgsUdgHwHFBqoHgAbbgr/DdfRzgAAAABJRU5ErkJggg==)}#webamp .digit-7{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANAgMAAAAGbqyVAAAACVBMVEUAAAAA+AAYISknP40bAAAAFklEQVQI12MMZdBmYGBwYOxg2EEsDQDjggmI1L+I9wAAAABJRU5ErkJggg==)}#webamp .digit-8{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANAgMAAAAGbqyVAAAACVBMVEUAAAAA+AAYISknP40bAAAAFklEQVQI12OYGtrA4ACEHh0OKDQecQArbgt/wD0r9gAAAABJRU5ErkJggg==)}#webamp .digit-9{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANAgMAAAAGbqyVAAAACVBMVEUAAAAA+AAYISknP40bAAAAIUlEQVQI12OYGtrA4ACEHh0OKPTUUAcGBiDd0YFKA9UDACFuCv9mR03UAAAAAElFTkSuQmCC)}#webamp .play #play-pause{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAgMAAACd/+6DAAAACVBMVEUAAAAA6AAYISlH3xqZAAAAH0lEQVQI12Po8GhgYAhgYOgIAdKhQDrUAUKHQMU9GgCL+gfA1jUO8AAAAABJRU5ErkJggg==)}#webamp .pause #play-pause{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAgMAAACd/+6DAAAACVBMVEUAAAAA6AAYISlH3xqZAAAAGklEQVQI12Po6GhgAIGQVgeGEFYHFBoEgPIAiaIHnsCfw8kAAAAASUVORK5CYII=)}#webamp .stop #play-pause{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAgMAAACd/+6DAAAACVBMVEUAAAAA6AAYISlH3xqZAAAAGUlEQVQI12Po6GhgAIHWkAYG1hBUGgSA8gCN1wfe41RVhgAAAABJRU5ErkJggg==)}#webamp #work-indicator{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAFVBMVEUAAAAAAAAA6AARQDMYISlODwD/KDN/MQZsAAAAAXRSTlMAQObYZgAAAB9JREFUCNdjUFI2ZmBgQCYFBQWBpKOLCJwdGpaGSgIAfI8Fm6vX5/8AAAAASUVORK5CYII=)}#webamp #work-indicator.selected{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAD1BMVEUAAAAAAAARQDMYISn/KDPWqFE6AAAAAXRSTlMAQObYZgAAABpJREFUCNdjUFJgAAJkUlAARBoaINguDmgkAEabAvbVxDW5AAAAAElFTkSuQmCC)}#webamp .playlist-top-left-fill,#webamp .playlist-top-left-spacer,#webamp .playlist-top-right-fill,#webamp .playlist-top-right-spacer{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAYAAAB4d5a9AAAAWUlEQVRIS2PU1nL+z0BjwFhRPoH2ltjZJAwTS+TllWjvk7ZyX9pb0jeRDhFvYqBDe5+kxzjR3hK6xImKqibtfUKXzEiXsosulowWkKRUQYx0SV10sYQeqQsAf0Ul/5LwY0QAAAAASUVORK5CYII=)}#webamp .playlist-top-left{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAMAAABPqWaPAAAA/FBMVEUdHS0dHS4eHi8fHyIfHzAfHzIgHzIgITMhITQiITQiIjUjIzYkIzckIzgkJDckJDkkJSklJTomJTsmJjsmJjwnJz0oJz4oKD8pKUApKUEqKUEqKkEqKkIrKUIrKkMrK0QsK0MsK0QsLEMsLEUtLUYuLUcuLUguLkcuLkkvL0owMEsxMEwyMU0yMU4yMk8zM1A0MCw0MlA0NFE1NFM2NVM2NVQ2NlU3NVY3N1Y4N1c4N1g4OFg5OFk6OVo7Olw8O109O149PF9FQTtnXEJqanpra3xsbHxsbH1tbX9uboFwb4NxcYZzcoh0c4p0dIp1dYx4do54d5CGd02OkZDLe86vAAAAvUlEQVQYGQXBMUodUBQFwDnnXdMq2LuWQFy/nYVFQAIu47+bmSDSpFFtmyRp452oiIhIIjJ8Nr/2nD1Nc5ppJS3idhVqIRii93wDABiC79/PAACDdbwAABju8fAXAMBg7/EKAGBYu/YFAGAg9+0DAMDgNo/XSdLm5JxW0sH+JE2TJm1a9aQI2NiSYD0Mlj9JEiKSkAzY/XrKnPQkpydJUoDrXnvFQlIAu67aLVDAfbAgu4k1gHX/pZ2cJKme/xmiNhnfUYYUAAAAAElFTkSuQmCC)}#webamp .playlist-top-title{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAUCAMAAABMHminAAABd1BMVEUdHS0dHS4eHS4eHi8fHyIfHzAfHzIgHzIgITMhITQiITQiIjUjIzYkIzckIzgkJDkkJSklJTomJTsmJjsmJjwnJz0oJz4oKD8pJ0ApKUApKUEpKkEqKUEqKkEqKkIrKUIrKkMrK0QrLEQsK0MsK0QsLEUtLUYtLkctLkguLUcuLUguLkcuLkkvL0ovMEsvMSUwL0swMEsxMEwyMU0yMU4yMk8zM1A0MCw0MlA0M1E0NFE1NFM2NVM2NVQ2Nk82NlU3NVY3N1Y4N1c4N1g4OFg5OFM5OFk6OVo7Olo7Olw8O109O149O2A9PFs9PF89PGA+PGBAQFhCQV9FQTtIR2ZMTGFVVG1WVmNbWnZfYGpgX3dlZXdlZnRnXEJnaHZoaHhpaXtqanpraoBra3xsbHxsbH1tbX9uboFwb4NxcYZzcohzc4p0c4p0dIp1dYZ1dYx4do54d5B5eIl9fY6FhJSGd02LjJqOkZCQj6CXlqeioq+srbettMQFH6KtAAADiklEQVQYGQXBTa8VVhkG0PW8+1zuRYuN4gfgpV4q3PpRNTFGw8Q4MlaJsUPjr/D3OHJgjANnNR2hxA6MNW00mKJAC0YSSZu2SkmBnrP361o5gsY09UL3Ymrd3bq7073obgAQSoUYJJKoqIgoY0DYvAgaaFbr1tA0mrawAABKQghBEIkBQXTY3AG7mrpZbfYylzVr123ZrWx199TLWsBYo6vYJEYqoySxFzV6qEqhGIUCGmKJXlqoKRoaWbozWwKzDYvVDYDRmFmAAGTDFVZtdbN69WQuvey6Lbu1stOzrc4uC1ClspkjGTGGSmKjkhpJRUnsbfdeYvNz9399xXze354/8dqFT7z+rfGnb9fNunTr3/393H3Djzz53Qsn/ea7h6x//Hnxs32eXL14fPeVTD8++ejlH+7fvPXC9vc/2P5Bff7SuzeOT5tv1UXsro+XfnpGVZ1DPqqTJzz99AOQI8zz6bPB/pcOSLv5cj1rwC9v738F9Djog/VqX7ycN8PQ+Nzp7Y23//f+a++5fV2cq9pc85iu/1w44my9B+yfpc6s7f7pd8xxyXavpxMXbWvC5T0LJd/MvcNv/P3uhU/d/1dYo8Hel7cPPwDaNer4+OvEEwe7+XHvB+aTp3Dqow99Ju733mMW559555UZ+MKZu3/E0odz69Bfp9ehFN6+M+0dLcHg+Ph4c8Zb8GiOD058bAuLf34tzmc85dwNHp+8d6R481WrFvyKcPo7/nKwDvsgWYMYz3iAz5697Tk05p4Pn7X5hYdXiAeffNcXH2qK/9694OyTa763/2nuXbx+JBu6uxZgcOqU+G0uH371DWh1yS08Gs+ZtwtYV65elZ8AW61ZbfYyl6V3utc0s9U9Wy89QWpupMgoNoY9STKSUpWNFAmbLnIENHNaTbduk2XRemltsRoARFEiBokkKpJEijEgFOgGQNC0poGGBQBIWokINAgJLABsXgQ0DaZumoamad1YAEChCCEIIWFAkA6bO2CZui169uq1dPeu25q92k6bbWXtohlzswbJJjJkZCTJiCqjYkRJ2IMC5gTFAugpFhB2pa01emCOXVplQ0iNClAMelDAahTYjQHoDkEIMaJmM2Z3d7cFU2CubtoEWExMAAkKbOYEizRTLLSYbQ0SCd0WkvRCNVitgVAI0OwgR9CYJqvp7ja17tZtac3S3QCQiJJIIpLEEBWkjAHh/7B25tuthDwsAAAAAElFTkSuQmCC)}#webamp .playlist-top-right{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAMAAABPqWaPAAABNVBMVEULDxYMDAwOFQsUFBQdHS0dHS4eHS4eHi8fEQofHyIfHzAfHzIgHzIhITQhIjQiITQiIjUjIzYkIzckIzgkJDklJTomJjsmJjwnJz0oJz4oKD8pKUApKUEpKkEqKUEqKkEqKkIrKUIrKkMrK0QsK0QsLEUtLUYtLkguLUcuLUguLkcuLkkvL0ovMSUwL0swMEsxMEwyMU0yMU4yMk0yMk8zM1A0LhA0MlA0NFE1NFM2NVM2NVQ2NlU3NVY3N1Y4N1c4OFg5OFk5OVc6OVo7Olo7Olw8O109O149PFs9PF89PGA+PGBFQTtGQh9ORDBQPx5YVjxnXEJqanpra3xsbHxsbH1tbX9uboFwTyxwb4NxcYZzcohzk5p0c4p0dIp1dYx4do54d5B4h4yGd02LjJqNcTiOkZC/uXdbAAABJElEQVQYGQXBsWpTYRyH4ff7cig5a8FCKAge2slNqFvoBai4e5d26h0UrCnYpaCSrbV2cA0k5/97fZ42WYVR1ZCgZWC4REGDSEAVuRpeUoayyiqddU6IdIGeDkCHBQFgpo2s1dXR/mj/66BvHm/h4vSunocv/67XrpYsWb69L5yAadsaw+IV8hMAAl8/Tbtxe/tahhtAAKAXuBt30KCfnUEHAAL8HXcnQKcfH2huAPje4fO0/fNjujC0kbXMNwds75ydHr/B+9NNntuHlJZWYpWpOcb4NDxYpUTVSAzzx03RoQECIAQomGG4RESDSFCuABheUv2AVTFV2ScamnRCNYiYKAsUhA5g0pqNRpgVADq01gCaxNIgAMODVZJz+F2WWisA+A8o2vB09xIFIgAAAABJRU5ErkJggg==)}#webamp .selected .playlist-top-left-fill,#webamp .selected .playlist-top-left-spacer,#webamp .selected .playlist-top-right-fill,#webamp .selected .playlist-top-right-spacer{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAYAAAB4d5a9AAAAWklEQVRIS2PU1nL+z0BjwFhRPoH2ltjZJAwTS+TkVWnvkzfnqmhvyf///2lviaujNe0tWTcplfaW0CVOVFQ1ae8TumRGupRddLFktIAkpQpipEvqoosl9EhdAAvFKfTd8tQbAAAAAElFTkSuQmCC)}#webamp .selected .playlist-top-left{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAMAAABPqWaPAAAA/FBMVEUdHS0dHS4eHi8eHyUfHzAfHzIgHzIgITMhITQiITQiIjUjIzYkIzckIzgkJDckJDkkJSklJTomJTsmJjsmJjwnJz0oJz4oKD8pKUApKUEqKUEqKkEqKkIrKUIrKkMrK0QsK0MsK0QsLEMsLEUtLUYuLUcuLUguLkcuLkkvL0owMEsxMEwyMU0yMU4yMk8zM1A0MlA0NFE1NFM2NVM2NVQ2NlU3NVY3N1Y4N1c4N1g4OFg5OFk6OVo7Olw8O109O149PF9FQTtqanpra3xsbHxsbH1tbX9uboFwb4NxcYZzbFJzcoh0c4p0dIp1dYx4do54d5CukmXsznr///9ua7yBAAAAvklEQVQYGQXBsU0dQBAFwHnvFsshErl7MQVQtlsgIEGWSMkd/FvPBJEmjWrbJEkbr0RFRFQSkeG9+bHn7GmaNtNKWsTtKsRCMETv+QQAMASfbwEAGKyjAACGezx8AwAY7D2eAQAMa9e/nwAAA7m//gAAGNzm8TJJ2jTntJIO9itpmjRp06onRcDGlgTrYbD8TpIQlYRkwO7HU+akTU5PkqQA1712xUJSALuu2C1QwH2wILuJNYB1/6adnCSpnv/+0TYBQOmyqAAAAABJRU5ErkJggg==)}#webamp .selected .playlist-top-title{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAUCAMAAABMHminAAABd1BMVEUdHS0dHS4eHS4eHi8eHyUfHzAfHzIgHzIgITMhITQiITQiIjUjIzYkIzckIzgkJDkkJSklJTomJTsmJjsmJjwnJz0oJz4oKD8pJ0ApKUApKUEpKkEqKUEqKkEqKkIrKUIrKkMrK0QrLEQsK0MsK0QsLEUtLUYtLkctLkguLUcuLUguLkcuLkkvL0ovMEswL0swMEsxMEwyMU0yMU4yMk8zM1A0MlA0M1E0NFE1NFM2NVM2NVQ2NlU3NVY3N1Y4N1c4N1g4OE44OFg5OFM5OFk6OVo7Olw8O109O149O2A9PF89PGA+PGA/QitAQFhCQV9FQTtIR2ZMTGFVVG1WVmNbWnZgX3djY3BlZXdlZnRqanpraoBra3xsbHxsbH1tbX9uboFwb4NxcYZzbFJzcohzc4p0c4p0dIp1dYZ1dYx4do54d5B9fY6FhJSLjJqQj6CXlqeioq+srbettMSukmW8u8XHx83KydLW1tzk5Ojsznry8vT////NCpc8AAADfklEQVQYGQXBS6tfBxUH0PXb5+Q+Y2oFI5ZoknpLiU8cCELopANJG+M38Ds48nM4ciw4cVJ0INhBK5T6KPVRChVFIzHUB4IQvYbEe+//7O1auQGDzWYaM81mzMyYmclMMzMAIJQKsZBIoqIioiwLhPUuGGDoMaNhGAyj0QAAJSGEICiJBYKYsD4EW9oMM3bTunVnm9G2zoWZ2UzrBpZepoo1saRSJYk1qmaxVIKiCgUMxIhpI6TFwCBtJttIYBuLpmcAUINOAwKQlTt07cww073Rbdo2o23d2Zlt9GSXBlSprNuSLLGUSmJRSZZURSTW3fo667edf+eO/pL3vrj/7mf3f/OVS29/df3Dwc0H9+dry3/eds/Zj1858oN7V9j+9Ivmm3uc/+rqC6c/yuYbR09+cnf//u9f3b3x6sWb6vmbj3/95eNcPLj8HC7er9e/taeqDpDz5XjftYMzkOfR15c5CPZvHRLu/3y5aYHv/XXvC2CWwzns387Nl+vPoQyeu3z+u6ePPnz3sb+/Lw6q1g9sTM4Ob/DMegpm/yq5ttv2P/XQbj1xvjdcPbTVBrevaJS8lNMrt985feb4vw/CZMD+586e/TcwPqBOTl4k/ubwYnc8HwZ2Z8c4ON+5Hk9n7ynN0ccfv7cFrh+c/hBtnt21j3pz5y2Iwj8eXdi/PqA4OTlZ9/wTnu7Ws6zn0Pzx83F9ucQBnh49uaL4yy91NXyflPX2vHO4Hc1h0oi84DE+uX/fLUCvHn3C+l2P7xD/u3zq+MJQ/OvRx1w7+6mX9z/Nk8O37glmphqwtKPPOPRaXvnISz+Dsd70AGfLLRf3A/Sd18jXgZ0xzNhN69ZmM9Nty4WZbUybDaS2VYosxWqxSpJKSiqXJCQsU+QGMGybHmbM2GjNmDZG0wMAoigRC4kkKpJEimWBUGAGAMEwhgEGGgCQjBIRGBASaACsdwHDgM0MzcAwjBk0AFAoQghCkbBAkAnrQ9DajGF20zNtZrYZ3dNjZ2yj07sYlm3thWSNLLKkkqSiSlWsEQkrFNANQgNMiwbCrozuZRZsyy6jshJSlQBFMSsBelBgqwJMF0EIUVHbsGwzMzMaNoGtZxgN0DR2ABIUWLrBUE2LxogevZBImNFIMo0a0GOAEBQwbJAbMNhs9DAzYzNmxow2hjYzAJCIkkgiksQiKkhZFgj/B6KI5O4cXV8dAAAAAElFTkSuQmCC)}#webamp .selected .playlist-top-right{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAMAAABPqWaPAAABI1BMVEUdHS0dHS4eHS4eHi8eHyUfHzAfHzIgHzIhITQhIjQiITQiIjUjIzYkIzckIzgkJDklJTomJjsmJjwnJz0oJz4oKD8pKUApKUEpKkEqKUEqKkEqKkIrKUIrKkMrK0QsK0QsLEUtLUYtLkguLUcuLUguLkcuLkkvL0owL0swMEsxMEwyMU0yMU4yMk0yMk8zM1A0LhA0MlA0NFE1NFM2NVM2NVQ2NlU3NVY3N1Y4N1c4OFg4QlY5OFk5OVc6OVo7Olo7Olw8O109O149PFs9PF89PGA+PGA/QitFQTtYVjxnXEJqanpra3xsbHxsbH1tbX9uboFwb4NxcYZzbFJzcoh0c4p0dIp1dYx4do54d5CNcTisrbeukmWwmV7O4tDsznr////5EmU+AAABC0lEQVQYGQXBMUpcYRiG0ef7708qu4mgxYCFVdbgtIGsIesLZAOuQ0GIlfXFMEMgTOXc7308p/Z2Y1Q1JGgMzAcUVIIIqsjjPKUNm912a+uWEBkCIwsAAwYBYKMmB3UP8Oeid65wW8/9Pn/274P7BeDbS+PXsnbHKmZN5B8ABNba9XJalbkCWgCOBvvLhxTMa2BggQSo5WMpGMzlTMUS+D+a293J2vk3zF8crPMVwBmt4wqWUN/T2rETu022GOM6X+1Womokhv7x1AwoQACEAIEN5gMiKkFEeQRgntLjglvHdOeSaCgZhC6ImCgLCsIAMF1lUcimADCgqgBKYmsQgPlqt8R73tpWcwMAn2oG882E0Lr4AAAAAElFTkSuQmCC)}#webamp .playlist-middle-left{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAdAgMAAADjkWVKAAAADFBMVEUAAAAdHS0pKUBqano8VvpZAAAAD0lEQVQI12OoilvCQGcMALzxKw1EtyFgAAAAAElFTkSuQmCC)}#webamp .playlist-middle-right{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAdAgMAAADX6KRWAAAADFBMVEUAAAAdHS0pKUBqano8VvpZAAAAEklEQVQI12OwmrXq1UuGIUICAIEjYC7HaOXEAAAAAElFTkSuQmCC)}#webamp .playlist-scrollbar-handle{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAASBAMAAACUbIJFAAAAG1BMVEUJAgJ1XCKNcTibgkmwmV6+sX3aypzy8vT06sbDyd/kAAAAKElEQVQI12NIAwKGJCWlAoakiHYHhqRGD/KJimYHhnQXFwEGBQYGBgB4dhfwKIryTQAAAABJRU5ErkJggg==)}#webamp .playlist-middle-right:active .playlist-scrollbar-handle{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAASBAMAAACUbIJFAAAAGFBMVEUgDABsURh1XCKNcTihhkuwmV7DrnXaypzxKekLAAAAKklEQVQI12MIDQ0NYAgUFCxgCHRLN2AITDQjnyhLMmAINzYWYFBgYGAAAIGKEsehmtv8AAAAAElFTkSuQmCC)}#webamp .playlist-bottom{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAmAgMAAABMq9iIAAAACVBMVEUnJz04OFh0dIo98+79AAAAGUlEQVQY02NYBQYNDKFg4DDiaHSAKzygAADHT1L3iexI4AAAAABJRU5ErkJggg==)}#webamp .playlist-bottom-left{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAH0AAAAmCAMAAADeF2QjAAABpFBMVEUODhYPDxgQERkREhsTFB4UFB8UFSAVFSIVFiEVFiIWFiEWFyMXFyQXGCQYGCUYGSYZGigaGykbGyobHCsbHCwcHCscHSwdHS0dHS4dHi0dHi4eHS4eHi8fHzAfHzIfIDEgHzIgITMhITQhIjQhIzYiITQiIjUjIzYjIzgjJDcjJDgkIzckIzgkJDckJDklJTolJjsmJTsmJjsmJjwnJz0nJz4nKD0nKD4oJz4oKD8pKUApKUEpKkEqKkEqKkIrKUIrKkMrK0QrLEMrLEQsK0QsLEUtLUYtLUgtLkctLkguLUcuLUguLkcuLkkvL0ovMEsvMEwvN00wL0swMEsxMEwxMU4xMk0xMk4yMU0yMU4yMk8zM1AzNFE0MlA0M1E0NFE1NFM1NVQ1NlQ2NVQ2NlU3NVY3N1Y3N1g3OFc3OFg4N1c4N1g4OFg4OFk5OFk5OVdGUF1OWG5XZHZbXGRfYGpjY3BlZnRnaHZoaHhpaXlpaXtqanlqanpra3xsbH1tbX9uboFwb4NxcYZzcohzc4p0dIp1dYx5gpaBkqWttMS/zdPt//+lzFndAAAFVklEQVRYw4WYPa4sSRGFvxOZvYQnYBc4gGoVSGgkVjBiLFgBDj5IYKGxsdBI7GDcksCADWCOhB4G5n39OjMORmZV/9zqnpRu3e4+lRkZJ34yIvWDL7/l33z5bTu//dyAAcTj0NEXzU8q26/zT7eviaf/6/jkdn77/JdzZhpQbEsIoRAqAUIKRIUoeUKgQkFBcVAGpHozo4JKotILkuQAogLRKoohvZ/fzudzpg2K8KBgVw5y58QCTE1AYRIghRLK1DyhYmppTWQQFCRvyzZIJBjSL347fzpn9majvOHZEFjI89uckS23/UnbewiYKlnQUDXOsXdDxtgxGZQ2mOCSPn+6ZMvU2JEZ8sZWU95JAhtUcUwXsW5MDfTsDUPrVGJQEwONkHGGW4DLWLRl+u1zNjflpqI9VhUkKXKoGoMEN06BUOJo4LBJ1AyleqOtdVOu+5JtBWFqZkd24M/nbL649w4bi1MXY4gQY5shD7OPDUCCUkKpBFSFSQjR6wmKEwyis5GPrRYUkhL0y1u7kC374JhbsyNICzx0n5hEB6BAODEUYERMDnMayBE9w1p4urJqJZDkevHb28X0bEK/+hEHw38A4Itj8BtA/OQY/CcGPhyD32VNv31K3DLgd98R79/Kj4D4zTMwwL94AiYU/fgJaNX0pwtJkvHVRtj9Fm0s//IpKPGzZ2DNwodnYK/R3DLBgX/I4TAInoPp56BfgcVxoXcPX+TZSI6o20a8wLZIPx6KpF+4zxeHGvJqby+wl1PDvvh+l+sK6/6YUH8AV2C9Jj+u8IYO7LoqsLJuKwy0mtSdCuvCunB9ANaVwGVdWIB12UQU7+C6AMutcu10xVbmimNV5NjSonfzrev7w/3K7rpMpdcDJpf1AcgbnxjYcoW9Hx5SbhKW5b3d407A0HA5qDw2dBvlZuIEbsRTmYcncec9K8t8ACj1DjwSvs/aZoperuK3V5YBy/UdScu+zeWAo2WCNwa+mvYRgWuoLjeTJ+6I7wmnecDvPn8wyouZzlfxnrHVSy/F+7WIV9L9Mtsc1awHCev7CTqW/irXaXdmE/mfmf3vx8SfgrJ4Dqafg7MAnJn2z0A6H8fQ/q/PQIf992dgVvHx6bJ3Pp+//coffWw+Tn/84hlI+G8/PQYF6F8fjsFU3WOKDL4elaSsvSmRrAgp4xsRBFKBKCiQ5gEn/qEgFIFUHCHECUQW4L//6wVBjP4gKllb7UWzCGeW9gnWNIqQtrNvFGZjsjvyrNhinP7GwSyxy8haLoYyw30m9FEByq3RTME38Z65p3ONatbGeJSypOdxppLjbROZGlVuJEYJtIgAKm3LNS6zWGZ0aKJGKfTbqiF2J3woq8mhhTDq4B4mnIiMQmxNlqGCqzMx6qdR8I+6uHvfQWaFFpciYvuRjJjHbM4CGDzshMpsbFTwrJJjK7hj+k2AkdqwZqvG3WEcnVJk7EwPOcSlmodMO8I/uNp7rtyHsMhhftc5qwMywtNs3mh0AxWlGJ6HwDGSTxvForeI+/1tutN97z07aUsabhh7dzt2qem7dfgqkUWuvQwN6hZYIvCNl8s1rnnaB/cDnv5uD4+56bGuDfY0ErsRZ68/j/A6zm4RvisfTa8Ap1+/uql494t4R0w83Fvo6LLi7kpD1rhcMH+axLC5obQ3bChcYpAbLnKERJSsQiGhiEF7FAJVZQVx6lWlR0GUaTmXabg6CYotzYutvBQSZnd8CNNzc7jR10cPPNNHzFAcrWYnEiFXTA3jgI61JaJUpQ8n1QG5erzxGa417ikcN6x4JImRl8sehwVBma+V1EzHgcMbqRbS/wFHTmME7id3UQAAAABJRU5ErkJggg==)}#webamp .playlist-bottom-right{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAAAmCAMAAAARFZKlAAAByFBMVEUAAAAA+AAODhYPDxgQERkREhsTFB4UFB8UFSAVFSIVFiEVFiIWFiEWFyMXFyQXGCQYGCUYGCkYGSYZGigaGykbGyobHCsbHCwcHCscHSwdHS0dHS4dHi0dHi4eHS4eHi8fHzAfHzIfIDEgHzIgITMhITQhIjQhIzYiITQiIjUjIzYjIzgjJDcjJDgkIzckIzgkJDckJDklJTolJjsmJTsmJjsmJjwnJz0nJz4nKD0nKD4oJz4oKD8pKUApKUEpKkEqKUEqKkEqKkIrKkMrK0QrLEQsK0QsLEUtLUYtLUgtLkctLkguLUcuLUguLkkvL0ovMDkvMEsvN00wL0swMEsxMEwxMU4xMk0xMk4yMU0yMU4yMk8zMz0zM1AzNFE0MlA0M1E0NFE1NFM1NVQ1NlQ2NVQ2NkE2NlU3NVY3N1Y3N1g3OFc3OFg4N1c4N1g4OEY4OFg4OFk5OFk5OVc5OVo7PEtGUF1OWG5QUFlTU11WVmNXZHZbXGRfYGpjY3BlZnRnaHZoaHhpaXlqanlqanpra3xsbH1tbX9uboFwb4NxcYZzbFJzcohzc4p0c4p0dIp1dYx5gpaBkqWttMS/zdPsznrt///////YTLulAAAHJklEQVQYGbXBTaim91kH4Ov+P8/p4tD90ERFpaCouBGxCxX7QpmCOxHBj40LP1ra0JLUTbeCO+lON/YDk6B12RYyLl4REVyK0DpCa2tTJwxmVzokeZ///fN5zzkzySQjdjPXVZ/zRKkkqCDO2rW4EgRBCFoQxJV4gkIpiiq7O9x25Y5v+fgd31q/M1KjBz1c6yw6Qnd1S7AJSW2NWZs4iXQ6zIiT2GTXobOJLelKTKoXRtWSCxejailrKdfueMwoRtOGG6medm3UMlaFzZW2jMFQKhQZhcIsQhRlm1NMVUNk6GkmnZ455ZT0FlvEI7dve2RQbRjtoRKpGK3fMmOwCmHOJj0jCGnMiIGMKjIYI9pSEmel2yk9s9vyVmSLLeLGbW57aFQMu+FtS0kx+mKlus0e5Wwso7GsFFJDM0rZ1bCb1fRcsUnJwFRpp9mzu7et3zx1trZFXLltd9uNkdLDNN3oMZoouqfYlY4r01AmlZVK9QUdtLOwBGv1OlSoijKKTs3OW53K3ObszLZFgtuu3HZtLcJicWN0FlOlTmNbrNtooxHGpE1j0m1X68ayiWUTHVTYxlRZtkqlGq3SVdtSpwtd62b0mMa2KtzxmDWV+hcpN1KiMuMsztJUp0JvS3cqwhSTELZgNiJII5FPv5gKxoyusa11WoZt2dTFmL1uC8rj1krJP3uaqlG/86OeIF9a56LyUdfuuDJSUZ6qrmqfZXkv97OZiVdcuePasIunKaR+267fbWab2cwZr9jdcWMkJZ62+hFnRxyPR45Hx+ORmDNTZrzCHQ+tVVk8XaO9w+F4cDxwOB7spt2SudQr5ZGBHp6minc7HD20zTl7JjPikUGN9jQl3uNwdCPbzOxOZsRDg3R5mmp45Hh0dHQ8HtyYvZ0yuzsz4sYqlKcqHjrggIPdwVmnNhczS4+5VMqVtSKbpyloV44cjg6OHBwdcLrY1k29rxlzqbiy2o3PeVxK0BVnsWvX4lrsQgiCFkQqrsSuwnDtcORwPByOB8eDs5wW67b0djGNuVQPuzX4pe/1cNaDNloELU7VdBLCjCaxRTaJbDJFbElmJJ3obdnEFtO7HA/ODseD3WmobXhrnC6mMT/yzbYbRZUbA2PMEVVsA2U3lFIsdqe2rTU3VBPDrpEhGGUUMatUxWMOrh2OdunTNnvO7lNmf+QNGislc/EO1SVBd6nYZVQwh926LTa7+LoWYhPatEuIRiKffnG0h44eOTrYhS3CvDhdfPSNl+YiZVWouXioGbOUrG9V6YtTGI1gSbNuFaNV+tv+f+2hAw52Bw6u9NDJBeN08etv/PUf/OUk1h7DHLdeM265zy2vMRn9jP9+37O+W1s+aHeXn/H1ufzcv3X1Youz4Yf0vR9HvFenFrNXxm+8+YWPvUFSPcrs6svxgZ+4xK3Lyw98IEslz1y+/9lnL9//Y2s+eHn207j8xZ932U56/ppa/R+qvMdLmOl3I52ZTp/mb33/83/8xhebLVbK4NblaLvh0jPuiRtbMWjCuPxZrOpXx4f/gWhPEI8bzfjT38v9zXs1Zemsv/v633zi+y9+7C86NmvJMsvlcGO49MxrHlo3NwrjkrRfGcaH/17FDyGxqxdlihDRomsO1S1Z/P7rLz/3gy994s2UHnMkNYsH7Ub3gwf3Ejc279QPqPELutsvY3iCKu9UzkrPQYgrRYZu6fT8w1e/+MnX/+rj3/98J7MNNSrcf9DOuh88uHevPFIr3Y3QD77u7MGZXXuCxGPKLmrpKLFrpOghXVt/7NW/ff7VLz33+hf+qNuc1mg8cN8t3L/lvhrNvWf81/qs78zlP3/S7j+UB9+YeYDLYdfih1JhmM6iInaRSnWp9sm7X33h1S8///rLz/0gbep1kKVfG9y3e40xpHrcm07fft+oLd+ku/iGxL/iHxeb3lQvf0YIQROCuBJnTRIypko8NJpqfOruVz5z92svvPrl519/mTRrKovhoWFOS6VitOU0LmwhY9p1Zd1Sa1Con/qnsYWNbCLJ1B3pOmlbJTFaxa4rro1WulJNPnX3K5+5+9UX/v1rL7z6d8//+ep0MetDi5JCypUwR3WCOEuqM6Zddy9Odlsl5mghmYKZ2LUujUZCptgFcS3iRpyVKlX1Jy+N/xmLoohylmA1K3Zll66my9lYbM6KMlAo7xAGA4OgU87ibfFIXIlEErN7/c3yBLFLVOziSjuLa7ELQRCaEOJKPBLvkoonKDJl/a6yG942l1khPbZi03SHmGNq6Y44kcQmuiWb6E7MiK2czESnOt1jmokIqTk6tCR6NLGrZYylxiqjJIamXZvLXFJS/VY4xa6dzdEMelmZq+go17rsQgqdOZuiCmO0VJVSyGiEKkZLRJLZc6a3basPWZSUs1RQPbZlCuIsXbTYdWxBTBItgi0kLUREIxGJaBG7uBbiWrytVKn6X7ReQxYUKuw2AAAAAElFTkSuQmCC)}#webamp .playlist-visualizer{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEsAAAAmBAMAAAB+CntdAAAAIVBMVEUAAAAAAAwAABAACCEAa7UYGCkZGSMnJz04OFhjnPd0dIrCNSsmAAAAW0lEQVQ4y2NYRQxYwNBBDGgYDsrKiQELGIgCCxhYiQFEm8aiSpRpTMSZxkmcaYxEus2MmqaNum0Yuk1FU0VTRFPF0sQSOwZBovNCFXEFF1HZuYBYZQNSWhLnNgDqVFE4O/Zo0wAAAABJRU5ErkJggg==)}#webamp #playlist-window-shade{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAOAgMAAACnVF/TAAAADFBMVEUAAAAdHS0pKUBqano8VvpZAAAAHUlEQVQI12MIBQMHhv9gcIBhFRg0MFALwMyD2gMAcRoULw29bBMAAAAASUVORK5CYII=)}#webamp #playlist-window-shade .left{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAOAgMAAACnVF/TAAAADFBMVEUAAAAdHS0pKUBqano8VvpZAAAAIklEQVQI12MIBQMHhvr/IHCAoWoVCDQwVDFAAMU01DyoPQAU7xeZEgCs6QAAAABJRU5ErkJggg==)}#webamp #playlist-window-shade .right{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAOCAMAAABaWb9VAAAANlBMVEUAAAALDxYMDAwdHS0fEQopKUA0LhBGQh9ORDBQPx5YVjxnXEJqanpwTyxzk5p5ip6NcTiOkZBJ6prXAAAAbUlEQVQoz6XSORaAIAxFUQjyFTEO+9+sBI82ajT6KgpukYAL5txgLbhoLbjLfpFGkkMGESHfk2kXGEtiegbA0MiGUEm5GKnjxCCdCMJykDZxekdKqASc5idSZ6nk5SznjXnvtY2p7/Lh9e3fcgVRHAwq+Kdj5gAAAABJRU5ErkJggg==)}#webamp #playlist-window-shade.selected .right{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAOCAMAAABaWb9VAAAAM1BMVEUAAAAdHS0pKUA0LhBFQTtPSThYVjxnXEJqanpzk5p5ip6NcTiOkZCsrbewmV7O4tD///+ogWxMAAAAbElEQVQoz52SSQ7AIAgAsQjU3f+/tpIup9ZI58SBCSs4M7BbcbBZcfDKHyXeCV7RQBgRWb6VfkmeQilBHa7CUnmmnBJRGdCIUGqqgnNFJWqPwqknXlIGtFxFG/O5tUyLs0TrxuLsLj+ub3/LA63jB8yJpQTsAAAAAElFTkSuQmCC)}#webamp #playlist-add-menu.selected .bar{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAA2AgMAAAB/8csyAAAADFBMVEUvL0RGUF2BkqXt//98VqXeAAAAFklEQVQI12NgYTBhKGHYQmNYArSFBQBn5SMZFZ1KogAAAABJRU5ErkJggg==)}#webamp #playlist-add-menu .add-url{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAWElEQVQI14WOsQ2AMAwEv3LPKBYTABsgorTfxCtkfRyUOIiGq04v62Sk4EKugxPZOmVzpxAGKeoupInwcWD6e3eP+9FpTnppOvm3g6307cTPinSsHcW+BDd3RTueo3YTtwAAAABJRU5ErkJggg==)}#webamp #playlist-add-menu .hover .add-url{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAV0lEQVQI14WOyQ2AMAwE9+MCEEkDdEAnGwmXACWQ9skFmx/zGq2skbEJLALBB8eOmF8S4n11zupOIxzW3Eg3Y3NAPu/Fv/tB77CU5OTfDtZSQpg6q/5/AGMtMU3PzLN0AAAAAElFTkSuQmCC)}#webamp #playlist-add-menu .add-dir{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAWUlEQVQI122OsQ2AMAwEv/qeUSwmADZARG6/iVdgfRrHScFVp5d1MlrxwN/BDY+kH/AQhQC7wYNSkOoGD2D6ulPzfnQsO2K6gtLifzuF4Uunfja0a08M51Z82fg51vPZ5kgAAAAASUVORK5CYII=)}#webamp #playlist-add-menu .hover .add-dir{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAV0lEQVQI12NQQgAGQQRgEAmFghBDBtFyGAhkEC1Lg4BUEDs0gDWAIZSBFcxmDQgIZWUNALMZGBBsZHEgG64eCuDmBLBC2QFgLQg2NnGQehBbBMkcYYT7AQVAL9EsAFyYAAAAAElFTkSuQmCC)}#webamp #playlist-add-menu .add-file{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAXklEQVQI12WOsQ2AMAwEv3LPKBYTABsgorTfxCuwPpZJDIJzc3q9LaMkB+o52FGt0xZ3CmGQpu5CmgjDgcffuXv2xx13wseIcPOW8c4lXH65xQa+d/JnRdnmjmKdkguiDDkEOAftpAAAAABJRU5ErkJggg==)}#webamp #playlist-add-menu .hover .add-file{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAXUlEQVQI12WOwQ2AMAwD/ckAiHYBNmATI+ERYARYnzQttBKXz8lyomDpYOogqbGvyPfLhnydlaO4aIRg4UbKjOFA9zF3//qN4oSPiHB5S6y5hdsvV2x4Pw135v7/A+euLyJ1PQpNAAAAAElFTkSuQmCC)}#webamp #playlist-remove-menu.selected .bar{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAABIAgMAAABO2aeDAAAADFBMVEUvL0RGUF2BkqXt//98VqXeAAAAFklEQVQI12NgYTBhKGHYMghgCdAlLABvUy/BqCAQTQAAAABJRU5ErkJggg==)}#webamp #playlist-remove-menu .remove-all{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAWklEQVQI13WOMQqAQBADp0rvUw5foP5AlG23MV/w+xbenSI41RBCCHtnI87GSrhyTIQxknUUwpJM3o4xPLnU/Om3nULYSmf1zJfzk2eS+LvTPxf2ZawU5qFzAa7rOIxN5zmHAAAAAElFTkSuQmCC)}#webamp #playlist-remove-menu .hover .remove-all{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAWElEQVQI13WO0QmAMAxE7ycDiO0CbuAmJ3gj6Ai6vtGmpD8+CDwuIRyWBFOComBfUe/OhnqdjeN1QTCTfW5uoPVcQOY+4XkfNDeK4eTg+MnpG7iX4c+c/R8m4y6+oJDkfgAAAABJRU5ErkJggg==)}#webamp #playlist-remove-menu .crop{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAR0lEQVQI12MIhYMQhvByGAhiCE+DglRHJLYhHjZDAlsCEIPYCWkJYABlswGZyOIw9QlA9fjNxMGGu9mQIdTZGAoMGZwE4QAAjAZBLD2pp6oAAAAASUVORK5CYII=)}#webamp #playlist-remove-menu .hover .crop{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAASElEQVQI12NQQgAGQQRgEAmFghBDBtFyGAhkEC1Lg4BUEBumCC+bIYA1AIhB7IDQADCAslmBTGRxmPoAoPpQ4swXQWILI9wPAIC4Ne4ZKh5qAAAAAElFTkSuQmCC)}#webamp #playlist-remove-menu .remove-selected{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAXUlEQVQI112OvQnDUBgDr1KfUR6ZIMkGxuZr1VgreP0Ufj/gqw4hhDgmO3UNNiqd80OFIEVnoyIp+HZCYOXS8NUfO41KMO7uOMMja7pXbhmT58783Dh+707j+5r8AVpzN34SgZTJAAAAAElFTkSuQmCC)}#webamp #playlist-remove-menu .hover .remove-selected{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAWklEQVQI102O0QmAMAwF388bQGwXcAM3iWBG0BF0fWOb+rxSOI40FIvAJFA82VfUe7ChXmfneN3hIJ3NGQbj6A6ox03XfNIdBku3drLT+LmpR40X4eW3Z9b/H/ZpLd3ACl8TAAAAAElFTkSuQmCC)}#webamp #playlist-remove-menu .remove-misc{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAYUlEQVQI102Ouw0CQRQDJ3JOKSsqADpAd3qpk3ULtE+wn7uJLGtkmXNzUL/Fl8qkv6gQpKg3KpKCRyYErl5a+fLXTqMcO4TeKIs4Hj04mtl27O1bw7/v7M+N8/OcNN6PzR8ABzaO5fDK/gAAAABJRU5ErkJggg==)}#webamp #playlist-remove-menu .hover .remove-misc{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAXklEQVQI102O7QmAMAxE788NILYLuIGbRPBG0BF0fZN+EB8UXo9LCLYES4KiwbmjvpMD9bk7V7ggkGJzusE4cwGZ+xue/UG4ySwmmhPyf88BE4c7UZt9Y/TLb8+a93++ly0VHemPIgAAAABJRU5ErkJggg==)}#webamp #playlist-selection-menu.selected .bar{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAA2AgMAAAB/8csyAAAADFBMVEUvL0RGUF2BkqXt//98VqXeAAAAFklEQVQI12NgYTBhKGHYQmNYArSFBQBn5SMZFZ1KogAAAABJRU5ErkJggg==)}#webamp #playlist-selection-menu .invert-selection{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAXUlEQVQI113OsQ3DQAwEwY0udymEK7DdgSCBKZO/FtS+k39K0EYDgiDI0e3kudpIz8aHNFKVNYJ0mbu5LIxHzP3ldSdIu4Q0LcvLZdrWNccIPe/0z8Hxe8+C76v7A5OQN+oVjwHMAAAAAElFTkSuQmCC)}#webamp #playlist-selection-menu .hover .invert-selection{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAXUlEQVQI103OwQ2AMAxDUV88AIIswAZs4kh4BBihrM+BhvafnqooKfYRlhE2984D8VSJaPfXlYgmyKSciGaKkzFZFP3Pd9eBRDSLgrppuSyLZXO8w4LgxDbtWcf/X0qvMI9I7cp+AAAAAElFTkSuQmCC)}#webamp #playlist-selection-menu .select-zero{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAYElEQVQI102OwQ2AMAwD/cqfUSomADZAVHz9oSuwPm4aAtfPyXKtoCYHzvtlx9mCa+kOgvIip7/hzWjp/HKl+hF57Mh7SGs2OqoL9z5jw30+cu8z+r+dvLmgbnNQsE7JAyOvPXLeVffRAAAAAElFTkSuQmCC)}#webamp #playlist-selection-menu .hover .select-zero{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAX0lEQVQI102Oyw2AMAxDc8kAiHYBNmATI+ERYARYn3wK4fXyZLlWZClkKqRxsK/S75dN+nUmhzspEJDhiJdOhX6Oyi21HyNP3D2EUrNjdSPcZzQ95kcefXi//Xbmuv8BohAy09WnmqwAAAAASUVORK5CYII=)}#webamp #playlist-selection-menu .select-all{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAUklEQVQI12MIhYMQhvByGAhiCE+DglRHEJshgSEByDYEshPAEMJOY0tgg7MTEOJAUaAOqDjUHKh6hBpk9Qw4xBOwmgN3syFDqLMxFBgyOAnCAQD0WT/cwFbKdgAAAABJRU5ErkJggg==)}#webamp #playlist-selection-menu .hover .select-all{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAVElEQVQI12NQQgAGQQRgEAmFghBDBtFyGAhkEC1Lg4BUEDs0lCGAISA0FMwOAEMIO5Q1gBXODkCIA0WBOqDiEABTj1CDrJ4Bh3gA1BwRJHOEEe4HAB23NNar7KHYAAAAAElFTkSuQmCC)}#webamp #playlist-close-button:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAD1BMVEU0MCxnXEKGd02ukmX///8tdlhEAAAAKElEQVQI12MwBgIDBkMBBkEgySjIaMBgIKAgACSFnARgbIg4RA1YPQCfwgXpyvsxsgAAAABJRU5ErkJggg==)}#webamp #playlist-window #playlist-shade-button:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAFVBMVEVFQTtPSThYVjxnXEKukmW0r4e+sX1mGpZYAAAANklEQVQI12NwAQIHBpe0tBQHBrfUtDAHBmdjY2MHBidjYyMgqWys5MDgqKSkCFQjKCACJEHqAT9eCss1JzHfAAAAAElFTkSuQmCC)}#webamp #playlist-window-shade #playlist-shade-button:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAFVBMVEVFQTtPSThYVjyukmW0r4e+sX3BsGNteY1yAAAAMUlEQVQI12MwBgIDBmMBAWEDBkORkEADBiPV0CAgmQom09KUgOJpaYogNYLMQBKkHgD8fwlqtoGUgQAAAABJRU5ErkJggg==)}#webamp #playlist-misc-menu.selected .bar{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAA2AgMAAAB/8csyAAAADFBMVEUvL0RGUF2BkqXt//98VqXeAAAAFklEQVQI12NgYTBhKGHYQmNYArSFBQBn5SMZFZ1KogAAAABJRU5ErkJggg==)}#webamp #playlist-misc-menu .misc-options{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAYElEQVQI112OsQ0CQQwEN9qcUiwqADpAvJxOctsC7RPgPyEmmmA9so7NS/0+eaozrJuaQBStUmOFkFVqJOJxIIwH8He/O6VGmLMDv7eO4/HEYfaJ8X9n/1w6HtehdL9sPlWoO+DkW3+GAAAAAElFTkSuQmCC)}#webamp #playlist-misc-menu .hover .misc-options{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAYElEQVQI102O2xGAIAwE7ycFOEIDdmAn54xXgpag7Rsembj8LMwSwJZgSVA0OXfUNzhQn3twNadIQehukO/VHaBsutOy6GmjjwdGT2PMaX3eNfmaLnfO3p1+Xn5z1vz/BxcjMYQLzDa1AAAAAElFTkSuQmCC)}#webamp #playlist-misc-menu .file-info{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAX0lEQVQI12WOsQ2AMAwEv/qeUSwmADZARGndxCuwPomJTcGlOb0+L6MkF+odnKg2aRuqoj9TNOluxu7mTnf+cvMf3s+d4WOG4JtTSVo4iHSN3PvR+XbyZkE51olgX5IHU8k5In6uSFkAAAAASUVORK5CYII=)}#webamp #playlist-misc-menu .hover .file-info{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAXUlEQVQI12WOyw2AMAxDffEAiHYBNmCTIJERYAS6Pq1LKBIvlycrPywDTAMkf9hX5BJsyNfZOZobarlB7s7qLqecv9w1of44IG9rCPacRtLDQbxukau/efrsmcf/N3ldLzugWMN5AAAAAElFTkSuQmCC)}#webamp #playlist-misc-menu .sort-list{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAXklEQVQI102OsQ2AQAwDXaVnlIgJgA0Qr7Ru3iuwPgVJ4Corsk/BaC7EXZwIJXNDCASNmI6gSFI2HSEjaZn53WlEd8rzbiGUR0ZlXzLZL5cHRPt/nv7ZMY41cexL8wCXGToqpM1dFQAAAABJRU5ErkJggg==)}#webamp #playlist-misc-menu .hover .sort-list{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAXUlEQVQI102O0Q2AMAhE74cBjO0CbuAmZyIj6Ai6vtBS6fvpCzmOYkuwJCganDvqOzhQn7tzuSsICuFOpaHS5mIq4cy5Z/9MELvwru62rZG3V2Xy0dPuupepZ83/f5v5MBfSedE0AAAAAElFTkSuQmCC)}#webamp #playlist-list-menu.selected .bar{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAA2AgMAAAB/8csyAAAADFBMVEUvL0RGUF2BkqXt//98VqXeAAAAFklEQVQI12NgYTBhKGHYQmNYArSFBQBn5SMZFZ1KogAAAABJRU5ErkJggg==)}#webamp #playlist-list-menu .new-list{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAYElEQVQI123OsQ2DQBBE0R9NTiknKgB3YIE2nYRpgfYd3PlEwI9esBot5+yg7n9fKqNroxwhRVejLClSNyLQbSm4+3E/dxrlmGC6I2dsJooe9jDGLzvz58b5WUeNfZn9AKbQNSZ12uygAAAAAElFTkSuQmCC)}#webamp #playlist-list-menu .hover .new-list{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAXklEQVQI112O0QmAMAxE7+cGENsF3MBNIngj6Ai6vk3T0uKDwCM5kmAbYBkgqXHuyG/nQH7u4HI3EaRYnW4MByEgvAwE4z/fD0TfSt4QLnp1Fye35iVrtZ+mPev4/wORlyvp1GfF2gAAAABJRU5ErkJggg==)}#webamp #playlist-list-menu .load-list{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAWklEQVQI12MIhYMQhvByGAhiCE+DglRHhvCEtAQGIGRLNQSzwQDOZkBiw8RBqhMg6uHmQNQwpAHlIOw0NhCGsUEQzk6AssG2pmGYA3ezIUOoszEUGDI4CcIBAJZqO86fMyFaAAAAAElFTkSuQmCC)}#webamp #playlist-list-menu .hover .load-list{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAV0lEQVQI12NQQgAGQQRgEAmFghBDBtFyGAhkEC1Lg4BUEDsgNIABCFmhbDCAsxmQ2DBxkOoAiHqYBTBzQoFyEHYoKwjD2CAIZwdA2WBbQWwRJHOEEe4HAE6RMXWXqbP6AAAAAElFTkSuQmCC)}#webamp #playlist-list-menu .save-list{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUvN01OWG5XZHZ5gpaBkqWttMS/zdPt//9STElyAAAAYklEQVQI102OuQ3EQAwDGSl3KYIrsK+Dwy2UTrJswe1fsA880YCgCKltfqpn8VV50i+VhQD1VGEA3FPlQED0VBlAIyfAMfp7Z9zKWjsO7FjueDnThZj5e2f/nGqfc5K6j80fAQw6zDOWMCAAAAAASUVORK5CYII=)}#webamp #playlist-list-menu .hover .save-list{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAASBAMAAACtCzMeAAAAGFBMVEUAAAALDxYZICpXZHZneYZ5ip6Jmq2tvMRwzsuHAAAAYElEQVQI102O0Q2AIAxE76cDGHEBN3CTM7Ej6Ai6vlwL4iMkL5ejBesA0wDFG8eG5ensWO4rOeUOgiTkdAqP3CK3cKXInFYLlv2+oL2FZqXXRr3ddT5nc+2NvPzmzOP/L+cIMJ5Oo2aQAAAAAElFTkSuQmCC)}#webamp #equalizer-window:not(.shade){background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARMAAAB0CAMAAACR8SbcAAAByFBMVEUNDRQPDxYQEBgRERoRERsREhsSEhsSEh0TEx4TFB0UEx4UFB8VFSEWFiIXFyQXGCQYGCUYGCYZGScZGigaGScaGigbGyobHCsbHCwcGyscGywcHCscHCwdHS0dHS4dHi0dHi4eHS0eHS4eHi0eHi8fHzAfIDEgHzEgIDIhITQhITUhIjQhIjYiITQiITYiIjUjIzYjIzgjJDcjJDgkIzckIzgkJDckJDklJTklJTolJTwlJjklJjslJjwmJTsmJTwmJjsnJz0nJz4nKD4oJz4oKD0oKD8pKT8pKUApKUIpKkEpKkIqKUEqKUIqKkEqKkMrK0QrLEMrLEQsK0MsK0QsLEMsLEUtLUYtLUgtLkctLkguLUcuLUguLkcuLkgvL0ovL0swL0owMEsxMU0xMU4xMk0xMk4yMU0yMU4yMk0yMk8yMlAzM1AzM1IzNFE0M1E0NFE0NFM1NVQ1NVY1NlM1NlQ2NVM2NVQ2NlM2NlQ2NlU3N1Y3N1c3N1g3OFc3OFg4N1c4N1g4OFc4OFg4OFk4OFo5OFk5OVk5OVpcXGRgX2pkZHFoaHhsbH5vb4JxcYZzc4hzc4p0c4p0dIt1dYzUqAzU1NnX192pRLExAAAnOklEQVQYGQTBP8+20ZoX5ON3rrXu+5m992QGDcRCDbEwRk0oJCEUJnZ8AkJDSIgyBXEKvgEJjXYUU4z/YkOHH0ALC8sJlSFSQGECGQviVicO2e/73Os6T44jAAIIEAgVhOoFMhEgFIJQQSy6KgJhVyYKhLC7ylBkCQXKufPuaoWBAiJCb00BgK5mptqI0aWB4O72oUEb3K4W7e5roNMYbhuM+K8BAAACAAAEAAAEAAACACAAQAAAAQSQCTIRkxEmAAAmk4FhMsBkYACAAQADAJgM/v7m78bUhEAgJBTVlcAh4ShRgpCdWbOlZOptikVRXqPYj11hs4SaImQ9tSkLekNO2/cgBGtSxeoKYQIwwQTuyoXhqe/1mIxh+LnxofGM0fph6LTJ3F4+3Opn3zaXnmK6ZxAkEBIydMUgl1CAGcFGzR5ErQu6ETratl9lZluLYYYMuYrMPFRtOD6PHBIJtWUXefAwEzNAAA+rx1q1UFPPnhkgzr2fD93xMNq0GUZjJISWfduAW6AEmCHIDIEhrCoZVTQkwA4keqJqikwVsafZHkj05wIFrLMxsZLGcbwBGKqyd7spZZZhngTAyMzyTI1HnvA85Soj3B8/P3tDZSxD9TOCGSb3s8od9n20dne3XZRKMBCZoKJQCjyKmKsqjDGhktk8VOgEs4rCitdjF6BIGCJyQURPw7m3gQyh09/KnieShGQNACF5rJqsus/M/ZkzW8gM+8v+OAfxPEN3B4wis+v7fia6uQwfdNFAIgkTaGaiCyydhDmEykTstM7dz65K2Jm2aDV717zcFYBZGwBGowZ64/Phc9bBRJBxEFvTT4IAgFYzw5OM3u+6c80YuD/Ojc/HNEtgNfRkGGqJ6bKGKOgukiDDDIJMSVAID4M6XYYREGRbaeMso3SUDu279tPAyyaoFRB1y4RnFYh9+iDB2NIDrBpVnpkBAGqS4VkzaHnaZATO+eyBxNMz9AWqZgwu6JsHqkWrIgaQAJmCqAScs0FvokzE7qqJ65nq+NTQFNAPm2oSUsA0MLwQa3XBsW8fYIiu2d2U50k9nVmSAYBhJuLpuLd9vzbDYH5+9vVBz2jTaj8YGtwuBm11cy+KwjCEAQgGDfi0sFXLkDBuYeznUKGSKtNUka0uXczePQQlgpQmrNHNcTd+AAXTT+0SiqkIDABE6Dxm2K9tdQ/Afbnb4Y6WqNtPMUzGxA5o9agX27RuhSIggBlkCAnrFNylTIoQ+5bUrvOAtxkqVYGiWbslPKsNOgyptbdk1sMuPmfjOcBE7fK6LXrHI0EoAGaQTK+VzHXne3QwUNd2PpSxpinzAAjdLnSv29/TerRSgAyBkCoSqhg0RGjBCOyebJ+uUqBo3WPvitdrP6Ogz60ESYR5aCPPSuB83OurQFDz7N5lZp6xhAEAA2aImUl5UusSwU+fvXw+SHEHADPNjBuGW+4mbgmPDb8BZAICoUQmSiYEAUJCECoIFipBeN1NFITAphhq3x13Fyg4FAZUK5CMotqkoAvo6uqZ3Z0xoKshk6v66Wqga3yGJszTDAba4JthzN/5nykEQAAiGGqkugWDAYEGYAio7hjM+N4EQAZaMar23dG7QOGcbg1QCoiJ7nlYBQpAdcXTlYyABhNVVae6AP10NkAKAA39zQAezwb+KwBAAABAAACAAABAAACZAIAAgExARgAZxQiZmAAATGBgZJgMMGAAAAMAAwAw8PfJrE0Gf49AJhSFCsERQV6kZELUZl7qKVWnCGJT26x5MVUZ2X0QVhchu5CwpoTj7nm+IGSy9dEV60Yp8+wJEwBm8iye5Zm7PdXXpDOZyc/92Xegp3XMrQ9GZwbzfdodt62rH3pmGE8xAYBQZDADzgW1d4s2JGxSMmWVT4OlxL7WuJ6+RjZaMGnIuppYTAIftw5kZOKm+iczT0oZtiAATCo7UfOMY9b3NSaMqM++g+7ElFE3gcpg7L7o2kAVpqEIAELSTFRVgI1RqQqRgAHzVIVTM01XSV26/rOtapPNX1SBSfmPmd5d0v78sgZu9r/bBWLyZ1epuxbW7zB04FcGwK/C7Sbtd32+88lLAjw/uBtSwxhuzcA8GPOUS5t1d/e+tyOgGCCADGqAcBqJ0UzFCLUjtiwZdJRUgZJ2FbiaDCrAmcYUzIMzxvk5xEBPpvYk65H1VDIDAjDGrE4/j9F7XfNtAPfrATzySNMbhgCZ3tgXl0taQBGQAbSKCT2gS4JSJkNQLnIresapUoxm2INNldgwQQPuLhQiG5/UY76CiQyvadAl3BYzABCRZz0xK1Oms8mY4VM/Dx/cagzq8zB4MPS6d8YFajM8aAUwQYgiUBH0ZcZqEkRGddFr96cqpa40S5G9rSrPc0tsNhkkhNe4ZMLMAHUEmSCZvrWxJDe1a3QCAHB3PHIHe/U1A5xdbcMaQ6X7BpiF+I6NLmjThkZTIUhgGEyiBKiSJEVGZZigpKjdOF2j6KFwp7dFm2HChALyfbzKmKUnkH2ByQTzurvuNQ9TirIAMJjhsmpi+CSFgImASXmme8oMQ3sw5MLtBXEBRGEwgwQlGSuRrLVUxTg20WOE3qX3dVXiUwWrAKWuZ++SUA10NcxqqKyRHccx+wOoYbtVd5/sKgo0AIRJeu1xk0n0pJv0BD9/PHc7pMcS2EAGdD0bdg2tMYyHUQABBFlFtrWqTgJNDZUK7GcUFjiGXo8FKva2G8JzBUUlqNaKJ2b4HHtyIBA367Fj7hOZ6R4AYMiozNh3zPTz+hSZGHyxPx8Qj+HezzYwGJ2+l763fdNX66ct2AgATKqEqMqEGNnRBSZh3yP77qhwulSXVZIdz/ZgE8NBEGDfTVgPG1xOYGJg7pth3yfj2UZhAGLE0J4MOt/qiUnGZNbjfD48GTJU+ci0wWSk6gPWlU8AEEUAoKpqRl7nlWQlxXulrqJKgjK0F0x8turyDLXD167NxeyNRJIpgbtVzcyzRoO9V/+EkCiZuYSsSpYOCACBwcINa25MIO6zwR3uDN/Xx0hVEKofh8tlTqOJBzYThCCKyqriFDJd1+t7I10mUV2buptKJqYaC1MG+cv8pwDiLwDgPyIAfx4I/DkBMvNnJRMwv5oA+BUAfilmwsz8G/6fajD4wQesplq85zsy08SgyiP2tb919qXaIGYTwIRJV3Jynlck6OWMF2AKXQVMTGKlFXqdMkXyR/7SH8VmCX/hf18E4j/8J7tia/x7/xzn8/oc68/9S5QJ+8/83y/sZ02e3/0Tlek14Vd/Chh++0+nZnrI/M6vRxsjzPeqTwZdoeqma17tQ+ma6Ax1qdf3rdGtdQ/csgGAUoup9UqwfZaOR0bUlLBN0tmquibvllhPrRgvzwJsFYFFsNaUV2LfvQIyzsfnQIx4fS7EUxolUgJAJxMxo5481VqMGOT9szMZ6lYXUa3z2HfUoxp8ZLrWZX1ryuOhygYgUEveZ1XtJYv1dGZWC2QycWvzunp1JbpMCLvmFS+xSSqfgzCJTEKroZecD8fNTd6IAj5TXnfP6l4UQUYAlMFMVx5ThtfPYRh4m/w4PraMB1Hsi6k8iHn5OdWpzmdfeWYANgAo5H3WeueVenf9Zn1Pf6iZar0IO58zd/eewioDWzqvZ9/XAae+6whKeT3P6smIqIjP+aA6E1CA0W5Jm2cJIEyAicwzUk1Gr5lvMSNpGM/mfAhLt8lTl0x6Kj1wX33re3WXMfXU0/iwAYBaWWet97vetar7F1P95BtpZWLi7jNiDYnqUqqrtqJ+SQrlPbAy7M/esLDypCDJcwgESKW+k82w+hEmQAAxsUyv9Ri6ZJBMOow8NfMNM/XUrEwXmaEyI/XERjz7+xn0NDgfG0CosPZa79cv8soh3535Id+TKSaE3VVZJgVFMTtE3ixBYqJ6mchaEpNhzOZwufs6BHa5+9Oe9/dAJtazTHR1AWAiYj2zn3Am1QwRZCz5cT5Ietm6sd31mJEaazqWz+v7vvIZJtPAbMhgQlbWWtm/rNdZL5zvevzm7rkmU0CVLrm7a7K6ZkpJrZ3yFlKjNBNyvCKYhIijpmZ7ZQ0m0Pfk5Xt7BZFZ1tVZpQCgy0OrfkDsb5gMk4HHBVPu7llPNR4yMTFZ0+p89v3OmpFW8GEjEyLBqpNf/qJ+sd97ZXrW6189v+Xn7GsyCdvnJGp2ZeqIIrLf388rL7EQ6aVVnErC8pxnxQ58nxxCCMI9NfGiBdZMsmzMJACjZM9YAMNrvskQA8q+g7BV3dOq9x3CuWIi34s1091mGIPeGIRJrexXvdf6xXu/s/CsH7/0/Vv9QQTuPtBpq9TddKm462UnK0BKFpbYmaTPZCKcu74gACJrEWRWoPQyQAJARjqypgGC90/7jpGMka8fjg/AxlDrM07n3H1Zz/umurV6GjBqI2GigKqv93t/rZzqm/v1492fNe65w0SVid2r1nj9fE+pVSzbWVlxqvknArHl/6yEks0/51wH/MsMIZz/975AJv6E9eTxVPlTAPwpCCb//wPA/8eovjJhMvj59bkbxyebT07fqpZt8/Lqj8y67uvH67tVMzBdBAJyXuv1Oq/1tfZvvV/vr/fO1/vrfGUfkrD/9u9N/a2/ZTF/I3/tDVrZqUxWznvVXvVKNvaraq3XOefgQK4vSVIzCRO4L0lkAp71rL0LAAAeup7UgrXK5rvYCCLF+2M751xxrxN2qderKlWnUifFjru+Xa0nQ6IYgFoqdb5Wfa3X69SrznnvnFR2PJjfr/sHMv/9f/c3RwWtms2+2z6xq/Zau/LazzmnzCruzSTn45zwJZGoEDW85iWsDLDMCtAwAFjumnU9xSKeeN2nC2xBOOfee6/7fn993RxFoZK1a5+qlaRmb3uAixmbAEFWfh/+KPucu646PfNXwH9z2+/7239Y4r8g/gbHX/M/kS75KxD/OKvA4z8B/qncd6z9078P/AsEMv828MdvqGfN828Cv96A8jvAnwCo3wV+XTyruh7/FvDHuTlux/w7wD87wZcf5/MfAP/HKmLZz18a/K9z7YuujDEbwESO+sNf/vZv/3K/99nblx+1P/nf7r/6+Zuf2bf+4L/8wy4T/0OFf/DXP/7hX1Wysut/eeedVe8Tx6dG/WMix5kD+Xr+GW+RCdZD/hh4E+Kxfw2VDcCfAADUr1VjobTm/2Kw7+nc2Vf+hfn5/mkt4P3TP53LZJXjo3LPP3rm5zxkdCUGnQJQVZx6fb1WUq8ria+z3uv9VPJG+4Ou3/N7/Od/E38df5U26GNn5bVzcm9k75Bs5x5JwnojTMnrvdebAm+Cx6pnQQIAAAD2slgZk7HwUnh3quzXI8j7p68jEfI+skxWnHuTE5XYQke1ew1sgJCElZx19v1KSE8leT/76zf7e82k93+bfv2PU+ofcP6hUfactWWIuF/8yP70fljhCzEx+foRRF7Y/f7uat4E6/GsZV8VAAAAQOapmBrPWo+M18PrMy+F10/w8yyQMD8xS8TNKz+uajWsu78fap63wWyAoE69ar+Wylfy5mdOOhSvp0x10wWl63RNtaib52XLrpyLr89Vz6KcuyVk4AtigbLTB7BYac+aPQEAAABQxYxnh/XAWj7rAs4nw5dnIWR8/WCNKfHm68fR59v6XEU9c9dPpVsBjMqq5F0rOUfeeMet13rnRb1musqU24X41FB2bOwstdwvOGLFIBIhAkQtBPVxIQCzEAAAAACMkTEJBLQXgnoJLBIIDvOU44v4uhZuVrXCpocoQA0ke16cuiEJeUu8Kkkn9amEvaZSOadSTc9WlVDlHEniC6nl3DfsNwESIRG81kZYMBUCAAAAAEPIjmERPKcQwTcBgRDvS23HFwEq9izKo/uRoVWA2ckKqTmrfDngnZzIya48hhp7S3oGKEvULsUoKxI4wFuSd3mTBNgCwb3ASJLBAAAAAEBiwoxkMBiAEAYI71dEHPhcIvE+gQO2apMZoxAQjtdar6WOVBDcdWLjtUuRe5+pClUGT3HUlryWS0i4B+dGFLwhSQAIe4MKSMgAAAAAYDAiiCX61kUgXhIIFgjgQEhuWHE9+mo8ZCmApqxJPQkAUFXyWgfKsDcm5xrUCd8PQiyALzgWbEBgvAUAhAgQMgAAAAAGGBjzoPQLAAGG2rzgfXEuCYGKueVMcx+Dpgik5KFOvWRdWGvxzpusKlI7hR3EeAa6J1UiUc5JBHC4JQABAiwAAQAZAQAAABBkBKILegPAAInAGxyHLwBs2RgB6KsALLvyWjt2yQmIRImpRfZW6oGkVhSror2UmFy8X2/h697jLLxJeG0kNtQsJQiWAEwAAAAAIGOSCViBFwRgEQk2kMQ9HwjEG6hNjX0GNsUQWImrpHwpAM4iLzLthluYnLsHHtnRYk4AjoALCLgSPJDQJAwACAAAAABmBgQwAGARW2QGAOPNuQRvfFsogG+Mb4ow1JB9zC6EJRYQ+ynvKltqpxY+m8KCXQgIlLDcUwQIG3iJhbUwmQCAAQAAAEAwAKIBALgGoRA2uNcxBHkfRdwPRgaYgoRUJU/W61EHRMBl2Zsabdxr1DoUFrtespVaDgE4yyeiAB5QAB5EAIAAAAAAQDAGAAAsUDKIEER8wxJe3jDisY9uJS02hYxs8Ep5BQCIvKxbazrsXdmUKtNtBTweAx9eEOF8fcEIxAtsAAsAAAAAAADAxIQBMEAAFJmgIApvgAMYPO5TJdfDuBQm9MPO8OACIFawqaqnGRhtStFVhjkpyfkK8AIDNoB3yhkgAFgCwAAAAAAgpkkASwQGAAQKAAAXuJu8WB69MRiFoIpKXnYsBJCXAzX6WEenqCi6RPp1kWACJEgIogCwtwIRlgUAQAAAAAAwLAYABsJiAREQAG/nTbwgCLKH8hMYCkFHMjtVQt5WkEWoRK0qeZ4dK7yLYlr16z57IwUAAMAC3FsEQzweAAAAAAAAwAQABmAAgAGAYH0iQGAMSZfR9SAUBiwTswEAANmDWnrMOBctq9TtlwubKwQAggBBv8GCsQAAAAAAAAAYACQAASAmAGDwYABQQqtxjy6gSFCeQ1XFLgDAAUXJnqkUZTCj+qW9pIBZwAbCvy4IDlv3b++7sL8+n+9x/v6XZXBFc41tNpcQWNPCKBuYtgFhjRUUx7oaNMKg+Az2GGR7BqPPQHtHE6euWJng1sDAahQGXUfX3siNJMVhYvO/5e88v8fxee/1gssF1gOgKFwAAAAAAAAABYAcAABEBYCieBEAoFpmtL7NIKZB4ToltmofCgBQFgrdS+hW3Up7m+pFVEMBDhAKaOhGAdCBCwAAAAAAQEWUAC4KAKChACh8+ORDKQ94A01hrLgatgahPPqNazUFALgY68qjyoDZMnSN06V1FQCUN0B5w6EAQAFVQAEAAAAAAExKFCAAgEYBAKLIhk0BzkgMT2aAJiCNBgAo2LoU1WWa8rgvWsElmOCCBWwKFXBxAECAcy4QAAAAAAAAEwAMAQAYCgCABwBA4+BD0QJdGqrElAYAwEp3NNM03Jc0Tbe0EfCoosBSEABNsQEF5boCVQAAAAAAAFejArgoACgg+AAA6oY3ACqsS+YZKNM6hRJVJRcaAGDDhH50U0Xr4Wj0aFWgETBQCkABAIBTEAAAAAAAAKoIoAAADiKwAYADAFBsUxhg6wJwNCsAAGjW0jwZ5frQNc1FOavLI8AjAA0pBQAsAMDlcgEAAAAAAAAUIAGgAT6oKi4AcH8CFEAOpUPYYtNCUdLRrQAAoLVSwYX//psprr+Rb8hcLxyUogCghAIAwAUgAAAAAAAAQBwCUANAAbwIBqAA2AKgiVHYoLVSAIAHAADQ+oO/lfbrf+/v/03tKLpVqWsBUABUEQVcAARAhQIAAAAAAKA0FUCuC8CBC4ANEDgA4IEZS6Ak9FgAusFfKPwQAPwM4p+OqV/3t34TB3+D9mt+Kw8n+AXghwB8CfhR6oLDZ8CPqwC+AHwE4FPgIwCfAh8B+BT4GMDxReDHQPBngR8C8CXgBxbg/grxHa7aAxgWAswF/+cnP/X4Uw0A/ijP9/2uO/nNX/87Tbdp//Ab47d+1eyl6O/2h7fHqgLgh0HVG+cCfgRKFOAnnAUAPgIA+AgA4CeVlHMB8OOAAgZ/HFEA8IN4/4RCgccf3v9h38EBQBYa6CrOAgAAaGMev8njW9/0bXxD+1V6ncZcBAAAWrkAoJgLAA0AAAAAAICYywUAAOA6AAAAKZCCG4a9DQmDWjQUA5fyAAAAmB6l99/X7duX/sdtHQCpvQAAGJwL1wFSACqYqhQAAAAAAFABAAAADgAAgP3ANAAez63PTaUG0QwltHkgbgAAYFruR0ENrQvzxjhQswCAwMKlACgugIJKAQAAAAAAFAAAAAARAgCw4AaAmEzILiBNEXWlAAAAAHQ97jwsaaql1+qXa1GoAYCSohxxBBRwAQTn2gUAAAAAAJAcBwBgIxwAKACId08AYMio1ENEkdIFOEXfAwAAgCbULdplBpulLYpcAAAADQBxFFDocwEAAAAAAAAJAMICmgMgAAAAAYAR0qUQHaWLS9BeAAAIMLofHx4pnKtaz+rq7NZYAABAUHAIFAIIdQEAAAAAAKBQEwHAa4Oh8UIACAER4AZscA/ZQ9EwjcBoA4AAMNNOzIBSTO+JCaF2FQCUAlEAAACCOAAAAAAAABGcLiAo3hoAQPACAJ4EhBVkCtgFoQtCF9gNAIAM9OiamzTQrDEWnVgBAoyIIA4AAKCo0gAAAAAAAIA6gAAABgsIAhAACILHzEDPdIGGKgaMAACwQGvbfFgFTU+vWcW2G7sQAFCBAgACAMJsAAAAAAAAByBQxGxPkMARhADwBAAB2fQ8x8veAU1XoyEFEgCAMMtc1qjm0j1N6zeLFEsAAFEQAAAAQF8AAAAAAADAQQHo67aFGRgCQGxYawkATLgMZWkQDQBRDAAAduFOowPQ7M6ASSE3AIACAKAAAAoAAAAAAKAAAkGYVwOaAABYAjzxBO4zsCHbNBLNCIpwsjOeOABgMmpA4RpqrEVvXRaEAAARBQAAAJwDAAAAAABAAEqiwNzGgAJAAngBFgGgycvUI0cZoTS6YFUJCC8XAI4Mc6GnoClrDrOwdrFTig1sFATiHIAAgOsCAAAAAAAAAEgOeuGNcEAARkLiLPcN8JR3bhtxz+UGaDpgZ6ZgRyIA3IJCl8qQdE9319HbZC8Fj5tLiAUFUC4AxQGEEAAAAAAAQBwSHFDw2ngCeBHADXDvm3tFPIE4NTuiBCHRKLB0HxOBTJDjmcDeMWZ02lWX4dXVLF0LwX14AVskEYOAAC4AiAIAAAAAAIACIWAu8AIIAGDDAhuegmBX1IxaQDQB7spt+hVnARB5msiVai3DNaF6La3XISAdgDBAIAYAcS5AYQAAAAAAAAACODAbhCCIvJ8IgyPcwn0EWCFbw5gbFN0aqMic1wIAAIoMNCkj9BlrX9RhqgcCCICtOAcACEilGgEAAAAAAABw4joiABCEuiBuBs8l4oEAIyXGu94lwdABMPpasyU3iACHBAbTui7d9nRTWVxHZQAEAETQAHAAFaoAAAAAAAAEKWFUAiQJCOB+P/cTvNwimORegeTcNZK1Z94AaOkAV2kzI0cIRxxYNdj7pNFk9Fjr6GZ6nKAAgCQoGgwBcClITomqAgAAAJAAiIEAZwYzCJ4IT7GsJRIZcE/mhKck3M49IPfsDDB0AecAM3B7BsBtZ6OMQingYda+7F5X6wqWGHgpkBiAwsxLEOCiBQAAAABVAgCBAIJQCQDluTDglljqcHKDgJx5DYoNoKNKAfad2TNzguPIK5xMvUZfLQZXaYS9jra7Hea4VW6IFCgAMLPflEMiBQkBAAAAEACBAACiBPGCpwT3nfudgEMMsd4lrEzYmWPGAERforhajZhLbgscJO8GixlQbdLAm2O1NaODedwpL14ISLwEEuQNOEoloBQAAABACgEcsJEAeycRyADe141FROK+zxnjnFvwfmdkX7rvAQJ0lHB4So1JnBtBIGJvZEY33aD1XhZ2d4xOOUYmAYALKEwBWpIaRQEAAACgZESSAKwXCqIViLjPfkq4wSISlsrMjLKevC9n7NhJ7BCALlJcschr9ktG8hQ8WRmRGpoRw1iVtthNFbFe5aa4XyS4wdmCsCcIp6jKlagAAAAAQKpMCg6B60WSxOuWgGAfyCLjvt9JeHdO3GZObu/v686c02SPjQgYjUKzuasmx5xnvCRjcp97xBi6u65u3ZSZbfUu11bVewkSAAaRRYLX9XZBQORAAQAAABDCJUDg7AugCCCBxPOWOHiHrLvG7d6viazFHjLPM2JmkyBtAZRF5tmz172WeL29wtNIzNbnOjR63nZNeVOzJnUezMXolYoSkecnnVI8PyCsM/FoxbGyr0vZLAAAAICji5RzHeBJ7/MG9gT38eH5CUG8I841ncf7o5+S4ymYo29m7mRH9/s8clCAhqJSkohK5H5P8oyxjuT5KjsK9Y1fM7/2V9eU/hV/cU1LQPbI/cRE8Mn7eSHxAq/pqLklyLnOkd2uAQAAAAxzGK6D8MTI8/Uih/BY6/kgibCW2TvnjHvdz7VkXkLsOZOZM47zuu/kvICB0VBNDWpOXic5Z0mS8X7PE9dMj435X+jf+id/leaYVrUOlDY8RWDeyTNR6onXo25yiqJxXY5pdQAAAMAMHNc5B+EJkPV6vojned9W3iG83/ccMhF3ct+zJ5kzktfsfe59J69dMVlzdkTDWDCF2h+S2t+Ef7NuF7xnxlfBP2D+Jv+w8au0v8zlL/pOahe+WuB7+34Q3v0M8H01nXplz08D//ahp5vMF4GfFIBPgY8A9heBH63LITx/GvghNwz/OfC99+uRus+65+eA3+uryji5vyrwr67no82d47+GvzvpJ6QEFh5VINz/0d/9Uz/1U5+s9+u2Pzyt1/3M776/7rNV+tudHvitt4r//VfKd35ZLRf+1eVx1arHfuA+1h8trrlEzavS44csmbdUXacZP9bTyrkAPgIA4sdAnR7w8kOjoIjgjxY3j9Q7a91nfn9m5zEt5Tr27btHFOe6kZPnPzv3c2JnbUmCOWnchaKo12S/zsl93znJa++cIzU9wXS+4df41b8SfgW/jM3QsY/kXu/3eT/WDvueoyA9aHvnjRxXObRRQwcAAJADCNMJgi6QBLyv+77D7V4r933K7Ir77Fdm7tm3HJF9kp1kn5z7nO2lhlAtoi08QPe5nIfsc1/n+eG+ntxzJvdrdm1Qrn+sHv+ki39mnf+jqyzm6mlp5ypLWDcs+yFgJD1WV5ScFAyXq6JIAQBMAVDicK8bCCrAXrfdc01XbqR2Xg7COcstRzyl1r3qEOeus0+cmFsAoou7KNPteL2e536+T973fd/P52vPeeWeM3Xh6qE4WHU0it0mct3jzJe/fN/rZ77M477v27vPfelLX6r89Jda7Nccn33GZ3zxi1zOKV/4QvjCp/j0U4D96fxpX9AA8dln/Kev/6wlSSE+/5zP379MLp3K/KyvfGXunzs/nySJ+K9yv76aX/BLc0TuM1/b55e+9ry/fv+3M5PahcoMnMviMQpSnboy3/Tbr6/77usX+Nf56u+ev/DP/9L/+td8K3eTaFgaC6m4SFHnIfVz/2/x5T/0lT+88dje+b7P5/Mf+NIPitoPP/LZj/nij33xT7gqX/hIvvAxX/j46UeffgS5EOY6xOut8iOf/X9iIsTzQ/7c998fLLcaTor79/0Xv2fDiB6ZX8xJ3LHH2uxf/h0TL1Ovk7lJVQ1ka3YnPBanZju+9d8c3/mFk3/5u/urv/u1218y/sE3V6vSjelYtr1VaWeoxi3xs1+x4eAhPuDz7wNI7vuzz34c4BwHn35aRQFAMf70T85FvLztuz777N8dP/2DUBIfvHz+M3378vdkzjlqIjPGn//XOUeY5Pziv8TXvhPnXFeu4+nrX79v/92385zaFsYI0C0Ud0axXnzzW7df/p13v3ievuaF8de/taky0Gl7Vb8tWatNq0R4Kb//B1+5iMZ9P96eoKCCij/+0RcLYl1tx8effAoAkHKBqCxmnn/87/7jC4Kq3O/xve/9ucVr9sQMR+bn/6+bk0iSwC/Z5PXa83q97pfjn/72X3mRmC2bQiA01wa9hDvb39kvv/31p995jX9u/CPlW6A0lo6FTe0tDwBmAzPg8bCX+/PvC6QQMY7AyVyrnQIARBE/+YIzySAVL9sPv0SC0Yvb7f/5WdeYmf3i+V/+m813f2nA2eP5L77j9jtfv7LlzkTc2/b3vvncMyEUAGt4FH3Zy1wlstvL+Lr/zcvLCNMkC/ai97rO6qLVdGGaxe/9vP97/cHP+YOKuj36AvX9z32/k05Z/4kftfrRZ37c06f7T/6Mj/n4qY8+fuojgHL0pDJ9yvizfsgInrHq9Pe+7A/BzvQYN/687xridel5yQuO19RtduL1j/6abx/HOGaTMqkjUJ/8T/9z/Ym//Ru1muqq1Y/rw+XqtmxjpobRF01b6V6OXtRy3lCUrlVaV65KqZmF4hNQQRXaA9VznSvlLEgBgCmkTk8YJwEGTyEe9+OWyBhDeSFMpJ64doozc/Gq2cyAjMy93Y4dSU34t/nbv+HfL8DVPRdkf9ie/eHurtltwmkDaJZmrytLQe2l0Di52rRziVIpqKcPzw9CVVi7L/bKJJdZuVIowLlAQxi8OtVbKoGsWzz27WZUAbkhTKipWXtztrfdvNc9zORKbyPuiWmbqURlkMpqwv+oUKhKl7qU61wOcB2X8VBQa7+pqEalKBaKXj0dDdBDP9AI0KZRVdPTGgCA0YbR02fa9ACK6bkfNwPwunhBMdiCYBCvt5eQGByQyhEyBAKINQoAREvlqN51AA4spMAipacJCqZbzIu3w9JgmgcIoGe6UVIdTKqNBpg+l2lU5OjRANDjcTMAr2b3FFF7GRBMKlhbgJ4DIo5IDQEVQo3V+DP/AwoAUAAAABQAoAAABQAoUAAlBZWCkgIAiEoFBAIIQABAAEAqAAABAEAAAALKQvmNlUV1qhRvykPTD22aNO2i9Upbk9WKNet+K3RNK/qiS13najzux+ZxvX+iUigeSevS03OpVNQ0AKmUwCEVzL02EfC+uDGpYypb7xBkiH3NFkZsI/aYgynjns5R87KvLWSIyRbRCKcpCuGOVabK8zljVNNV9NLTs/RC1rLyJnSmq6JS3YLLCffD4s4nBMWq+zp7i1GOHBWNAEoxhau57eera0dQnPe1N+w06bK6gmIGXjNW2Lbt5ezNDKbGfY/J7NddihDENkD9VKFQgKIpFF3TBRe6FGppFA2qUiya9LRF0UDzMIsAemjQ0alpPbNGYxrTpndFTx8VA1AY0/fjTmA4+sQUtt4EwRBehFScCcTUBCKBQBCE/x8RUYSGZ4cLTgAAAABJRU5ErkJggg==)}#webamp .equalizer-top{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARMAAAAOCAMAAAA7SAh7AAACBFBMVEUICBALFRINDRQOFQsPDxYQEBgRERoRERsREhsSEhsSEh0TEx4TFB0UEx4UFB8VFSEWFiIXFyQXGCQYFBIYGCUYGCYZGScaGScaGigbGyobHCscGyscHCscHCwdHS0dHS4dHi0dHi4eHS4eHi8fHyIfHzAfIDEgHzEgIDIhITQhITUhIjQiITQiITYiIjUjIzYjIzgjJDcjJDgkIzckIzgkJDckJDkkJSklJTklJTolJTwlJjsmJTsmJTwmJjsnJz0nJz4nKD4oJz4oKD8pKT8pKUApKkIqKUEqKUIqKkEqKkMrK0QrLEQsK0MsK0QsLEUtLUYtLUgtLkctLkguLUcuLUguLkcuLkgvL0ovL0svMiQwL0owMEsxMC0xMU0xMU4xMk0xMk4yMU0yMU4yMk8yMlAzM1AzM1IzNFE0M1E0NEs0NFE0NFM1LxI1NVQ1NVY1NlQ2NVM2NVQ2NlM2NlQ2NlU3N1Y3N1c3N1g3OFc3OFg4N1c4N1g4OFc4OFg4OFk4OFo5OFk5OVk5OVo6Plg+PldBQipCQl1EQTxISGRNTWZYWHJZVjxcXGRgX2pkW0RkZHFoaHhsbH5vb4JxcYZzc4hzc4p0c4p0dIt1dYx2kZ13Qyh3d4t4eIh4h4x7e4+Dg5WHd0yNjp2QkJCSkqKTk6OVlaaZmaidnamfn62pqbWvr7tT7jRLAAAFcklEQVQYGa3Bz49WdxnG4c/9fM+ZH7wglAGGgVZGQmKiAWuj3TQu1Gi0uujamPQPqOx0rSs37a7WvYk2ujCNCauauOmOmCaFdGGsMEwgIzD8ahyGd97zfW7PeWeo0KBSwnUp2BFsE1OiJwgBgsjCQBZiSlAAAQIJEAGWhOgJiiKDYCAQFCswBKggCAaFkm4zkgBML5gSQpAFg3iQZbAjMcJkkEwJqCWpUBkkBrqMRCS1VEwvlUBCJgZMw+v8F+KRgkcRjyA+TTxEPExsE9tkAbIQlhFYfJplmZ7BMlOW6ZmHmAeZh1kG3mjg58JhgeiJnkABAbIkegUkaBBBIECgIhc3KIgsLQ4oIAgaE1CSIkEDBUHJAgEqNQoEhV629KJJmq4FBAKKFQElQyCw2GEBFr2uqKNnqLFVKpYxGLYKMIEKVGNMVkioUbHcZWECNTJLTZyQDnCmDQiQ6AkUIIMlDChBEGyzEVCAcGMgKFEZZAKCFEmhNMJuKAUMaYgEdQTIrlBKS6+lS9SChATRoCZAFahgC5spsa1CSVNKFCActbHNlGhqnUygZlDBGCeZYCpgJBAYlZqYQTYMgkUen6lsm/A/HE9RyAIIMtUwKEyVQs/hEtQC7aRlZov7LCJUyOjaqIELBmfhE5ZM4Tc8sa+45btN13RnKvGdC2/C6eNniAYiQ4de289TdvOtE7T5Y37/yuh339x75pW5P/xg9qN2eeUDfliuvK/vsfHeS7v588klyEur0H51Hjbff/ZwTC6vf318/rnFD3LPcS5s+Evjf4j9iyvzi8DKMnCVRchLY1F/+9p+ntDNt57f+v4cDc0rf6TWU6fh1DlwA0nvAE/bAdpJLXf3vDjipYUbQIOOXgNOFu/DMDoxYrAy/uKhVSbAe00eOfLP1ZPH1knAjKzRXUMWerdu7V0a32N8EZ5hpTtx5GJGcIAndYDgPFNR+ekvT10/eO7Nb9sNCMG7fCaVxzCJkjf3HIb5mTED79oF2r01GR1bZWvmKJvzwBwYCPja1t/muaePFw8yUF34+HML14GwgDp72Fdg5gs378CzMCEs3uXxVR7WBduS3vWD18GoAdniBZ66sxS4eGzP3WbRfxW9cR4CFjbvjhYucePw/L8KvYXuxjq0Fa6agYEA/Exzb2521wZIHVCO6upY1LUEbhzMyxbmBZ7Y2WBHTGDt1PWja8g0gAXjJZ6yNaIWVu/N3YnFzQQE518UJ0vZw76Ajd3rixS4cqHQTmoBdGiTOfa688yBhawj7yuMNijzdMDcvDfnOyBmYXNzNLOFzHiJJ7QGvP0jer9+Ocobe8+xdur0h0kDBFx7h8/kBv/fiQwibi2N4U6dAcOV1WPs3vgL3xo9B+ujvy9SgQKTlt4ynJ09fJiN25c+v5yrMwvXrunLCzdpllkBltAyKzTLjG/DndGhy6BX3+Hx3eAhz9N94224ve/lmlnO/Qp+cvzDQPH6L0DIQvQECkCyJECgAAkVUBA4ZFFA0VCLggItDkCEIgjcQqpYosmmNqKnAkGvBRFWIQS0k7bCrAXo6NKl9ca1JRgosiCweIBlhFFXcEU1xrNd2QKMYWtmPNNpQs/UtAFnGhKnwbDVuDN0sssEnKSS+lFDb5NtshiIniAQsghkgQAxJVCAAIEECAhAEiBoMiAIegLRKxBgiKZrRNcEg0KvQABmEEkwkEyAjCV6FlOWZbs4ZcwgI+nJqshZS2Uqw0wMCQJnggHTSxLowGD8sz9BAOI+sUMIMIRRZCLAgBmIXuUTBjGQLQzYdAHBfTI9E2Aimq4R2QSDApRik+wIgilhkemEEANxnyyRGZIRg2RgIYVKqYVtWVMNOyT+I+m5A7Otkv8GlLRudA0dHtMAAAAASUVORK5CYII=)}#webamp .selected .equalizer-top{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARMAAAAOCAMAAAA7SAh7AAACAVBMVEUNDRQPDxYQEBgRERoRERsREhsSEhsSEh0TEx4TFB0UEx4UFB8VFSEWFiIXFyQXGCQYGCUYGCYZGScaGScaGigbGyobHCscGyscHCscHCwdHS0dHS4dHi0dHi4eHS4eHi8eHyUfHzAfIDEgHzEgIDIhITQhITUhIjQiITQiITYiIjUjIzYjIzgjJDcjJDgkIzckIzgkJDckJDkkJSklJTklJTolJTwlJjsmJTsmJTwmJjsnJz0nJz4nKD4oJz4oKD8pKT8pKUApKkIqKUEqKUIqKkEqKkMrK0QrLEQsK0MsK0QsLEUtLUYtLUgtLkctLkguLUcuLUguLkcuLkgvL0ovL0swL0owMEsxMU0xMU4xMk0xMk4yMU0yMU4yMk8yMlAzM1AzM1IzNFE0M1E0NFE0NFM1LxI1NVQ1NVY1NlQ2NVM2NVQ2NlQ2NlU3N1Y3N1c3N1g3OFc3OFg4N1c4N1g4OFc4OFg4OFk4OFo5OFk5OVE5OVk5OVo6Plg+PldBQipCQl1EQTxISGRNTWZYWHJZVjxcXGRgX2pkW0RkZHFoaHhsbH5vb4JxcYZzbFJzc4hzc4p0c4p0dIt1dYx3d4t7e4+Dg5WHd0yNjp2SkqKTk6OTk6WVlaadnamfn62pmGWpqbWvr7u6usTHx87JydLO4tHU1NnX193d5unsznr5/v/0rKtaAAAFXklEQVQYGbXBT4udZx3G8e/1u+9ncmYm/5OaYWImqYQQJcWKSKFUBHUlChaUbtz4FnwDpSjd+hpEI7pwJ3UhbhRBTFAQtCHGkknS1rSGmJM/MznPuX+XzzmTqZkSNQ3x8xHbxBYxJwaCECCILMzIQswJAhAgkAARYEmIgaAoMghmBIJiBYYAFQTBTKGku4wkADMI5oQQZMEgHmYZ7EiMMBkkcwJaSRo0ZhID04xEJK00zCCVQEImBox4nf9APFLwKOIRxIeJHcROwRaxRRYgC2EZgcWHWZYZGCwzZ5lBsoN5mNnJMvD9Ct8VDgvEQAwEEgTIkhgUkKAigkCAQEUuriiILB0OKCAIqgkoSZGgQkEQDhCotCgQFAZZGURNSquAQECxIqBkBAgsHrAAi0Ff1TMwtJiUhmUMhr4APSTQjDHZwJBKLE+z0EOLzNISJ6QDnGkDAiQGAglksIQBJQiCLTYCChCuBoISjZlMQJAiKZQq7EopYLBBBk0JkN0gojLomCaqICFBVFQD1IAp2MJmTmyZQm2m1qhAOFq1zZyorfU9ZIoGxjixwSRgJBAYlZaYmazMBB/j8ZnGlp7/4hMpClkAQaYqM8FcKQwcLiIDur6j69lmEaFCxrSLFmTF4Fb5gCVT+RFP7NPueJnBTxvxxbYOx8sviAqRoWdeXeIpu/faSbr8Nj98ZfSDry7/7Ju7zn5914XRicvneTn+8Wt9jc1ffmmRN148AHlpHboXF2Dy208ejPa3916anDuz7/e5/xQXx/7M5M/Bs3uv7N8LXD0GjNkLeWUspj95dYkndO+15yffqAxe+TGtrZZWjrwDrpAMlnnalun6VjaXXhjxhb1joMKJvwPPBbsxjE4tMrN+91Nr6/TAr2oePXzrTy+cfI8ZswIrtw0ZgC7z8YOTm8cmF+AEV++eXh23UljmSS0TvMtcNNbLkc3R9XXsCkLwJh9J8hj6KHljaQ0O1TFzo8Og1daPTv2VVp5lsgDsW8RAwOcnfzzCP7Wxbw0Qast3di8ziAxgunSQy7Bw+s41WIUJxeJNHl+y0zRaYdASaJuHbjSMKsgWa/wfFLhxbOl+2cPvxOC+dwNL9xsrFxkfWNgoDPa0O1ega/DufUBs8+GSk4U9Ywj14HqC8YZo1zeAu7vzLQuzxpMLaAUa0UMZ3RgVZCpgwc2jPGVvE63whzP1brdnMwHBpTPwXESwO2Bj8fZ+Cly7EHR9K8Cutev79rHIHRZOLWdbYVRYGVMOcA/YP+LWgXvA4gLc6hZHm8jcPMoTehuY1gZsEuX4keutHGkXkgoEvH+Wj+QG/9vJDCLGB8fsudcWwPCXA0dZ3XyDr4xOwu3F81+mAQF9x+A4/ObgwZfYuPn+oWfy2sLy+KI+u9xR1rgCrMAxrlKOMdmEO4urb4G+dZbHd4Mdnmd67nMMzrfM8s46tEIgXv8eCFmIgUACJEsCBAqQUAEFgUMWBRSVVhQU6HAAIhRB4A5SxRI1a6tioAAx6ECEVZCAru8aLFiATh++crW6dQQziqwILB5iGWHUV7KhFvd3TcsEMIa+m3RNPQOTaQPONBjbYJhUTw1T2aUHJ6mkXaoMNtgiixkxEARCFoEsECDmBBIIEEiAgAAkAYKaAUEwEIhBgQBD1GkV0xrMFAYFAjDngEiCGckEyFhiYDFnWbaLU8bMZCQDWQ05W2nMZZjekCBwJhgwgySBKRiMv/NzCEBsEw8IAYYwikwEGDAzYpB8wCBmZAsDNtOAYJvMwASYiDqtImswU4BSbJIHgmBOWGQ6IcSM2CZLZIZkxEwyYyGFSmmFLdlSlQck/i0ZeApmSyP/BQLQYu4DqTgYAAAAAElFTkSuQmCC)}#webamp .band{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANEAAACBCAMAAABpaq8qAAABEVBMVEUAxv8SEh0SWwQTEx4XFyQaGigcGysdMBwfIDEhITQqKUIqKkEqmhYsK0MuLUcuLkgvL0ovL0svMiQwMEsxMC0xMU0xMU4yMU4yMk8yMlAzM1AzNFE0M1E0NFE0NFM1NVQ1NlQ2IRs2NVM2NlQ2NlU3N1Y3N1c3N1g4N1g4OFg4OFk5OFk5OVk9dCpCQl1EQTxNTWZYWHJZVjxasCxlmUVoaHhrcC1xzTR3QyiDg5WHd0yJ4jCNjp2QkJCQxz2SkqKTk6OTk6WWrI+ZmaidpDWfn62k4jipmGWrrZCtLSOvk4yvwziwcR3DcCrE2zLFVCrFhzDGeA/GszXOxtbTIhvTSR/cdx/gVB7gkijgsijgzTBk+3VYAAADm0lEQVR42u3bX09bNxjH8a8fP/lTombrhEC01TSkSuNik/Ym9q73XnKxqVs6VnUbNIFzbPcikNiIk4ZCIY4eXyB98OGIn+JjB4Wf+0aZN0l1KL5p4q+/VU91wqW0YXR0qsEnnHApPyJpUz5/dRe+4eJrU70nBjgaeG2jw3viyYTjYUaIOfs4t+KrtXwTSo75cBd+bO5OFSH+NAHtBfEREeIEJj+v2KeY7UPqZVTabjoFWXF4yV7TyfGAb88L8gVU8TCByS+hl5wgHgB8N5U2o4Lm1OLiQcDH7GeHzH0nB57B/N4U59zid+459Y7PU0E3vvgJqKpcDRdEqJ8iIVwJxVE/ld51QInaUj9l9Yo5glA/ZRlv+aVySlh+A6dQPxV3lfJqH6+esnyqHJDtE9VScRSjekoxFaifslOvz+qRupajfkqRTqmf4rxfPlIO6me5M+zC2MFEu3Yc2aqzRJbIElkiS2SJLJElskSWyBJZIktUT6JUun7u9KqL5UytFGIswlVPTalYjvVTs+crpET9LHaG1FI/7YTd/qHF+eSpn7JchiFBS/3UlJbHVFrshJXz+l8CiZAaqJ/Slu/56qcsT9wU8In6qeH6E7LkUhupn5r84kxypJZI/ZTUtg7AN8kHqJ8SQ9BjOBFPmwK38BJcxgCDjfkR2JgX0N6fGhMix4Nns1ZjhJgQOWGc0xVs2NNuxou1nLN31sn3eDe7NzW2DKZHvXYW274/Y8HhbB2bpptvP8Phv2uYhtyfGgQNfwBeIFA/Nfv7opXEDnDnhtvNRtUDNpteHzJ7Wuo9uksLHvA+4+H+3XgaunnINOcL2IQqQnwN4z+zdtK4LCut5UvhYLrivvLdP910JWG/nM15CIfvMvbpZ3wxgg+3UW9pNo2HMN+UDJjljaryVjfonhUX06NZM3ujfsW6ntcIRv9/YaPqBgXkcTpTIjlHMLJGlTWqrFH1lWiNqu2nNaq2n9ao2n5ao2r7aY0qa1TZJ8sPkMgaVbbqLJElskSWyBJZIktkiSyRJbJElsgSPVUia1TVtOqsUYU1qh6H1qjaftoJu/3DGlXbT2tUbT+tUWWNqsenNaq2hg5cd6PqPzjP2kl34l8l38GsmwkuM55C0z07LZtclzHGjGflxefLW+mijjQo2kmezTn/u2g2zeczf97J30fPc86mB8Xs976YnceQ3fntDyVf9ptbqQ9XZdqA06NUclpQhg9Aa1RtPz8But0Pz3B64+AAAAAASUVORK5CYII=)}#webamp .band .slider-handle{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAALBAMAAABbgmoVAAAAGFBMVEUAAAAICBApKUJKWmt7hJSLm6etvcbd5ukLNggsAAAAMElEQVQI12NQZGBgYFRgEC8vLy8WYBBPS0tzRqIExXDyQlxcQJQxEAgwAE1hFFQAAB9KDSykox1vAAAAAElFTkSuQmCC)}#webamp .band:active .slider-handle{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAALBAMAAABbgmoVAAAAD1BMVEUAAAApKUJKWmvd5un5/v8UiEZ+AAAAJ0lEQVQI12MQYAACAQZmY2NjIwYGZiCHCYlyccDNg1BKQAAyAGQKAHJPAsUS1KniAAAAAElFTkSuQmCC)}#webamp #on{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAMBAMAAACO67B7AAAAIVBMVEUAAAASWwQvN01KWmtSZnN7hJSLm6ettca9ztbV3vL5/v8M+RL1AAAATklEQVQI12MoRwIJDFWr4GC5A0NVBxyUGjBUNRsbdzRpNHVoQHiCkh0aTU0aKDwlKG/mTBCvCcID6UfoQzUTYTmQV54aCgcGDCnGCGAAAPUyQLvRdOj2AAAAAElFTkSuQmCC)}#webamp #on:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAMBAMAAACO67B7AAAAFVBMVEUICBASWwRSZnNje4R7jJyLm6etvcYvdU+XAAAAQElEQVQI12NgwAdMXODAgYHBLQ0OEoA8VDkgdnFgcXBhgfAERV1YHBxYUHgMUF5oKIjnAOGB9cP0maGYqYDkEgAFZxmn+1/+wgAAAABJRU5ErkJggg==)}#webamp #on.selected{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAMBAMAAACO67B7AAAAIVBMVEUAAAAA1gAvN01KWmtSZnN7hJSLm6ettca9ztbV3vL5/v911B9qAAAATklEQVQI12MoRwIJDFWr4GC5A0NVBxyUGjBUNRsbdzRpNHVoQHiCkh0aTU0aKDwlKG/mTBCvCcID6UfoQzUTYTmQV54aCgcGDCnGCGAAAPUyQLvRdOj2AAAAAElFTkSuQmCC)}#webamp #on.selected:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAMBAMAAACO67B7AAAAFVBMVEUA1gAICBBSZnNje4R7jJyLm6etvcapTzEQAAAARElEQVQI12MQRAYMaDwTFzhwZBB0S4ODRCAPVc5RUNDFUcTRRQTCY2B1EXF0FEHhCUJ5oaEgniOEB9YP02eGYqYiklsAdNMdgDKFw2kAAAAASUVORK5CYII=)}#webamp #auto{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAMBAMAAADxOqKKAAAAHlBMVEUSWwQvN01KWmtSZnN7hJSLm6ettca9ztbV3vL5/v/WADVeAAAAV0lEQVQI12NIQwWpDJkzUUAyQ2Y5MihzYsgsUlIqLxQvLBcXFC8UBwswcJSLFwIFQAgmICiILNDRgaoCZBaQI1heWA4xA8MWVIc5MaSFuCADJ4ZgJVQAABsNRRhxaDvQAAAAAElFTkSuQmCC)}#webamp #auto:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAMBAMAAADxOqKKAAAAFVBMVEUICBASWwRSZnNje4R7jJyLm6etvcYvdU+XAAAAS0lEQVQI14WOsQ2AQBDDAh8GYKMUHgF6ihP7j0CFxF+DS8tSIv0ymIh8T1xy9aIkI5wIEbmW/Qh2cPAr9BXb2QogOMaIaPSVtR19ACp1H3+cU6+ZAAAAAElFTkSuQmCC)}#webamp #auto.selected{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAMBAMAAADxOqKKAAAAHlBMVEUA1gAvN01KWmtSZnN7hJSLm6ettca9ztbV3vL5/v+vLTjBAAAAV0lEQVQI12NIQwWpDJkzUUAyQ2Y5MihzYsgsUlIqLxQvLBcXFC8UBwswcJSLFwIFQAgmICiILNDRgaoCZBaQI1heWA4xA8MWVIc5MaSFuCADJ4ZgJVQAABsNRRhxaDvQAAAAAElFTkSuQmCC)}#webamp #auto.selected:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAMBAMAAADxOqKKAAAAFVBMVEUA1gAICBBSZnNje4R7jJyLm6etvcapTzEQAAAATElEQVQI12WOwQmAQBADtwSjsaDAlKAFCIf9l+BL8NZ5DgNJqVE/sTGR8j1xlUcvhmSEEyFSHksdwQ4OfoW+Yj9bAQTHGJHa+sranj59DSTnUdDwigAAAABJRU5ErkJggg==)}#webamp #eqGraph{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHEAAAATCAMAAACQnBKzAAAAw1BMVEUqKUEqKUIqKkMrK0QrLEQsK0MsK0QsLEUtLUYtLUgtLkctLkguLUcuLUguLkcuLkgvL0ovL0swL0owMEsxMU0xMU4xMk0xMk4yMU0yMU4yMk0yMk8yMlAzM1AzM1IzNFE0M1E0NFE0NFM1NVQ1NVY1NlM1NlQ2NVM2NVQ2NlQ2NlU3N1Y3N1c3N1g3OFc3OFg4N1c4N1g4OFc4OFg4OFk4OFo5OFk5OVk5OVpsbH5vb4JxcYZzc4hzc4p0c4p0dIt1dYwbWqB2AAAC2klEQVQYGQXBIQ9lSRkFwDpf930zCQqBxaLQ/H+PRuDXrCQkbObd7kNVzD/+qSay+fu/BDL87d/MMtL5628iiP2X31cQ5M//6cp3nrJ//u+upgM//2gAfv7BO6aOP/33ndQx4HVJMQGeXnSgB0/V/lWicJvObrKOrDNJCwJQ1XVzz1F3DxYTsaHBBbx7MIhsfDNHfwSNlE8vuCO8V7QAEJGzTnSlYxL3nojNJkVC+NRLGtoC8wjSIOl9Z2NJ3syeugkAwLvjyFtMl6FaGhoGyK/HZ1SX20D2CzQN+nn3vK8eOoaxAFC0vKxplMlx14qEucCdC10XJquy4/Ho/gKmbO/Mu5/sGQZcAAhN7tr1Jk3cWcu6EM4rGCbBXNdwouX72M0DgXizjh19T6S9twBASU1a+632nn2wiPIgCLDfTViHDV52oFHo+4Oy35M6Ww0KEBXlOilu9uKs6AMCHYH3McpZdQe29gshzE17tlSWZLkDAkCKhnV4wxwW8t4ZCqUAZC8xeL5yLihY6Xx3NGfclqEAgLg30dPcW3dcNzBCigBAigvI95kPSMp36Udti+be6kkBoK0knVTXJzKLwnYgzBAea8Y0hwGery9I2vjkheSMe5iJjABwG5G0Rm6v27ksCXNfEMDXoLHSAq/nM0grfDs+r46LIUgLwKRoj1wd5TOzSG2ZLUgFmCu1dALPd7sFSVDXO3L1rDWARAElTmXuEe5qf8290uDdUqZDyHJnJAfwePrc7wtVsz+SPdou5xwKCCDK0pNFuehkkaI0dC7YXDe6kzP4ft/j+bGJ4J5fH4WIZSnXBYBGxDrvgt2MPRW2hhB30nDHIHTw4OXXD9BBn3yCNF3W62aNAYA7Dtfc4867j2sOxBkCiWIGUsrw5bXyA9FRJj0SzVJZ9qK3ANqRvWql7crWMitq27OBlNAro0E6+OKeF6Sy7XOPNhk3CmQCIORWVk/inPcO/g8Gk8tpHAw47gAAAABJRU5ErkJggg==)}#webamp #presets{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAMBAMAAADrBkIEAAAAGFBMVEUvN01KWmtSZnN7hJSLm6ettca9ztb5/v8/TtPPAAAAXUlEQVQY022PsQ2AQAwDXblnlBcbwAYI9K0bbgXWpwAEErnSuii2topV/ShY1PmzN3UiZOQIWY7uGDsBEwj+2pHjyCF+bJwACdfBGyNfD9Bt102qOU3bPP5pmoaKE9BgTHfswQ68AAAAAElFTkSuQmCC)}#webamp #presets:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAMBAMAAADrBkIEAAAAElBMVEUAAAAICBBSZnNje4R7jJytvcYlh7IyAAAAW0lEQVQY03WPsQ2AMAwEv/gFMgI7QP+RLgNQsP8qFAGBlOTK01m2VaZopXdGqkq7Rk6VtqiJkJEjZDl6NHYCJhD8ryPHkUP81jgBEvrAp5H7AmSqyjG/ZJt9eQMWOi9EkrQa+gAAAABJRU5ErkJggg==)}#webamp #preamp-line{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHEAAAABCAYAAADpXEERAAAAE0lEQVQoU2Pcdfruf4ZRMKRDAAD1lwNjTqcaUQAAAABJRU5ErkJggg==)}#webamp #equalizer-window.shade{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARMAAAAOCAMAAAA7SAh7AAAChVBMVEULFRIMDAwNDRQNDhQODRQODhUPDxYPDxgPEBgQDxgQEBgRERsREhsSERsSEhwTEx0TEx4TFB0TFB4UEx0UEx4UFB0UFB8VFSAVFSIVFiEVFiIWFSAWFiEWFiIXFyMXFyQXGCQYFyUYGCUZGCYZGSgZGicaGSgaGicaGigbGyobHCscGyscHCsdHS0dHS4dHi0dHi4eEQoeHS8eHi8fHyIfHzAfHzIfIDEfIDIgHzEgHzIgIDEgIDMhITQhIjQiITQiIjUiIyYjIzYjIzgjJDcjJDgkIzckIzgkJDckJDklJTolJjsmJTsmJjsmJj0nJz4nKD0nKD4oJz0oJz4oKD8pKUApKUIpKkEpKkIqKUEqKUIqKkEqKkMrK0QrLEQsK0QsLEUtLUctLUgtLkctLkguLUcuLUguLkcuLkkvJwgvL0ovMEsvMSUwL0swL0wwMEsxKQgxMC0xMUwxMU4xMk0xMk4yMU0yMU4yMk8zM1AzNFEzNFI0M1E0M1I0NFE0NFI1NVM1NVQ1NlQ2NVU2Nhg2NlU3KxA3N1Y3N1g3OFc3OFg4N1c4N1g4OFc4OFk5OVpGQh9JRjlORDBQPx5aWmFbW2JbXGNcW2NcXGNcXWVdVztdXWddXmZeXWVeXWZeXmdeXmhgX2phYGphYWxiWkViYm5jY29jY3BkZHFlZXJlZnRmZXRmZnNmZnVoZ3VoaHdoaHhpaXlpanlpanpqaXpqanlqanprXUFra3xrbH1sa3xsbH1sbH9tbYBtbn9ubYBuboFvb4NvcINwTyxwb4Nwb4RwcINxcIRxcYZxcodycYdycodyk5lzc4lzc4pzdIp0c4p0dIt1dYyCmI+Gd02QkJCZc0K7v3F3AAAEz0lEQVQYGQXBsesvVBkH4OfznvO9FdGfULQGEvfiLHdwb2ksWiKizbmQSIlWqSECXYOGwD9ABxGiRbpra85OQpi/c96350lBEgiBBQIqCI/zDGTKAygWglCFKCYhEHaqy+ZuVKhJoMgSCkS1NRlBALYTpTgPQwDAZOjex3LNPgAGXaMZ0AanqzG62jQ9ddDcOgO2PxIK6ULYpGcLCGQKKAQhYgKlEEEQqYKiuhIgSiDwMFgANaoAEJIJMhGTESYAACaTgaGrMUBXMxqYJp5gYDSD4YKG8+vN25X76BIiS02ipkRm35XAIniGsuuWEirWbCmZLNnHgxDPRhEqgZ0qljJ7u+vWIhbMJlJj3YViYyaFIiZMAAAwMtBM9cTZR4MzGHq4kzE6vhKnrtbdY+hMZ9ocRtH3pAF7yWCmQLpikAYFOEuJQs0eRNLY+xyEjha1YsZ+hG4u+xyhwGWtDfSwqLI3TQrVzAQBADAAoKbj9AFaJSZul8sY075i2tW4IYzJtAG9Qfk+AAAAAADGk8s3+Y8IRBVBEYJMdihst9hdoQQKu6umgGCNqZgAvPMRvf0jdMF5ADBxK542x+62nN99xN8BAAAAADyfx9Mr+GHzk8/e5t3XP1CbfXd9763nAAAAAAAAr977lnyv+tnZd6uQNdlnJ4RdY1FBqFqqi1XLdm0irK7ZQlTLorpspBvV7stgBACACYOu1pHJ3956DgAAAAB49d6L8+rlT/GL18znL9+tfvkpU1x4kSRJkiRJkiRJkiRJkiRJkiRJkhdq0c6+uyqoCbuN2LumjAKYtC6AszQyMJsZdGWhy8YdhbKYmUkAAIwAqqnUDC+SJEmSJEmSJEmSJEmSJEleqHkJXhq//NfL77z89DdmNg/hfQAAAAAAeAI0alvpmtQILjGh0xUT8OzrDawy2FedB+E+u5CYNQuFY5MLKIIJAEAwoMFM8T4AAAAAnoDDz/8H0K+ev/rcyGbS5XUAAAAAAAD+OYGzb6qXroAN9GwhE8FDUegC63qA5S4yTGYBXbau2QOmY0QmAMCEEUN1d9UpvA4AAAAA4J/VfIMPaP77xqs3v5SxK27xxZsAAAAAAAAfC9j3MQoZ2dbZgiw1MWHi6x2KR5uNG72E1TVdJIOzu/DsbGbsUAAIEwAEGaOVKpZuX7wJAAAAAPjY8cnP4ZPXyl9+8OnnX77x+8+O3aP4/MMPAQAAAADwJfh2rz9g6ZQIBNm9oLrILEEmSSCQEkUAFihAJDM1FJV3CAAAEzBgJpOOqh9/+CEAAAAAX4IXx/OfwWvTvvvXP/OrH322pf70W9aEnSBYIlQFIUXIA2XrVb0Uqe2ulLDE5trJVqZCahJq3ypFttk2ITJZKgihCorNJECBAAAAGOhqk16No2m9bxuMMwbTvc7+Ku1q+uwnw81MLnNM2vy7CjVwzx1IgmEMIREoFGyWSDh2iLWwj9gJZmQgGXqqCqvahiuE1foSTFVD2eimNQUJBgCAmQG0m+5znKNR8nQNxpklZmRdx/SF5gnUjOEeoyErIQhkKgioSULV2CDJPKAmMpUglBKotAqQHYrtshUhCZR9dnQVCMqIENgHG5dqSgkAMDGZU71n4i4cwBgZPRnQOl1HA9NM6zrLoY1jYMyk/w9e+WXwreroJgAAAABJRU5ErkJggg==)}#webamp #equalizer-window.shade.selected{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARMAAAAOCAMAAAA7SAh7AAACdlBMVEUAAAAAAAgNDRQNDhQODRQODhUPDxYPDxgQEBgRERsSERsSEhwTEx0TEx4TFB0TFB4UEx0UEx4UFB0UFB8VFSAVFSIVFiEVFiIWFSAWFiEWFiIXFyMXFyQXGCQYFyUYGCUZGCYZGSgZGicaGSgaGicaGigbGyobHCscGyscHCsdHS0dHS4dHi0dHi4eHS8eHi8eHyUfHzAfHzIfIDEfIDIgHzEgHzIgIDEgIDMhITQhIjQiITQiIjUjIzYjIzgjJDcjJDgkIzckIzgkJDckJDklJTolJiwlJjsmJTsmJjsmJj0nJz4nKD0nKD4oJz0oJz4oKD8pKUApKUIpKkEpKkIqKUEqKUIqKkEqKkMrK0QrLEQsK0QsLEUtLUctLUgtLkctLkguLUcuLUguLkcuLkkvL0ovMEswL0swL0wwMEsxMUwxMU4xMk0xMk4yMU0yMU4yMk8zM1AzNFEzNFI0M1E0M1I0NFE0NFI1NVM1NVQ1NlQ2NVU2Nhg2NlU3N1Y3N1g3OFc3OFg4N1c4N1g4OFc4OFk5OVo/QitCQTtKQT5SSj1aWmFbW2JbXGNcW2NcXGNcXWVdVztdXWddXmZeXWVeXWZeXmdeXmhgX2phYGphYWxiYm5jY29jY3BkZHFlZXJlZnRmZXRmZnNmZnVoZ3VoaHdoaHhpaXlpanlpanpqaXpqanlqanprXUFra3xrbH1sa3xsbH1sbH9tbYBtbn9ubYBuboFvb4NvcINwb4Nwb4RwcINxcIRxcYZxcodycYdycodyk5lzbFJzc4lzc4pzdIp0c4p0dIt1dYyCmI+Zc0KjlGqqurGxnVm2nF7O4s/sznr///8TArHKAAAEcUlEQVQYGd3BMc9m6xgG0HXdz/N+yEl0ujlx9AoqiehEq/MT/AoKgoK/oFRpFBqF6HQaEZXqJL7KdBIRM3vft/1+MxzORMxEZ62USxKXEJe4i7sE4XY8uMuUmyfFQhCqEMUkxCWsVJfNuVGhJnEJWUK5i3XakxHEa9sRpThuhvhXk6F7H5bT7MM/DLrGybhrg2MyGF1tmp460HTOcbf9kFBIF8ImPVvcxSVTngRBiJi4lEIEQaTKpaiuxJMocYnLNlheq1HLR0IyQSZiMsLEx00m4zJ0NcaTc52M9mSaOFzGZTSD4XTXLsd3N9+rnLcuIbLUJGpKZPa5EpdFcEPZdZYSKmq2lEy27MONEA+jCJW47FQoZWo711mLWC6zidRY50LYmEmhiAkTbxoZl2aqJ459GHfHYOjhnIzR8UKcaaO7x9CZzrQ5GEWfR9ore8lgptylKwZpd+WVYylRyOxBpBp7HwdCR4taMWPfwgxN9SGUu5O1tic9LBJ706RQzUwQHzf+VU3HMYcnrRITZ5eTMaa9YFobnCGMybRx19td+ay3N146+SR/FHGJKoIiBJmsUNjOYneFEpdgd9WUJ8EeUzHx2rd/RW+/CV0ux80/TZwVLzeH3W05vvUrfu5tfWFuLz/v8rvmG4/P+cyzn6jNPne9/+Obd/Tym5+S9zO3Y59bhVqTfeyEsGssKghVSyZUxXbaRFhds4WolkUmNtKNaueXgxFvmDDoah2Z/OzHN2/n5Te/eHw+X3rPX/zWPH7lw8dnH/ya2ZwuD97Vgwrj2OcuQU3YvSax1VRPymuTronXjn12kQlmM0LXLExsnEuhejGIN0zilWpKZuLBW3pQR7zHezGef/jB++vD52Y2N+EX3sF4pZFtpWuyRnASEzpdMXH38GJ7UmXCPtVxI5wPp0ti1iwEh01OrxTBxMcE467dzRS/8N+NJwdfO732+P4n/vZoZDPp8lXv7KcTl2OfqV7OFXfbk54tZCK4KYIud+t0c7eciwyTWZ5MbF2zx910jMjEv5kwYqjurjoKX/W2flrN4pc0z9bf9rPnGbviLP76ae/oz+Jun7dRyMi2ji3IUhMTJl7sEHabwhm9hNU1XSSDY3fhdmxm7FA+EiY+EmSMVqpYuv31097Onx3mxYMXRvnMBx8+Pvvc4xx2j+Lx+97Bn9y91+s7WDol4hJk93KpLjJLkMnFJS6JKOK15W55JZKZGorKt4k3TNyNu5lMOqq+/n3/3Z/cffHwe3e/nfbs1889f3xmS/3oB6wJO0GwRKgKQoqQjbL1ql6KZDtXSthic9rJVqZCahJqn1VClimbEJksFYRQ5RI2k3hS7uI/GZeuNunVOAyt99kG4xiD6V7HfpHWhj72S8OZmZzMYdLmD1WocTmPc1ySYBhDSMSlUC6bJRIOO8Te2IfYCWZkXJKhpyqotHI5hbBanwRT1S6x0U1ryiXBeMPMeKWd6T4Ox2FQ8vI0GMcsMSPrdJhpl+alu5oxnIfRLvG/iv8b4y5/B72CM+yl6NhDAAAAAElFTkSuQmCC)}#webamp #equalizer-volume.left::-webkit-slider-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAgMAAACw1x86AAAADFBMVEU5QE1jXjujlGrsznokh70QAAAAE0lEQVQI12PYwPCF4QcYfmHYAAArXgYxq2vCDQAAAABJRU5ErkJggg==)}#webamp #equalizer-volume.left::-moz-range-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAgMAAACw1x86AAAADFBMVEU5QE1jXjujlGrsznokh70QAAAAE0lEQVQI12PYwPCF4QcYfmHYAAArXgYxq2vCDQAAAABJRU5ErkJggg==)}#webamp #equalizer-volume.center::-webkit-slider-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAQMAAAD3d2XqAAAABlBMVEWjlGrsznoPowceAAAADklEQVQI12NwYHgAhw4AIi4E4a+iLsYAAAAASUVORK5CYII=)}#webamp #equalizer-volume.center::-moz-range-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAQMAAAD3d2XqAAAABlBMVEWjlGrsznoPowceAAAADklEQVQI12NwYHgAhw4AIi4E4a+iLsYAAAAASUVORK5CYII=)}#webamp #equalizer-volume.right::-webkit-slider-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAgMAAACw1x86AAAADFBMVEU5QE1jXjujlGrsznokh70QAAAAEklEQVQI12OwYKhh2AOGNQwWABlSA52dOQTnAAAAAElFTkSuQmCC)}#webamp #equalizer-volume.right::-moz-range-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAgMAAACw1x86AAAADFBMVEU5QE1jXjujlGrsznokh70QAAAAEklEQVQI12OwYKhh2AOGNQwWABlSA52dOQTnAAAAAElFTkSuQmCC)}#webamp #equalizer-balance.left::-webkit-slider-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAgMAAACw1x86AAAADFBMVEU5QE1jXjujlGrsznokh70QAAAAE0lEQVQI12PYwPCF4QcYfmHYAAArXgYxq2vCDQAAAABJRU5ErkJggg==)}#webamp #equalizer-balance.left::-moz-range-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAgMAAACw1x86AAAADFBMVEU5QE1jXjujlGrsznokh70QAAAAE0lEQVQI12PYwPCF4QcYfmHYAAArXgYxq2vCDQAAAABJRU5ErkJggg==)}#webamp #equalizer-balance.center::-webkit-slider-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAQMAAAD3d2XqAAAABlBMVEWjlGrsznoPowceAAAADklEQVQI12NwYHgAhw4AIi4E4a+iLsYAAAAASUVORK5CYII=)}#webamp #equalizer-balance.center::-moz-range-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAQMAAAD3d2XqAAAABlBMVEWjlGrsznoPowceAAAADklEQVQI12NwYHgAhw4AIi4E4a+iLsYAAAAASUVORK5CYII=)}#webamp #equalizer-balance.right::-webkit-slider-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAgMAAACw1x86AAAADFBMVEU5QE1jXjujlGrsznokh70QAAAAEklEQVQI12OwYKhh2AOGNQwWABlSA52dOQTnAAAAAElFTkSuQmCC)}#webamp #equalizer-balance.right::-moz-range-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAgMAAACw1x86AAAADFBMVEU5QE1jXjujlGrsznokh70QAAAAEklEQVQI12OwYKhh2AOGNQwWABlSA52dOQTnAAAAAElFTkSuQmCC)}#webamp #equalizer-shade:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAD1BMVEVKQT5SSj1sXUO0kWO/uX6z+JYEAAAAM0lEQVQIHQXBwRGAIAwAsLT07Z2zsP8qbuDBAliTmDjl1m8Gob6HK5uWti27V6uxDDFxfn1PDx8P0VYSAAAAAElFTkSuQmCC)}#webamp #equalizer-window.shade #equalizer-shade:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAD1BMVEVKQT5SSj20kWO/uX7CsWHebnl7AAAALUlEQVQI12NQAgIFBiUGBiYFBgVhYwMFBkVhY0Mg6QwmXVwEgeIuLgIwNWD1AJzCBeFqt4OOAAAAAElFTkSuQmCC)}#webamp #equalizer-window.selected #eq-buttons.clicked #equalizer-close{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAFVBMVEUpKUI1LxJZVjxkW0SHd0ypmGX5/v9OYEDlAAAAJ0lEQVQI12NgAANmRUFlBgamYOUgBgZGU1dDIKmSoghjQ8QhasAAAHO7BEc0qEt/AAAAAElFTkSuQmCC)}#webamp #equalizer-window.selected #eq-buttons.clicked #equalizer-close:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAElBMVEUxMC1ZVjxkW0SHd0ypmGX5/v/v3/6CAAAAKUlEQVQI12NwAQIHBicBBiEHBkcmIUYHBgcFAwUgKRwsAGNDxCFqwOoB1gEH67W94+0AAAAASUVORK5CYII=)}#webamp #equalizer-window.shade.selected #eq-buttons.clicked #equalizer-close{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAALVBMVEUoJz4oKD8pKUAqKUEqKUIqKkMrK0Q6MSljXjtsXUORbkq0h2O0kWPCsWH///8vo79mAAAAO0lEQVQI12NIdTFWUmDIbC/vFGCI2Nl5QoAhfM6a6UCy61U7A4P7nLVAdsTJzhsMDJ5ANQwMLkaKCgwA6D4RaTQt0CAAAAAASUVORK5CYII=)}#webamp #equalizer-window.shade.selected #eq-buttons.clicked #equalizer-close:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAElBMVEU6MSljXjtsXUORbkq0kWP////9IyyfAAAAKUlEQVQI12NwAQIHBicBBiEHBkcmIUYHBgcFAwUgKRwsAGNDxCFqwOoB1gEH67W94+0AAAAASUVORK5CYII=)}#webamp #position{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPgAAAAKCAMAAACuVWMrAAAByFBMVEUPDxgPEBkQDxgQEBkRERoREhsSERsSEhsTEx0TEx4TFB4UEx8UFB8VFSEVFSIVFiEVFiIWFSEWFiIXFyMXFyQXGCUYFyUYGCUZGSYZGSgZGicZGigaGSYaGSgaGicaGikbGyobGywbHCsbHCwcGyscGywcHCsdHSwdHS4dHi0dHi4eHS0eHS4eHi0eHi8fHzAfHzEfHzIfIDEfIDIgHzEgHzIgIDEgIDMhITQhIjUiITUiIjUiIzYjIzcjJDgkIzckIzgkJDckJTklJTolJTwlJjslJjwmJTsmJTwmJjwnJz0nJz4nKD4oJz4oKD8pKUApKUIpKkEpKkIqKUEqKUIqKkErK0IrK0QrK0YrLEUrLEYsK0UsK0YsLEUtLUctLUgtLkctLkguLUcuLUguLkcuLkkvL0ovMEswL0swL0wwMEswMEwxMUwxMU1hYm1iYW1jY29jY3BjZHFkY3FlZHFlZXNmZXRmZnNnZnVnZ3ZoZ3VoaHVoaHdpaXhpaXppanlpanpqanlqanpra3xrbHxsbH1sbH9tbYBuboBvboFvb4NvcINwcINwcYVxcYZxcoZycYdycodzc4hzc4pzdIp0c4p0dIt1dYwExkcuAAACuklEQVQYGQXBAWEANxADMPmSFsOAjT+QNX+eFEYgZicIBCMQMBlphNGBIJgZQLjId3bmPtcHfncAkIZoAAAAAECBAuy7Hsfb2dnuwEPB7qKawjer1OYBhR0jAFMAFQIAQRJsAjSBnQUJF74aHp+DuQAgDVEAAAAA0EIVAPvgy7BSeLTgWUChFhr5QAsS/jFumXD3NrlkiGDOkNnJbGJigksiOHuIuyYmFdzxMmaH3/9+GHvAqKPTkMKgAQCbziLV77xZCiv/AZY+qB2bv/Oofmn5+1mPWnm0fPieUjVG5pZJMZJ9aqXB75nFTm3qxgAsxZ5SxrBNcN/uGQz256vdKdg5+aRBMSAAAFlorc0OCQtg11sXYnbtobUU7nJJ1FA+1D3QmNQZjHKXmptFA3+LmAzGK3D1OyAjxDo1swV0Abc95UQZY4toTBKjAAqgE1qdo5YW/HFh/OSBMuBiBLx97+GTtxrf0NVHpSbxHki4w65eI8GECWoGluBxP0gg7iQwgTdmAF9nx6iwmeecpNK0aVdQEKWKLch+MxB4zvVgAbCr3vewCp+5QKpU6FKASaQM7oWZ3y9vBPTMgtCMeyjoOzBN4fGZ3YDfmWVA7zcmpTjvWpVSVkYRQAiTgXxfp4uqrJt92KUPAJun+FJwAkpHFAsvoLuD81MLrLqSSwOHCRM2jBnhXi7iGxH3rmEGWH8H4P4NKglchgoTkwUA0M3aqJ67pgt8w9+MNcjlgcV3oaelLA/7bSgahUfBrBkMnlHoR1LMM0Ew7HQFfDcgi3pzQYB1i+HKDxbg+8yXENasqQAASbNa5c1OhjRr/d3HWNiF2tHOg1ShO6hxPCld4S8IuOPfCIjpIJiaHdMDaXL2QJAQEAYEGCKAEQRpgLGGaBoBAABomkIrWkAVbIFSNkVhU4raFMWbLYV2WcX/K67c097eK2wAAAAASUVORK5CYII=)}#webamp #position::-webkit-slider-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAKBAMAAAC6bkgfAAAAJ1BMVEUJAgJlZXNlZnN1WyKDaTCNdTqcgkqvmGHFsn7by57u4rv06sf19fW6wGFFAAAARElEQVQI12PQnIkMAhgkXZDAUQYGSY/dcLCnFMj3PgMHp8F8YziwBvPL4aAaxPdB6N8G4p9CyJebAvmhyICBQYABBQAALnc7YhsUgeUAAAAASUVORK5CYII=)}#webamp #position::-moz-range-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAKBAMAAAC6bkgfAAAAJ1BMVEUJAgJlZXNlZnN1WyKDaTCNdTqcgkqvmGHFsn7by57u4rv06sf19fW6wGFFAAAARElEQVQI12PQnIkMAhgkXZDAUQYGSY/dcLCnFMj3PgMHp8F8YziwBvPL4aAaxPdB6N8G4p9CyJebAvmhyICBQYABBQAALnc7YhsUgeUAAAAASUVORK5CYII=)}#webamp #position:active::-webkit-slider-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAKBAMAAAC6bkgfAAAAJ1BMVEUgDABhRhBmSxNsUBdwVRt4XSGBZyqPdTmhhkuwmF6+qG/DrnXYxZOv4MtwAAAAR0lEQVQI12PwnIkMAhg8XZDAUQYGT4/dcLCnlIHB0vsMHJwG85XgQBvML4eDaiBf0wehfxuIfwohX67KwCAZigwYGAQYUAAAXWI7mESGeYIAAAAASUVORK5CYII=)}#webamp #position:active::-moz-range-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB0AAAAKBAMAAAC6bkgfAAAAJ1BMVEUgDABhRhBmSxNsUBdwVRt4XSGBZyqPdTmhhkuwmF6+qG/DrnXYxZOv4MtwAAAAR0lEQVQI12PwnIkMAhg8XZDAUQYGT4/dcLCnlIHB0vsMHJwG85XgQBvML4eDaiBf0wehfxuIfwohX67KwCAZigwYGAQYUAAAXWI7mESGeYIAAAAASUVORK5CYII=)}#webamp #shuffle{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC8AAAAPCAMAAABDVWaoAAAAilBMVEUQWgAqKUIqKkEqKkMrK0QsK0MsK0QsLEUsLEYtLUcuLUcuLUguLkkvL0ovN00wL0swL0wwMEsxMU0xMU4yMU4yMk8zM1A0M1E0M1I0NFE0NFM1NVQ1NlQ2NVM2NlU2NlY3N1c3N1g3OFc4N1g4OFk5OVpKWmtSY3N7hJSElKWttca9ztbV3vLv///LbncEAAAAqklEQVQoz5WSsQ7CMBBD37WpGPgDpJtY+/8fAxLLfUbVM0OiNgKG4CGKL45jRbYbiSUIkBAiMZJEqI2EMjGYynVhHHoWmIfle1IEOeqeogCwAQwFq3oesIoADyfaAt4mBHivb/Av5h8nRQCslQVOHPrK/Nif/ouaSdDd+OlvXYDD2qOP1r9j98s8/p/5KlarMIoCu/SPXvmf/yb2SQJkotZD087Z2VrcBIM3KB9V4lGQbMMAAAAASUVORK5CYII=)}#webamp #shuffle:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC8AAAAPBAMAAACGpYupAAAAGFBMVEUAAAAICBAQWgBSa3Nje4R7jJyPn6itvca8iDuFAAAAY0lEQVQY02MQxA4EGHBLuIZighBDoER4ORYQCJLAoiMUIiEoKIpdQkgpNYAhIJSVNQBIARkBDEgSoRCJUAiESoilgXQwYOoAgQBsOkDiIDsCWMHCDCg6sLoKh4Q7LglD7IEIAKjwVurEkbm9AAAAAElFTkSuQmCC)}#webamp #shuffle.selected{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC8AAAAPCAMAAABDVWaoAAAAilBMVEUA1gAqKUIqKkEqKkMrK0QsK0MsK0QsLEUsLEYtLUcuLUcuLUguLkkvL0ovN00wL0swL0wwMEsxMU0xMU4yMU4yMk8zM1A0M1E0M1I0NFE0NFM1NVQ1NlQ2NVM2NlU2NlY3N1c3N1g3OFc4N1g4OFk5OVpKWmtSY3N7hJSElKWttca9ztbV3vLv//8gEwg9AAAAqklEQVQoz5WSsQ7CMBBD37WpGPgDpJtY+/8fAxLLfUbVM0OiNgKG4CGKL45jRbYbiSUIkBAiMZJEqI2EMjGYynVhHHoWmIfle1IEOeqeogCwAQwFq3oesIoADyfaAt4mBHivb/Av5h8nRQCslQVOHPrK/Nif/ouaSdDd+OlvXYDD2qOP1r9j98s8/p/5KlarMIoCu/SPXvmf/yb2SQJkotZD087Z2VrcBIM3KB9V4lGQbMMAAAAASUVORK5CYII=)}#webamp #shuffle.selected:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC8AAAAPBAMAAACGpYupAAAAGFBMVEUAAAAA1gAICBBSa3Nje4R7jJyPn6itvcZs8alFAAAAY0lEQVQY02NQwg4UGHBLuIZighAjoER4ORYQBJLAoiMUIqGkpIpdQlEwNYAhIJSVNQBIARkBDEgSoRCJUAiESqilgXQwYOoAgQBsOkDiIDsCWMHCDCg6sLoKh4Q7Lgkj7IEIAGMfXXXsp3orAAAAAElFTkSuQmCC)}#webamp #repeat{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAPCAMAAADAkV+TAAAAeFBMVEUQWgAoKD8pKUApKkEqKUEqKkEqKkMrK0QsK0MsK0QsLEUsLEYtLUcuLUcuLUguLkkvL0ovN00wL0swL0wwMEsxMU01NlQ2NVM2NVQ2NlU2NlY3N1c3N1g3OFg4N1g4OFlKWmtSY3N7hJSElKWttca9ztbV3vLv//8ki4GoAAAAgUlEQVQYGQXBMQ7CUAwFMP+SzkgoO1vvfyQOgJBYWKB52OsOQpIVSJaZTdTnCgAAIDUuAACAcwoDAAAyKfCFHQBAAQ+OyO8NGlAAkL3Bs4Fa4AAvGgAqsAfQAKAWAPQTNKACgNYAoBYBAAAozgQAAFAyAQAAWLeRNSQRmS3j3GTCH4ZgNtlEi15VAAAAAElFTkSuQmCC)}#webamp #repeat:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAPBAMAAAAFYbKSAAAAFVBMVEUICBAQWgBSa3Nje4R7jJyPn6itvcb4vicLAAAASElEQVQI12NgwA9MXODAWYGBwS0NARyAXISsC5jLwMCCzGUUDAHpYkFwnUBSUC5raIgDA4ILkmFB5Tog9KJZhMI1Q+UqIHsAAPs1JqMDCtK2AAAAAElFTkSuQmCC)}#webamp #repeat.selected{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAPCAMAAADAkV+TAAAAeFBMVEUA1gAoKD8pKUApKkEqKUEqKkEqKkMrK0QsK0MsK0QsLEUsLEYtLUcuLUcuLUguLkkvL0ovN00wL0swL0wwMEsxMU01NlQ2NVM2NVQ2NlU2NlY3N1c3N1g3OFg4N1g4OFlKWmtSY3N7hJSElKWttca9ztbV3vLv///lInoXAAAAgUlEQVQYGQXBMQ7CUAwFMP+SzkgoO1vvfyQOgJBYWKB52OsOQpIVSJaZTdTnCgAAIDUuAACAcwoDAAAyKfCFHQBAAQ+OyO8NGlAAkL3Bs4Fa4AAvGgAqsAfQAKAWAPQTNKACgNYAoBYBAAAozgQAAFAyAQAAWLeRNSQRmS3j3GTCH4ZgNtlEi15VAAAAAElFTkSuQmCC)}#webamp #repeat.selected:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAPBAMAAAAFYbKSAAAAFVBMVEUA1gAICBBSa3Nje4R7jJyPn6itvcYox7XLAAAATElEQVQI12MQRAEM6FwTFzhwVmQQdEtDAEcgFyHrAuYKCoogcwUYQpwVwWIwrhNICsoVDQ1xFERwQTIiqFxHhF40i1C4ZqhcRWQvAAA51isA/VWazgAAAABJRU5ErkJggg==)}#webamp #equalizer-button{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAMCAMAAAC+5dbKAAAAUVBMVEUQWgAqKUIqKkMrK0QrLEQsK0MsK0QsK0YsLEUsLEYtLUcuLUcuLUguLkkvL0ovN00wL0wwMEsxMU1KWmtSY3N7hJSElKWttca9ztbV3vLv//9O4LHRAAAAaUlEQVQYGQXBwQ2DUAwFMEODRCao2H++HnrKofBf7e0NAAD5lhcAAM+6iwUAkJVXwQ8Ho42GVeDjimmmTSM7AGYAKHCBhmmww5GEntHTAykCcIozZ6A8CQAAqawAAEDda/NgbZFErMfuD041NCuZPULmAAAAAElFTkSuQmCC)}#webamp #equalizer-button.selected{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAMBAMAAAB7FTvLAAAAIVBMVEUA1gArK0QvN01KWmtSY3N7hJSElKWttca9ztbV3vLv//9R/wqlAAAAT0lEQVQI12Moh4MyAYaqVTBQAuR0QEF7MIhjbNzRpNGkAeEYcHZodGg0wTlKGjCO5UyQDFQZEAD1QGTg9gA55amhUADkpBjDgQCDIAIIAAAWsDNHmvvPEQAAAABJRU5ErkJggg==)}#webamp #equalizer-button:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAMBAMAAAB7FTvLAAAAGFBMVEUAAAAICBAQWgBSa3Nje4R7jJyPn6itvca8iDuFAAAASElEQVQI12MQRAABBhSOgGsoFAQDOeHlUFAK4sBkQsEcQcHQANYAVghHSC2UNZQ1AM5hYIVxxNJAMlBlQADUA5ZxRzbNEOECAM5YHW8MP5O/AAAAAElFTkSuQmCC)}#webamp #equalizer-button.selected:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAMBAMAAAB7FTvLAAAAGFBMVEUAAAAA1gAICBBSa3Nje4R7jJyPn6itvcZs8alFAAAAR0lEQVQI12NQUIIDBQZUjmsoFAQDOeHlUFAK4sBkQsEcJaXQANYAVghHUSyUNZQ1AM5hYIVx1NJAMlBlQADUA5ZxRzYNyQUAEUAg+7nvOG8AAAAASUVORK5CYII=)}#webamp #playlist-button{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAMCAMAAAC+5dbKAAAAUVBMVEUQWgAjIzgkIzckIzgkJDklJTolJjsmJTwmJjsnJz0nKD4oJz0oJz4oKD8pKUAqKUEqKUIqKkEvN01KWmtSY3N7hJSElKWttca9ztbV3vLv//+EzjHeAAAAXklEQVQYGQXBgRHCMAwEMLk4WYFj//nKAOHqR6o3AADk214AADyjGQCATKrhh+WwzwZygfve2ADUBYADwDT4gA2AhhUAxwZNACssAtqTAACgMwEAwPRRI5GpmTIhUX81UygSftVjhQAAAABJRU5ErkJggg==)}#webamp #playlist-button.selected{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAMBAMAAAB7FTvLAAAAIVBMVEUA1gArK0QvN01KWmtSY3N7hJSElKWttca9ztbV3vLv//9R/wqlAAAASklEQVQI12Moh4MyAYaqVTBQAuR0QEF7MIhjbNyhpKEB5RhwdmggcxAyljM7NDpgHCDQAMqBOXB7gJzy1FAoAHJSjOFAgEEQAQQAwMcyRToQk0kAAAAASUVORK5CYII=)}#webamp #playlist-button:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAMBAMAAAB7FTvLAAAAGFBMVEUAAAAICBAQWgBSa3Nje4R7jJyPn6itvca8iDuFAAAARElEQVQI12MQRAABBhQOo2soFDgDOeHlUFAK4sBkQsEcQcFQBlZWKEdILZQVmYOQEUsLZQ2FcYCAFSgH4rgjm2aIcAEAbLsb8tZoQy8AAAAASUVORK5CYII=)}#webamp #playlist-button.selected:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAMBAMAAAB7FTvLAAAAGFBMVEUAAAAA1gAICBBSa3Nje4R7jJyPn6itvcZs8alFAAAARElEQVQI12NgUoIDBQZUjmsoFDgDOeHlUFAK4sBkQsEcJaVQBlZWKEdRLJQVmYOQUUsLZQ2FcYCAFSgH4rgjm2aEcAEAZCcevKaFFFgAAAAASUVORK5CYII=)}#webamp #title-bar{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARMAAAAOCAMAAAA7SAh7AAACH1BMVEULFRIMDAwNDRQOFQsPDxcQEBkRERsTEh0TEx4TFB4UFBQUFB0UFB8VFSAVFSIVFiEWFSAWFiEWFiIXFyQXGCQYFyUYGCUZGSYZGicaGScaGSgaGicaGigbGyobHCscGyscHCsdHS0dHS4dHi0dHi4eEQoeHS8eHi8fHyIfHzAfHzIfIDEgIDEgIDMhITQhIjQiITQiIjUiIyYjIzYjIzgjJDcjJDgkGwkkIzckIzgkJDklJTolJjsmJTsmJjsmJj0nJz4nKD4oJz4oKD8pKUAqKUEqKUIqKkEqKkMrK0QrLEQsIx8sK0QsLEUtLUctLUgtLkctLkguLUcuLUguLkcuLkkvL0ovMEsvMSUwL0swMEswMEwxMU0xMk0xMk4yMU0yMU4yMk8zM1AzNFI0MCw0M1E0NFE0NFI1LRA1NVM1NVQ1NlQ2NVU2NlU3N1Y3N1g3OFc3OFg4N1c4N1g4OFk5OVo7O1U+PlpAQF5CNhtDQ2BFQTxGQh9HR2RPTmdRPhtRUWxSSj1VVW9ZWXNaVzpbW2JdUCldXWdgYGpgYHliWkViYm5kZHJmZnVnZ3xoWTVpaHdqanpqaoBqe3trXUNra3xsbH5uboFuboZwcINwgY9xcYZzc4hzc4pzk5p0dIt1dYx4eIt6eo9+fo+AgJSBl42Gd02IiJeJlZqPj5+QkJCUlJ6VlaaZc0KdnaiggTSgoK+oqLOtrbivr7y2nFTBZ8mPAAAErElEQVQYGbXB36vfdR0H8Mfz/fl8p86Zx6Gz1YKDgaNp0vIiSLqoRLuokO66SGgJdtk/EARCXXZpEhjojVcKSoyUbroQssBdKKZWVjgkFZ24lut8P+9Xn885Z2uzHxc5H480u5rzYlssYluMFqlmtC0MdgypNESjEmIWxrTexGIgtErMGhmFWETrhkoJYldUROiDIi5UKapat6iUcwq9lU5ZlMJWbx2lt64wpQqdqa3LYnSfizUXi/MG/xIXiB2DXbFjtIhzYltzXnOB2BE7Wm92RKWEiverVMqit966bZUyKxfodnU7yq6yWFv8eOSHUkGINCFaNdH62FtiNhDsQZPWB4QWQ60kUhkEAyGG0ghDYjamhUFEjJU+EINZH2nSSusNYURVGkJUqPh3JWVWFBXrca0spkKnY6qU0rtSpjYpvfdSTK33VFdFaayndbdraEKoZtGmRCHdotlRDdHQatURSUfSO0KPLoYxqoyrUMVkVqZJs5hobbStF43EONJJQ4qqIN6vXCQ91rW2rbREb3qPiVKqKVImhSmEUqmuLPpoMfDwt0j1NKnr/E+l/P+OCjHYNURvNAyTc9aj3hK0J1xan9pbfmv2mXWttu5aj+vx0YmvPvcA9978mDYyTiOP3P/w3USkDhw75EPz6oOfJd/w+O0fefTo9b+484onvnz5ry8/+uxr7hxe/r2vOP3056721JGPM514e+SJY4dcSq8+eGue2W924pZa37XX7OuPqVOH7+Xwc9TIhEfu/wMGs4pNH55Ni9MbH/2IzY+9Xmb59Mv064d+8I/Fvo2rGDnxt9sO/8Zs0yW1if1HzZ7V1s/YUb7/g8OnNl584EtVI4PZbbd56E9sfkd40qV02sUS/rxxhEN7Xg+T2vcJ2g1nt/ZdecbZy252Zu+a6/aYYvakD+i0i1WOXrOHfxx9Y+0CW6c2TlEyMg18s+KhBz55zzHBjT5EJ1S8a+Pvw4H6Cwbv9Wux8e607/pXvHlw7zsrs2uveeuF3nCjS+tE6uAVh3j1yjdat6vz5uFTtzwlZUQfVMzuEYt3bvKhed7i9bOX/XXvgTN2nPh8c92wh4Ov8O7VJzeNvPCmsRHv3ORSel7Zv7+41oktD91t9tM7mvuufNFTh+99qRsZEXz7Z8cI3jh+3CV0xkVulVr11zbfeuvA2zVanPrdETec/lW+sG8vJ686uWnb2Jv42vHjPpgzLnJEPf3FET8vbv/lSWcvu6O6jed+wndvfqlJu+9HpMKQICQiGIOQRsgKzdDTiEbaynpMhEHErCXRVAsZKqGNU2tCBiGMRCqDBI3QYhZGKrEtFvHflFmlVHrM1orSh951FGuF6m1NVZkUfT1uKdapykSVStdfGc3ec04qFrEjZq1GizAkFiHNtoE0BA2JWVhNA03MBlKhEYu22lrF1ioWMWsEcYGQ0kipxKxiW6VSVUP1lFml7KhUl6pK2Vbp1kW3qCoKk1npqLUyq+89TvOfxAXGlsmipCaLmE3lnE4sUmVblRpoziuzErPWVlurmFaxCFqrUnbFLAkqeq9Oi0Wck0r03hKziB0pmbVU7KguK7sS2yazMqtaK7Oi9H8CJR/yJg+gKVcAAAAASUVORK5CYII=)}#webamp .selected #title-bar{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARMAAAAOCAMAAAA7SAh7AAACClBMVEUNDRQPDxcQEBkRERsTEh0TEx4TFB4UFB0UFB8VFSAVFSIVFiEWFSAWFiEWFiIXFyQXGCQYFyUYGCUZGSYZGicaGScaGSgaGicaGigbGyobHCscGyscHCsdHS0dHS4dHi0dHi4eHS8eHi8eHyUfHzAfHzIfIDEgIDEgIDMhITQhIjQiITQiIjUjIzYjIzgjJDcjJDgkIzckIzgkJDklJTolJiwlJjsmJTsmJjsmJj0nJz4nKD4oJz4oKD8pKUAqKUEqKUIqKkEqKkMrK0QrLEQsK0QsLEUtLUctLUgtLkctLkguLUcuLUguLkcuLkkvL0ovMEswL0swMEswMEwxMU0xMk0xMk4yMU0yMU4yMk8zM1AzNFI0MCw0M1E0NFE0NFI1LRA1NVM1NVQ1NlQ2NVU2NlU3N1Y3N1g3OFc3OFg4N1c4N1g4OFk5OVo6QFU+Plo/QitDQ2BFQTxPTmdRUWxSSj1aVzpbW2JdXWdgYGpgYHliYm5kZHJmZnVnZ3xoWTVpaHdqanpqaoBrXUNra3xsbH5uboFuboZwcINxcYZzbFJzc4hzc4p0dIt1dYh1dYx4eIt6eo+Id0mIiJePj5+UlJ6VlaaZc0Kah12ckXWgoK+jlGqqurGtrbivr7yztri2nFS71tm/uX7AwcbE3+HJydDO4c7O4tHV1drj4+fsznrvvmbx8fP////AbX/CAAAEhklEQVQYGbXBz6tndR0H4Of1Oec2M7eud5ipKbHBKaJSoaZlJISrQhdCEEiQkPU/6J/gstYtgibazKJEFIpoEYm7omAsRFBRgi7OyPg1Z+R+z+fdOffHNNd+LPLO88ShuCX2xCL2xGCRakZ7wmDfkEpDNCohZmFI600sBkKrxCxkEGIRw2SslCAOREWEPijidpWiqnWLSjlU6K1MlEUprCuF0ltXmFKFTs9UFvGko+KouKX5l7hN7BsciH2DRRyKPc0tcZtmX+xLxb6mt67Rmw/qrbduUamUPZUy625TDnT7yoGymCx+PPJDqSBEmhCtmmh97C0xGwg20KT1AaFFq1EilVEwEGIojdASszEtNBExVvpADGZ9pEkrrTeEEVVpCFGh4t+VlFlRVKzHtbKYCp2OqVJK70rp6UrvvRQ91VNdFaUx9akcGJoQqlm0KVFIt2j2VUM0pMZCpHUkvSP06KINUWXcCFV0szJNmsVEa6M9vWgkxpFOGlJUBfFB5Yj0WNfantISvek9JkqppkjpClMIpVJdWfTRonHpu6R6mtTH/U+l/P++JMTgwBC90TBMDq1HvSVozzteXzhVPmP2yro2dh8z+3nnodUO57Z+rY0MfeDSM5ceJyL1iae23THXn/4y+bZfPLJ5+cHTzz1y8pffOPHi9gNXXvXN8W9/9LD3fvfVbb+6+EnWf7o68vxT247T9acv5t7B7HMv1/qxk2bf+Zla3b+12jr/EjXScekZs8Gs4ow754zFu6fv2fT5s1fLLBdfpd8z1ulWbG7fxcjLOw/e96LZGcfqDMZTI+sb2vpN+8rO1vkbp97YUTXSzB7kp1c5+33hBcepOyrh+un7+fTG1TCpzU/RLuzubm69a3fjK26eXLO9aTdmL/iQuqMqWydOcnO0ttoyW5mtbpzbWSkZ6Y3HK376e48+IbjPHfSsitfvPX1zOFt/xeD9fhbb/1hvfvbPrp07ef2E2Znp6l96w32O17Opc05xg9attljR2Tq1c2prJ2VERcXsUbF4+4I75jWLv+9uvP2Rszfs+8PX4u7xxAmn8c726oSRV18zNuLtC47Ta8qwiY9O2bUeV7ipOXf+jdXW+dUr3ciA4Hs/eYLgrcuO0zVHXJTa6G/dfc3Zd2q0uPbmeRfe+20e2vwYq7uufN2esTfx8GUf0jVHfFE9962Oy8WVB8yuVLf10o6d1ZYmnvwRqTAkCIkIxiCkETKiGXoa0UhG05AIo4hZS6KpFtIqoY1Ta0KaEEYilUGCRmgxCyOV2BOL+G/KrFIqPWZrRelD7zqKtUL1tqaqdEVfj7uKKVWZqFLp+uuj2fsOpWIR+2LWarAIQ2IR0uwZSEPQkJiFsTeamA2kQiMWGddjrMdYxGwgiNuElEZKJWYVeyqVqhqqp8wqZV+lulSvlD2VbirKoqooTGaloyZlVj/4Dc1/ErcZkm5RUpNFzKZyqBOLVNlTpRrNLWVWYpaM6zH6GItgGKqUAzFLgoreq9NiEYdSid5bYhaxLyWzIRX7qmR0ILFnMiuzqkmZFaX/E7gg7x1c8BJqAAAAAElFTkSuQmCC)}#webamp .llama #title-bar{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARMAAAAOCAMAAAA7SAh7AAACW1BMVEULFRIMDAwNDRQOFQsPDxcQEBkRERsTEh0TEx4TFB4UFBQUFB0UFB8VFSAVFSIVFiEWFSAWFiEWFiIXFyQXGCQYFyUYGCUZGSYZGicaGScaGSgaGicaGigbGyobHCscGyscHCsdHS0dHS4dHi0dHi4eEQoeHS0eHS8eHi8fHyIfHzAfHzIfIDEgIDEgIDMhITQhIjQiITQiIjUiIyYjIzYjIzgjJDcjJDgkGwkkIzckIzgkJDklJTclJTolJjsmJTsmJjsmJj0nJz4nKD4oJz4oKD8pKUApKUIpKkEpKkIqKUEqKUIqKkEqKkMrK0QrLEQsIx8sK0QsLEUtLD0tLUctLUgtLkctLkguLUcuLUguLkcuLkkvL0ovMEsvMSUwL0swMEswMEwwMUAxMU0xMk0xMk4yMU0yMU4yMk8zM1AzNFI0MCw0M1E0NFE0NFI1LRA1NVM1NVQ1NlQ2NVU2Nkk2Nk82NlU3N1Y3N1g3OFc3OFg4N1c4N1g4OEw4OFk5OUc5OVo7O1U9P0w+PlpAQF5CNhtDQ1NDQ2BFQTxGQh9HR2RJSVlOTl9PTmdRPhtRUWxSSj1VVW9ZWXNaVzpbW2JdUCldXWdgYGpgYHliWkViYm5kZHJmZnVnZ3xoWTVpaHdqanpqaoBqe3trXUNra3xsbH5uboFuboZwcINwgY9xcYZzc31zc4hzc4pzk5p0dIt1dYh1dYx3d4F4eIt6eo9+fo+AgJSBl42EhI2Gd02IiJeJlZqPj5+QkJCUlJ6VlaaZc0KdnaiggTSgoK+lpauoqLOtrbivr7y2nFRq7ap0AAAHC0lEQVQYGQXBbayehVkA4Ou+n+ct7U7LaUGggOfs4FpwdKUZ/eDDoJjRLCtm0x9+TX9pTPxhkDDnTPzh/GGyRKPYGGPUmAwzk63JEhHIMkYmiFgOlYrYoptCoaOUMvpJ21PO+9631xUJkAAEECCAMILoNALBABiiIxGSjiAgmERWCjAQZEdAEqMgQMoydLRAAIQOIahBEwCgo+nOAh0NoFHZigKtsVpZaJWlMYtuFNNhtcFoPwAgAQABwACAAIAADAABGEEACCABSABIQACyEpAqS1IJAKCyskBlZQEdDQUABVCABmgwBV8e+ZLoQBAiBSE7hayxMgIGAlchRdaAIMPQExGychAYCMKalgRDJIyRwSCENHbUQBigRlJkG6cjghHdkUhSJZUAAChZUDQdpuNUg9VGUZh1tFaltFnOtKpqxSyroktPacl0Ni2AIQVBJ8hZhEYUSEAnQiJ7UkgZhYgqBBVKGMZQZZwE3cygzGYSzMgcgWpGIowjRSSyqEokAIACAKLCtKfATEaoVBVmtNapiDbTmAVJ6+jSoEYw8NQ+oitS9PUAAGCFHAARQAZk6EohQAaMXSGApMRYGQyCNAAMoZLEZBXAdFQZgRoBUAkAKlPJIkuWrsRk2hE96y5NlnwGAPdmtRdgz7Qnq59fnaxO/n7GLxzaz0O7HpMj42zkO1956kFCiL7h4SUAABx7dEX/ye9+4av7fvI/f2w9nvu6+M1tXHn+nx7F0cd2/5xv/etn7j36Db4494d+a+O/PfeFD/427Nj7/lcfvvR3v3b87D2vffdX1v/1/VtfvGYrqy++fvuOyeor3+/Kz85hedvcNz6655glPEH+9Nw/jq7ffexIyltunT7t40sOrt7n+FF7Np1Z9unjR29bzIuvnsH06vv8y7lY3DZOj7yxeftcvXX45j3HTu1Z3vPGQU8/vATg2KN3i+evheVdPf38Bvilr+mzOx5ixyF6ZIbvfOV/MECHLQAAsAW/s/YXP3Yrvth/9cGXZDTP/vsje77lwh/htum4+Dw6gjEP/PrOm/IQXrn/6nty/cL6swDw4vm9n3h95/TpHz2jRo/75YtP2ibA8okRMwYwlrqxxk3nBrZeAvM1z0XzSxeWF85BLlQunO/t9cyNP7Rt7oVxOjvv1KXpdIW2BYAtcO1d8KKcPgtoD/3ZjrMbX9n/QPfIAHv3evJ/2fKzgm/CBQAA0keuWrMFlaCCXbu809b9/utf71uOL9wSCI1677/u+OhrLyfeWbyVnV6+05aFjwhwzaCY7L1y8f0ENPsGuGPb00YIgDUbji9sXWZlfv7CBjbn8YXNJz88Om/Dpy6cPoPafGbT5iNh/NTK6nnunf7g3QtMTx/fflD4JlwA5Czuun4dl+86NQWAK2c3nqXFyGxgb4cn//i2Rz4ncAcAAHiJPx09lr9KBD10hD625cpfTlx59d26a93lyxt+AqB6fGLruseHGuS7i9e+tbh4FleOb0lgcXbiiIPb567a+b0kiw7em1+Lk6eMKqmEkgtO3jyfMyeXvLOBxZXLFk8u17lXtsxt2PZCcfXak2vnrj69vG1u7fbXl+/cMC6dOHHh/OnveoJyBwBequhb1i1x7OpTWQDFiR1n73xTtBE16IBHBDjzSQAAHDaZDWShEZWIH2666adewA2fuW66MFo864ZP+zYPuHioqKR+sNvb1699Jzj13MIE+I+jgxt//LXv//xYkgQO37wH3Hz+cjebrTD/I07fOL29xvnB8aWVc5j/8OaaJ+cXX3afUhbqusHCh7f999s/kz527p/v3+SG98eG6eDMJwEc1lxzXXGdWPU3vwF/8WDaP/eKN3c8dKSMjAh89vHPETh14AAuAQCsWBNUYoCsAZM3b/rEC+budWH83j/48i2HXXuPb3OP15YxzAb5xgfrD238+OnmCgCDOLm6a/fqwRGVALC05KXLWex27D2bdntmw8Fz83dvveTSynvY7Fm3L2w+6eJ4n4vLpM1vHakHN78627l7uuzSrUt19MTi0imK9MCBA7gE3N36mX0THGj2PfW2K1c92GXjoT/nt3cdSZH7f4/oYIhAECEExkAQSRBrkIaKJCSRE9MxQjIIARkxSp1BDB1JjrNMQQyCZCRExyACSZADBCMdASRIAAAABZWlowKmmpmaTEuhmWp05ZTqNtPUdFxVTKM7ZvRUR6n/G2EFQHSAAARkjyAYIkAQCQxEIpCIgGDNdCQFDEQHSYCcrE7C6iRAQhIIAAiiJdE6AjqAjo7uHrqioaMBHV2iu7KAjjJtCnQ3jRm0Qq9q6D/4GgkAAAIAxowZaNEzEDBrAEWA6Aa69UgC0NACMierkzCbBEhkdmuAgIhAh6ouMkAAiI5QlREQAhAtIiKzEtAlJgARwAwaulc1NK3+HwQZGF3RS6s/AAAAAElFTkSuQmCC)}#webamp .llama.selected #title-bar{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARMAAAAOCAMAAAA7SAh7AAACSVBMVEUNDRQPDxcQEBkRERsTEh0TEx4TFB4UFB0UFB8VFSAVFSIVFiEWFSAWFiEWFiIXFyQXGCQYFyUYGCUZGSYZGicaGScaGSgaGicaGigbGyobHCscGyscHCsdHS0dHS4dHi0dHi4eHS0eHS8eHi8eHyUfHzAfHzIfIDEgIDEgIDMhITQhIjQiITQiIjUjIzYjIzgjJDcjJDgkIzckIzgkJDklJTolJiwlJjsmJTsmJjsmJj0nJz4nKD4oJz4oKD8pKUApKUIpKkEpKkIqKUEqKUIqKkEqKkMrK0QrLEQsK0QsLEUtLD0tLUctLUgtLkctLkguLUcuLUguLkcuLkkvL0ovMEswL0swMEswMEwxMUIxMU0xMk0xMk4yMU0yMU4yMk8zM1AzNFI0MCw0M1E0NFE0NFI1LRA1NVM1NVQ1NlQ2NVU2Nk82NlU3N1Y3N1g3OFc3OFg4N1c4N1g4OFk5OVo6QFU7O1U9P0w+Plo/QitAQF5DQ1NDQ2BFQTxHR2RJSVlOTl9RUWxSSj1VVW9ZWXNaVzpbW2JdXWdgYGpgYHliYm5kZHJmZnVnZ3xoWTVpaHdqanpqaoBrXUNra3xsbH5uboFuboZub3pwcINxcYZzbFJzc4hzc4p0dIt1dYh1dYx4eIt6eo9+fo9/f4eEhI2Id0mIiJePj5+UlJ6VlaaZc0Kah12ckXWdnaigoK+jlGqoqLOqurGtrbivr7yztri2nFS71tm/uX7AwcbE3+HJydDO4c7O4tHV1drj4+fsznrvvmbx8fP///8QuCFEAAAG4ElEQVQYGQXBX6zfd10H4Of1+X4POz3lrH/P2rMOGZaWdmsZnSsbatIRCDDcILuQG5ULQgzqhQazGBK4UOO8wMSLOWMEEzOiNwN2wUw7WTJnWUdTks7NgFA3LHQ9dadlbc5a253v7/P2eQIgAAQICBADSDUjEAbAkEpDNCohEMa03gQMhFYJhAxCQAwzY6UEAYiKCH1QBABUiqrWQaUAFHorMwqUwlQplN66wixV6MzaVCAeBQAEABAAGgACAAEMAAEMIAACDAAEABoggFQATW9dozcAAL311kGlUkCloANAAcwABVBgBv5q5E+lghBpQrRqovWxtwQGgnegSesDQotWo0Qqo2AgxDtKI7Q0GNNCE9GMlT4QA/SRJq0MswFhRFUaQlSoAACgpKAoKqZxUmAqdDpmlVJ615WervTeS6eneqqridKY9VkBDE0I1UCbJQrpoAGqIRpSYyHSOpLeEXp00Ybo3TgXqujQzWYamNHaCPRiIDGOdNKQoioIAIACANJjqgnoWqI3vceMUqrppHSFWWiUSnUF+ggaxz5BqqdJLQEAgBu0BkiAFkiUiIAWGKtHgEaXsbfQhGYAGKI3GsYJwDTqLUEfAFABAJUoKVJSqjfMTZVUr+qK1rXnAfDB1sv74IdTza1/AR7vPLh2lncvflMbGfrAsSeOPUBE6pavbgYAwOVHbqjH/vAvvvHrv3Zu6wJe+IZ86Tamf3/qMZz764983DP/9un7zv0dX57/ii/efPLZP7n2eBz+yOW/f+TG3/7+pfOHX//W5+cf//SuU7fuYjpx5sO/NE4/+1719pvzOL1//p/3HVqxjKdoD8x/c/TeAysnI3ffNv2LDy578e0jVk45sunK8z61curwzlw//Qb6liOeu5xD7xqnn//gtkPzdeH4/oMrFw6dPrTyrOe+uhnA5UfukT1zcMd/1vSFefiDx9TaBxbXFne/RI10HHsCBqjYBgAA2/Doht++5QD+qL527YtaihP/8Xv3fce1r+DOyp3PoRLGdvQzv/LLwymcOvLO+zO/d/48AJxa/eQ9Z94zO3bgJ/roSb9z/dv2ywiv/NeIGQNopbbWeMsq9qyDm+tmrltavnZi3ypkb2Xfybp99q93nHHX/IvvfKuvHLxwebq+TtkGwDaY3zAy/Z82vQYoZxd3X9346llVIw0e4OgqS58SvgsTAADN3E3jZvQGejh82JWy4c9XH68dF7fvCKLQf3z29qXXTwZvLu3lXid+1Y7fvUnArVu8zfiJ9bdXG6B4eIB9e75jhABsXFhZ3vMG65tdW+BgVpYPvnLj1JKFj15begO1/dK27WL82Pr6KT40rf78MuuXX7vrWfFdmABtlsX5jVwdTdYWYQ3Wru68sKZkpDceqDh61GcfEtwNAACe5MuDf2ifI6GGSvjfndOjo+nlK7OPzd24MX8/QK/xiS/N/WOraBeXNq8uLV3DdGnHCNwyu/gDx+/ZMPee443WqfDmwiZcvGjUG71ByT6Xdm4OF5ddWGDr+sxWz9fqT5fnF+56ttgyt35jfsvq9+/aMHf7qe/du3FcftfZa6sXn/EtursB8GRP3WojN9G6tUXW6CxuvLBxUcqIigp8VsDqHgAAnDH2RusopDf42cLWB49h02/sre2DO89ZeMjTfNJbL87mVOiv7vfTzXNvhktPfX4EXjo92PX+H7/8W0PXaMDxPYfA/vNXq9jrEgu7vbZ1eu9sXOIny+uXb+PmaXvdTJa2nnREKXtry2DvjTte+9HDg4PXnvn4JjuuzBVMg9U9AM4o5hawOMu66/NruKx59+5X1xZ3r/2oGxkQPPj0QwSrX4dfAADcMBd6wwCtD7Cy9f3HzN3n+vD63/jLHedsvdfT3Ov1F9B6tB9+dP6FXbv+uwDAIOenDxyajo/oDTDC8jJnWueAlUs2bXJh4cXVpQ/tWXdl/SIOOurw8sFXXJ074voJYvuFk/3h7W+t33lg+r7Zzs/UubPvW75wXqe5/+vwC+CeUv/0uY6vFacPwcvVLb50lrVFTTz6Z6TCkCAkIhiDkEbIHJqhpxGNZDQbEmEUgZaMmmohrdJo46w1IU1ojEQqgwSN0BqEkUqAgAAAACiolEoPTIquj7Ouo5gUqreJXqUr+jSu68xSlRk1qXT9f0a4ASAVEECg1QDCkICQBgykIWhIIMzNBprAQCo0AjJOY0xjQGAgCACElEZKJVABKpWqGqqnoFKASnWpXimg0s2KAlVFYQaloyYF9cffpgEAgADAkHRQUjMQmBWATkCqgCo10AAoKIFknMboY0AwDFUKIJAEFb1XpwUEQCrRe0sgAkhJkiEVQJWMAAkwg4KqSUFR+v8DYP8M63Qn0TQAAAAASUVORK5CYII=)}#webamp .selected #title-bar #option.clicked{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAHlBMVEUUFB8VFSAVFSIVFiEWFSAWFiEWFiI0MCyah13sznoaG8L5AAAAPElEQVQI12NgYBAUCmBgmCCoaMDAWSmoZMAwvVIwNIBhRueMjgkMAoLTKwMYGAWnz0xgEBT0DAWxXdMSACxMDDJsyBoOAAAAAElFTkSuQmCC)}#webamp .selected #title-bar #option.selected,#webamp .selected #title-bar #option:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAD1BMVEUhKDU0MCyah12jlGrsznoe/O3VAAAAMklEQVQI12MwBgIDBgMHBgYDBhMRASDpKCIIJJ1UnJQcGAwEHUWAsoyOLkCSgQWIweoBtzQG0TH1VqcAAAAASUVORK5CYII=)}#webamp .selected #title-bar #minimize.clicked{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAMAAADXT/YiAAAASFBMVEUqKUIqKkMrK0QrLEQsK0QsLEUtLUctLUgtLkcuLUhFQTxSSj1aVzpoWTVrXUNzbFKId0mckXWqurG71tm/uX7AwcbE3+HO4c5KSa+JAAAAPElEQVQIHQXBwQHAMAjEMJvQfLv/lJ0ArpK3FsLQZxogW9uqXjqlkKQphYTmcGBI4wPU6OVd4FtvYEzyA+cLGDTjuSw1AAAAAElFTkSuQmCC)}#webamp .selected #title-bar #minimize:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAIVBMVEVFQTxSSj1aVzpoWTVrXUNzbFKId0mRbkqckXWjlGq/uX4Hs2WWAAAAOUlEQVQI12OYCQQTGKYzMLBPYJggKCgwgWGSiYvRBIYpYWkhExhmdK3qAJKrVq0AqunoaJ/AAFYPAAQVFS+2qihdAAAAAElFTkSuQmCC)}#webamp .selected #title-bar #shade.clicked{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAMFBMVEUtLUgtLkguLUcuLUguLkcuLkkvL0ovMEswL0swMEswMExFQTxSSj1rXUOqurHO4c6W/ePHAAAAQUlEQVQIHQE2AMn/AKqHZlVQAJnu7uUQAK7///4wAK3d3d0wAKzd3dwwAJzN3cwwAJvMzMNAAIi7u7MgAIZlVTAwDDgbUKzozR4AAAAASUVORK5CYII=)}#webamp .selected #title-bar #shade:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAD1BMVEVFQTxSSj1rXUOjlGq/uX5Idn/CAAAAM0lEQVQIHQXBwRGAIAwAsLT07Z2zsP8qbuDBAliTmDjl1m8Gob6HK5uWti27V6uxDDFxfn1PDx8P0VYSAAAAAElFTkSuQmCC)}#webamp .selected #title-bar #close.clicked{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAALVBMVEUoJz4oKD8pKUAqKUEqKUIqKkMrK0Q0MCxoWTVrXUORbkqjlGq0h2PCsWH///9ex0i3AAAAO0lEQVQI12NIdTFWUmDIbC/vFGCIONm5Q4AhfPbq6UCy61U7A4P77LVAdsTOzhsMDJ5ANQwMLkaKCgwA5wURVkMAFf0AAAAASUVORK5CYII=)}#webamp .selected #title-bar #close:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAElBMVEU0MCxoWTVrXUORbkqjlGr///+HjTObAAAAKUlEQVQI12NwAQIHBicBBiEHBkcmIUYHBgcFAwUgKRwsAGNDxCFqwOoB1gEH67W94+0AAAAASUVORK5CYII=)}#webamp #clutter-bar{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAArBAMAAAC3GdQgAAAAElBMVEUAAAAAAAgQECEYGCkzPElgYGraVCJcAAAAVElEQVQI132NsQ2AQAwDr8gCv0FGMNLTu8gKv/8qFCAgQqI7WWebbYyBACQJEUbyRDgaTf95Va3xeGWkKUTQqPz12m9eyyYB8s7eVEUSJs8VIPe1DmVJGRTmaMgdAAAAAElFTkSuQmCC)}#webamp #clutter-bar.disabled{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAArBAMAAAC3GdQgAAAAD1BMVEUAAAAAAAgQECEYGClgYGoHCnLLAAAAIklEQVQI12MwFBQUZDBgAAIDIBhULAVUlgJhFlivgomLCwA8qROh1kJ8awAAAABJRU5ErkJggg==)}#webamp #button-0.selected,#webamp #button-o:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAIAgMAAAC5YVYYAAAACVBMVEUAAAAYGClwgY/qIgoqAAAAGUlEQVQI12Nw0GBwaWNwaIKRGQwODAwuLgA+SAT1jbNsAAAAAABJRU5ErkJggg==)}#webamp #button-a.selected,#webamp #button-a:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAHAgMAAABIN+TNAAAACVBMVEUAAAAYGClwgY/qIgoqAAAAGElEQVQI12Nw0GBwaWNwaGJwWQUmgWwGADIVBK9/og4OAAAAAElFTkSuQmCC)}#webamp #button-i.selected,#webamp #button-i:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAHAgMAAABIN+TNAAAACVBMVEUAAAAYGClwgY/qIgoqAAAAF0lEQVQI12NwcWFwWMHgksLgoAAjVwAALckEbUwsrjEAAAAASUVORK5CYII=)}#webamp #button-d.selected,#webamp #button-d:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAIAgMAAAC5YVYYAAAADFBMVEUAAAAQECEYGClwgY/lGZUOAAAAHElEQVQI12NoYGDo6GBo+MPQcZqh4TCIdACSfwBnkgl9KMHv2wAAAABJRU5ErkJggg==)}#webamp #button-v.selected,#webamp #button-v:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAHAgMAAABIN+TNAAAADFBMVEUAAAAQECEYGClwgY/lGZUOAAAAF0lEQVQI12NwYGDwOM3gcBhG/mdwsAEAPG8GMJvxEOEAAAAASUVORK5CYII=)}#webamp .shade #title-bar{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARMAAAAOCAMAAAA7SAh7AAACJVBMVEUAAAAA+AAKDRYKDhYLFRIMDAwNDRQPDxcQEBkRERsTEh0TEx4TFB4UFB0UFB8VFSAVFSIVFiEVFiIWFSAWFiEWFiIXFyQXGCQYFyUYGCUZGSYZGicZGigaGScaGSgaGicaGigbGyobHCscGyscHCsdHS0dHS4dHi0dHi4eEQoeHS0eHS8eHi8fHyIfHzAfHzIfIDEgIDEgIDMhITQhIjQiITQiIjUiIyYjIzYjIzgjJDcjJDgkGwkkIzckIzgkJDklJTclJTolJjIlJjsmJTsmJjsmJj0nJz4nKD4oJz4oKD8pKUApKjUpKkEqKUEqKUIqKjoqKkEqKkMrKzwrK0QrLEQsIx8sK0QsLDssLEUtLUctLUgtLkctLkguLUcuLUguLkcuLkkvL0ovMEsvMSUwL0swMEswMEwwMUAxMU0xMk0xMk4yMU0yMU4yMk8zM1AzNFI0MCw0M1E0NFE0NFI1LRA1NVM1NVQ1NlQ2NVU2NlU3N0Q3N1Y3N1g3OFc3OFg4N1c4N1g4OFk5OVo9P0xCNhtDQ1NFQTxGQh9JSVlOTl9RPhtSSj1YWGJaVzpbW2JdUCldXWdgYGpiWkViYm5kZHJmZnVoWTVpaHdqanpqe3trXUNra3xsbH5uboFub3pwcINwgY9xcYZzc31zc4hzc4pzk5p0dIt1ZDd1dYx3d4F/f4eBl42EhI2Gd02IiJeQkJCUlJ6Zc0KdnaiggTSlpau2nFTZBQIoAAAFhklEQVQYGQXBQailB3kG4Of9/v9MohPDTUZT4umU5FKjNaIEtHGCu65asgpYq4LaKhZ0YaQFaUGDLS6C1KYbEUWwi0gWBbvIpnRlETS4CFaNGMW2CZc2QydzqUkmzTn/9/k8uQAQAAIEBIgFZMoOCAtgzaQQxSQEwi7VJWAh1CRQZBUCyrJZJyMIQExE6MUQADAZZqrBZAAMusZGgzE4dDVGVxtsmUFzXA4DVo8CAAoAEAAKAAGAAAoggAUEQIACoACgAAFUF6B0taILAEBXV4OurgYmAw0ADdCAARiwgS+vfEEmCJFFiJoSy7brSmAhuAkl1QtCxTI7iepaBQshLrSFYqnAmgqLiLJOeiEW6JWSGtWFYsVMCiEmTAAAMDIwDBPH9ajBNmga22SMbm1stRndPYZj9Va9mY1RbL0NwLoIYQosx8QgDQowhSjU7BqlqpF0I2xlU5ZdmbHuwgwbtG1TYKNqBXooqqwrTQoZZoIAABgAIB3HPgKjEl26Y2OMKU3GZrCFMKZ6M6BXUHz7Q2S2KhkyXdiW6hIKoRZAAlRuAIBnAAAAAABvB54BAABgAm+H94OTc06cc+IccOI8J65n3AYvmkuucecLXdUzw1BPATM4NJ/6/vgevPc4u8PT8M6NP3z2MR6+5ztqZemFJ7717Q8TkcnX/fnf3f6Jv/ydz/zD6z/52M2Pv+O+p79ZX1l/+g1f8fLf/MUd/urPfpfjj78jbnxyDwAPAQAAAAC+CDwEAAAA8EWcff39wv76bXtnnOxxDif7Yl+uu20PrsV+f3Zt/0I1ybufGrA3cECD/Nsl+MHvz/HpB+/D396rf336MKfPMkXjiW/9DOu6MPE/u/fc7tN3PYdSD8GfrH0XXHzfG1n40TfWe2oZLldVVVVVVRUAAAAAQFVVVQEAIAGAqqrLmBm37QtU7fcnbwEAVBVB7S/RmHfX/QnNAABcunLlypUrl9Q8CB7UPvfy6R2nv3rMzErBAw94/Hku/6nw4uUHObn5BqIvnuDNrx0u7v/baxf+wKs3D7c84P91+C4AAAAAAAD4Lvg1AAAGADwJEPYFUPbe8gsAAAS1p5r3lLr/BxoZHJZNg8mVkwu8duXqkftfAzi+dMtLjKx08cGJx7/6ex/5mOCJd11+pe4+fnWhvDp3s/z2i69c/KNveu709Vdvhcv9/L9OwikAAAAAAAA4BQAAEAOAd8FTYjjbF6CdvekXAGQAjuizveZOjcvPg4xDNqoh81s37Tl73dVqLvAUG9dOX3rrVRkrJibwEQEvvHrzczfd/X+Ar322fGC95RZ34X/vuHqriZ/9UxS89FYAAAAAAADYAwAAGACwx88B5/ZMtDPn5wAYNFjosxf24AyAwe6Arrb1uPX25pJ/P3jyfnjy3sWjr/uVq6cP/6StLAg++o8fIzD/+bYbN1xdgP945h3e/PJf50sX7+TqGx9/RCGqFy7+MwAoAAAIAACPglcAAAAAPAJ/PCPOnJ+fiHPOwZxzjutcB9e2cnbt6KyxL+j/4uOgAbT54ft2+Jfhvs/Dvb15w7N/z2fv+UnJhUcfIRPWBCERwS4IKUIuoCydIorUznFNFKsIVLJY9FJk7Qq1blVCFqFYiUwWCYpQgWJlEiAgAAAABiZj0oGjZvTSrTEcDabrSM/YDH1cD4ZDpuvAbCatf1lgYDtuAyYYFkNIBAoFISLhYBfKusIolaBbNVSGnqpgqQFWISwxTWGqGsqKbloTSDAAAMwMYGzp7qPjUSNyPGoMx0XM6CNteoPmAJZpTW9GQy4QADKBAASLUSDJ7CDIVGAlSqDSKkB2oQgsEJJA2R12sS0BhcWIEMggQIaIAAATk+lMmQEGMEbG1tVgbLUtBw1MM2wwtHEwMGbSvwGhZ2YZd3bCBAAAAABJRU5ErkJggg==)}#webamp .shade.selected #title-bar{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARMAAAAOCAMAAAA7SAh7AAACFlBMVEUAAAAA+AAKDRYNDRQPDxcQEBkRERsTEh0TEx4TFB4UFB0UFB8VFSAVFSIVFiEVFiIWFSAWFiEWFiIXFyQXGCQYFyUYGCUZGSYZGicZGigaGScaGSgaGicaGigbGyobHCscGyscHCsdHS0dHS4dHi0dHi4eHS0eHS8eHi8eHyUfHzAfHzIfIDEgIDEgIDMhITQhIjQiITQiIjUjIzYjIzgjJDgkIzckIzgkJDklJTolJiwlJjIlJjsmJTsmJjsmJj0nJz4nKD4oJz4oKD8pKUApKkEqKUEqKUIqKjoqKkEqKkMrK0QrLEQsK0QsLDssLEUtLD0tLUctLUgtLkctLkguLUcuLUguLkcuLkkvL0EvL0ovMEswL0swMEswMEwxMUIxMU0xMk0xMk4yMU0yMU4yMk8zM1AzNFI0MCw0M1E0NFE0NFI1LRA1NVM1NVQ1NlQ2NVU2NlU3N0Q3N1Y3N1g3OFc3OFg4N1c4N1g4OFk5OUc5OVo9P0w/QitFQTxJSVlOTl9SSj1YWGJaVzpbW2JdXWdgYGpiYm5kZHJmZnVoWTVpaHdqanprXUNra3xsbH5uboFwcINxcYZzbFJzc4hzc4pzk5p0dIt1dYx3d4GBl42EhI2Id0mIiJeUlJ6Zc0Kah12ckXWjlGqlpauqurGztri2nFS71tm/uX7AwcbE3+HO4c7V1drj4+fsznrvvmbx8fP////Kv08RAAAFRklEQVRIx+2XTYiVVRjHf89z3jszXq4zmJozvpJhfoQp4a5NIrRwEYFIi4hUKsIW0aKdGISISZCLBDcRuFCIVm4icpXtohoilEEFwcXc8UrkoNnVYd7zPC3Oee/MnQ8cXHcY5p6P55z3Of/n638kkJvAgq70D5KkuNLorde7C3FRQFBwkbxNoBA1zYcEEFCXelEUmftOUdFwcWS+NoILgoAFvE9NwMXBXW1uVK8Apk6VuuA4EJOMY2ppQtwBg6hVkiw4QX+T5ceynFg90KUnZGm0F5+jC7ebzoPGEfCF+oFLDYapZXhqfKxPcGFnwUQSPlfA54hn0wgS0q+6IoTYME1WTTZmAFBELaQdKqgHRBCXBtKTFBpWO4Zq8iVVUARBKVws9NzPinSsZxgUCsBr70MxhR5E85uRcPD0J1RFla8XswtY7SGOGYZjYhhm5hhEcROPuIGjEC328CoyJHj6eqhEcECsz5DeCxTEg5PgNEDELF0jKhFBC8WMoiFgWT+MGPNhEVSLfD0HBVWKAgwSJA5WQ7UIkH6nNqGyqja+imCKmRBT9LhiII4loAQUHBePtbcU9VUvvgPiURVxEDcFYsjJoLZWz5WzB6s86tPpBitrO1YovgPgAACjHRil/pem6OgoU2psBGjjm5iELbdN1dyT4+hvGSHPjnNk3NkCcLPyxuxugD8MXuvehQ3NH9ACggW4ePniIRAEcfmao2dbH5wa/vjs0NGvBn8devnPb/RM0fmCMzw8eXyYY5+sg+rqJYRHx1rz73BwhZicWqH4KeDh6QMolFMbS9owWkJCZbQMUAam2FgCMCmUZXuyvK0GIq9eSYYfS95U9fKGPB8Atl/3andYP8yDPeN494Vmtzl2Czy5KBcvp4QLuNAdPtziozXTKXe8dAs4UngLoPXmaghw7dpb21RcGOFpWlh2ReYSX5YbySGysQwxzfVQ6ROMiEMos7jvDfuu4HU66WuNwQBxBq0CwzD8F87d5tjM4J27uBc5SF+BC/dh5H0EJnfugU2NO0nF1iZg8+xMa9cEs43dPB5yGB3AMIHxp8JkvD/tL1UbAPh9XkUqwxwA5SJQevUqlKAGewNh308YaUiViy+4NAdWwaNABTtn6s3dmWfudXGkSMn8kAsXfmH/ewjw/c7hx2GtnwugzFRrIYx0Z1uvTzC9fujBAMBI6++fXQS2PhUmW1foJ9tqRAzaPVAi7fmQaM8PKiC2Swy2EIHtN2uJSlJuBcTXMQiNtHMQJiBCc/DeYBPxVPEkV/39mRjcmG08CGv/zR+68KFwuBgYoAX8M9x5Docb36Wqw/3yaTBpLbvii+Taud+hBNOFiORK24ug9u2kUbtfoKgyaYnuhEFgVZRZ4vQapokENozd6TbHuhNGkWJWgHfPv5fZkk8/e4e13WyWiRsvsvnhp3KytQs6q89/lquQWoDmtyxFup7UvgRg+olyxwEOmqG06XRGUTp12FjuTcFUSrFRaU9WtI060uJ1eHsB1o7/+IYBlxyuMgmMe6R56y50mygSTpwmkbZCauaWyTQN6VFwBKQBKMHSWEEkYCqCQCNvQkWUgAUBCaYKWkRVtCbziZEJ4hJSWdeaAPb4mksf510ebKtZq4tJCiADx4IlDuJQ4YCbVmCeyYlVxSwGlbhLBW64GHZb50CMVaxzUJqq3xdSX7bWTXLVFoiERFobmSWReK9ZDl5VA/PEZbV+kBSZGgbBLZ3qmvKCUlCzO8uQqLJE9QAz6xk/iplVVInDCpJ7DlVAcMcqMNwzbWQ2we2Og1kqUiD/vwEXvQH/A3+xY8OlLccKAAAAAElFTkSuQmCC)}#webamp .shade.selected #title-bar #shade{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJCAMAAADXT/YiAAAAM1BMVEUtLUgtLkguLUcuLUguLkcuLkkvL0ovMEswL0swMEswMExFQTxSSj1zk5qBl42qurHO4c7FV37rAAAAOklEQVQIHQXBwQ2EQAwEMCdEPK7/YhFiM2fXzybCxAXvN1VVbe9tpenSDDCh+GhZVmpyHDwZu2HP9QfI+BkLtDdVPQAAAABJRU5ErkJggg==)}#webamp .shade #title-bar #shade:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAD1BMVEVFQTxSSj2jlGq/uX7CsWH/Y2uiAAAALUlEQVQI12NQAgIFBiUGBiYFBgVhYwMFBkVhY0Mg6QwmXVwEgeIuLgIwNWD1AJzCBeFqt4OOAAAAAElFTkSuQmCC)}#webamp .shade #position{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAHAgMAAACTjE7vAAAADFBMVEUAABAwMEsxMUJaa3u9OGBkAAAAIklEQVQI12NgAIIDDFqrVq06wCAaBiZDQ8PAZCiM/A8EBwAZeBBhq+F40QAAAABJRU5ErkJggg==)}#webamp .shade #position::-moz-range-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAQMAAAD3d2XqAAAABlBMVEWjlGrsznoPowceAAAADklEQVQI12NwYHgAhw4AIi4E4a+iLsYAAAAASUVORK5CYII=)}#webamp .shade #position::-webkit-slider-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAQMAAAD3d2XqAAAABlBMVEWjlGrsznoPowceAAAADklEQVQI12NwYHgAhw4AIi4E4a+iLsYAAAAASUVORK5CYII=)}#webamp .shade #position.left::-moz-range-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAgMAAACw1x86AAAADFBMVEU9P0xoWTWjlGrsznp9Nqf9AAAAE0lEQVQI12PYwPCF4QcYfmHYAAArXgYxq2vCDQAAAABJRU5ErkJggg==)}#webamp .shade #position.left::-webkit-slider-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAgMAAACw1x86AAAADFBMVEU9P0xoWTWjlGrsznp9Nqf9AAAAE0lEQVQI12PYwPCF4QcYfmHYAAArXgYxq2vCDQAAAABJRU5ErkJggg==)}#webamp .shade #position.right::-moz-range-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAgMAAACw1x86AAAADFBMVEU9P0xoWTWjlGrsznp9Nqf9AAAAEklEQVQI12OwYKhh2AOGNQwWABlSA52dOQTnAAAAAElFTkSuQmCC)}#webamp .shade #position.right::-webkit-slider-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAHAgMAAACw1x86AAAADFBMVEU9P0xoWTWjlGrsznp9Nqf9AAAAEklEQVQI12OwYKhh2AOGNQwWABlSA52dOQTnAAAAAElFTkSuQmCC)}#webamp #volume{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEQAAAGkCAMAAAC//nO2AAAC5VBMVEUVFSEVFSIVgAoWFiMXFyQYFyUYGCUYGCYYkgsZGSgZdhAcHC0cbBQchRIeHi8fHzEfMh0fVR0omRwpKUArYyIsLEYujhYunBIvfhsvgRswSD4xMUoxMU0yMk8zM1AzM1IzNFEzNh80M1E0M1I0NFE0NFM0shU1NVQ1NlQ2NVM2NVQ2NlU3Ihw3N1c3N1g3OFc3OFg4N1c4N1g4OFc4OFk5OVo5bSw6OltAUkRCtiZHhidKSmhMlSVOeC9PpCNQT2lQUkRRmyxTO0BTU29WqypXjEFauihcmyxcwCphoCxixDFkritlvjdpdy9p2jBquCtrwCpsa4FtoCxvRB9woEtw1T5xcYlyxypz3D50xzF1TSd3iDd3oDF3tCt30zB4bi14eIx6IiN62jB7OCd7fI98e498fI59Vyp9fJB9fZJ+fpJ/f5R/1T6BxyqB4jCC3D6EtDGEwF6FnDGGYzmIoDGJQyyJYjGJrVqKxDCK4z6LfjiLjkiLmCyMpI2NmiyOWxeOjqGOmyyQxzGSRz2SVj+SkqSS4jCUyjiWlqiXXCGXaECaaSma4z6bXSGbfiebjSybw2Gb2jmdryydsJOeYhKeayafFhufKhufMzefPiGfSSGfVyGfbCefgSefkCyfmyyhok6j4Tik20Wk4jimxzGndkip40atrZKuV0auag2uwCqvlI6wYh+yERayKBayRx6ydiWynCqyriuywF+yxDG1hVK3RUy94ji/bRu/dRC/uyq/0zDB40bCcFTClFnCsV3Cv17DciPD1T7FDBLFJxLFQxvFURvFZRvFgCPFnCPFsSrFwCrF2TDGeA/G2jDIxdPI2z7JVyLJgSDJhSnJoCnJtDHJxDHJ3D7ZSh7ZWh7Zbx7ZfB/ZjifZlDfZrCfZsTfZwzDZxj7Z1DfbhC/fsSjgDhXgLBXgTB7gXB7gch7gkijgsijgyTDg2jDhHybhPCbhWC7hZy7hfC7hmTfhtjfhzD7h3D7eIOpxAAAEo0lEQVR42u3WeVRUZRjH8VuKpWZFkpjlWLN0uTMNMNOdycwpM0ZLIyjHSkoJyLBSMdvITGk1pVRMyzZTw4JSEVNLbVMgqCw1l9RcyfZ9/bv3vfd971jgP7/6o3Pe58vM4cA585z3zn3mc0brzXK5vW6Px+Pz+XRd9+sBqyArK5SZFQ6HTf4TMc2I9Wyb1tvFZrjPtIYYPsPQ9YAYw6dkhsLhbDaCT7Fqb4apuVwuNkIcxDAMvzOCTwkF2QxW5GgD7JOc2rWDdkyHZB3tUjqm8Dp1sn6lHNdunU/s7j6PD+l6cuoJeKm9LmBvltY5tcuxeF2iV7Or1E5K63Y8Xrf4w/wk3XtFT8GL31fB35MzXBddecNNN44eM3oM72b2sLpFdit7HK2KRysu4UPYHXa7vR6PwW+wnhEIOKsWCgbP5fdXLAi/w6b1+NuOWLfY5XZ5PV6PwRctQw9k+JP7aq2JvbDmES822y5bH34Sj4+tq274dT+fERTbmsU2LVtMiVhz2iyc/V+NrbzXWlfDxy7GWlf7FMGsYMi+Gv785xUc8YcZYUO87j585X3sJH75jvBB2eHM7HDyU2O2cyHiMNrpm/99GlHQHgVpPU9D65kmKEjrkY7XI2ZTEE0/Gy9dUtDvfLwEUUAUKExBtB9etK9NQbT/hXj94zYFsZxBeDkJm4K+8cvxiAKiQGkKLsaLCQrYp/hStEE5goL4kCvwhkgKEsOvRRt+2xNEAVGgLgWxwXgOBUPz8tHyhkoKRowqRhs14m5JwdgytLFEAVGgNgWXoSUpyMu/Bi0/LyEpKB6PVpykoOwetDKigChQmIKzYlfhORSMHIc3UlJQ/gheuUNB1WNoVbOJAqJAZQqux8sVFOROKH8ArXyCoOC6aVWLXsRaVDVNUDAgsfgltMVEAVFAFBAFRAFRoDgFuRPvQJuYO0BQMKcab869goLq1/GqJQUL38R77WWigChQmILJU+7HmjI5ScEreA4Fq9Zv+hhr0/pVCyUFG7d8irVlI1FAFBAFRAFRQBQQBUQBUUAUEAVEAVFAFBAFjILCF/AKBQWFK9d9iLZupaBg0s7WH9BadzoUtP6J1vouUUAUqEzBrAVosxwK6j/Aq5cU7Dj4PdrBHQ4Fh/5AO/QOUUAUEAVEAVFAFBAFRAFRQBQoT0HpzOfRZiYpeB+vfpKgYPv+w99hHd6/XVKw4MDvaAeIAqJAYQrOKaic9xzWvMrSgTYFpSta8FbMsCm4a9veb9H2blttUzBwyb7f0Pa9/SpRQBQQBUQBUUAUKE3BsOmPo00vEBQULH0Db6mgoHTDZ3gblggKZnyOt5ooIApUpmAqnqRg2NxavLm3Cwpq136EtrZWUlDZ8glaC1FAFChNwbN4yW8FzXjOt4LmPd+g7Wl2vhX8ikcUEAUqU1DyDF6JoKCk7j28uodsCu7cuvtrtN1bJQU1v+C9RRQQBSpT8DRekoImvLoHBQVNu75C29VUIyn4GY8oIApUpqDoKbwiQUHR8ka85YKCksYv8RolBfN/wqshCogClSl4Es+hYFkD3rL5NgVFDV/gNayRFPyIt4Yo+P9T8B9IsPkvQxJ1ta+jwcEAAAAASUVORK5CYII=)}#webamp #volume input::-webkit-slider-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAALBAMAAAC9q6FRAAAAFVBMVEUAAAALDxYvL0RKWmt7hJStvMTa5+opTTwbAAAAMUlEQVQI12NQFAQBIQaxNBBIZGALBYIQAyAtKiqKlwapM2RgcwEBQwZhYxAwZICaBwCdgQ6Jd297uQAAAABJRU5ErkJggg==)}#webamp #volume input::-moz-range-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAALBAMAAAC9q6FRAAAAFVBMVEUAAAALDxYvL0RKWmt7hJStvMTa5+opTTwbAAAAMUlEQVQI12NQFAQBIQaxNBBIZGALBYIQAyAtKiqKlwapM2RgcwEBQwZhYxAwZICaBwCdgQ6Jd297uQAAAABJRU5ErkJggg==)}#webamp #volume input:active::-webkit-slider-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAALBAMAAAC9q6FRAAAAFVBMVEUAAAALDxYZICovL0RKWmva5+r///+U4Y9MAAAAMUlEQVQI12MwFAQBYQbRUBAQZGBlAAIWBiQ6ISEBKw2SV4TTIi4gIMhgJKQopCgoDAB2aAh/NddRQgAAAABJRU5ErkJggg==)}#webamp #volume input:active::-moz-range-thumb{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAALBAMAAAC9q6FRAAAAFVBMVEUAAAALDxYZICovL0RKWmva5+r///+U4Y9MAAAAMUlEQVQI12MwFAQBYQbRUBAQZGBlAAIWBiQ6ISEBKw2SV4TTIi4gIMhgJKQopCgoDAB2aAh/NddRQgAAAABJRU5ErkJggg==)}#webamp .gen-window .gen-top{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUAgMAAAAFGX4uAAAACVBMVEUeHi8rK0Rra3zjkZV/AAAAG0lEQVQI12NggIJVYNDAEAoGDlSj0QGx9kABAFXxKF3wQT+3AAAAAElFTkSuQmCC)}#webamp .gen-window .gen-top-left{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAYAAAB4d5a9AAAB4ElEQVRIS61Vu04DMRDc3WuQqEBIVKlAQkKioEZU1PkVpHzhXZX8RUCiTpUjojs04/XrcjyUxFF09p3t8c7OjnU2exikaiqqmt6wryY6iLCrxg5+aGp4Wh77WszjDMwFyHw+r2GwEb9jmm+GycXmEYhgFjaM8/fWRZCuXYaj8kweTbExI4gbqYpxnIFThFxj+UBlJG27DFQ4DE9anb4Y+yYJhNSoqMWD/ATSrSIxKZJtv67TdeAo5SREoqJD4Ljv1/LydCO3s7MDt87LEsg4J/3nmywWr0cDkP6U+G4l0LKnXQByeXF+YhCoC1lxmQIEdJ2iTdAlzEu/e5f7u2t5frw6GqcG8QrFA3Ww+/o4GqDOCeny5iqD7vkP9ZzrZqJOyDTs5bdipLpEZNtv9guSi8MBcuXnwvMP2SmSE4y8awwyrnzaSGmMlc2MDTLazR8gMM1sM7Rb5im4cuHCUZFuQdlQs9ftJT7SBZCOVuNUaSNmOGEjhnfsF5R5Tho1GSpjLax+TBdB2pWXTsPUmzXBYV0M6JvfN3R8CZTGdxRM6cLTIMH+UTe8nCJl1jh1iDJSmNVVglBt1X1SqCtE4rIeSdpIHaIK9FF4BmKjOAA88Nv/InHgcJXmeyJTN3X91ur6BrqJo0MRJOhhAAAAAElFTkSuQmCC)}#webamp .gen-window .gen-top-left-end{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAYAAAB4d5a9AAABxklEQVRIS7WVvUoDQRDHZ/r4DIEThCiCtn4UCpa+gIiF76DmCWwv+D5WYm0nCFpZCSKWKZIdmY//Zu/CxSaXQPZuM7v/md2Z3/DO6FSEhESE9COSbCSbjUdKpC9qY7Nmu7wGa5MQsVn6Djy+qWMpRHwD1+nazIXwdVGTtfkU7+EZ8dHBpVnoD5tBcglsoqNGZ2Nsi7nCGbWx/+EYIhUhPj68Et/EpVTCDIsNTVznUyJhIUouZh7H8apzcIQ4HApRHg4rHH3cwHqHwaAivr87703k/XNKj88fxJPJpDcRPZO6fiDe39vtTSTxlH5/5sTXF2e9iWgkdlx93snTyze9vn0RV5tbvUUyn81osFGVdeJalu9R7VbBKVmN2JzWSVQ1UASUoBiBJq96rxdeF7u8lt3BJXZtj06CIisA2Y6uzbQcnQs5uhYI4vFtLZmuK6CIYyi5lsFYOBGYzAxTmwKQosjpZlcAEPfWuAtEUrQL3ImJAJDGOu0bIPAShb3XLHqP09lhGmgFqdVbPDdE0LDQrAoROwLNrPZcRn5k5X+o7+4nqXGMubdEerZT2BxpR+Ip7BlRpiHaL5pQo3aK7MpNOqLKTbHIrj9doofFD8vqAQAAAABJRU5ErkJggg==)}#webamp .gen-window .gen-top-right{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAMAAABPqWaPAAABYlBMVEULFRIMDAweHS4eHi8fHyIfHzAfHzIgHzEgHzIhIDIhITMhITQiITQiIjUiIyYjIjYkIzckIzgkJDklJDomJTkmJTsmJTwmJjsnJj0oJj0oJz4oKD8oKEApKEApKUApKkEqKUAqKUEqKkEqKkIrKUIrKkMrK0QsK0QsLEMsLEUsLEYtLUYuLUcuLUguLkcvJwgvLkkvL0ovMSUwL0kwL0owMEsxL0wxMC0xMEwxMU4yMU0yMU4zMk8zMlA0MlA0M1E1M1I1NFM2NFM2NVQ2Nhg3KxA3NlU3NlY4NVU4NlU4N1c5N1g5OFo6OFk6OVo7OVw7Ols7Olw8OVs8Olw8O11GQh9JRjlORDBQPx5dVztiWkVqanprXUFra3xsa3xsbH5tbX9tboBubX9vboFvb4JwTyxwb4Nxb4RxcIVxcYZycYZzcodzcoh0c4l0c4p1dIt1dIx2dY13dY6Gd02QkJCZc0LWhhB9AAABJUlEQVQYGT3BvWqUYRRG0X2++bRSGxsVhBls0oidP3W8gYCFXoW3JV6DVgmxslBbIQELJRAQA0Kc9zzbmcBkrVrZrTEaYuylEXs+EK/EEKNo4HA+SVf0n2mTMTqJcc00TTeBoGwUBZMINXPteTL2fn2E/XvHg/ktOz/fP4Ve7ZerU2Cqaw/YePdndXd1+qEWzIfsrKGbXNy+OCPN/IhrX1nI7+XFw3OqnO+z8wOa17dOz86XL79L3WHn7zMz9r59gSePP62pgxrG0bG1L23TraRWI24kRGNilv3iqJiaAgQRtEAomF+JIYRotPGIrfkki3UcncTkcqQHsjEtGEBRVeRymIBsTBYb3lCaqTqJbE0lG5WqVHrEyJX586A12omj45tj2foP9wDyBsXxPvcAAAAASUVORK5CYII=)}#webamp .gen-window .gen-top-right-end{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAYAAAB4d5a9AAAByUlEQVRIS7VVPUsDQRCdWRvBShGszoAKYg4C1mJj8m8Cgr2/1cLfENBu5b352D1NY7GXhLvszc57MzvzRqdpU1VV8MOlolJFpeCvFuEq3uMDGyxU3Ls1mrit22MvfWDffv9e7dGccfGXg3CYd5o6KS1GrtsbPoK0zuttNXtjh3thZG0zWaYTY8z3ngGVIlosMiMS0cNGhCBprCq1ihTEWVW0mPNMlRNAKrC5SAAZoRLA/uzsRed5Vw+HDxqNunS1uqnbp1u5m05HYQhB3t5ehwHweABycX42HgTpGnkxkvX9lTw/Xg7DYXV9fX8OA+CZzA8vVbwfotYhK9Zw3iuhAtmgaEhvvGhIykqoABq6UJ74vZ422YwhAyYLTbOsgTv5iOdOz9j1qVve/a5UekwgE2ThfAnSVMCpdXLS5MlOIQWyZ2tpa/q1EMbQOAV3k5c/kaYqe/r+L5AOvtAuW4voeKY8DmhfJ5BkXzwlfOksUBR5oFhvotkLa4BYVKHGATLvcp5AdS3DHYinrZ8XrQgccDEa4MMjCQVnCZ+oaEy7fkZ0g2kBQp1HfA3E5lArDpawF0OWcIaJ4/TDzPF7tMpatNYOffX5hPUW/wFZNjaZ4b4luAAAAABJRU5ErkJggg==)}#webamp .gen-window .gen-top-left-fill,#webamp .gen-window .gen-top-right-fill{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAYAAAB4d5a9AAAAWklEQVRIS2PU0nT8z0BjwFhe1kd7S2ysY4eJJfLySrT3SVu5L+0tmTBhAu0tMTTQpb0lSVGutLeELnGipKxGe5/QJTPSpeyiiyWjBSQpVRAjXVIXXSyhR+oCAGL8JbEqBdscAAAAAElFTkSuQmCC)}#webamp .gen-window.selected .gen-top{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUAgMAAAAFGX4uAAAACVBMVEUeHi8rK0Rra3zjkZV/AAAAG0lEQVQI12NggIJVYNDAEAoGDlSj0QGx9kABAFXxKF3wQT+3AAAAAElFTkSuQmCC)}#webamp .gen-window.selected .gen-top-left{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAMAAABPqWaPAAABHVBMVEUdHS0dHS4dHi4eHS4eHi8eHyUfHzAfHzIfIDIgHzEgHzIhIDIhITMiITQiIjUjIjYkIzckIzgkJDckJDklJDolJiwmJTsmJTwnJj0oJj0oJz4pKUApKkEqKUAqKUEqKkEqKkIrKUIrKkMrK0QsK0MsK0QsLEUsLEYtLUYuLUcuLUgvLkkvL0owL0owMEsxL0wxMEwyMU0yMU4zMk8zMlA0Mk80MlA0M1E0NFE1M1I1NFM2NFM2NVQ3NVY3NlY4NVU4NlU4N1c5N1g5OFk6OFlCQTtqanpra3xrbHxsa3xsbH1sbH5tbX9ubYBuboBvboFvb4Jwb4Nxb4RxcIVxcYZycYZzbFJzcodzcoh0c4l0c4p1dIujlGrsznr///9wBmqFAAAAvklEQVQYGQXBwQlVSQBFwTq33+DWnUuj0RQmXMNwMzAKgjkI/7dVQYdtrZwyq3xFTlqqtUoP39dOa9apc9pOjXe8cRky8NDN/gcA8HDVj38DAHiYew0AwMNeD78BADy8hk8AAB4W/nwAAHh4nXz+BgDgoejjqXaqp22nHs79lZ0yM2tVgze8BHcBD68zX0yt1Jbp4XrPf6fqbJ72zz1tsN7e6N47eo07eFvBcrnQIPdyXbjyuu7DdOlnZk5Z1V/Roy8hK3ODtwAAAABJRU5ErkJggg==)}#webamp .gen-window.selected .gen-top-left-end{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAYAAAB4d5a9AAAByUlEQVRIS7WVPU4DQQyF7Z5cgaVJpAAnIFAk50AcgB4UwQEoKNJQp6GkpKCgp6ShoUFcgCJtkBgj/7zZ2Y0WmmwiZXcnXj97xv7MB+OZCAmJCOlHJNmVbDVuKZE+qI2tmu3mO3g3CRGbpXvg+cUiXoWIO3CdLmcuhK+Lmqytp3iOyIiPj07NQn/YDJJLwIleNTu7hlusFcGojf2PwJCpCPHJ5EzciUuphBkWDk1c11MiYSFKLmYRx/ZqcAiEOAIKUd6thtj6OIHtXgY7FfHX61VvIk8vK7q+fdZjyKe03RTCW7U3Ip5NJ71l8sMr+vz4Jr6/O+9NRJOx7erzTG6W7/Tw+EY8HB32lsl6vabBoCr7xLWs3qPbrYNTsh6xNe2T6GqgCChBMwJN3vXeL7wtdnkve4Ab7NofT4MifwCynV2baTk7F/KmqBHE88uFtQqI2QVFbEPJtQzGIojAZGaY2hSAFEVON7sCgDi3xlkgk2Jc4ExMBIA01uncAIE3KOyzpp49TmeHaaAVpNZocd8QwcDCsCpEbAu0stprGflRlf+hvnuepMY25tkS5dkuYQuknYmXsFdEWYYYvyiERu8U1ZWHdGRV47aurl8JSofPjXVkWwAAAABJRU5ErkJggg==)}#webamp .gen-window.selected .gen-top-right{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAMAAABPqWaPAAABO1BMVEUeHyUfHzAfHzIgHzEgHzIhIDIhITMhITQiITQiIjUjIjYkIzckIzgkJDklJDolJiwmJTsmJTwmJjsnJj0oJj0oJz4oKD8oKEApKEApKUApKkEqKUAqKUEqKkEqKkIrKUIrKkMrK0QsK0QsLEUsLEYtLUYuLUcuLUguLkcvLkkvL0owL0owMEsxMEwyMU0yMU4zMk8zMlA0MlA0M1E1M1I1NFM2NFM2NVQ2Nhg3NlU3NlY4NVU4NlU4N1c5N1g5OFo6OFk6OVo7OVw7Ols7Olw8OVs8Olw8O10/QitCQTtdVztqanprXUFra3xsa3xsbH5tbX9tboBubYBvboFvb4Jwb4Nxb4RxcIVxcYZycYZzbFJzcodzcoh0c4l0c4p1dIt1dIx2dY13dY6Zc0KjlGqxnVm2nF7sznr///+ZhXPBAAABBUlEQVQYGQXBwYmUURBG0Vv1P90KvWtnQCcBxyBEEAMxKWMSWjQAB2V2DeKyX33Xc+reGY3RoHHeGHHWR1HVMWgUDXxbT5mK3swYkyQab3T3SyAoQFFQIhQAAPA+5iFXOPVls74AADBf30HuOn3+A6wCAGABXPucfr7WMesXAICAkry4hQzrDgAAoIru29FUuQ4AAP6BnM7P6df5LfUKAOAvj5qHXOHU32/Uh9rGnTiaMSapza77HdWEqCbm7Txetj0UIIigJRBkfRJDGKJq5EID6ynHLe4kMTpxAKEPNlBUFRiQAhZtAbgUqgqqJDV0CVCpEqHAojesn5vRyBh0/PyD5tj8B5vM5TGngJW4AAAAAElFTkSuQmCC)}#webamp .gen-window.selected .gen-top-right-end{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAYAAAB4d5a9AAABzUlEQVRIS7VVu04DQQy0lx+gokuQEEjAiXwAJYSCgpIfoE1NgUTLT1KRjh4qKBbN+LF7kIZiL4nusuf1jL32WBeLVVVVwQ+XikoVlYK/WoSreI8PbLBQce/WaOK2bo+99IF9m81ztUdzxsVfDsJh3mnqpLQYuW5v+AjSOp1fV7M3drgXRtY2k2U6McZ87xlQKaLFIjMiET1sRAiSxqpSq0hBnFVFiznPVDkBpAKbiwSQESoB7M/OXnSa1vXjc0ujUZcuD0/qy+ON3F7uj8IQgmzfXocB8HgAcnx0MB4E6Rp5MZL7uwt5ejgdhsPq+vp+HwbAM5nOrqp4P0StQ1as4bxXQgWyQdGQ3njRkJSVUAE0dKE88btcrLIZQwZMFppmWQN38hHPnZ6x61O3vPtdqXSXQCbIzPkcpKmAU+vkpMmTnUIKZM/W0tb0ayaMoXEK7iYvfyJNVfb0/V8gHXymXbYW0fFMeRzQvk4gyb54SvjSWaAo8kCx3kSzF9YAsahCjQNkWuc8gepahjsQT1s/L1oROOBsNMCHRxIKzhLeU9GYdv2M6AbTDIQ6j/gaiM2hVhwsYS+GLOEME8fph5njd2eVtWitHfrq8wnrLf4D9zg6mAHJo5AAAAAASUVORK5CYII=)}#webamp .gen-window.selected .gen-top-left-fill,#webamp .gen-window.selected .gen-top-right-fill{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAUCAYAAAB4d5a9AAAAWklEQVRIS2PU0nT8z0BjwFhe1kd7S2ysY4eJJXLyqrT3yZtzVbS35P///7S3xMnRmvaWLJ6SRXtL6BInqmo6tPcJXTIjXcouulgyWkCSUgUx0iV10cUSeqQuABQNKbDZQyxmAAAAAElFTkSuQmCC)}#webamp .gen-window .gen-bottom-left{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAH0AAAAOCAMAAAA16ON4AAABfVBMVEUdHS0dHS4dHi4eHS4eHi8fHzAfHzIgHzEgHzIhIDIhITMhITQiITQiIjUjIjYkIzckIzgkJDckJDklJDomJTsmJTwmJjsnJj0oJj0oJz4oKD8oKEApKEApKUApKkEqKUAqKUEqKkEqKkIrKUIrKkMrK0QrLEQsK0MsK0QsLEUsLEYtLUYtLUgtLkctLkguLUcuLUguLkcvLkkvL0ovMEowL0kwL0owMEsxL0wxMEwxMU4yMU0yMU4zMk8zMlA0MlA0M1E0NFE1M1I1NFM1NFQ2NFM2NFQ2NVQ3NlU3NlY4NVU4NlU4N1c5N1g5OFk5OFo6N1k6OFk6OVo7OVw7Ols7Olw8OVs8OVw8Olw8O109O149O2A9PF89PGA+O18+O2A+PF8+PGBqanpra3xsa3xsbH1sbH5tbX9ubX9ubYBuboBvboFvb4Jwb4Nxb4RxcIVxcYZycYZzcYhzcodzcoh0c4l0c4p1dIt1dIx2dY13dY53do54dY94do94d5Ap3ahhAAACBUlEQVQYGQXBAQEYNRAEwNlLig3E4KTCcFK81AZ8bpmJn7/89vOX3z+BgBAEgQyBNARCIEHS2YEICIEAIR0BUsEF8OcvxhhwKxiXKQNxZDCBMGJ0mL3OmhpJwxHBfacmzA4u333+gAGAMQk6PqlkL7tYrnOSWca2CaCb1g5vqESDReG8+koHcOdcHwYAI6SVPWcL+RgMvmA6kEQLdOrMDHYAOHaFxxl3Hxafz6Y9ywAQEZWKTEgVwQB9igVJqkbtpkA84Jl56tjNiaM78F1mtsMAaLSrxWjKTgIB4DQs1Wg13U5p0W3nALrS7TPd/x4MYHZzggGIBmlEvUrYizwLfWvBCAVNNB3zhMYDTo5xfpzPMQ4Bxk7+/f77GEDfiYyXYh3RrO+z3xgcqmWsgkjaRuweNSbn0VIv+rmM82jB4vtxzuUCf5OKQUBgEAiSgATSIBiCwGww0hAkHRyEA0BgAFSwAsDA7iaQAECRYUYCMDvMUBJoAp51AARw4c+/AASIRgTSmEYCIkAIIQ1iEAQEIg0CqVMBBBfrn67rHZEBmWCa+913YcLhwAghaSJx1umI2RwBZ08a15c5zyGBS3NoDGtekTFMmXNm26i6TsyMOk+2BkAlgjUZTM+8tiV7FJ9rzXlPAZv0CQGAMDUNBIaOkCbSEAIiMAEERo1UCCSB67vOOwBR8T8KSRhI0bzb7AAAAABJRU5ErkJggg==)}#webamp .gen-window .gen-bottom-right{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAH0AAAAOCAMAAAA16ON4AAABfVBMVEUdHS0dHS4dHi4eHS4eHi8fHzAfHzIgHzEgHzIhIDIhITMhITQiITQiIjUjIjYkIzckIzgkJDklJDomJTkmJTsmJTwmJjsnJj0oJj0oJz4oKD8oKEApKEApKUApKkEqKUAqKUEqKkEqKkIrKUIrKkMrK0QrLEQsK0MsK0QsLEMsLEUsLEYtLUYuLUcuLUguLkcvLkkvL0ovMEowL0owMEsxL0wxMEwyMU0yMU4zMk8zMlA0Mk80MlA0M1E0NFE1M1I1NFM1NFQ2NFM2NFQ2NVQ3NlU3NlY4NVU4NlU4N1c5N1g5OFk5OFo6N1k6OFk6OVo7OVw7Ols7Olw8OVs8OVw8Olw8O109O149O2A9PF89PGA+O18+O2A+PF8+PGBAP1BAQFFAQFJfX3Fqanpra3xrbHxsa3xsbH1sbH5tbX9ubYBuboBvboFvb4Jwb4Nxb4RxcIVxcYZycYZzcYhzcodzcoh0c4l0c4p1dIt1dIx2dY13dY54dY94do94d5CUuEDKAAACKUlEQVQYGQXBwZFdRRAEwKyev3ZwwQ8gFisgdMIPzFlhhLhih2THvukiM3+jqRRolgIKpUAV2KZoU6WgaQGrKQoK3VQBvvH7Nz9e39nZ7ezsPJoFrni8PvOgNNUV91y7s21xqaaqWM2dy5qVLS12Ps3q1sL7v2Awd/u6Y56XmHB7N4960mOKVDO1uSwlSgsKjNQeZuhKStg9lkwM3i8wcPblwIOGfbzdFy6bfQFbaXtqZg+ROxEqBJ0ai91AUTvjhZox3u8HMKg8l31AlrfxibfXMHPQclzJubnWbTasVChFsFPQQXTgU6GM9/vxBRikk6zxAuHOcfAElAjS7dUTkxjOGBBgl1nAYjMLbxYhftt/vlxgIIfBA8rJTXa9WstC3UwS4s6dAl2ECjS7xI6Kxk6wDcT+0q9/7gcwwNnxvEAHV9t5PkPbCeFYHfSsG6gUGEV0UGMiomkhCeLXfvzZr1+A/ExTAFw8xwVdKIU1XdhZilIKFKWxpdGdsqBA2Ub565sfgzQAwHMu0AIKTAErSAMAKNJt0AoMAHsVLeD1B1QKaNEoqIJCUWiVpkpTTaEFbKooFLUACsDrO2zhARaXDg+3zNWUS+fiZnVn6ZaiTVk2FyzZplqWO4srzTaes2NgZ7AvUNyj1kOHc0mDmTjIIo2aCTQpRrOCDSvbbcApbaapcd2s13/QFMDlOXmgNtqURq1Ys3aWRosWUAW1qaZZDQuF7qkt+Gke/wNCVMxEPwTsWgAAAABJRU5ErkJggg==)}#webamp .gen-window .gen-bottom{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAAOAgMAAACnVF/TAAAACVBMVEUrKkM+PGB4d5A1hmUAAAAAGElEQVQI12NYBQYNDKFg4EAyjQ5wmQcFAFaEHSfLt0cNAAAAAElFTkSuQmCC)}#webamp .gen-window .gen-middle-left{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAdAgMAAAABTX4zAAAACVBMVEUdHS0qKUBqanoMSFahAAAAD0lEQVQI12NQ5QxhoDMGAFFyDru7vcmtAAAAAElFTkSuQmCC)}#webamp .gen-window .gen-middle-left-bottom{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAYAgMAAABRgO+AAAAACVBMVEUdHS0qKUBqanoMSFahAAAAD0lEQVQI12NQ5QxhoCEGAEUWDDHkAu/CAAAAAElFTkSuQmCC)}#webamp .gen-window .gen-middle-right{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAdAgMAAADqesUwAAAACVBMVEUdHS0qKUBqanoMSFahAAAADklEQVQI12OYOoWBBggAuDohplXr188AAAAASUVORK5CYII=)}#webamp .gen-window .gen-middle-right-bottom{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAYAgMAAAC6t1SDAAAACVBMVEUdHS0qKUBqanoMSFahAAAADklEQVQI12OYOoWBGggA6uEb2fBejlkAAAAASUVORK5CYII=)}#webamp .gen-window .gen-close:active{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJBAMAAAASvxsjAAAAElBMVEU6MSljXjtsXUORbkq0kWP////9IyyfAAAAKUlEQVQI12NwAQIHBicBBiEHBkcmIUYHBgcFAwUgKRwsAGNDxCFqwOoB1gEH67W94+0AAAAASUVORK5CYII=)}#webamp .character-48{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAE0lEQVQI12NIYJjAsIHhApBMAAAULANhy/alSwAAAABJRU5ErkJggg==)}#webamp .character-49{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAD0lEQVQI12NQYEhgUIBAAAbMAQE/4OmzAAAAAElFTkSuQmCC)}#webamp .character-50{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12N4wCAAhAkMDQwfAA78AtFOxm3MAAAAAElFTkSuQmCC)}#webamp .character-51{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAFElEQVQIHWP4wKDAkMAgwDCBIQEAEHwCcej/ubUAAAAASUVORK5CYII=)}#webamp .character-52{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAFElEQVQIHWNQYEhgWMDwgUGBQQEADlwCUbptSVYAAAAASUVORK5CYII=)}#webamp .character-53{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAE0lEQVQI12P4wNDA8IBBAAgfAAAWXANRkouswAAAAABJRU5ErkJggg==)}#webamp .character-54{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12NIYGhgeMAwAQgTABOsA0E/JWQ/AAAAAElFTkSuQmCC)}#webamp .character-55{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEUlEQVQI12P4wCDAoMDgAIIADgwB4bVklkQAAAAASUVORK5CYII=)}#webamp .character-56{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEElEQVQI12NIYJjAAMJAEgAQvALRax9yugAAAABJRU5ErkJggg==)}#webamp .character-57{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12NIYJgAhAUMAgwJAA/sAmFIDiRPAAAAAElFTkSuQmCC)}#webamp .character-97{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEUlEQVQI12NIYJjA8AGIgRAAFNwDkUdAkdwAAAAASUVORK5CYII=)}#webamp .character-98{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEElEQVQI12N4wDCBAYSBJAAaPARRW/xs+gAAAABJRU5ErkJggg==)}#webamp .character-99{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12NIYJjA0ACEExgSABFMAuEl/r42AAAAAElFTkSuQmCC)}#webamp .character-100{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAIUlEQVQYV2NkeMTwnwEG5CAMRrAglMPwiIEBxKaKIJpFADZCEAGAIkAWAAAAAElFTkSuQmCC)}#webamp .character-101{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAE0lEQVQI12P4wNDA8ACIGxg+AAAZ7ARBle8LfgAAAABJRU5ErkJggg==)}#webamp .character-102{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEUlEQVQI12P4wNDA8ACIgRAAGXwD0QArRQgAAAAASUVORK5CYII=)}#webamp .character-103{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12MoYGhg2MAwAQgTABMMAyEYrKesAAAAAElFTkSuQmCC)}#webamp .character-104{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAIklEQVQYV2NkeMTwn0GOAQIeMTCA2Iy4BaEKwRR+lcSYCQBnQhEB2omL+AAAAABJRU5ErkJggg==)}#webamp .character-105{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAADklEQVQI12MoYFCAwgIACEwBYXIvChIAAAAASUVORK5CYII=)}#webamp .character-106{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEElEQVQI12MQYADBCUCYAAAGnAGx9K9L/wAAAABJRU5ErkJggg==)}#webamp .character-107{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAE0lEQVQI12OYwLCA4QAQLmCYAAAXTAPhR2cHZQAAAABJRU5ErkJggg==)}#webamp .character-108{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAGUlEQVQYV2NkeMTwn0GOAQUw0kwQ2RqgpQBKiwwB5wSvgwAAAABJRU5ErkJggg==)}#webamp .character-109{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAIUlEQVQYV2NkeMTwn0GOAQIeMTCA2IxgQWSAXxCrdmIEAQtSEAH0ktA/AAAAAElFTkSuQmCC)}#webamp .character-110{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAE0lEQVQI12OYwMTAcIHpARAyAAATGAMpx84ilAAAAABJRU5ErkJggg==)}#webamp .character-111{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAADklEQVQI12NIYJgAhQkAEgwDAakOOnUAAAAASUVORK5CYII=)}#webamp .character-112{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12N4wDCB4QFDAwgCABlcA9Fh/HqiAAAAAElFTkSuQmCC)}#webamp .character-113{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAE0lEQVQI12NIYJgAhBcYNjAUAAATvANxqBzBZwAAAABJRU5ErkJggg==)}#webamp .character-114{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12N4wKzA8IAJBD8AABkSBJqXbNZ9AAAAAElFTkSuQmCC)}#webamp .character-115{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12MoYGhgSGAQAMIHAA1cAlFD9hA9AAAAAElFTkSuQmCC)}#webamp .character-116{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAADUlEQVQI12MoYFCAQQAH/AERspkQDgAAAABJRU5ErkJggg==)}#webamp .character-117{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAADUlEQVQI12OYwACDCQAUHAMxvRgSGgAAAABJRU5ErkJggg==)}#webamp .character-118{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAD0lEQVQI12OYwACBCQwJABOMAwEw9lTJAAAAAElFTkSuQmCC)}#webamp .character-119{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEElEQVQI12OYwACCH4BwAgAXTAQhMxLiQgAAAABJRU5ErkJggg==)}#webamp .character-120{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEUlEQVQI12OYwDCBIQEIgTQAEgwDAb4oAK0AAAAASUVORK5CYII=)}#webamp .character-121{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEUlEQVQI12OYwDCBIYFBAQQBDwwB4W/sEnMAAAAASUVORK5CYII=)}#webamp .character-122{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAFElEQVQIHWP4wCDAoMDgwNDA8AEAD3wC0QyxJxkAAAAASUVORK5CYII=)}#webamp .character-34{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAADUlEQVQIHWMIYGKAAQADkABTwIHJLQAAAABJRU5ErkJggg==)}#webamp .character-64{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12OQYFBgiABCBQYJAAbMASFkTTvgAAAAAElFTkSuQmCC)}#webamp .character-32{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAE0lEQVQYV2NkYGD4z4AGGOklCAChpQYBD5K5XgAAAABJRU5ErkJggg==)}#webamp .character-8230{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAC0lEQVQIHWNAgBUAALQAqf6ZnokAAAAASUVORK5CYII=)}#webamp .character-46{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAGUlEQVQYV2NkYGD4z4AGGGki+AhqkRzCNgCztQcBQ/F5qwAAAABJRU5ErkJggg==)}#webamp .character-58{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAG0lEQVQYV2NkYGD4z4AGGHELPoIqlYPQFKoEABHUCAEa7xBFAAAAAElFTkSuQmCC)}#webamp .character-40{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12NgYBBgUABCAQYGAAJMAGFQC8mLAAAAAElFTkSuQmCC)}#webamp .character-41{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12NgYGhgcADCBgYGAAkMAYFEejkbAAAAAElFTkSuQmCC)}#webamp .character-45{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAG0lEQVQYV2NkYGD4z4AGGEkQfISmXY6BgXjtANzFBwGYHC/oAAAAAElFTkSuQmCC)}#webamp .character-39{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAADUlEQVQIHWNQYGKAAQABgAAjjGgVVgAAAABJRU5ErkJggg==)}#webamp .character-33{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAH0lEQVQYV2NkYGD4z/CIgYFBjgEOGKkhiDAOzMJqJgAQawsBnvEUjAAAAABJRU5ErkJggg==)}#webamp .character-95{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAFklEQVQYV2NkYGD4z4AGGGki+AjTIgCyawbjsVUKxAAAAABJRU5ErkJggg==)}#webamp .character-43{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEUlEQVQI12NQYGJg+MEAIhkACPABPfEgkLEAAAAASUVORK5CYII=)}#webamp .character-92{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAD0lEQVQI12NgYGhgZoBAAATIAI13IxiAAAAAAElFTkSuQmCC)}#webamp .character-47{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAFElEQVQIHWNgYOBgEGBQYHBgaAAAAqQA+cACQKYAAAAASUVORK5CYII=)}#webamp .character-91{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAHUlEQVQYV2NkYGD4z/CIAQLkIBQjXBAqQFVBJIsAMwMMAVy4DMAAAAAASUVORK5CYII=)}#webamp .character-93{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAIElEQVQYV2NkYGD4zwACj8AkA4McAwMjXBAmQU1BJIsACwMMAZBptUcAAAAASUVORK5CYII=)}#webamp .character-94{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEElEQVQIHWNQYAhg6GAAAwAH9AD5R+QUOwAAAABJRU5ErkJggg==)}#webamp .character-38{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12NQYAhgUGCIAJIaAAfsAWHaIpwJAAAAAElFTkSuQmCC)}#webamp .character-37{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAFElEQVQIHWNIYMhgEGBQYIhgkAAACgQBacCaDW0AAAAASUVORK5CYII=)}#webamp .character-44{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAHklEQVQYV2NkYGD4z4AGGKkl+IiBgUEOYjjCTCRBAMu1CAHlOP+DAAAAAElFTkSuQmCC)}#webamp .character-61{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAH0lEQVQYV2NkYGD4z4AGGMGCj5BE5RgYIIIUqkTTDgA65AgBoymWoAAAAABJRU5ErkJggg==)}#webamp .character-36{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12NQYChgSGAwAJIKAApcAbE85GZ1AAAAAElFTkSuQmCC)}#webamp .character-35{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAD0lEQVQI12NIYPjAAMEMABUMAwFxUzDLAAAAAElFTkSuQmCC)}#webamp .character-197{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEklEQVQI12NIYJjAAMIfGCYAABIMA2Fjj6V0AAAAAElFTkSuQmCC)}#webamp .character-214{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAEElEQVQI12OYwJDAMAEMEwASbAMBKm1nAQAAAABJRU5ErkJggg==)}#webamp .character-196{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAFElEQVQIHWOYwMDAkMAwgeEDwwQADwwDAcWvnbkAAAAASUVORK5CYII=)}#webamp .character-63{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAFElEQVQIHWNIYJjAIMCQwMDAkAAAC+wBwX8tiscAAAAASUVORK5CYII=)}#webamp .character-42{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGAQMAAAAxNcYIAAAABlBMVEUAAAAA4gDJLyihAAAAFElEQVQIHWNgYFBgeMBQwODAwAAACjwBsYRIp8kAAAAASUVORK5CYII=)}#webamp .character-60{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAHUlEQVQYV2NkYGD4z/CIAQLkIBQjXBAqQFVBJIsAMwMMAVy4DMAAAAAASUVORK5CYII=)}#webamp .character-62{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAIElEQVQYV2NkYGD4zwACj8AkA4McAwMjXBAmQU1BJIsACwMMAZBptUcAAAAASUVORK5CYII=)}#webamp .character-123{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAHUlEQVQYV2NkYGD4z/CIAQLkIBQjXBAqQFVBJIsAMwMMAVy4DMAAAAAASUVORK5CYII=)}#webamp .character-125{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAGCAYAAAAL+1RLAAAAIElEQVQYV2NkYGD4zwACj8AkA4McAwMjXBAmQU1BJIsACwMMAZBptUcAAAAASUVORK5CYII=)}#webamp .gen-text-a{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAGFBMVEUpKUA3N01bW21iYnN4eIZ/f4yNjZmUlKDQ9WnQAAAAIUlEQVQIHWMAAcZyAQamdAUGVrMABnGVQgY11yKGIIZUACkrA92ildtqAAAAAElFTkSuQmCC)}#webamp .gen-window.selected .gen-text-a{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAGFBMVEUpKUBGRlmNjZmbm6bGxszU1Nnx8fL///8iRh7bAAAAIUlEQVQIHWMAAcZyAQamdAUGVrMABnGVQgY11yKGIIZUACkrA92ildtqAAAAAElFTkSuQmCC)}#webamp .gen-text-b{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAHlBMVEUpKUAxMUdGRlliYnNqanpwcIB4eIZ/f4yNjZmUlKBMQpI+AAAAIUlEQVQI12NgAAHOmVOARIKlAgNnWyuQVRQuAOXOnMoAAFkvBehWf7S3AAAAAElFTkSuQmCC)}#webamp .gen-window.selected .gen-text-b{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAHlBMVEUpKUA3N01iYnObm6apqbO4uL/GxszU1Nnx8fL////s2d+PAAAAIUlEQVQI12NgAAHOmVOARIKlAgNnWyuQVRQuAOXOnMoAAFkvBehWf7S3AAAAAElFTkSuQmCC)}#webamp .gen-text-c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAJ1BMVEUpKUAxMUc3N00/P1NGRllUVGZbW21qanpwcIB4eIaGhpONjZmUlKBrx3tvAAAAJUlEQVQI12NgAAHWNZMZGHQSdzAw5DgwgAgFBgabgk6gxJ7JDABjoQaLYu6ObAAAAABJRU5ErkJggg==)}#webamp .gen-window.selected .gen-text-c{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAJ1BMVEUpKUA3N01GRllUVGZiYnN/f4yNjZmpqbO4uL/Gxszi4ubx8fL///9AK9zxAAAAJUlEQVQI12NgAAHWNZMZGHQSdzAw5DgwgAgFBgabgk6gxJ7JDABjoQaLYu6ObAAAAABJRU5ErkJggg==)}#webamp .gen-text-d{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAElBMVEUpKUBUVGZbW214eIaNjZmUlKBPxwelAAAAG0lEQVQI12NgAALTEAUGU6ZABlOGYAgGsUMUACkqA3OelxceAAAAAElFTkSuQmCC)}#webamp .gen-window.selected .gen-text-d{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAElBMVEUpKUB/f4yNjZnGxszx8fL///90u0SbAAAAG0lEQVQI12NgAALTEAUGU6ZABlOGYAgGsUMUACkqA3OelxceAAAAAElFTkSuQmCC)}#webamp .gen-text-e{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAHlBMVEUpKUA3N00/P1NGRllUVGZbW214eIZ/f4yNjZmUlKBpF6uKAAAAH0lEQVQI12NgAALOmVMZOBOAdJsDA2exABAbAcWmAQA4DwTidXJmqwAAAABJRU5ErkJggg==)}#webamp .gen-window.selected .gen-text-e{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAHlBMVEUpKUBGRllUVGZiYnN/f4yNjZnGxszU1Nnx8fL///+DgC81AAAAH0lEQVQI12NgAALOmVMZOBOAdJsDA2exABAbAcWmAQA4DwTidXJmqwAAAABJRU5ErkJggg==)}#webamp .gen-text-f{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAElBMVEUpKUA3N01GRllbW21qanqUlKC2H8YaAAAAGklEQVQI12NgAALT0CAGUwUg7SwAwSC2AgMAKTIC7Ms0rr0AAAAASUVORK5CYII=)}#webamp .gen-window.selected .gen-text-f{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAElBMVEUpKUBGRlliYnONjZmpqbP///9D5gpdAAAAGklEQVQI12NgAALT0CAGUwUg7SwAwSC2AgMAKTIC7Ms0rr0AAAAASUVORK5CYII=)}#webamp .gen-text-g{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAIVBMVEUpKUA/P1NGRllUVGZbW21wcIB4eIZ/f4yGhpONjZmUlKCnwN9hAAAAJ0lEQVQIHWMAA8aqZgYGzoQoAQYtBwYGBi2XVQoMnAVeCgyMXa0KAE4GBYcb4B3nAAAAAElFTkSuQmCC)}#webamp .gen-window.selected .gen-text-g{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAIVBMVEUpKUBUVGZiYnN/f4yNjZm4uL/GxszU1Nni4ubx8fL///+LwSrlAAAAJ0lEQVQIHWMAA8aqZgYGzoQoAQYtBwYGBi2XVQoMnAVeCgyMXa0KAE4GBYcb4B3nAAAAAElFTkSuQmCC)}#webamp .gen-text-h{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAJFBMVEUpKUBwcIBycoGCgo+hoauqqrO3t767u8O8vMPDw8nGxszKytD26YaTAAAAGElEQVQI12NgAAJphQoITl3BIO08A8YHADj6BOvV9DaxAAAAAElFTkSuQmCC)}#webamp .gen-window.selected .gen-text-h{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAFVBMVEUpKUCrq7TDw8no6Ovw8PH5+fr///9e3zXEAAAAFklEQVQI12NgAAIxgTQIDgFiozQYHwAqqAOv6ufnjgAAAABJRU5ErkJggg==)}#webamp .gen-text-i{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAHBAMAAADdS/HjAAAAFVBMVEUhITkkJDxra3xwcIBycoF6eoiCgo8pCsaXAAAAFUlEQVQI12MQEGQQCoQi4UQGERACABeTAqlm5PZ5AAAAAElFTkSuQmCC)}#webamp .gen-window.selected .gen-text-i{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAHBAMAAADdS/HjAAAAFVBMVEUkJDwxMULAwMfDw8ne3uHh4eXl5ehBk9l/AAAAFUlEQVQI12NgFGBgcgCjAAZmCEoAABAKAfHk6DTHAAAAAElFTkSuQmCC)}#webamp .gen-text-j{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAGFBMVEUpKUAxMUdGRllNTWBUVGZ4eIaNjZmUlKAAywzwAAAAE0lEQVQI12NgAIFSVCwCxOrJDAAh4QLodMJ9awAAAABJRU5ErkJggg==)}#webamp .gen-window.selected .gen-text-j{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAGFBMVEUpKUA3N01iYnNwcIB/f4zGxszx8fL///+/0FlwAAAAE0lEQVQI12NgAIFSVCwCxOrJDAAh4QLodMJ9awAAAABJRU5ErkJggg==)}#webamp .gen-text-k{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAHlBMVEUpKUAxMUc/P1NGRllNTWBUVGZbW22GhpONjZmUlKC0yuawAAAAIklEQVQI12NgAIFM00lAIiMBSHQGAImKAiDhNhVIGLYzAABxtgda2evVPQAAAABJRU5ErkJggg==)}#webamp .gen-window.selected .gen-text-k{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAHlBMVEUpKUA3N01UVGZiYnNwcIB/f4yNjZni4ubx8fL////1B4EGAAAAIklEQVQI12NgAIFM00lAIiMBSHQGAImKAiDhNhVIGLYzAABxtgda2evVPQAAAABJRU5ErkJggg==)}#webamp .gen-text-l{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAHBAMAAAAyiZrdAAAAElBMVEUpKUAxMUdGRll4eIZ/f4yUlKDDTNTnAAAAFUlEQVQI12NgAIJgNByiJMAQGqoAABtZAp1Ff+GZAAAAAElFTkSuQmCC)}#webamp .gen-window.selected .gen-text-l{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAHCAYAAADAp4fuAAAAMklEQVQYV2PU1HT4z4AGGP//////+PGzDMnJJXApaghevXqLoa9vFthMEBtsJrLlIAsBN0svzTt3mzcAAAAASUVORK5CYII=)}#webamp .gen-text-m{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAHBAMAAADHdxFtAAAAIVBMVEUpKUAxMUdGRllUVGZbW21iYnNwcIB4eIZ/f4yGhpOUlKBZcblpAAAAI0lEQVQI12NgAAGtJZzLGbRWaAGJrjIg4bUYSGguBBKqCcsBjp0JorkYhMsAAAAASUVORK5CYII=)}#webamp .gen-window.selected .gen-text-m{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAHBAMAAADHdxFtAAAAIVBMVEUpKUA3N01iYnN/f4yNjZmbm6a4uL/GxszU1Nni4ub////cS6NmAAAAI0lEQVQI12NgAAGtJZzLGbRWaAGJrjIg4bUYSGguBBKqCcsBjp0JorkYhMsAAAAASUVORK5CYII=)}#webamp .gen-text-n{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAHlBMVEUpKUAxMUc3N01GRllNTWBiYnNwcIB4eIaNjZmUlKCfa5y8AAAAIElEQVQI12NgAIIK5clMjA4MTP+NgPgKAxPDeiB+wwAASdwGGeDXGZQAAAAASUVORK5CYII=)}#webamp .gen-window.selected .gen-text-n{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAHlBMVEUpKUA3N01GRlliYnNwcICbm6a4uL/Gxszx8fL///8Fv7lnAAAAIElEQVQI12NgAIIK5clMjA4MTP+NgPgKAxPDeiB+wwAASdwGGeDXGZQAAAAASUVORK5CYII=)}#webamp .gen-text-o{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAHlBMVEUpKUA/P1NGRllUVGZbW214eIZ/f4yGhpONjZmUlKDmamWaAAAAHElEQVQI12NgAAKx6QYMrSwTGaYwTQFjEBsoBgBK6AZDMgIWOQAAAABJRU5ErkJggg==)}#webamp .gen-window.selected .gen-text-o{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAHlBMVEUpKUBUVGZiYnN/f4yNjZnGxszU1Nni4ubx8fL////xzWRAAAAAHElEQVQI12NgAAKx6QYMrSwTGaYwTQFjEBsoBgBK6AZDMgIWOQAAAABJRU5ErkJggg==)}#webamp .gen-text-p{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAJ1BMVEUpKUAxMUc/P1NGRllNTWBbW21iYnNqanpwcIB4eIZ/f4yGhpOUlKBLTaK7AAAAIElEQVQI12NgAIKYM5sYYgxPMMSEHGeIWZnIEGPAAMIAZzYHJUki1qIAAAAASUVORK5CYII=)}#webamp .gen-window.selected .gen-text-p{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAJ1BMVEUpKUA3N01UVGZiYnNwcICNjZmbm6apqbO4uL/GxszU1Nni4ub////2OqNjAAAAIElEQVQI12NgAIKYM5sYYgxPMMSEHGeIWZnIEGPAAMIAZzYHJUki1qIAAAAASUVORK5CYII=)}#webamp .gen-text-q{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAJFBMVEUpKUA3N00/P1NGRllUVGZbW214eIZ/f4yGhpONjZmSkp6UlKAHPYNOAAAAI0lEQVQI12NgAAGm6hYGBs6EaAEG6wDrAAjBmdBtAJTY1QAAWmwG3UPBF3oAAAAASUVORK5CYII=)}#webamp .gen-window.selected .gen-text-q{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAJ1BMVEUpKUBGRllUVGZiYnN/f4yNjZm4uMDGxszU1Nni4ubx8fL7+/v////Rx7x8AAAAI0lEQVQI12NgAAGmnikMDFwFMQIMNgE2ARCCq2COAVDidAIAYQkHOMhnyMoAAAAASUVORK5CYII=)}#webamp .gen-text-r{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAJ1BMVEUpKUAxMUc3N01GRllUVGZbW21qanpwcIB4eIZ/f4yGhpONjZmUlKDditvQAAAAIklEQVQI12NgAAGbM1uARMAcILHiJJBIPwQkQo4AicCTDACHOAih1LnoFgAAAABJRU5ErkJggg==)}#webamp .gen-window.selected .gen-text-r{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAJ1BMVEUpKUA3N01GRlliYnN/f4yNjZmpqbO4uL/GxszU1Nni4ubx8fL///9vCc2uAAAAIklEQVQI12NgAAGbM1uARMAcILHiJJBIPwQkQo4AicCTDACHOAih1LnoFgAAAABJRU5ErkJggg==)}#webamp .gen-text-s{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAJFBMVEUpKUAxMUc/P1NGRllUVGZbW21qanpwcIB4eIaGhpONjZmUlKCHjnJIAAAAIklEQVQIHWMAAY1dAQzVygoM1TsDGMRmb2IIZdvE4LnLAQBTHAco/pVKOwAAAABJRU5ErkJggg==)}#webamp .gen-window.selected .gen-text-s{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAJFBMVEUpKUA3N01UVGZiYnN/f4yNjZmpqbO4uL/Gxszi4ubx8fL///+qJyS0AAAAIklEQVQIHWMAAY1dAQzVygoM1TsDGMRmb2IIZdvE4LnLAQBTHAco/pVKOwAAAABJRU5ErkJggg==)}#webamp .gen-text-t{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAHCAYAAADAp4fuAAAALklEQVQYV2PU0XH+z4AGGCdMmIMpqKZq819FVZHBzc2eYfXqLQyvX71hYKSBIACnryn7i49aBgAAAABJRU5ErkJggg==)}#webamp .gen-window.selected .gen-text-t{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAHAgMAAAC9yW99AAAADFBMVEUpKUBUVGZycoH///9VDRy9AAAAE0lEQVQI12NgYGD4f4BBlwEZAQAkDAKhcYNEwQAAAABJRU5ErkJggg==)}#webamp .gen-text-u{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAFVBMVEUpKUAxMUdGRllUVGZbW21qanqUlKDA77WeAAAAFklEQVQI12NgAAI3hRRUHJLMIJoWAAA5UATxAlDxBQAAAABJRU5ErkJggg==)}#webamp .gen-window.selected .gen-text-u{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAFVBMVEUpKUA3N01iYnN/f4yNjZmpqbP///8SF7O4AAAAFklEQVQI12NgAAI3hRRUHJLMIJoWAAA5UATxAlDxBQAAAABJRU5ErkJggg==)}#webamp .gen-text-v{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAKlBMVEUpKUAxMUc/P1NGRllNTWBUVGZbW21iYnNqanpwcIB4eIaGhpONjZmUlKDthvA2AAAAIklEQVQIHWMAAd8EWQaeDTEMHJeWMzDfvMTAsHcDA0NtAgBSrAdcNQnv8gAAAABJRU5ErkJggg==)}#webamp .gen-window.selected .gen-text-v{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAKlBMVEUpKUA3N01UVGZiYnNwcIB/f4yNjZmbm6apqbO4uL/Gxszi4ubx8fL///81zHafAAAAIklEQVQIHWMAAd8EWQaeDTEMHJeWMzDfvMTAsHcDA0NtAgBSrAdcNQnv8gAAAABJRU5ErkJggg==)}#webamp .gen-text-w{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAHBAMAAADHdxFtAAAALVBMVEUpKUAxMUc3N00/P1NGRllNTWBUVGZbW21iYnNqanpwcIB4eIZ/f4yNjZmUlKD3PA89AAAAKUlEQVQIHWMAg3nqT/wY8rKfdzPIzXt9nIHnXd9jBo7XcRcYWJ7zLQAAwo4M1uKKXVEAAAAASUVORK5CYII=)}#webamp .gen-window.selected .gen-text-w{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAHBAMAAADHdxFtAAAALVBMVEUpKUA3N01GRllUVGZiYnNwcIB/f4yNjZmbm6apqbO4uL/GxszU1Nnx8fL///+8HCoLAAAAKUlEQVQIHWMAg3nqT/wY8rKfdzPIzXt9nIHnXd9jBo7XcRcYWJ7zLQAAwo4M1uKKXVEAAAAASUVORK5CYII=)}#webamp .gen-text-x{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAJFBMVEUpKUAxMUc3N01GRllNTWBbW21iYnNwcIB4eIaGhpONjZmUlKDqWCJLAAAAJElEQVQI12NgAAHJiVECDMzbtwCZ2Q0gYhEDA/PWHUCJhOwAAGilBx+T4WwNAAAAAElFTkSuQmCC)}#webamp .gen-window.selected .gen-text-x{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHBAMAAAA2fErgAAAAJFBMVEUpKUA3N01GRlliYnNwcICNjZmbm6a4uL/Gxszi4ubx8fL///+x/boCAAAAJElEQVQI12NgAAHJiVECDMzbtwCZ2Q0gYhEDA/PWHUCJhOwAAGilBx+T4WwNAAAAAElFTkSuQmCC)}#webamp .gen-text-y{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAJFBMVEUpKUAxMUc/P1NGRllNTWBUVGZbW21iYnN4eIaGhpONjZmUlKAsqFJVAAAAHklEQVQI12NgAIIdrJsYsrMKGDh3CTCwbGNgYIZgAE8aBbSrMTxDAAAAAElFTkSuQmCC)}#webamp .gen-window.selected .gen-text-y{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAHBAMAAADZviHeAAAAJFBMVEUpKUA3N01UVGZiYnNwcIB/f4yNjZmbm6bGxszi4ubx8fL///+UuWJCAAAAHklEQVQI12NgAIIdrJsYsrMKGDh3CTCwbGNgYIZgAE8aBbSrMTxDAAAAAElFTkSuQmCC)}#webamp .gen-text-z{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAHBAMAAAAsQKpuAAAAIVBMVEUAAAApKUAxMUc/P1NGRllbW21qanp4eIZ/f4yGhpOUlKAeeVtyAAAAAXRSTlMAQObYZgAAACdJREFUCNdjEBQUYACCqlULQJRgVgCIElkBFtRcDKaiShxA1CqwEgClfwdsfnJFGQAAAABJRU5ErkJggg==)}#webamp .gen-window.selected .gen-text-z{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAHBAMAAAAsQKpuAAAAIVBMVEUAAAApKUA3N01UVGZiYnONjZmpqbPGxszU1Nni4ub///8EpbEBAAAAAXRSTlMAQObYZgAAACdJREFUCNdjEBQUYACCqlULQJRgVgCIElkBFtRcDKaiShxA1CqwEgClfwdsfnJFGQAAAABJRU5ErkJggg==)}#webamp .gen-text-a,#webamp .selected .gen-text-a{width:6px}#webamp .gen-text-b,#webamp .gen-text-c,#webamp .selected .gen-text-b,#webamp .selected .gen-text-c{width:7px}#webamp .gen-text-d,#webamp .gen-text-e,#webamp .gen-text-f,#webamp .selected .gen-text-d,#webamp .selected .gen-text-e,#webamp .selected .gen-text-f{width:6px}#webamp .gen-text-g,#webamp .selected .gen-text-g{width:7px}#webamp .gen-text-h,#webamp .selected .gen-text-h{width:6px}#webamp .gen-text-i,#webamp .selected .gen-text-i{width:4px}#webamp .gen-text-j,#webamp .selected .gen-text-j{width:6px}#webamp .gen-text-k,#webamp .selected .gen-text-k{width:7px}#webamp .gen-text-l,#webamp .selected .gen-text-l{width:5px}#webamp .gen-text-m,#webamp .selected .gen-text-m{width:8px}#webamp .gen-text-n,#webamp .gen-text-o,#webamp .gen-text-p,#webamp .selected .gen-text-n,#webamp .selected .gen-text-o,#webamp .selected .gen-text-p{width:6px}#webamp .gen-text-q,#webamp .gen-text-r,#webamp .selected .gen-text-q,#webamp .selected .gen-text-r{width:7px}#webamp .gen-text-s,#webamp .selected .gen-text-s{width:6px}#webamp .gen-text-t,#webamp .selected .gen-text-t{width:5px}#webamp .gen-text-u,#webamp .gen-text-v,#webamp .selected .gen-text-u,#webamp .selected .gen-text-v{width:6px}#webamp .gen-text-w,#webamp .selected .gen-text-w{width:8px}#webamp .gen-text-x,#webamp .selected .gen-text-x{width:7px}#webamp .gen-text-y,#webamp .selected .gen-text-y{width:6px}#webamp .gen-text-z,#webamp .selected .gen-text-z{width:11px}#webamp #title-bar #close{cursor:url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAgICAAMDAwAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4gAAAAAAAAAAAAAAAAAAAf4AAAAAAAAAAAAAAAAAAB/gAAIgAAAAAAAAAAAAAAAf4AACAAAAAAAAAAAAAcAB/gAAAAAAAAAAAAAAAAHgAf4AAAAAAAAAAAAAAAAB/gPgAAADwAAAAAAAAAAAAf/gAAAAA8AAAAAAAAAAAAH//iIiAAPAAAAAAAAAAAAB//4iIAADwAAAAAAAAAAAAf/iIgAAA8AAAAAAAAAAAAH/4iAAAAAAAAAAAAAAAAAB/iIAAAAAAAAAAAAAAAAAAf4gAAAAAAAAAAAAAAAAAAHiAAAAAAAAAAAAAAAAAAAB4AAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//////////////////////////////////////////////////////////////////////j////w////8P///+HP//3hz//8w8///EP///wHz//8AE///ADP//wBz//8A8///AfP//wP///8H////D////x////8/////f////w==),auto}#webamp #equalizer-window .band{cursor:url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAwMDAAICAgAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPcAAAAAAAAAAAAAAAAAAA/3cAAAAAAAAAAAAACHcAAAAAAAAAAAAAAAAAAAj3AAAAAAAAAAAAAAAAAACPcAAAAAAAAAAAAAAAAAAAj3AAAA9wAAAAAAAAAAgACPcAAAAPcAAAAAAAAAAIcAj3AAAAAAAAAAAAAAAACPcPcAAAAAAAAAAAAAAAAAj/cAAAAAAAAAAAAAAAAAAI//d3dwAA/3cAAAAAAAAACP/3d3AAAA9wAAAAAAAAAAj/d3cAAAAAAAAAAAAAAAAI/3dwAAAAAAAAAAAAAAAACPd3AAAAAAAAAAAAAAAAAAj3cAAAAAAAAAAAAAAAAAAIdwAAAAAAAAAAAAAAAAAACHAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD////////////////////////////////////////////////////////////8////+H///jA///wwP//8P///+Hz//3h4f/8w+H//EPz//wH///8AED//ADA//wB4f/8A/P//Af///wP///8H////D////x////8/////f////w==),auto}#webamp #equalizer-window.shade,#webamp #equalizer-window.shade input,#webamp #equalizer-window .title-bar{cursor:url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAwMDAAICAgAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD3AAAAAAAAAAAAAAAAAAAP93AAAAAAAAAAAACHcAAAAAAAAAAAAAAAAAAAj3AAAAAAAAAAAAAAAAAACPcAAHAAAAAHAAAAAAAAAAj3AAdwAHcAB3AAAAAAgACPcAAP8AD/AA/wAAAAAIcAj3AAAPAAAAAPAAAAAACPcPcAAAAAAAAAAAAAAAAAj/cAAAAAAAAAAAAAAAAAAI//d3dwAAAP93AAAAAAAACP/3d3AAAAAPcAAAAAAAAAj/d3cAAAAAAAAAAAAAAAAI/3dwAAAAAAAAAAAAAAAACPd3AAAAAAAAAAAAAAAAAAj3cAAAAAAAAAAAAAAAAAAIdwAAAAAAAAAAAAAAAAAACHAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////////////////////////////P////h///jwP//w8D//8M/P/+GMx/3hCEP8wwhD/EOMx/wHz8/8AHA//ADwP/wB+H/8A/z//Af///wP///8H////D////x////8/////f////w==),auto}#webamp #main-window,#webamp #main-window.shade #title-bar,#webamp #playlist-window,#webamp .window,#webamp .window input{cursor:url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAgICAAMDAwAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4gAAAAAAAAAAAAAAAAAAAf4AAAAAAAAAAAAAAAAAAB/gAAAAAAAAAAAAAAAAAAAf4AAAAAAAAAAAAAAAAcAB/gAAAAAAAAAAAAAAAAHgAf4AAAAAAAAAAAAAAAAB/gPgAAAAAAAAAAAAAAAAAf/gAAAAAAAAAAAAAAAAAAH//iIiAAAAAAAAAAAAAAAB//4iIAAAAAAAAAAAAAAAAf/iIgAAAAAAAAAAAAAAAAH/4iAAAAAAAAAAAAAAAAAB/iIAAAAAAAAAAAAAAAAAAf4gAAAAAAAAAAAAAAAAAAHiAAAAAAAAAAAAAAAAAAAB4AAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//////////////////////////////////////////////////////////////////////j////w////8P///+H///3h///8w////EP///wH///8AH///AD///wB///8A////Af///wP///8H////D////x////8/////f////w==),auto}#webamp #playlist-window .playlist-top{cursor:url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAwMDAAICAgAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD3AAAAAAAAAAAAAAAAAAAP93AAAAAAAAAAAACHcAAAAAAAAAAAAAAAAAAAj3AAAAAAAAAAAAAAAAAACPcAAHAAAAAHAAAAAAAAAAj3AAdwAHcAB3AAAAAAgACPcAAP8AD/AA/wAAAAAIcAj3AAAPAAAAAPAAAAAACPcPcAAAAAAAAAAAAAAAAAj/cAAAAAAAAAAAAAAAAAAI//d3dwAAAP93AAAAAAAACP/3d3AAAAAPcAAAAAAAAAj/d3cAAAAAAAAAAAAAAAAI/3dwAAAAAAAAAAAAAAAACPd3AAAAAAAAAAAAAAAAAAj3cAAAAAAAAAAAAAAAAAAIdwAAAAAAAAAAAAAAAAAACHAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////////////////////////////P////h///jwP//w8D//8M/P/+GMx/3hCEP8wwhD/EOMx/wHz8/8AHA//ADwP/wB+H/8A/z//Af///wP///8H////D////x////8/////f////w==),auto}#webamp #main-window #position{cursor:url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAwMDAAICAgAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACHcAAAAAAAAAAAAAAAAAAAj3AAAAAAAAAAAAAAAAAACPcAAHAAAAAHAAAAAAAAAAj3AAdwAHcAB3AAAAAAgACPcAAP8AD/AA/wAAAAAIcAj3AAAPAAAAAPAAAAAACPcPcAAAAAAAAAAAAAAAAAj/cAAAAAAAAAAAAAAAAAAI//d3dwAAAAAAAAAAAAAACP/3d3AAAAAAAAAAAAAAAAj/d3cAAAAAAAAAAAAAAAAI/3dwAAAAAAAAAAAAAAAACPd3AAAAAAAAAAAAAAAAAAj3cAAAAAAAAAAAAAAAAAAIdwAAAAAAAAAAAAAAAAAACHAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//////////////////////////////////////////////////////////////////////j////w////8M/P/+GMx/3hCEP8wwhD/EOMx/wHz8/8AH///AD///wB///8A////Af///wP///8H////D////x////8/////f////w==),auto}#webamp #playlist-window #playlist-resize-target{cursor:url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAwMDAAICAgAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPcAAAAAAAAAAAAAAAAAAA/3cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACHcAAAAAAAAAAAAAAAAAAAj3AAAAAAcAAAAAAAAAAACPcAAAdwAHcAAAAAAAAAAAj3AAAP8AD/AAAAAAAAgACPcAAAAAAA8AAAAAAAAIcAj3AAAAAAAAAAAAAAAACPcPcAAAAAAAAAAAAAAAAAj/cAAAAAAAAAAAAAAAAAAI//d3dwAAAAAAAAAAAAAACP/3d3AAAAAAAAAAAAAAAAj/d3cAAAAAAAAAAAAAAAAI/3dwAAAAAAAAAAAAAAAACPd3AAAAAAAAAAAAAAAAAAj3cAAAAAAAAAAAAAAAAAAIdwAAAAAAAAAAAAAAAAAACHAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///////////////////////////////////////////////////////n////w////4H///iB///w/n//8OY//+HCH/3hwh/8w+Y//EP+f/wH///8AH///AD///wB///8A////Af///wP///8H////D////x////8/////f////w==),auto}#webamp #playlist-window .playlist-scrollbar{cursor:url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAwMDAAICAgAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPcAAAAAAAAAAAAAAAAAAA/3cAAAAAAAAAAAAACHcAAAAAAAAAAAAAAAAAAAj3AAAAAAAAAAAAAAAAAACPcAAAAAAAAAAAAAAAAAAAj3AAAA9wAAAAAAAAAAgACPcAAAAPcAAAAAAAAAAIcAj3AAAAAAAAAAAAAAAACPcPcAAAAAAAAAAAAAAAAAj/cAAAAAAAAAAAAAAAAAAI//d3dwAA/3cAAAAAAAAACP/3d3AAAA9wAAAAAAAAAAj/d3cAAAAAAAAAAAAAAAAI/3dwAAAAAAAAAAAAAAAACPd3AAAAAAAAAAAAAAAAAAj3cAAAAAAAAAAAAAAAAAAIdwAAAAAAAAAAAAAAAAAACHAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD////////////////////////////////////////////////////////////8////+H///jA///wwP//8P///+Hz//3h4f/8w+H//EPz//wH///8AED//ADA//wB4f/8A/P//Af///wP///8H////D////x////8/////f////w==),auto}#webamp #main-window #title-bar{cursor:url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAwMDAAICAgAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD3AAAAAAAAAAAAAAAAAAAP93AAAAAAAAAAAACHcAAAAAAAAAAAAAAAAAAAj3AAAAAAAAAAAAAAAAAACPcAAHAAAAAHAAAAAAAAAAj3AAdwAHcAB3AAAAAAgACPcAAP8AD/AA/wAAAAAIcAj3AAAPAAAAAPAAAAAACPcPcAAAAAAAAAAAAAAAAAj/cAAAAAAAAAAAAAAAAAAI//d3dwAAAP93AAAAAAAACP/3d3AAAAAPcAAAAAAAAAj/d3cAAAAAAAAAAAAAAAAI/3dwAAAAAAAAAAAAAAAACPd3AAAAAAAAAAAAAAAAAAj3cAAAAAAAAAAAAAAAAAAIdwAAAAAAAAAAAAAAAAAACHAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////////////////////////////P////h///jwP//w8D//8M/P/+GMx/3hCEP8wwhD/EOMx/wHz8/8AHA//ADwP/wB+H/8A/z//Af///wP///8H////D////x////8/////f////w==),auto}#webamp #balance,#webamp #volume,#webamp #volume input{cursor:url(data:image/x-win-bitmap;base64,AAACAAEAICAAAAAAAADoAgAAFgAAACgAAAAgAAAAQAAAAAEABAAAAAAAgAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAACAAAAAgIAAgAAAAIAAgACAgAAAwMDAAICAgAAAAP8AAP8AAAD//wD/AAAA/wD/AP//AAD///8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACHcAAAAAAAAAAAAAAAAAAAj3AAAAAAAAAAAAAAAAAACPcAAHAAAAAHAAAAAAAAAAj3AAdwAHcAB3AAAAAAgACPcAAP8AD/AA/wAAAAAIcAj3AAAPAAAAAPAAAAAACPcPcAAAAAAAAAAAAAAAAAj/cAAAAAAAAAAAAAAAAAAI//d3dwAAAAAAAAAAAAAACP/3d3AAAAAAAAAAAAAAAAj/d3cAAAAAAAAAAAAAAAAI/3dwAAAAAAAAAAAAAAAACPd3AAAAAAAAAAAAAAAAAAj3cAAAAAAAAAAAAAAAAAAIdwAAAAAAAAAAAAAAAAAACHAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD//////////////////////////////////////////////////////////////////////j////w////8M/P/+GMx/3hCEP8wwhD/EOMx/wHz8/8AH///AD///wB///8A////Af///wP///8H////D////x////8/////f////w==),auto}", ""]);
          },
          /* 102 */
          /***/
          function(module2, exports2) {
            exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
              var e, m;
              var eLen = nBytes * 8 - mLen - 1;
              var eMax = (1 << eLen) - 1;
              var eBias = eMax >> 1;
              var nBits = -7;
              var i = isLE ? nBytes - 1 : 0;
              var d = isLE ? -1 : 1;
              var s = buffer[offset + i];
              i += d;
              e = s & (1 << -nBits) - 1;
              s >>= -nBits;
              nBits += eLen;
              for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
              }
              m = e & (1 << -nBits) - 1;
              e >>= -nBits;
              nBits += mLen;
              for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
              }
              if (e === 0) {
                e = 1 - eBias;
              } else if (e === eMax) {
                return m ? NaN : (s ? -1 : 1) * Infinity;
              } else {
                m = m + Math.pow(2, mLen);
                e = e - eBias;
              }
              return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
            };
            exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
              var e, m, c;
              var eLen = nBytes * 8 - mLen - 1;
              var eMax = (1 << eLen) - 1;
              var eBias = eMax >> 1;
              var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
              var i = isLE ? 0 : nBytes - 1;
              var d = isLE ? 1 : -1;
              var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
              value = Math.abs(value);
              if (isNaN(value) || value === Infinity) {
                m = isNaN(value) ? 1 : 0;
                e = eMax;
              } else {
                e = Math.floor(Math.log(value) / Math.LN2);
                if (value * (c = Math.pow(2, -e)) < 1) {
                  e--;
                  c *= 2;
                }
                if (e + eBias >= 1) {
                  value += rt / c;
                } else {
                  value += rt * Math.pow(2, 1 - eBias);
                }
                if (value * c >= 2) {
                  e++;
                  c /= 2;
                }
                if (e + eBias >= eMax) {
                  m = 0;
                  e = eMax;
                } else if (e + eBias >= 1) {
                  m = (value * c - 1) * Math.pow(2, mLen);
                  e = e + eBias;
                } else {
                  m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                  e = 0;
                }
              }
              for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
              }
              e = e << mLen | m;
              eLen += mLen;
              for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
              }
              buffer[offset + i - d] |= s * 128;
            };
          },
          /* 103 */
          /***/
          function(module2, exports2) {
            var toString = {}.toString;
            module2.exports = Array.isArray || function(arr) {
              return toString.call(arr) == "[object Array]";
            };
          },
          /* 104 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            (function(global) {
              var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
              var apply = Function.prototype.apply;
              exports2.setTimeout = function() {
                return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
              };
              exports2.setInterval = function() {
                return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
              };
              exports2.clearTimeout = exports2.clearInterval = function(timeout) {
                if (timeout) {
                  timeout.close();
                }
              };
              function Timeout(id, clearFn) {
                this._id = id;
                this._clearFn = clearFn;
              }
              Timeout.prototype.unref = Timeout.prototype.ref = function() {
              };
              Timeout.prototype.close = function() {
                this._clearFn.call(scope, this._id);
              };
              exports2.enroll = function(item, msecs) {
                clearTimeout(item._idleTimeoutId);
                item._idleTimeout = msecs;
              };
              exports2.unenroll = function(item) {
                clearTimeout(item._idleTimeoutId);
                item._idleTimeout = -1;
              };
              exports2._unrefActive = exports2.active = function(item) {
                clearTimeout(item._idleTimeoutId);
                var msecs = item._idleTimeout;
                if (msecs >= 0) {
                  item._idleTimeoutId = setTimeout(function onTimeout() {
                    if (item._onTimeout)
                      item._onTimeout();
                  }, msecs);
                }
              };
              __webpack_require__2(119);
              exports2.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
              exports2.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
            }).call(this, __webpack_require__2(17));
          },
          /* 105 */
          /***/
          function(module, exports, __webpack_require__) {
            "use strict";
            (function(Buffer) {
              const { stringToBytes, readUInt64LE, tarHeaderChecksumMatches, uint8ArrayUtf8ByteString } = __webpack_require__(131);
              const xpiZipFilename = stringToBytes("META-INF/mozilla.rsa");
              const oxmlContentTypes = stringToBytes("[Content_Types].xml");
              const oxmlRels = stringToBytes("_rels/.rels");
              const fileType = (input) => {
                if (!(input instanceof Uint8Array || input instanceof ArrayBuffer || Buffer.isBuffer(input))) {
                  throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof input}\``);
                }
                const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);
                if (!(buffer && buffer.length > 1)) {
                  return;
                }
                const check = (header, options) => {
                  options = Object.assign({
                    offset: 0
                  }, options);
                  for (let i = 0; i < header.length; i++) {
                    if (options.mask) {
                      if (header[i] !== (options.mask[i] & buffer[i + options.offset])) {
                        return false;
                      }
                    } else if (header[i] !== buffer[i + options.offset]) {
                      return false;
                    }
                  }
                  return true;
                };
                const checkString = (header, options) => check(stringToBytes(header), options);
                if (check([255, 216, 255])) {
                  return {
                    ext: "jpg",
                    mime: "image/jpeg"
                  };
                }
                if (check([137, 80, 78, 71, 13, 10, 26, 10])) {
                  return {
                    ext: "png",
                    mime: "image/png"
                  };
                }
                if (check([71, 73, 70])) {
                  return {
                    ext: "gif",
                    mime: "image/gif"
                  };
                }
                if (check([87, 69, 66, 80], { offset: 8 })) {
                  return {
                    ext: "webp",
                    mime: "image/webp"
                  };
                }
                if (check([70, 76, 73, 70])) {
                  return {
                    ext: "flif",
                    mime: "image/flif"
                  };
                }
                if ((check([73, 73, 42, 0]) || check([77, 77, 0, 42])) && check([67, 82], { offset: 8 })) {
                  return {
                    ext: "cr2",
                    mime: "image/x-canon-cr2"
                  };
                }
                if (check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
                  return {
                    ext: "orf",
                    mime: "image/x-olympus-orf"
                  };
                }
                if (check([73, 73, 42, 0, 16, 251, 134, 1])) {
                  return {
                    ext: "arw",
                    mime: "image/x-sony-arw"
                  };
                }
                if (check([73, 73, 42, 0, 8, 0, 0, 0, 45])) {
                  return {
                    ext: "dng",
                    mime: "image/x-adobe-dng"
                  };
                }
                if (check([73, 73, 42, 0, 48, 61, 114, 1, 28])) {
                  return {
                    ext: "nef",
                    mime: "image/x-nikon-nef"
                  };
                }
                if (check([73, 73, 42, 0]) || check([77, 77, 0, 42])) {
                  return {
                    ext: "tif",
                    mime: "image/tiff"
                  };
                }
                if (check([66, 77])) {
                  return {
                    ext: "bmp",
                    mime: "image/bmp"
                  };
                }
                if (check([73, 73, 188])) {
                  return {
                    ext: "jxr",
                    mime: "image/vnd.ms-photo"
                  };
                }
                if (check([56, 66, 80, 83])) {
                  return {
                    ext: "psd",
                    mime: "image/vnd.adobe.photoshop"
                  };
                }
                if (check([80, 75, 3, 4])) {
                  if (check([109, 105, 109, 101, 116, 121, 112, 101, 97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110, 47, 101, 112, 117, 98, 43, 122, 105, 112], { offset: 30 })) {
                    return {
                      ext: "epub",
                      mime: "application/epub+zip"
                    };
                  }
                  if (check(xpiZipFilename, { offset: 30 })) {
                    return {
                      ext: "xpi",
                      mime: "application/x-xpinstall"
                    };
                  }
                  if (checkString("mimetypeapplication/vnd.oasis.opendocument.text", { offset: 30 })) {
                    return {
                      ext: "odt",
                      mime: "application/vnd.oasis.opendocument.text"
                    };
                  }
                  if (checkString("mimetypeapplication/vnd.oasis.opendocument.spreadsheet", { offset: 30 })) {
                    return {
                      ext: "ods",
                      mime: "application/vnd.oasis.opendocument.spreadsheet"
                    };
                  }
                  if (checkString("mimetypeapplication/vnd.oasis.opendocument.presentation", { offset: 30 })) {
                    return {
                      ext: "odp",
                      mime: "application/vnd.oasis.opendocument.presentation"
                    };
                  }
                  const findNextZipHeaderIndex = (arr, startAt = 0) => arr.findIndex((el, i, arr2) => i >= startAt && arr2[i] === 80 && arr2[i + 1] === 75 && arr2[i + 2] === 3 && arr2[i + 3] === 4);
                  let zipHeaderIndex = 0;
                  let oxmlFound = false;
                  let type;
                  do {
                    const offset = zipHeaderIndex + 30;
                    if (!oxmlFound) {
                      oxmlFound = check(oxmlContentTypes, { offset }) || check(oxmlRels, { offset });
                    }
                    if (!type) {
                      if (checkString("word/", { offset })) {
                        type = {
                          ext: "docx",
                          mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                        };
                      } else if (checkString("ppt/", { offset })) {
                        type = {
                          ext: "pptx",
                          mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
                        };
                      } else if (checkString("xl/", { offset })) {
                        type = {
                          ext: "xlsx",
                          mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                        };
                      }
                    }
                    if (oxmlFound && type) {
                      return type;
                    }
                    zipHeaderIndex = findNextZipHeaderIndex(buffer, offset);
                  } while (zipHeaderIndex >= 0);
                  if (type) {
                    return type;
                  }
                }
                if (check([80, 75]) && (buffer[2] === 3 || buffer[2] === 5 || buffer[2] === 7) && (buffer[3] === 4 || buffer[3] === 6 || buffer[3] === 8)) {
                  return {
                    ext: "zip",
                    mime: "application/zip"
                  };
                }
                if (check([48, 48, 48, 48, 48, 48], { offset: 148, mask: [248, 248, 248, 248, 248, 248] }) && // Valid tar checksum
                tarHeaderChecksumMatches(buffer)) {
                  return {
                    ext: "tar",
                    mime: "application/x-tar"
                  };
                }
                if (check([82, 97, 114, 33, 26, 7]) && (buffer[6] === 0 || buffer[6] === 1)) {
                  return {
                    ext: "rar",
                    mime: "application/x-rar-compressed"
                  };
                }
                if (check([31, 139, 8])) {
                  return {
                    ext: "gz",
                    mime: "application/gzip"
                  };
                }
                if (check([66, 90, 104])) {
                  return {
                    ext: "bz2",
                    mime: "application/x-bzip2"
                  };
                }
                if (check([55, 122, 188, 175, 39, 28])) {
                  return {
                    ext: "7z",
                    mime: "application/x-7z-compressed"
                  };
                }
                if (check([120, 1])) {
                  return {
                    ext: "dmg",
                    mime: "application/x-apple-diskimage"
                  };
                }
                if (check([102, 114, 101, 101], { offset: 4 }) || // `free`
                check([109, 100, 97, 116], { offset: 4 }) || // `mdat` MJPEG
                check([109, 111, 111, 118], { offset: 4 }) || // `moov`
                check([119, 105, 100, 101], { offset: 4 })) {
                  return {
                    ext: "mov",
                    mime: "video/quicktime"
                  };
                }
                if (check([102, 116, 121, 112], { offset: 4 }) && // `ftyp`
                (buffer[8] & 96) !== 0 && (buffer[9] & 96) !== 0 && (buffer[10] & 96) !== 0 && (buffer[11] & 96) !== 0) {
                  const brandMajor = uint8ArrayUtf8ByteString(buffer, 8, 12);
                  switch (brandMajor) {
                    case "mif1":
                      return { ext: "heic", mime: "image/heif" };
                    case "msf1":
                      return { ext: "heic", mime: "image/heif-sequence" };
                    case "heic":
                    case "heix":
                      return { ext: "heic", mime: "image/heic" };
                    case "hevc":
                    case "hevx":
                      return { ext: "heic", mime: "image/heic-sequence" };
                    case "qt  ":
                      return { ext: "mov", mime: "video/quicktime" };
                    case "M4V ":
                    case "M4VH":
                    case "M4VP":
                      return { ext: "m4v", mime: "video/x-m4v" };
                    case "M4P ":
                      return { ext: "m4p", mime: "video/mp4" };
                    case "M4B ":
                      return { ext: "m4b", mime: "audio/mp4" };
                    case "M4A ":
                      return { ext: "m4a", mime: "audio/x-m4a" };
                    case "F4V ":
                      return { ext: "f4v", mime: "video/mp4" };
                    case "F4P ":
                      return { ext: "f4p", mime: "video/mp4" };
                    case "F4A ":
                      return { ext: "f4a", mime: "audio/mp4" };
                    case "F4B ":
                      return { ext: "f4b", mime: "audio/mp4" };
                    default:
                      if (brandMajor.startsWith("3g")) {
                        if (brandMajor.startsWith("3g2")) {
                          return { ext: "3g2", mime: "video/3gpp2" };
                        }
                        return { ext: "3gp", mime: "video/3gpp" };
                      }
                      return { ext: "mp4", mime: "video/mp4" };
                  }
                }
                if (check([77, 84, 104, 100])) {
                  return {
                    ext: "mid",
                    mime: "audio/midi"
                  };
                }
                if (check([26, 69, 223, 163])) {
                  const sliced = buffer.subarray(4, 4 + 4096);
                  const idPos = sliced.findIndex((el, i, arr) => arr[i] === 66 && arr[i + 1] === 130);
                  if (idPos !== -1) {
                    const docTypePos = idPos + 3;
                    const findDocType = (type) => [...type].every((c, i) => sliced[docTypePos + i] === c.charCodeAt(0));
                    if (findDocType("matroska")) {
                      return {
                        ext: "mkv",
                        mime: "video/x-matroska"
                      };
                    }
                    if (findDocType("webm")) {
                      return {
                        ext: "webm",
                        mime: "video/webm"
                      };
                    }
                  }
                }
                if (check([82, 73, 70, 70])) {
                  if (check([65, 86, 73], { offset: 8 })) {
                    return {
                      ext: "avi",
                      mime: "video/vnd.avi"
                    };
                  }
                  if (check([87, 65, 86, 69], { offset: 8 })) {
                    return {
                      ext: "wav",
                      mime: "audio/vnd.wave"
                    };
                  }
                  if (check([81, 76, 67, 77], { offset: 8 })) {
                    return {
                      ext: "qcp",
                      mime: "audio/qcelp"
                    };
                  }
                }
                if (check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
                  let offset = 30;
                  do {
                    const objectSize = readUInt64LE(buffer, offset + 16);
                    if (check([145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101], { offset })) {
                      if (check([64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43], { offset: offset + 24 })) {
                        return {
                          ext: "wma",
                          mime: "audio/x-ms-wma"
                        };
                      }
                      if (check([192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43], { offset: offset + 24 })) {
                        return {
                          ext: "wmv",
                          mime: "video/x-ms-asf"
                        };
                      }
                      break;
                    }
                    offset += objectSize;
                  } while (offset + 24 <= buffer.length);
                  return {
                    ext: "asf",
                    mime: "application/vnd.ms-asf"
                  };
                }
                if (check([0, 0, 1, 186]) || check([0, 0, 1, 179])) {
                  return {
                    ext: "mpg",
                    mime: "video/mpeg"
                  };
                }
                for (let start = 0; start < 2 && start < buffer.length - 16; start++) {
                  if (check([73, 68, 51], { offset: start }) || // ID3 header
                  check([255, 226], { offset: start, mask: [255, 230] })) {
                    return {
                      ext: "mp3",
                      mime: "audio/mpeg"
                    };
                  }
                  if (check([255, 228], { offset: start, mask: [255, 230] })) {
                    return {
                      ext: "mp2",
                      mime: "audio/mpeg"
                    };
                  }
                  if (check([255, 248], { offset: start, mask: [255, 252] })) {
                    return {
                      ext: "mp2",
                      mime: "audio/mpeg"
                    };
                  }
                  if (check([255, 240], { offset: start, mask: [255, 252] })) {
                    return {
                      ext: "mp4",
                      mime: "audio/mpeg"
                    };
                  }
                }
                if (check([79, 112, 117, 115, 72, 101, 97, 100], { offset: 28 })) {
                  return {
                    ext: "opus",
                    mime: "audio/opus"
                  };
                }
                if (check([79, 103, 103, 83])) {
                  if (check([128, 116, 104, 101, 111, 114, 97], { offset: 28 })) {
                    return {
                      ext: "ogv",
                      mime: "video/ogg"
                    };
                  }
                  if (check([1, 118, 105, 100, 101, 111, 0], { offset: 28 })) {
                    return {
                      ext: "ogm",
                      mime: "video/ogg"
                    };
                  }
                  if (check([127, 70, 76, 65, 67], { offset: 28 })) {
                    return {
                      ext: "oga",
                      mime: "audio/ogg"
                    };
                  }
                  if (check([83, 112, 101, 101, 120, 32, 32], { offset: 28 })) {
                    return {
                      ext: "spx",
                      mime: "audio/ogg"
                    };
                  }
                  if (check([1, 118, 111, 114, 98, 105, 115], { offset: 28 })) {
                    return {
                      ext: "ogg",
                      mime: "audio/ogg"
                    };
                  }
                  return {
                    ext: "ogx",
                    mime: "application/ogg"
                  };
                }
                if (check([102, 76, 97, 67])) {
                  return {
                    ext: "flac",
                    mime: "audio/x-flac"
                  };
                }
                if (check([77, 65, 67, 32])) {
                  return {
                    ext: "ape",
                    mime: "audio/ape"
                  };
                }
                if (check([119, 118, 112, 107])) {
                  return {
                    ext: "wv",
                    mime: "audio/wavpack"
                  };
                }
                if (check([35, 33, 65, 77, 82, 10])) {
                  return {
                    ext: "amr",
                    mime: "audio/amr"
                  };
                }
                if (check([37, 80, 68, 70])) {
                  return {
                    ext: "pdf",
                    mime: "application/pdf"
                  };
                }
                if (check([77, 90])) {
                  return {
                    ext: "exe",
                    mime: "application/x-msdownload"
                  };
                }
                if ((buffer[0] === 67 || buffer[0] === 70) && check([87, 83], { offset: 1 })) {
                  return {
                    ext: "swf",
                    mime: "application/x-shockwave-flash"
                  };
                }
                if (check([123, 92, 114, 116, 102])) {
                  return {
                    ext: "rtf",
                    mime: "application/rtf"
                  };
                }
                if (check([0, 97, 115, 109])) {
                  return {
                    ext: "wasm",
                    mime: "application/wasm"
                  };
                }
                if (check([119, 79, 70, 70]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
                  return {
                    ext: "woff",
                    mime: "font/woff"
                  };
                }
                if (check([119, 79, 70, 50]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
                  return {
                    ext: "woff2",
                    mime: "font/woff2"
                  };
                }
                if (check([76, 80], { offset: 34 }) && (check([0, 0, 1], { offset: 8 }) || check([1, 0, 2], { offset: 8 }) || check([2, 0, 2], { offset: 8 }))) {
                  return {
                    ext: "eot",
                    mime: "application/vnd.ms-fontobject"
                  };
                }
                if (check([0, 1, 0, 0, 0])) {
                  return {
                    ext: "ttf",
                    mime: "font/ttf"
                  };
                }
                if (check([79, 84, 84, 79, 0])) {
                  return {
                    ext: "otf",
                    mime: "font/otf"
                  };
                }
                if (check([0, 0, 1, 0])) {
                  return {
                    ext: "ico",
                    mime: "image/x-icon"
                  };
                }
                if (check([0, 0, 2, 0])) {
                  return {
                    ext: "cur",
                    mime: "image/x-icon"
                  };
                }
                if (check([70, 76, 86, 1])) {
                  return {
                    ext: "flv",
                    mime: "video/x-flv"
                  };
                }
                if (check([37, 33])) {
                  return {
                    ext: "ps",
                    mime: "application/postscript"
                  };
                }
                if (check([253, 55, 122, 88, 90, 0])) {
                  return {
                    ext: "xz",
                    mime: "application/x-xz"
                  };
                }
                if (check([83, 81, 76, 105])) {
                  return {
                    ext: "sqlite",
                    mime: "application/x-sqlite3"
                  };
                }
                if (check([78, 69, 83, 26])) {
                  return {
                    ext: "nes",
                    mime: "application/x-nintendo-nes-rom"
                  };
                }
                if (check([67, 114, 50, 52])) {
                  return {
                    ext: "crx",
                    mime: "application/x-google-chrome-extension"
                  };
                }
                if (check([77, 83, 67, 70]) || check([73, 83, 99, 40])) {
                  return {
                    ext: "cab",
                    mime: "application/vnd.ms-cab-compressed"
                  };
                }
                if (check([33, 60, 97, 114, 99, 104, 62, 10, 100, 101, 98, 105, 97, 110, 45, 98, 105, 110, 97, 114, 121])) {
                  return {
                    ext: "deb",
                    mime: "application/x-deb"
                  };
                }
                if (check([33, 60, 97, 114, 99, 104, 62])) {
                  return {
                    ext: "ar",
                    mime: "application/x-unix-archive"
                  };
                }
                if (check([237, 171, 238, 219])) {
                  return {
                    ext: "rpm",
                    mime: "application/x-rpm"
                  };
                }
                if (check([31, 160]) || check([31, 157])) {
                  return {
                    ext: "Z",
                    mime: "application/x-compress"
                  };
                }
                if (check([76, 90, 73, 80])) {
                  return {
                    ext: "lz",
                    mime: "application/x-lzip"
                  };
                }
                if (check([208, 207, 17, 224, 161, 177, 26, 225])) {
                  return {
                    ext: "msi",
                    mime: "application/x-msi"
                  };
                }
                if (check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
                  return {
                    ext: "mxf",
                    mime: "application/mxf"
                  };
                }
                if (check([71], { offset: 4 }) && (check([71], { offset: 192 }) || check([71], { offset: 196 }))) {
                  return {
                    ext: "mts",
                    mime: "video/mp2t"
                  };
                }
                if (check([66, 76, 69, 78, 68, 69, 82])) {
                  return {
                    ext: "blend",
                    mime: "application/x-blender"
                  };
                }
                if (check([66, 80, 71, 251])) {
                  return {
                    ext: "bpg",
                    mime: "image/bpg"
                  };
                }
                if (check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
                  if (check([106, 112, 50, 32], { offset: 20 })) {
                    return {
                      ext: "jp2",
                      mime: "image/jp2"
                    };
                  }
                  if (check([106, 112, 120, 32], { offset: 20 })) {
                    return {
                      ext: "jpx",
                      mime: "image/jpx"
                    };
                  }
                  if (check([106, 112, 109, 32], { offset: 20 })) {
                    return {
                      ext: "jpm",
                      mime: "image/jpm"
                    };
                  }
                  if (check([109, 106, 112, 50], { offset: 20 })) {
                    return {
                      ext: "mj2",
                      mime: "image/mj2"
                    };
                  }
                }
                if (check([70, 79, 82, 77])) {
                  return {
                    ext: "aif",
                    mime: "audio/aiff"
                  };
                }
                if (checkString("<?xml ")) {
                  return {
                    ext: "xml",
                    mime: "application/xml"
                  };
                }
                if (check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
                  return {
                    ext: "mobi",
                    mime: "application/x-mobipocket-ebook"
                  };
                }
                if (check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
                  return {
                    ext: "ktx",
                    mime: "image/ktx"
                  };
                }
                if (check([68, 73, 67, 77], { offset: 128 })) {
                  return {
                    ext: "dcm",
                    mime: "application/dicom"
                  };
                }
                if (check([77, 80, 43])) {
                  return {
                    ext: "mpc",
                    mime: "audio/x-musepack"
                  };
                }
                if (check([77, 80, 67, 75])) {
                  return {
                    ext: "mpc",
                    mime: "audio/x-musepack"
                  };
                }
                if (check([66, 69, 71, 73, 78, 58])) {
                  return {
                    ext: "ics",
                    mime: "text/calendar"
                  };
                }
                if (check([103, 108, 84, 70, 2, 0, 0, 0])) {
                  return {
                    ext: "glb",
                    mime: "model/gltf-binary"
                  };
                }
                if (check([212, 195, 178, 161]) || check([161, 178, 195, 212])) {
                  return {
                    ext: "pcap",
                    mime: "application/vnd.tcpdump.pcap"
                  };
                }
                if (check([68, 83, 68, 32])) {
                  return {
                    ext: "dsf",
                    mime: "audio/x-dsf"
                    // Non-standard
                  };
                }
                if (check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
                  return {
                    ext: "lnk",
                    mime: "application/x.ms.shortcut"
                    // Invented by us
                  };
                }
                if (check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
                  return {
                    ext: "alias",
                    mime: "application/x.apple.alias"
                    // Invented by us
                  };
                }
                if (checkString("Creative Voice File")) {
                  return {
                    ext: "voc",
                    mime: "audio/x-voc"
                  };
                }
                if (check([11, 119])) {
                  return {
                    ext: "ac3",
                    mime: "audio/vnd.dolby.dd-raw"
                  };
                }
              };
              module.exports = fileType;
              Object.defineProperty(fileType, "minimumBytes", { value: 4100 });
              fileType.stream = (readableStream) => new Promise((resolve, reject) => {
                const stream = eval("require")("stream");
                readableStream.once("readable", () => {
                  const pass = new stream.PassThrough();
                  const chunk = readableStream.read(module.exports.minimumBytes) || readableStream.read();
                  try {
                    pass.fileType = fileType(chunk);
                  } catch (error) {
                    reject(error);
                  }
                  readableStream.unshift(chunk);
                  if (stream.pipeline) {
                    resolve(stream.pipeline(readableStream, pass, () => {
                    }));
                  } else {
                    resolve(readableStream.pipe(pass));
                  }
                });
              });
            }).call(this, __webpack_require__(9).Buffer);
          },
          /* 106 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            module2.exports = Stream;
            var EE = __webpack_require__2(50).EventEmitter;
            var inherits = __webpack_require__2(31);
            inherits(Stream, EE);
            Stream.Readable = __webpack_require__2(51);
            Stream.Writable = __webpack_require__2(155);
            Stream.Duplex = __webpack_require__2(156);
            Stream.Transform = __webpack_require__2(157);
            Stream.PassThrough = __webpack_require__2(158);
            Stream.Stream = Stream;
            function Stream() {
              EE.call(this);
            }
            Stream.prototype.pipe = function(dest, options) {
              var source = this;
              function ondata(chunk) {
                if (dest.writable) {
                  if (false === dest.write(chunk) && source.pause) {
                    source.pause();
                  }
                }
              }
              source.on("data", ondata);
              function ondrain() {
                if (source.readable && source.resume) {
                  source.resume();
                }
              }
              dest.on("drain", ondrain);
              if (!dest._isStdio && (!options || options.end !== false)) {
                source.on("end", onend);
                source.on("close", onclose);
              }
              var didOnEnd = false;
              function onend() {
                if (didOnEnd) return;
                didOnEnd = true;
                dest.end();
              }
              function onclose() {
                if (didOnEnd) return;
                didOnEnd = true;
                if (typeof dest.destroy === "function") dest.destroy();
              }
              function onerror(er) {
                cleanup();
                if (EE.listenerCount(this, "error") === 0) {
                  throw er;
                }
              }
              source.on("error", onerror);
              dest.on("error", onerror);
              function cleanup() {
                source.removeListener("data", ondata);
                dest.removeListener("drain", ondrain);
                source.removeListener("end", onend);
                source.removeListener("close", onclose);
                source.removeListener("error", onerror);
                dest.removeListener("error", onerror);
                source.removeListener("end", cleanup);
                source.removeListener("close", cleanup);
                dest.removeListener("close", cleanup);
              }
              source.on("end", cleanup);
              source.on("close", cleanup);
              dest.on("close", cleanup);
              dest.emit("pipe", source);
              return dest;
            };
          },
          /* 107 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            (function(global, process) {
              var pna = __webpack_require__2(44);
              module2.exports = Readable;
              var isArray = __webpack_require__2(103);
              var Duplex;
              Readable.ReadableState = ReadableState;
              var EE = __webpack_require__2(50).EventEmitter;
              var EElistenerCount = function(emitter, type) {
                return emitter.listeners(type).length;
              };
              var Stream = __webpack_require__2(108);
              var Buffer2 = __webpack_require__2(52).Buffer;
              var OurUint8Array = global.Uint8Array || function() {
              };
              function _uint8ArrayToBuffer(chunk) {
                return Buffer2.from(chunk);
              }
              function _isUint8Array(obj) {
                return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
              }
              var util = Object.create(__webpack_require__2(34));
              util.inherits = __webpack_require__2(31);
              var debugUtil = __webpack_require__2(149);
              var debug = void 0;
              if (debugUtil && debugUtil.debuglog) {
                debug = debugUtil.debuglog("stream");
              } else {
                debug = function() {
                };
              }
              var BufferList = __webpack_require__2(150);
              var destroyImpl = __webpack_require__2(109);
              var StringDecoder;
              util.inherits(Readable, Stream);
              var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
              function prependListener(emitter, event, fn) {
                if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
                if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
                else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);
                else emitter._events[event] = [fn, emitter._events[event]];
              }
              function ReadableState(options, stream2) {
                Duplex = Duplex || __webpack_require__2(24);
                options = options || {};
                var isDuplex = stream2 instanceof Duplex;
                this.objectMode = !!options.objectMode;
                if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
                var hwm = options.highWaterMark;
                var readableHwm = options.readableHighWaterMark;
                var defaultHwm = this.objectMode ? 16 : 16 * 1024;
                if (hwm || hwm === 0) this.highWaterMark = hwm;
                else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
                else this.highWaterMark = defaultHwm;
                this.highWaterMark = Math.floor(this.highWaterMark);
                this.buffer = new BufferList();
                this.length = 0;
                this.pipes = null;
                this.pipesCount = 0;
                this.flowing = null;
                this.ended = false;
                this.endEmitted = false;
                this.reading = false;
                this.sync = true;
                this.needReadable = false;
                this.emittedReadable = false;
                this.readableListening = false;
                this.resumeScheduled = false;
                this.destroyed = false;
                this.defaultEncoding = options.defaultEncoding || "utf8";
                this.awaitDrain = 0;
                this.readingMore = false;
                this.decoder = null;
                this.encoding = null;
                if (options.encoding) {
                  if (!StringDecoder) StringDecoder = __webpack_require__2(110).StringDecoder;
                  this.decoder = new StringDecoder(options.encoding);
                  this.encoding = options.encoding;
                }
              }
              function Readable(options) {
                Duplex = Duplex || __webpack_require__2(24);
                if (!(this instanceof Readable)) return new Readable(options);
                this._readableState = new ReadableState(options, this);
                this.readable = true;
                if (options) {
                  if (typeof options.read === "function") this._read = options.read;
                  if (typeof options.destroy === "function") this._destroy = options.destroy;
                }
                Stream.call(this);
              }
              Object.defineProperty(Readable.prototype, "destroyed", {
                get: function() {
                  if (this._readableState === void 0) {
                    return false;
                  }
                  return this._readableState.destroyed;
                },
                set: function(value) {
                  if (!this._readableState) {
                    return;
                  }
                  this._readableState.destroyed = value;
                }
              });
              Readable.prototype.destroy = destroyImpl.destroy;
              Readable.prototype._undestroy = destroyImpl.undestroy;
              Readable.prototype._destroy = function(err, cb) {
                this.push(null);
                cb(err);
              };
              Readable.prototype.push = function(chunk, encoding) {
                var state = this._readableState;
                var skipChunkCheck;
                if (!state.objectMode) {
                  if (typeof chunk === "string") {
                    encoding = encoding || state.defaultEncoding;
                    if (encoding !== state.encoding) {
                      chunk = Buffer2.from(chunk, encoding);
                      encoding = "";
                    }
                    skipChunkCheck = true;
                  }
                } else {
                  skipChunkCheck = true;
                }
                return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
              };
              Readable.prototype.unshift = function(chunk) {
                return readableAddChunk(this, chunk, null, true, false);
              };
              function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
                var state = stream2._readableState;
                if (chunk === null) {
                  state.reading = false;
                  onEofChunk(stream2, state);
                } else {
                  var er;
                  if (!skipChunkCheck) er = chunkInvalid(state, chunk);
                  if (er) {
                    stream2.emit("error", er);
                  } else if (state.objectMode || chunk && chunk.length > 0) {
                    if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
                      chunk = _uint8ArrayToBuffer(chunk);
                    }
                    if (addToFront) {
                      if (state.endEmitted) stream2.emit("error", new Error("stream.unshift() after end event"));
                      else addChunk(stream2, state, chunk, true);
                    } else if (state.ended) {
                      stream2.emit("error", new Error("stream.push() after EOF"));
                    } else {
                      state.reading = false;
                      if (state.decoder && !encoding) {
                        chunk = state.decoder.write(chunk);
                        if (state.objectMode || chunk.length !== 0) addChunk(stream2, state, chunk, false);
                        else maybeReadMore(stream2, state);
                      } else {
                        addChunk(stream2, state, chunk, false);
                      }
                    }
                  } else if (!addToFront) {
                    state.reading = false;
                  }
                }
                return needMoreData(state);
              }
              function addChunk(stream2, state, chunk, addToFront) {
                if (state.flowing && state.length === 0 && !state.sync) {
                  stream2.emit("data", chunk);
                  stream2.read(0);
                } else {
                  state.length += state.objectMode ? 1 : chunk.length;
                  if (addToFront) state.buffer.unshift(chunk);
                  else state.buffer.push(chunk);
                  if (state.needReadable) emitReadable(stream2);
                }
                maybeReadMore(stream2, state);
              }
              function chunkInvalid(state, chunk) {
                var er;
                if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
                  er = new TypeError("Invalid non-string/buffer chunk");
                }
                return er;
              }
              function needMoreData(state) {
                return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
              }
              Readable.prototype.isPaused = function() {
                return this._readableState.flowing === false;
              };
              Readable.prototype.setEncoding = function(enc) {
                if (!StringDecoder) StringDecoder = __webpack_require__2(110).StringDecoder;
                this._readableState.decoder = new StringDecoder(enc);
                this._readableState.encoding = enc;
                return this;
              };
              var MAX_HWM = 8388608;
              function computeNewHighWaterMark(n) {
                if (n >= MAX_HWM) {
                  n = MAX_HWM;
                } else {
                  n--;
                  n |= n >>> 1;
                  n |= n >>> 2;
                  n |= n >>> 4;
                  n |= n >>> 8;
                  n |= n >>> 16;
                  n++;
                }
                return n;
              }
              function howMuchToRead(n, state) {
                if (n <= 0 || state.length === 0 && state.ended) return 0;
                if (state.objectMode) return 1;
                if (n !== n) {
                  if (state.flowing && state.length) return state.buffer.head.data.length;
                  else return state.length;
                }
                if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
                if (n <= state.length) return n;
                if (!state.ended) {
                  state.needReadable = true;
                  return 0;
                }
                return state.length;
              }
              Readable.prototype.read = function(n) {
                debug("read", n);
                n = parseInt(n, 10);
                var state = this._readableState;
                var nOrig = n;
                if (n !== 0) state.emittedReadable = false;
                if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
                  debug("read: emitReadable", state.length, state.ended);
                  if (state.length === 0 && state.ended) endReadable(this);
                  else emitReadable(this);
                  return null;
                }
                n = howMuchToRead(n, state);
                if (n === 0 && state.ended) {
                  if (state.length === 0) endReadable(this);
                  return null;
                }
                var doRead = state.needReadable;
                debug("need readable", doRead);
                if (state.length === 0 || state.length - n < state.highWaterMark) {
                  doRead = true;
                  debug("length less than watermark", doRead);
                }
                if (state.ended || state.reading) {
                  doRead = false;
                  debug("reading or ended", doRead);
                } else if (doRead) {
                  debug("do read");
                  state.reading = true;
                  state.sync = true;
                  if (state.length === 0) state.needReadable = true;
                  this._read(state.highWaterMark);
                  state.sync = false;
                  if (!state.reading) n = howMuchToRead(nOrig, state);
                }
                var ret;
                if (n > 0) ret = fromList(n, state);
                else ret = null;
                if (ret === null) {
                  state.needReadable = true;
                  n = 0;
                } else {
                  state.length -= n;
                }
                if (state.length === 0) {
                  if (!state.ended) state.needReadable = true;
                  if (nOrig !== n && state.ended) endReadable(this);
                }
                if (ret !== null) this.emit("data", ret);
                return ret;
              };
              function onEofChunk(stream2, state) {
                if (state.ended) return;
                if (state.decoder) {
                  var chunk = state.decoder.end();
                  if (chunk && chunk.length) {
                    state.buffer.push(chunk);
                    state.length += state.objectMode ? 1 : chunk.length;
                  }
                }
                state.ended = true;
                emitReadable(stream2);
              }
              function emitReadable(stream2) {
                var state = stream2._readableState;
                state.needReadable = false;
                if (!state.emittedReadable) {
                  debug("emitReadable", state.flowing);
                  state.emittedReadable = true;
                  if (state.sync) pna.nextTick(emitReadable_, stream2);
                  else emitReadable_(stream2);
                }
              }
              function emitReadable_(stream2) {
                debug("emit readable");
                stream2.emit("readable");
                flow(stream2);
              }
              function maybeReadMore(stream2, state) {
                if (!state.readingMore) {
                  state.readingMore = true;
                  pna.nextTick(maybeReadMore_, stream2, state);
                }
              }
              function maybeReadMore_(stream2, state) {
                var len = state.length;
                while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
                  debug("maybeReadMore read 0");
                  stream2.read(0);
                  if (len === state.length)
                    break;
                  else len = state.length;
                }
                state.readingMore = false;
              }
              Readable.prototype._read = function(n) {
                this.emit("error", new Error("_read() is not implemented"));
              };
              Readable.prototype.pipe = function(dest, pipeOpts) {
                var src = this;
                var state = this._readableState;
                switch (state.pipesCount) {
                  case 0:
                    state.pipes = dest;
                    break;
                  case 1:
                    state.pipes = [state.pipes, dest];
                    break;
                  default:
                    state.pipes.push(dest);
                    break;
                }
                state.pipesCount += 1;
                debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
                var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
                var endFn = doEnd ? onend : unpipe;
                if (state.endEmitted) pna.nextTick(endFn);
                else src.once("end", endFn);
                dest.on("unpipe", onunpipe);
                function onunpipe(readable, unpipeInfo) {
                  debug("onunpipe");
                  if (readable === src) {
                    if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                      unpipeInfo.hasUnpiped = true;
                      cleanup();
                    }
                  }
                }
                function onend() {
                  debug("onend");
                  dest.end();
                }
                var ondrain = pipeOnDrain(src);
                dest.on("drain", ondrain);
                var cleanedUp = false;
                function cleanup() {
                  debug("cleanup");
                  dest.removeListener("close", onclose);
                  dest.removeListener("finish", onfinish);
                  dest.removeListener("drain", ondrain);
                  dest.removeListener("error", onerror);
                  dest.removeListener("unpipe", onunpipe);
                  src.removeListener("end", onend);
                  src.removeListener("end", unpipe);
                  src.removeListener("data", ondata);
                  cleanedUp = true;
                  if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
                }
                var increasedAwaitDrain = false;
                src.on("data", ondata);
                function ondata(chunk) {
                  debug("ondata");
                  increasedAwaitDrain = false;
                  var ret = dest.write(chunk);
                  if (false === ret && !increasedAwaitDrain) {
                    if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                      debug("false write response, pause", src._readableState.awaitDrain);
                      src._readableState.awaitDrain++;
                      increasedAwaitDrain = true;
                    }
                    src.pause();
                  }
                }
                function onerror(er) {
                  debug("onerror", er);
                  unpipe();
                  dest.removeListener("error", onerror);
                  if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
                }
                prependListener(dest, "error", onerror);
                function onclose() {
                  dest.removeListener("finish", onfinish);
                  unpipe();
                }
                dest.once("close", onclose);
                function onfinish() {
                  debug("onfinish");
                  dest.removeListener("close", onclose);
                  unpipe();
                }
                dest.once("finish", onfinish);
                function unpipe() {
                  debug("unpipe");
                  src.unpipe(dest);
                }
                dest.emit("pipe", src);
                if (!state.flowing) {
                  debug("pipe resume");
                  src.resume();
                }
                return dest;
              };
              function pipeOnDrain(src) {
                return function() {
                  var state = src._readableState;
                  debug("pipeOnDrain", state.awaitDrain);
                  if (state.awaitDrain) state.awaitDrain--;
                  if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
                    state.flowing = true;
                    flow(src);
                  }
                };
              }
              Readable.prototype.unpipe = function(dest) {
                var state = this._readableState;
                var unpipeInfo = { hasUnpiped: false };
                if (state.pipesCount === 0) return this;
                if (state.pipesCount === 1) {
                  if (dest && dest !== state.pipes) return this;
                  if (!dest) dest = state.pipes;
                  state.pipes = null;
                  state.pipesCount = 0;
                  state.flowing = false;
                  if (dest) dest.emit("unpipe", this, unpipeInfo);
                  return this;
                }
                if (!dest) {
                  var dests = state.pipes;
                  var len = state.pipesCount;
                  state.pipes = null;
                  state.pipesCount = 0;
                  state.flowing = false;
                  for (var i = 0; i < len; i++) {
                    dests[i].emit("unpipe", this, unpipeInfo);
                  }
                  return this;
                }
                var index = indexOf(state.pipes, dest);
                if (index === -1) return this;
                state.pipes.splice(index, 1);
                state.pipesCount -= 1;
                if (state.pipesCount === 1) state.pipes = state.pipes[0];
                dest.emit("unpipe", this, unpipeInfo);
                return this;
              };
              Readable.prototype.on = function(ev, fn) {
                var res = Stream.prototype.on.call(this, ev, fn);
                if (ev === "data") {
                  if (this._readableState.flowing !== false) this.resume();
                } else if (ev === "readable") {
                  var state = this._readableState;
                  if (!state.endEmitted && !state.readableListening) {
                    state.readableListening = state.needReadable = true;
                    state.emittedReadable = false;
                    if (!state.reading) {
                      pna.nextTick(nReadingNextTick, this);
                    } else if (state.length) {
                      emitReadable(this);
                    }
                  }
                }
                return res;
              };
              Readable.prototype.addListener = Readable.prototype.on;
              function nReadingNextTick(self2) {
                debug("readable nexttick read 0");
                self2.read(0);
              }
              Readable.prototype.resume = function() {
                var state = this._readableState;
                if (!state.flowing) {
                  debug("resume");
                  state.flowing = true;
                  resume(this, state);
                }
                return this;
              };
              function resume(stream2, state) {
                if (!state.resumeScheduled) {
                  state.resumeScheduled = true;
                  pna.nextTick(resume_, stream2, state);
                }
              }
              function resume_(stream2, state) {
                if (!state.reading) {
                  debug("resume read 0");
                  stream2.read(0);
                }
                state.resumeScheduled = false;
                state.awaitDrain = 0;
                stream2.emit("resume");
                flow(stream2);
                if (state.flowing && !state.reading) stream2.read(0);
              }
              Readable.prototype.pause = function() {
                debug("call pause flowing=%j", this._readableState.flowing);
                if (false !== this._readableState.flowing) {
                  debug("pause");
                  this._readableState.flowing = false;
                  this.emit("pause");
                }
                return this;
              };
              function flow(stream2) {
                var state = stream2._readableState;
                debug("flow", state.flowing);
                while (state.flowing && stream2.read() !== null) {
                }
              }
              Readable.prototype.wrap = function(stream2) {
                var _this = this;
                var state = this._readableState;
                var paused = false;
                stream2.on("end", function() {
                  debug("wrapped end");
                  if (state.decoder && !state.ended) {
                    var chunk = state.decoder.end();
                    if (chunk && chunk.length) _this.push(chunk);
                  }
                  _this.push(null);
                });
                stream2.on("data", function(chunk) {
                  debug("wrapped data");
                  if (state.decoder) chunk = state.decoder.write(chunk);
                  if (state.objectMode && (chunk === null || chunk === void 0)) return;
                  else if (!state.objectMode && (!chunk || !chunk.length)) return;
                  var ret = _this.push(chunk);
                  if (!ret) {
                    paused = true;
                    stream2.pause();
                  }
                });
                for (var i in stream2) {
                  if (this[i] === void 0 && typeof stream2[i] === "function") {
                    this[i] = /* @__PURE__ */ function(method) {
                      return function() {
                        return stream2[method].apply(stream2, arguments);
                      };
                    }(i);
                  }
                }
                for (var n = 0; n < kProxyEvents.length; n++) {
                  stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
                }
                this._read = function(n2) {
                  debug("wrapped _read", n2);
                  if (paused) {
                    paused = false;
                    stream2.resume();
                  }
                };
                return this;
              };
              Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function() {
                  return this._readableState.highWaterMark;
                }
              });
              Readable._fromList = fromList;
              function fromList(n, state) {
                if (state.length === 0) return null;
                var ret;
                if (state.objectMode) ret = state.buffer.shift();
                else if (!n || n >= state.length) {
                  if (state.decoder) ret = state.buffer.join("");
                  else if (state.buffer.length === 1) ret = state.buffer.head.data;
                  else ret = state.buffer.concat(state.length);
                  state.buffer.clear();
                } else {
                  ret = fromListPartial(n, state.buffer, state.decoder);
                }
                return ret;
              }
              function fromListPartial(n, list, hasStrings) {
                var ret;
                if (n < list.head.data.length) {
                  ret = list.head.data.slice(0, n);
                  list.head.data = list.head.data.slice(n);
                } else if (n === list.head.data.length) {
                  ret = list.shift();
                } else {
                  ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
                }
                return ret;
              }
              function copyFromBufferString(n, list) {
                var p = list.head;
                var c = 1;
                var ret = p.data;
                n -= ret.length;
                while (p = p.next) {
                  var str = p.data;
                  var nb = n > str.length ? str.length : n;
                  if (nb === str.length) ret += str;
                  else ret += str.slice(0, n);
                  n -= nb;
                  if (n === 0) {
                    if (nb === str.length) {
                      ++c;
                      if (p.next) list.head = p.next;
                      else list.head = list.tail = null;
                    } else {
                      list.head = p;
                      p.data = str.slice(nb);
                    }
                    break;
                  }
                  ++c;
                }
                list.length -= c;
                return ret;
              }
              function copyFromBuffer(n, list) {
                var ret = Buffer2.allocUnsafe(n);
                var p = list.head;
                var c = 1;
                p.data.copy(ret);
                n -= p.data.length;
                while (p = p.next) {
                  var buf = p.data;
                  var nb = n > buf.length ? buf.length : n;
                  buf.copy(ret, ret.length - n, 0, nb);
                  n -= nb;
                  if (n === 0) {
                    if (nb === buf.length) {
                      ++c;
                      if (p.next) list.head = p.next;
                      else list.head = list.tail = null;
                    } else {
                      list.head = p;
                      p.data = buf.slice(nb);
                    }
                    break;
                  }
                  ++c;
                }
                list.length -= c;
                return ret;
              }
              function endReadable(stream2) {
                var state = stream2._readableState;
                if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
                if (!state.endEmitted) {
                  state.ended = true;
                  pna.nextTick(endReadableNT, state, stream2);
                }
              }
              function endReadableNT(state, stream2) {
                if (!state.endEmitted && state.length === 0) {
                  state.endEmitted = true;
                  stream2.readable = false;
                  stream2.emit("end");
                }
              }
              function indexOf(xs, x) {
                for (var i = 0, l = xs.length; i < l; i++) {
                  if (xs[i] === x) return i;
                }
                return -1;
              }
            }).call(this, __webpack_require__2(17), __webpack_require__2(30));
          },
          /* 108 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            module2.exports = __webpack_require__2(50).EventEmitter;
          },
          /* 109 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var pna = __webpack_require__2(44);
            function destroy(err, cb) {
              var _this = this;
              var readableDestroyed = this._readableState && this._readableState.destroyed;
              var writableDestroyed = this._writableState && this._writableState.destroyed;
              if (readableDestroyed || writableDestroyed) {
                if (cb) {
                  cb(err);
                } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
                  pna.nextTick(emitErrorNT, this, err);
                }
                return this;
              }
              if (this._readableState) {
                this._readableState.destroyed = true;
              }
              if (this._writableState) {
                this._writableState.destroyed = true;
              }
              this._destroy(err || null, function(err2) {
                if (!cb && err2) {
                  pna.nextTick(emitErrorNT, _this, err2);
                  if (_this._writableState) {
                    _this._writableState.errorEmitted = true;
                  }
                } else if (cb) {
                  cb(err2);
                }
              });
              return this;
            }
            function undestroy() {
              if (this._readableState) {
                this._readableState.destroyed = false;
                this._readableState.reading = false;
                this._readableState.ended = false;
                this._readableState.endEmitted = false;
              }
              if (this._writableState) {
                this._writableState.destroyed = false;
                this._writableState.ended = false;
                this._writableState.ending = false;
                this._writableState.finished = false;
                this._writableState.errorEmitted = false;
              }
            }
            function emitErrorNT(self2, err) {
              self2.emit("error", err);
            }
            module2.exports = {
              destroy,
              undestroy
            };
          },
          /* 110 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var Buffer2 = __webpack_require__2(153).Buffer;
            var isEncoding = Buffer2.isEncoding || function(encoding) {
              encoding = "" + encoding;
              switch (encoding && encoding.toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                case "raw":
                  return true;
                default:
                  return false;
              }
            };
            function _normalizeEncoding(enc) {
              if (!enc) return "utf8";
              var retried;
              while (true) {
                switch (enc) {
                  case "utf8":
                  case "utf-8":
                    return "utf8";
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return "utf16le";
                  case "latin1":
                  case "binary":
                    return "latin1";
                  case "base64":
                  case "ascii":
                  case "hex":
                    return enc;
                  default:
                    if (retried) return;
                    enc = ("" + enc).toLowerCase();
                    retried = true;
                }
              }
            }
            ;
            function normalizeEncoding(enc) {
              var nenc = _normalizeEncoding(enc);
              if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
              return nenc || enc;
            }
            exports2.StringDecoder = StringDecoder;
            function StringDecoder(encoding) {
              this.encoding = normalizeEncoding(encoding);
              var nb;
              switch (this.encoding) {
                case "utf16le":
                  this.text = utf16Text;
                  this.end = utf16End;
                  nb = 4;
                  break;
                case "utf8":
                  this.fillLast = utf8FillLast;
                  nb = 4;
                  break;
                case "base64":
                  this.text = base64Text;
                  this.end = base64End;
                  nb = 3;
                  break;
                default:
                  this.write = simpleWrite;
                  this.end = simpleEnd;
                  return;
              }
              this.lastNeed = 0;
              this.lastTotal = 0;
              this.lastChar = Buffer2.allocUnsafe(nb);
            }
            StringDecoder.prototype.write = function(buf) {
              if (buf.length === 0) return "";
              var r;
              var i;
              if (this.lastNeed) {
                r = this.fillLast(buf);
                if (r === void 0) return "";
                i = this.lastNeed;
                this.lastNeed = 0;
              } else {
                i = 0;
              }
              if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
              return r || "";
            };
            StringDecoder.prototype.end = utf8End;
            StringDecoder.prototype.text = utf8Text;
            StringDecoder.prototype.fillLast = function(buf) {
              if (this.lastNeed <= buf.length) {
                buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
                return this.lastChar.toString(this.encoding, 0, this.lastTotal);
              }
              buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
              this.lastNeed -= buf.length;
            };
            function utf8CheckByte(byte) {
              if (byte <= 127) return 0;
              else if (byte >> 5 === 6) return 2;
              else if (byte >> 4 === 14) return 3;
              else if (byte >> 3 === 30) return 4;
              return byte >> 6 === 2 ? -1 : -2;
            }
            function utf8CheckIncomplete(self2, buf, i) {
              var j = buf.length - 1;
              if (j < i) return 0;
              var nb = utf8CheckByte(buf[j]);
              if (nb >= 0) {
                if (nb > 0) self2.lastNeed = nb - 1;
                return nb;
              }
              if (--j < i || nb === -2) return 0;
              nb = utf8CheckByte(buf[j]);
              if (nb >= 0) {
                if (nb > 0) self2.lastNeed = nb - 2;
                return nb;
              }
              if (--j < i || nb === -2) return 0;
              nb = utf8CheckByte(buf[j]);
              if (nb >= 0) {
                if (nb > 0) {
                  if (nb === 2) nb = 0;
                  else self2.lastNeed = nb - 3;
                }
                return nb;
              }
              return 0;
            }
            function utf8CheckExtraBytes(self2, buf, p) {
              if ((buf[0] & 192) !== 128) {
                self2.lastNeed = 0;
                return "�";
              }
              if (self2.lastNeed > 1 && buf.length > 1) {
                if ((buf[1] & 192) !== 128) {
                  self2.lastNeed = 1;
                  return "�";
                }
                if (self2.lastNeed > 2 && buf.length > 2) {
                  if ((buf[2] & 192) !== 128) {
                    self2.lastNeed = 2;
                    return "�";
                  }
                }
              }
            }
            function utf8FillLast(buf) {
              var p = this.lastTotal - this.lastNeed;
              var r = utf8CheckExtraBytes(this, buf, p);
              if (r !== void 0) return r;
              if (this.lastNeed <= buf.length) {
                buf.copy(this.lastChar, p, 0, this.lastNeed);
                return this.lastChar.toString(this.encoding, 0, this.lastTotal);
              }
              buf.copy(this.lastChar, p, 0, buf.length);
              this.lastNeed -= buf.length;
            }
            function utf8Text(buf, i) {
              var total = utf8CheckIncomplete(this, buf, i);
              if (!this.lastNeed) return buf.toString("utf8", i);
              this.lastTotal = total;
              var end = buf.length - (total - this.lastNeed);
              buf.copy(this.lastChar, 0, end);
              return buf.toString("utf8", i, end);
            }
            function utf8End(buf) {
              var r = buf && buf.length ? this.write(buf) : "";
              if (this.lastNeed) return r + "�";
              return r;
            }
            function utf16Text(buf, i) {
              if ((buf.length - i) % 2 === 0) {
                var r = buf.toString("utf16le", i);
                if (r) {
                  var c = r.charCodeAt(r.length - 1);
                  if (c >= 55296 && c <= 56319) {
                    this.lastNeed = 2;
                    this.lastTotal = 4;
                    this.lastChar[0] = buf[buf.length - 2];
                    this.lastChar[1] = buf[buf.length - 1];
                    return r.slice(0, -1);
                  }
                }
                return r;
              }
              this.lastNeed = 1;
              this.lastTotal = 2;
              this.lastChar[0] = buf[buf.length - 1];
              return buf.toString("utf16le", i, buf.length - 1);
            }
            function utf16End(buf) {
              var r = buf && buf.length ? this.write(buf) : "";
              if (this.lastNeed) {
                var end = this.lastTotal - this.lastNeed;
                return r + this.lastChar.toString("utf16le", 0, end);
              }
              return r;
            }
            function base64Text(buf, i) {
              var n = (buf.length - i) % 3;
              if (n === 0) return buf.toString("base64", i);
              this.lastNeed = 3 - n;
              this.lastTotal = 3;
              if (n === 1) {
                this.lastChar[0] = buf[buf.length - 1];
              } else {
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
              }
              return buf.toString("base64", i, buf.length - n);
            }
            function base64End(buf) {
              var r = buf && buf.length ? this.write(buf) : "";
              if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
              return r;
            }
            function simpleWrite(buf) {
              return buf.toString(this.encoding);
            }
            function simpleEnd(buf) {
              return buf && buf.length ? this.write(buf) : "";
            }
          },
          /* 111 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            module2.exports = Transform;
            var Duplex = __webpack_require__2(24);
            var util = Object.create(__webpack_require__2(34));
            util.inherits = __webpack_require__2(31);
            util.inherits(Transform, Duplex);
            function afterTransform(er, data) {
              var ts = this._transformState;
              ts.transforming = false;
              var cb = ts.writecb;
              if (!cb) {
                return this.emit("error", new Error("write callback called multiple times"));
              }
              ts.writechunk = null;
              ts.writecb = null;
              if (data != null)
                this.push(data);
              cb(er);
              var rs = this._readableState;
              rs.reading = false;
              if (rs.needReadable || rs.length < rs.highWaterMark) {
                this._read(rs.highWaterMark);
              }
            }
            function Transform(options) {
              if (!(this instanceof Transform)) return new Transform(options);
              Duplex.call(this, options);
              this._transformState = {
                afterTransform: afterTransform.bind(this),
                needTransform: false,
                transforming: false,
                writecb: null,
                writechunk: null,
                writeencoding: null
              };
              this._readableState.needReadable = true;
              this._readableState.sync = false;
              if (options) {
                if (typeof options.transform === "function") this._transform = options.transform;
                if (typeof options.flush === "function") this._flush = options.flush;
              }
              this.on("prefinish", prefinish);
            }
            function prefinish() {
              var _this = this;
              if (typeof this._flush === "function") {
                this._flush(function(er, data) {
                  done(_this, er, data);
                });
              } else {
                done(this, null, null);
              }
            }
            Transform.prototype.push = function(chunk, encoding) {
              this._transformState.needTransform = false;
              return Duplex.prototype.push.call(this, chunk, encoding);
            };
            Transform.prototype._transform = function(chunk, encoding, cb) {
              throw new Error("_transform() is not implemented");
            };
            Transform.prototype._write = function(chunk, encoding, cb) {
              var ts = this._transformState;
              ts.writecb = cb;
              ts.writechunk = chunk;
              ts.writeencoding = encoding;
              if (!ts.transforming) {
                var rs = this._readableState;
                if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
              }
            };
            Transform.prototype._read = function(n) {
              var ts = this._transformState;
              if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
                ts.transforming = true;
                this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
              } else {
                ts.needTransform = true;
              }
            };
            Transform.prototype._destroy = function(err, cb) {
              var _this2 = this;
              Duplex.prototype._destroy.call(this, err, function(err2) {
                cb(err2);
                _this2.emit("close");
              });
            };
            function done(stream2, er, data) {
              if (er) return stream2.emit("error", er);
              if (data != null)
                stream2.push(data);
              if (stream2._writableState.length) throw new Error("Calling transform done when ws.length != 0");
              if (stream2._transformState.transforming) throw new Error("Calling transform done when still transforming");
              return stream2.push(null);
            }
          },
          /* 112 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            (function(Buffer2) {
              Object.defineProperty(exports2, "__esModule", { value: true });
              class GUID {
                constructor(str) {
                  this.str = str;
                }
                static fromBin(bin, offset = 0) {
                  return new GUID(this.decode(bin, offset));
                }
                /**
                 * Decode GUID in format like "B503BF5F-2EA9-CF11-8EE3-00C00C205365"
                 * @param objectId Binary GUID
                 * @param offset Read offset in bytes, default 0
                 * @returns {string} GUID as dashed hexadecimal representation
                 */
                static decode(objectId, offset = 0) {
                  const guid = objectId.readUInt32LE(offset).toString(16) + "-" + objectId.readUInt16LE(offset + 4).toString(16) + "-" + objectId.readUInt16LE(offset + 6).toString(16) + "-" + objectId.readUInt16BE(offset + 8).toString(16) + "-" + objectId.slice(offset + 10, offset + 16).toString("hex");
                  return guid.toUpperCase();
                }
                /**
                 * Decode stream type
                 * @param {string} mediaType
                 * @returns {string}
                 */
                static decodeMediaType(mediaType) {
                  switch (mediaType.str) {
                    case GUID.AudioMedia.str:
                      return "audio";
                    case GUID.VideoMedia.str:
                      return "video";
                    case GUID.CommandMedia.str:
                      return "command";
                    case GUID.Degradable_JPEG_Media.str:
                      return "degradable-jpeg";
                    case GUID.FileTransferMedia.str:
                      return "file-transfer";
                    case GUID.BinaryMedia.str:
                      return "binary";
                  }
                }
                /**
                 * Encode GUID
                 * @param guid GUID like: "B503BF5F-2EA9-CF11-8EE3-00C00C205365"
                 * @returns {Buffer} Encoded Bnary GUID
                 */
                static encode(str) {
                  const bin = Buffer2.alloc(16);
                  bin.writeUInt32LE(parseInt(str.slice(0, 8), 16), 0);
                  bin.writeUInt16LE(parseInt(str.slice(9, 13), 16), 4);
                  bin.writeUInt16LE(parseInt(str.slice(14, 18), 16), 6);
                  Buffer2.from(str.slice(19, 23), "hex").copy(bin, 8);
                  Buffer2.from(str.slice(24), "hex").copy(bin, 10);
                  return bin;
                }
                equals(guid) {
                  return this.str === guid.str;
                }
                toBin() {
                  return GUID.encode(this.str);
                }
              }
              GUID.HeaderObject = new GUID("75B22630-668E-11CF-A6D9-00AA0062CE6C");
              GUID.DataObject = new GUID("75B22636-668E-11CF-A6D9-00AA0062CE6C");
              GUID.SimpleIndexObject = new GUID("33000890-E5B1-11CF-89F4-00A0C90349CB");
              GUID.IndexObject = new GUID("D6E229D3-35DA-11D1-9034-00A0C90349BE");
              GUID.MediaObjectIndexObject = new GUID("FEB103F8-12AD-4C64-840F-2A1D2F7AD48C");
              GUID.TimecodeIndexObject = new GUID("3CB73FD0-0C4A-4803-953D-EDF7B6228F0C");
              GUID.FilePropertiesObject = new GUID("8CABDCA1-A947-11CF-8EE4-00C00C205365");
              GUID.StreamPropertiesObject = new GUID("B7DC0791-A9B7-11CF-8EE6-00C00C205365");
              GUID.HeaderExtensionObject = new GUID("5FBF03B5-A92E-11CF-8EE3-00C00C205365");
              GUID.CodecListObject = new GUID("86D15240-311D-11D0-A3A4-00A0C90348F6");
              GUID.ScriptCommandObject = new GUID("1EFB1A30-0B62-11D0-A39B-00A0C90348F6");
              GUID.MarkerObject = new GUID("F487CD01-A951-11CF-8EE6-00C00C205365");
              GUID.BitrateMutualExclusionObject = new GUID("D6E229DC-35DA-11D1-9034-00A0C90349BE");
              GUID.ErrorCorrectionObject = new GUID("75B22635-668E-11CF-A6D9-00AA0062CE6C");
              GUID.ContentDescriptionObject = new GUID("75B22633-668E-11CF-A6D9-00AA0062CE6C");
              GUID.ExtendedContentDescriptionObject = new GUID("D2D0A440-E307-11D2-97F0-00A0C95EA850");
              GUID.ContentBrandingObject = new GUID("2211B3FA-BD23-11D2-B4B7-00A0C955FC6E");
              GUID.StreamBitratePropertiesObject = new GUID("7BF875CE-468D-11D1-8D82-006097C9A2B2");
              GUID.ContentEncryptionObject = new GUID("2211B3FB-BD23-11D2-B4B7-00A0C955FC6E");
              GUID.ExtendedContentEncryptionObject = new GUID("298AE614-2622-4C17-B935-DAE07EE9289C");
              GUID.DigitalSignatureObject = new GUID("2211B3FC-BD23-11D2-B4B7-00A0C955FC6E");
              GUID.PaddingObject = new GUID("1806D474-CADF-4509-A4BA-9AABCB96AAE8");
              GUID.ExtendedStreamPropertiesObject = new GUID("14E6A5CB-C672-4332-8399-A96952065B5A");
              GUID.AdvancedMutualExclusionObject = new GUID("A08649CF-4775-4670-8A16-6E35357566CD");
              GUID.GroupMutualExclusionObject = new GUID("D1465A40-5A79-4338-B71B-E36B8FD6C249");
              GUID.StreamPrioritizationObject = new GUID("D4FED15B-88D3-454F-81F0-ED5C45999E24");
              GUID.BandwidthSharingObject = new GUID("A69609E6-517B-11D2-B6AF-00C04FD908E9");
              GUID.LanguageListObject = new GUID("7C4346A9-EFE0-4BFC-B229-393EDE415C85");
              GUID.MetadataObject = new GUID("C5F8CBEA-5BAF-4877-8467-AA8C44FA4CCA");
              GUID.MetadataLibraryObject = new GUID("44231C94-9498-49D1-A141-1D134E457054");
              GUID.IndexParametersObject = new GUID("D6E229DF-35DA-11D1-9034-00A0C90349BE");
              GUID.MediaObjectIndexParametersObject = new GUID("6B203BAD-3F11-48E4-ACA8-D7613DE2CFA7");
              GUID.TimecodeIndexParametersObject = new GUID("F55E496D-9797-4B5D-8C8B-604DFE9BFB24");
              GUID.CompatibilityObject = new GUID("26F18B5D-4584-47EC-9F5F-0E651F0452C9");
              GUID.AdvancedContentEncryptionObject = new GUID("43058533-6981-49E6-9B74-AD12CB86D58C");
              GUID.AudioMedia = new GUID("F8699E40-5B4D-11CF-A8FD-00805F5C442B");
              GUID.VideoMedia = new GUID("BC19EFC0-5B4D-11CF-A8FD-00805F5C442B");
              GUID.CommandMedia = new GUID("59DACFC0-59E6-11D0-A3AC-00A0C90348F6");
              GUID.JFIF_Media = new GUID("B61BE100-5B4E-11CF-A8FD-00805F5C442B");
              GUID.Degradable_JPEG_Media = new GUID("35907DE0-E415-11CF-A917-00805F5C442B");
              GUID.FileTransferMedia = new GUID("91BD222C-F21C-497A-8B6D-5AA86BFC0185");
              GUID.BinaryMedia = new GUID("3AFB65E2-47EF-40F2-AC2C-70A90D71D343");
              GUID.ASF_Index_Placeholder_Object = new GUID("D9AADE20-7C17-4F9C-BC28-8555DD98E2A2");
              exports2.default = GUID;
            }).call(this, __webpack_require__2(9).Buffer);
          },
          /* 113 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            (function(Buffer2) {
              Object.defineProperty(exports2, "__esModule", { value: true });
              const Token = __webpack_require__2(6);
              const ID3v2_1 = __webpack_require__2(33);
              class VorbisPictureToken {
                constructor(len) {
                  this.len = len;
                }
                static fromBase64(base64str) {
                  return this.fromBuffer(Buffer2.from(base64str, "base64"));
                }
                static fromBuffer(buffer) {
                  const pic = new VorbisPictureToken(buffer.length);
                  return pic.get(buffer, 0);
                }
                get(buffer, offset) {
                  const type = ID3v2_1.AttachedPictureType[Token.UINT32_BE.get(buffer, offset)];
                  const mimeLen = Token.UINT32_BE.get(buffer, offset += 4);
                  const format = buffer.toString("utf-8", offset += 4, offset + mimeLen);
                  const descLen = Token.UINT32_BE.get(buffer, offset += mimeLen);
                  const description = buffer.toString("utf-8", offset += 4, offset + descLen);
                  const width = Token.UINT32_BE.get(buffer, offset += descLen);
                  const height = Token.UINT32_BE.get(buffer, offset += 4);
                  const colour_depth = Token.UINT32_BE.get(buffer, offset += 4);
                  const indexed_color = Token.UINT32_BE.get(buffer, offset += 4);
                  const picDataLen = Token.UINT32_BE.get(buffer, offset += 4);
                  const data = Buffer2.from(buffer.slice(offset += 4, offset + picDataLen));
                  return {
                    type,
                    format,
                    description,
                    width,
                    height,
                    colour_depth,
                    indexed_color,
                    data
                  };
                }
              }
              exports2.VorbisPictureToken = VorbisPictureToken;
              exports2.CommonHeader = {
                len: 7,
                get: (buf, off) => {
                  return {
                    packetType: buf.readUInt8(off),
                    vorbis: new Token.StringType(6, "ascii").get(buf, off + 1)
                  };
                }
              };
              exports2.IdentificationHeader = {
                len: 23,
                get: (buf, off) => {
                  return {
                    version: buf.readUInt32LE(off + 0),
                    channelMode: buf.readUInt8(off + 4),
                    sampleRate: buf.readUInt32LE(off + 5),
                    bitrateMax: buf.readUInt32LE(off + 9),
                    bitrateNominal: buf.readUInt32LE(off + 13),
                    bitrateMin: buf.readUInt32LE(off + 17)
                  };
                }
              };
            }).call(this, __webpack_require__2(9).Buffer);
          },
          /* 114 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const Token = __webpack_require__2(6);
            const FourCC_1 = __webpack_require__2(15);
            const initDebug = __webpack_require__2(8);
            const debug = initDebug("music-metadata:parser:MP4:atom");
            exports2.Header = {
              len: 8,
              get: (buf, off) => {
                const length = Token.UINT32_BE.get(buf, off);
                if (length < 0)
                  throw new Error("Invalid atom header length");
                return {
                  length,
                  name: FourCC_1.FourCcToken.get(buf, off + 4)
                };
              },
              put: (buf, off, hdr) => {
                Token.UINT32_BE.put(buf, off, hdr.length);
                return FourCC_1.FourCcToken.put(buf, off + 4, hdr.name);
              }
            };
            exports2.ExtendedSize = Token.UINT64_BE;
            exports2.ftyp = {
              len: 4,
              get: (buf, off) => {
                return {
                  type: new Token.StringType(4, "ascii").get(buf, off)
                };
              }
            };
            exports2.mhdr = {
              len: 8,
              get: (buf, off) => {
                return {
                  version: Token.UINT8.get(buf, off + 0),
                  flags: Token.UINT24_BE.get(buf, off + 1),
                  nextItemID: Token.UINT32_BE.get(buf, off + 4)
                };
              }
            };
            class FixedLengthAtom {
              /**
               *
               * @param {number} len Length as specified in the size field
               * @param {number} expLen Total length of sum of specified fields in the standard
               */
              constructor(len, expLen, atomId) {
                this.len = len;
                if (len < expLen) {
                  throw new Error(`Atom ${atomId} expected to be ${expLen}, but specifies ${len} bytes long.`);
                } else if (len > expLen) {
                  debug(`Warning: atom ${atomId} expected to be ${expLen}, but was actually ${len} bytes long.`);
                }
              }
            }
            exports2.FixedLengthAtom = FixedLengthAtom;
            class MdhdAtom extends FixedLengthAtom {
              constructor(len) {
                super(len, 24, "mdhd");
                this.len = len;
              }
              get(buf, off) {
                return {
                  version: Token.UINT8.get(buf, off + 0),
                  flags: Token.UINT24_BE.get(buf, off + 1),
                  creationTime: Token.UINT32_BE.get(buf, off + 4),
                  modificationTime: Token.UINT32_BE.get(buf, off + 8),
                  timeScale: Token.UINT32_BE.get(buf, off + 12),
                  duration: Token.UINT32_BE.get(buf, off + 16),
                  language: Token.UINT16_BE.get(buf, off + 20),
                  quality: Token.UINT16_BE.get(buf, off + 22)
                };
              }
            }
            exports2.MdhdAtom = MdhdAtom;
            class MvhdAtom extends FixedLengthAtom {
              constructor(len) {
                super(len, 100, "mvhd");
                this.len = len;
              }
              get(buf, off) {
                return {
                  version: Token.UINT8.get(buf, off + 0),
                  flags: Token.UINT24_BE.get(buf, off + 1),
                  creationTime: Token.UINT32_BE.get(buf, off + 4),
                  modificationTime: Token.UINT32_BE.get(buf, off + 8),
                  timeScale: Token.UINT32_BE.get(buf, off + 12),
                  duration: Token.UINT32_BE.get(buf, off + 16),
                  preferredRate: Token.UINT32_BE.get(buf, off + 20),
                  preferredVolume: Token.UINT16_BE.get(buf, off + 24),
                  // ignore reserver: 10 bytes
                  // ignore matrix structure: 36 bytes
                  previewTime: Token.UINT32_BE.get(buf, off + 72),
                  previewDuration: Token.UINT32_BE.get(buf, off + 76),
                  posterTime: Token.UINT32_BE.get(buf, off + 80),
                  selectionTime: Token.UINT32_BE.get(buf, off + 84),
                  selectionDuration: Token.UINT32_BE.get(buf, off + 88),
                  currentTime: Token.UINT32_BE.get(buf, off + 92),
                  nextTrackID: Token.UINT32_BE.get(buf, off + 96)
                };
              }
            }
            exports2.MvhdAtom = MvhdAtom;
            class DataAtom {
              constructor(len) {
                this.len = len;
              }
              get(buf, off) {
                return {
                  type: {
                    set: Token.UINT8.get(buf, off + 0),
                    type: Token.UINT24_BE.get(buf, off + 1)
                  },
                  locale: Token.UINT24_BE.get(buf, off + 4),
                  value: new Token.BufferType(this.len - 8).get(buf, off + 8)
                };
              }
            }
            exports2.DataAtom = DataAtom;
            class NameAtom {
              constructor(len) {
                this.len = len;
              }
              get(buf, off) {
                return {
                  version: Token.UINT8.get(buf, off),
                  flags: Token.UINT24_BE.get(buf, off + 1),
                  name: new Token.StringType(this.len - 4, "utf-8").get(buf, off + 4)
                };
              }
            }
            exports2.NameAtom = NameAtom;
            class TrackHeaderAtom {
              constructor(len) {
                this.len = len;
              }
              get(buf, off) {
                return {
                  version: Token.UINT8.get(buf, off),
                  flags: Token.UINT24_BE.get(buf, off + 1),
                  creationTime: Token.UINT32_BE.get(buf, off + 4),
                  modificationTime: Token.UINT32_BE.get(buf, off + 8),
                  trackId: Token.UINT32_BE.get(buf, off + 12),
                  // reserved 4 bytes
                  duration: Token.UINT32_BE.get(buf, off + 20),
                  layer: Token.UINT16_BE.get(buf, off + 24),
                  alternateGroup: Token.UINT16_BE.get(buf, off + 26),
                  volume: Token.UINT16_BE.get(buf, off + 28)
                  // ToDo: fixed point
                  // ToDo: add remaining fields
                };
              }
            }
            exports2.TrackHeaderAtom = TrackHeaderAtom;
            const stsdHeader = {
              len: 8,
              get: (buf, off) => {
                return {
                  version: Token.UINT8.get(buf, off + 0),
                  flags: Token.UINT24_BE.get(buf, off + 1),
                  numberOfEntries: Token.UINT32_BE.get(buf, off + 4)
                };
              }
            };
            class SampleDiscriptionTable {
              constructor(len) {
                this.len = len;
              }
              get(buf, off) {
                return {
                  dataFormat: FourCC_1.FourCcToken.get(buf, off),
                  dataReferenceIndex: Token.UINT16_BE.get(buf, off + 10)
                };
              }
            }
            class StsdAtom {
              constructor(len) {
                this.len = len;
              }
              get(buf, off) {
                const header = stsdHeader.get(buf, off);
                off += stsdHeader.len;
                const table = [];
                for (let n = 0; n < header.numberOfEntries; ++n) {
                  const size = Token.UINT32_BE.get(buf, off);
                  off += Token.UINT32_BE.len;
                  table.push(new SampleDiscriptionTable(size).get(buf, off));
                  off += size;
                }
                return {
                  header,
                  table
                };
              }
            }
            exports2.StsdAtom = StsdAtom;
          },
          /* 115 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            (function(Buffer2, global, setImmediate) {
              var require2;
              var require2;
              !function(t) {
                if (true) module2.exports = t();
                else {
                }
              }(function() {
                return function s(a, o, h) {
                  function u(r, t2) {
                    if (!o[r]) {
                      if (!a[r]) {
                        var e = "function" == typeof require2 && require2;
                        if (!t2 && e) return require2(r, true);
                        if (l) return l(r, true);
                        var i = new Error("Cannot find module '" + r + "'");
                        throw i.code = "MODULE_NOT_FOUND", i;
                      }
                      var n = o[r] = { exports: {} };
                      a[r][0].call(n.exports, function(t3) {
                        var e2 = a[r][1][t3];
                        return u(e2 || t3);
                      }, n, n.exports, s, a, o, h);
                    }
                    return o[r].exports;
                  }
                  for (var l = "function" == typeof require2 && require2, t = 0; t < h.length; t++) u(h[t]);
                  return u;
                }({ 1: [function(t, e, r) {
                  "use strict";
                  var c = t("./utils"), d = t("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                  r.encode = function(t2) {
                    for (var e2, r2, i, n, s, a, o, h = [], u = 0, l = t2.length, f = l, d2 = "string" !== c.getTypeOf(t2); u < t2.length; ) f = l - u, i = d2 ? (e2 = t2[u++], r2 = u < l ? t2[u++] : 0, u < l ? t2[u++] : 0) : (e2 = t2.charCodeAt(u++), r2 = u < l ? t2.charCodeAt(u++) : 0, u < l ? t2.charCodeAt(u++) : 0), n = e2 >> 2, s = (3 & e2) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | i >> 6 : 64, o = 2 < f ? 63 & i : 64, h.push(p.charAt(n) + p.charAt(s) + p.charAt(a) + p.charAt(o));
                    return h.join("");
                  }, r.decode = function(t2) {
                    var e2, r2, i, n, s, a, o = 0, h = 0, u = "data:";
                    if (t2.substr(0, u.length) === u) throw new Error("Invalid base64 input, it looks like a data url.");
                    var l, f = 3 * (t2 = t2.replace(/[^A-Za-z0-9\+\/\=]/g, "")).length / 4;
                    if (t2.charAt(t2.length - 1) === p.charAt(64) && f--, t2.charAt(t2.length - 2) === p.charAt(64) && f--, f % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
                    for (l = d.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < t2.length; ) e2 = p.indexOf(t2.charAt(o++)) << 2 | (n = p.indexOf(t2.charAt(o++))) >> 4, r2 = (15 & n) << 4 | (s = p.indexOf(t2.charAt(o++))) >> 2, i = (3 & s) << 6 | (a = p.indexOf(t2.charAt(o++))), l[h++] = e2, 64 !== s && (l[h++] = r2), 64 !== a && (l[h++] = i);
                    return l;
                  };
                }, { "./support": 30, "./utils": 32 }], 2: [function(t, e, r) {
                  "use strict";
                  var i = t("./external"), n = t("./stream/DataWorker"), s = t("./stream/DataLengthProbe"), a = t("./stream/Crc32Probe");
                  s = t("./stream/DataLengthProbe");
                  function o(t2, e2, r2, i2, n2) {
                    this.compressedSize = t2, this.uncompressedSize = e2, this.crc32 = r2, this.compression = i2, this.compressedContent = n2;
                  }
                  o.prototype = { getContentWorker: function() {
                    var t2 = new n(i.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new s("data_length")), e2 = this;
                    return t2.on("end", function() {
                      if (this.streamInfo.data_length !== e2.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
                    }), t2;
                  }, getCompressedWorker: function() {
                    return new n(i.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
                  } }, o.createWorkerFrom = function(t2, e2, r2) {
                    return t2.pipe(new a()).pipe(new s("uncompressedSize")).pipe(e2.compressWorker(r2)).pipe(new s("compressedSize")).withStreamInfo("compression", e2);
                  }, e.exports = o;
                }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(t, e, r) {
                  "use strict";
                  var i = t("./stream/GenericWorker");
                  r.STORE = { magic: "\0\0", compressWorker: function(t2) {
                    return new i("STORE compression");
                  }, uncompressWorker: function() {
                    return new i("STORE decompression");
                  } }, r.DEFLATE = t("./flate");
                }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(t, e, r) {
                  "use strict";
                  var i = t("./utils");
                  var o = function() {
                    for (var t2, e2 = [], r2 = 0; r2 < 256; r2++) {
                      t2 = r2;
                      for (var i2 = 0; i2 < 8; i2++) t2 = 1 & t2 ? 3988292384 ^ t2 >>> 1 : t2 >>> 1;
                      e2[r2] = t2;
                    }
                    return e2;
                  }();
                  e.exports = function(t2, e2) {
                    return void 0 !== t2 && t2.length ? "string" !== i.getTypeOf(t2) ? function(t3, e3, r2, i2) {
                      var n = o, s = i2 + r2;
                      t3 ^= -1;
                      for (var a = i2; a < s; a++) t3 = t3 >>> 8 ^ n[255 & (t3 ^ e3[a])];
                      return -1 ^ t3;
                    }(0 | e2, t2, t2.length, 0) : function(t3, e3, r2, i2) {
                      var n = o, s = i2 + r2;
                      t3 ^= -1;
                      for (var a = i2; a < s; a++) t3 = t3 >>> 8 ^ n[255 & (t3 ^ e3.charCodeAt(a))];
                      return -1 ^ t3;
                    }(0 | e2, t2, t2.length, 0) : 0;
                  };
                }, { "./utils": 32 }], 5: [function(t, e, r) {
                  "use strict";
                  r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
                }, {}], 6: [function(t, e, r) {
                  "use strict";
                  var i = null;
                  i = "undefined" != typeof Promise ? Promise : t("lie"), e.exports = { Promise: i };
                }, { lie: 37 }], 7: [function(t, e, r) {
                  "use strict";
                  var i = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, n = t("pako"), s = t("./utils"), a = t("./stream/GenericWorker"), o = i ? "uint8array" : "array";
                  function h(t2, e2) {
                    a.call(this, "FlateWorker/" + t2), this._pako = null, this._pakoAction = t2, this._pakoOptions = e2, this.meta = {};
                  }
                  r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function(t2) {
                    this.meta = t2.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, t2.data), false);
                  }, h.prototype.flush = function() {
                    a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
                  }, h.prototype.cleanUp = function() {
                    a.prototype.cleanUp.call(this), this._pako = null;
                  }, h.prototype._createPako = function() {
                    this._pako = new n[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
                    var e2 = this;
                    this._pako.onData = function(t2) {
                      e2.push({ data: t2, meta: e2.meta });
                    };
                  }, r.compressWorker = function(t2) {
                    return new h("Deflate", t2);
                  }, r.uncompressWorker = function() {
                    return new h("Inflate", {});
                  };
                }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(t, e, r) {
                  "use strict";
                  function A(t2, e2) {
                    var r2, i2 = "";
                    for (r2 = 0; r2 < e2; r2++) i2 += String.fromCharCode(255 & t2), t2 >>>= 8;
                    return i2;
                  }
                  function i(t2, e2, r2, i2, n2, s2) {
                    var a, o, h = t2.file, u = t2.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h.name)), d = I.transformTo("string", O.utf8encode(h.name)), c = h.comment, p = I.transformTo("string", s2(c)), m = I.transformTo("string", O.utf8encode(c)), _ = d.length !== h.name.length, g = m.length !== c.length, b = "", v = "", y = "", w = h.dir, k = h.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
                    e2 && !r2 || (x.crc32 = t2.crc32, x.compressedSize = t2.compressedSize, x.uncompressedSize = t2.uncompressedSize);
                    var S = 0;
                    e2 && (S |= 8), l || !_ && !g || (S |= 2048);
                    var z = 0, C = 0;
                    w && (z |= 16), "UNIX" === n2 ? (C = 798, z |= function(t3, e3) {
                      var r3 = t3;
                      return t3 || (r3 = e3 ? 16893 : 33204), (65535 & r3) << 16;
                    }(h.unixPermissions, w)) : (C = 20, z |= function(t3) {
                      return 63 & (t3 || 0);
                    }(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + d, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y);
                    var E = "";
                    return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z, 4) + A(i2, 4) + f + b + p };
                  }
                  var I = t("../utils"), n = t("../stream/GenericWorker"), O = t("../utf8"), B = t("../crc32"), R = t("../signature");
                  function s(t2, e2, r2, i2) {
                    n.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = e2, this.zipPlatform = r2, this.encodeFileName = i2, this.streamFiles = t2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
                  }
                  I.inherits(s, n), s.prototype.push = function(t2) {
                    var e2 = t2.meta.percent || 0, r2 = this.entriesCount, i2 = this._sources.length;
                    this.accumulate ? this.contentBuffer.push(t2) : (this.bytesWritten += t2.data.length, n.prototype.push.call(this, { data: t2.data, meta: { currentFile: this.currentFile, percent: r2 ? (e2 + 100 * (r2 - i2 - 1)) / r2 : 100 } }));
                  }, s.prototype.openedSource = function(t2) {
                    this.currentSourceOffset = this.bytesWritten, this.currentFile = t2.file.name;
                    var e2 = this.streamFiles && !t2.file.dir;
                    if (e2) {
                      var r2 = i(t2, e2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                      this.push({ data: r2.fileRecord, meta: { percent: 0 } });
                    } else this.accumulate = true;
                  }, s.prototype.closedSource = function(t2) {
                    this.accumulate = false;
                    var e2 = this.streamFiles && !t2.file.dir, r2 = i(t2, e2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                    if (this.dirRecords.push(r2.dirRecord), e2) this.push({ data: function(t3) {
                      return R.DATA_DESCRIPTOR + A(t3.crc32, 4) + A(t3.compressedSize, 4) + A(t3.uncompressedSize, 4);
                    }(t2), meta: { percent: 100 } });
                    else for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
                    this.currentFile = null;
                  }, s.prototype.flush = function() {
                    for (var t2 = this.bytesWritten, e2 = 0; e2 < this.dirRecords.length; e2++) this.push({ data: this.dirRecords[e2], meta: { percent: 100 } });
                    var r2 = this.bytesWritten - t2, i2 = function(t3, e3, r3, i3, n2) {
                      var s2 = I.transformTo("string", n2(i3));
                      return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(t3, 2) + A(t3, 2) + A(e3, 4) + A(r3, 4) + A(s2.length, 2) + s2;
                    }(this.dirRecords.length, r2, t2, this.zipComment, this.encodeFileName);
                    this.push({ data: i2, meta: { percent: 100 } });
                  }, s.prototype.prepareNextSource = function() {
                    this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
                  }, s.prototype.registerPrevious = function(t2) {
                    this._sources.push(t2);
                    var e2 = this;
                    return t2.on("data", function(t3) {
                      e2.processChunk(t3);
                    }), t2.on("end", function() {
                      e2.closedSource(e2.previous.streamInfo), e2._sources.length ? e2.prepareNextSource() : e2.end();
                    }), t2.on("error", function(t3) {
                      e2.error(t3);
                    }), this;
                  }, s.prototype.resume = function() {
                    return !!n.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
                  }, s.prototype.error = function(t2) {
                    var e2 = this._sources;
                    if (!n.prototype.error.call(this, t2)) return false;
                    for (var r2 = 0; r2 < e2.length; r2++) try {
                      e2[r2].error(t2);
                    } catch (t3) {
                    }
                    return true;
                  }, s.prototype.lock = function() {
                    n.prototype.lock.call(this);
                    for (var t2 = this._sources, e2 = 0; e2 < t2.length; e2++) t2[e2].lock();
                  }, e.exports = s;
                }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(t, e, r) {
                  "use strict";
                  var u = t("../compressions"), i = t("./ZipFileWorker");
                  r.generateWorker = function(t2, a, e2) {
                    var o = new i(a.streamFiles, e2, a.platform, a.encodeFileName), h = 0;
                    try {
                      t2.forEach(function(t3, e3) {
                        h++;
                        var r2 = function(t4, e4) {
                          var r3 = t4 || e4, i3 = u[r3];
                          if (!i3) throw new Error(r3 + " is not a valid compression method !");
                          return i3;
                        }(e3.options.compression, a.compression), i2 = e3.options.compressionOptions || a.compressionOptions || {}, n = e3.dir, s = e3.date;
                        e3._compressWorker(r2, i2).withStreamInfo("file", { name: t3, dir: n, date: s, comment: e3.comment || "", unixPermissions: e3.unixPermissions, dosPermissions: e3.dosPermissions }).pipe(o);
                      }), o.entriesCount = h;
                    } catch (t3) {
                      o.error(t3);
                    }
                    return o;
                  };
                }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(t, e, r) {
                  "use strict";
                  function i() {
                    if (!(this instanceof i)) return new i();
                    if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
                    this.files = {}, this.comment = null, this.root = "", this.clone = function() {
                      var t2 = new i();
                      for (var e2 in this) "function" != typeof this[e2] && (t2[e2] = this[e2]);
                      return t2;
                    };
                  }
                  (i.prototype = t("./object")).loadAsync = t("./load"), i.support = t("./support"), i.defaults = t("./defaults"), i.version = "3.4.0", i.loadAsync = function(t2, e2) {
                    return new i().loadAsync(t2, e2);
                  }, i.external = t("./external"), e.exports = i;
                }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(t, e, r) {
                  "use strict";
                  var i = t("./utils"), n = t("./external"), o = t("./utf8"), h = (i = t("./utils"), t("./zipEntries")), s = t("./stream/Crc32Probe"), u = t("./nodejsUtils");
                  function l(i2) {
                    return new n.Promise(function(t2, e2) {
                      var r2 = i2.decompressed.getContentWorker().pipe(new s());
                      r2.on("error", function(t3) {
                        e2(t3);
                      }).on("end", function() {
                        r2.streamInfo.crc32 !== i2.decompressed.crc32 ? e2(new Error("Corrupted zip : CRC32 mismatch")) : t2();
                      }).resume();
                    });
                  }
                  e.exports = function(t2, s2) {
                    var a = this;
                    return s2 = i.extend(s2 || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: o.utf8decode }), u.isNode && u.isStream(t2) ? n.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : i.prepareContent("the loaded zip file", t2, true, s2.optimizedBinaryString, s2.base64).then(function(t3) {
                      var e2 = new h(s2);
                      return e2.load(t3), e2;
                    }).then(function(t3) {
                      var e2 = [n.Promise.resolve(t3)], r2 = t3.files;
                      if (s2.checkCRC32) for (var i2 = 0; i2 < r2.length; i2++) e2.push(l(r2[i2]));
                      return n.Promise.all(e2);
                    }).then(function(t3) {
                      for (var e2 = t3.shift(), r2 = e2.files, i2 = 0; i2 < r2.length; i2++) {
                        var n2 = r2[i2];
                        a.file(n2.fileNameStr, n2.decompressed, { binary: true, optimizedBinaryString: true, date: n2.date, dir: n2.dir, comment: n2.fileCommentStr.length ? n2.fileCommentStr : null, unixPermissions: n2.unixPermissions, dosPermissions: n2.dosPermissions, createFolders: s2.createFolders });
                      }
                      return e2.zipComment.length && (a.comment = e2.zipComment), a;
                    });
                  };
                }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(t, e, r) {
                  "use strict";
                  var i = t("../utils"), n = t("../stream/GenericWorker");
                  function s(t2, e2) {
                    n.call(this, "Nodejs stream input adapter for " + t2), this._upstreamEnded = false, this._bindStream(e2);
                  }
                  i.inherits(s, n), s.prototype._bindStream = function(t2) {
                    var e2 = this;
                    (this._stream = t2).pause(), t2.on("data", function(t3) {
                      e2.push({ data: t3, meta: { percent: 0 } });
                    }).on("error", function(t3) {
                      e2.isPaused ? this.generatedError = t3 : e2.error(t3);
                    }).on("end", function() {
                      e2.isPaused ? e2._upstreamEnded = true : e2.end();
                    });
                  }, s.prototype.pause = function() {
                    return !!n.prototype.pause.call(this) && (this._stream.pause(), true);
                  }, s.prototype.resume = function() {
                    return !!n.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
                  }, e.exports = s;
                }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(t, e, r) {
                  "use strict";
                  var n = t("readable-stream").Readable;
                  function i(t2, e2, r2) {
                    n.call(this, e2), this._helper = t2;
                    var i2 = this;
                    t2.on("data", function(t3, e3) {
                      i2.push(t3) || i2._helper.pause(), r2 && r2(e3);
                    }).on("error", function(t3) {
                      i2.emit("error", t3);
                    }).on("end", function() {
                      i2.push(null);
                    });
                  }
                  t("../utils").inherits(i, n), i.prototype._read = function() {
                    this._helper.resume();
                  }, e.exports = i;
                }, { "../utils": 32, "readable-stream": 16 }], 14: [function(t, e, r) {
                  "use strict";
                  e.exports = { isNode: "undefined" != typeof Buffer2, newBufferFrom: function(t2, e2) {
                    if (Buffer2.from && Buffer2.from !== Uint8Array.from) return Buffer2.from(t2, e2);
                    if ("number" == typeof t2) throw new Error('The "data" argument must not be a number');
                    return new Buffer2(t2, e2);
                  }, allocBuffer: function(t2) {
                    if (Buffer2.alloc) return Buffer2.alloc(t2);
                    var e2 = new Buffer2(t2);
                    return e2.fill(0), e2;
                  }, isBuffer: function(t2) {
                    return Buffer2.isBuffer(t2);
                  }, isStream: function(t2) {
                    return t2 && "function" == typeof t2.on && "function" == typeof t2.pause && "function" == typeof t2.resume;
                  } };
                }, {}], 15: [function(t, e, r) {
                  "use strict";
                  function s(t2, e2, r2) {
                    var i2, n2 = u.getTypeOf(e2), s2 = u.extend(r2 || {}, f);
                    s2.date = s2.date || /* @__PURE__ */ new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), "string" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (t2 = g(t2)), s2.createFolders && (i2 = _(t2)) && b.call(this, i2, true);
                    var a2 = "string" === n2 && false === s2.binary && false === s2.base64;
                    r2 && void 0 !== r2.binary || (s2.binary = !a2), (e2 instanceof d && 0 === e2.uncompressedSize || s2.dir || !e2 || 0 === e2.length) && (s2.base64 = false, s2.binary = true, e2 = "", s2.compression = "STORE", n2 = "string");
                    var o2 = null;
                    o2 = e2 instanceof d || e2 instanceof l ? e2 : p.isNode && p.isStream(e2) ? new m(t2, e2) : u.prepareContent(t2, e2, s2.binary, s2.optimizedBinaryString, s2.base64);
                    var h2 = new c(t2, o2, s2);
                    this.files[t2] = h2;
                  }
                  var n = t("./utf8"), u = t("./utils"), l = t("./stream/GenericWorker"), a = t("./stream/StreamHelper"), f = t("./defaults"), d = t("./compressedObject"), c = t("./zipObject"), o = t("./generate"), p = t("./nodejsUtils"), m = t("./nodejs/NodejsStreamInputAdapter"), _ = function(t2) {
                    "/" === t2.slice(-1) && (t2 = t2.substring(0, t2.length - 1));
                    var e2 = t2.lastIndexOf("/");
                    return 0 < e2 ? t2.substring(0, e2) : "";
                  }, g = function(t2) {
                    return "/" !== t2.slice(-1) && (t2 += "/"), t2;
                  }, b = function(t2, e2) {
                    return e2 = void 0 !== e2 ? e2 : f.createFolders, t2 = g(t2), this.files[t2] || s.call(this, t2, null, { dir: true, createFolders: e2 }), this.files[t2];
                  };
                  function h(t2) {
                    return "[object RegExp]" === Object.prototype.toString.call(t2);
                  }
                  var i = { load: function() {
                    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                  }, forEach: function(t2) {
                    var e2, r2, i2;
                    for (e2 in this.files) this.files.hasOwnProperty(e2) && (i2 = this.files[e2], (r2 = e2.slice(this.root.length, e2.length)) && e2.slice(0, this.root.length) === this.root && t2(r2, i2));
                  }, filter: function(r2) {
                    var i2 = [];
                    return this.forEach(function(t2, e2) {
                      r2(t2, e2) && i2.push(e2);
                    }), i2;
                  }, file: function(t2, e2, r2) {
                    if (1 !== arguments.length) return t2 = this.root + t2, s.call(this, t2, e2, r2), this;
                    if (h(t2)) {
                      var i2 = t2;
                      return this.filter(function(t3, e3) {
                        return !e3.dir && i2.test(t3);
                      });
                    }
                    var n2 = this.files[this.root + t2];
                    return n2 && !n2.dir ? n2 : null;
                  }, folder: function(r2) {
                    if (!r2) return this;
                    if (h(r2)) return this.filter(function(t3, e3) {
                      return e3.dir && r2.test(t3);
                    });
                    var t2 = this.root + r2, e2 = b.call(this, t2), i2 = this.clone();
                    return i2.root = e2.name, i2;
                  }, remove: function(r2) {
                    r2 = this.root + r2;
                    var t2 = this.files[r2];
                    if (t2 || ("/" !== r2.slice(-1) && (r2 += "/"), t2 = this.files[r2]), t2 && !t2.dir) delete this.files[r2];
                    else for (var e2 = this.filter(function(t3, e3) {
                      return e3.name.slice(0, r2.length) === r2;
                    }), i2 = 0; i2 < e2.length; i2++) delete this.files[e2[i2].name];
                    return this;
                  }, generate: function(t2) {
                    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                  }, generateInternalStream: function(t2) {
                    var e2, r2 = {};
                    try {
                      if ((r2 = u.extend(t2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: n.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), "binarystring" === r2.type && (r2.type = "string"), !r2.type) throw new Error("No output type specified.");
                      u.checkSupport(r2.type), "darwin" !== r2.platform && "freebsd" !== r2.platform && "linux" !== r2.platform && "sunos" !== r2.platform || (r2.platform = "UNIX"), "win32" === r2.platform && (r2.platform = "DOS");
                      var i2 = r2.comment || this.comment || "";
                      e2 = o.generateWorker(this, r2, i2);
                    } catch (t3) {
                      (e2 = new l("error")).error(t3);
                    }
                    return new a(e2, r2.type || "string", r2.mimeType);
                  }, generateAsync: function(t2, e2) {
                    return this.generateInternalStream(t2).accumulate(e2);
                  }, generateNodeStream: function(t2, e2) {
                    return (t2 = t2 || {}).type || (t2.type = "nodebuffer"), this.generateInternalStream(t2).toNodejsStream(e2);
                  } };
                  e.exports = i;
                }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(t, e, r) {
                  e.exports = t("stream");
                }, { stream: void 0 }], 17: [function(t, e, r) {
                  "use strict";
                  var i = t("./DataReader");
                  function n(t2) {
                    i.call(this, t2);
                    for (var e2 = 0; e2 < this.data.length; e2++) t2[e2] = 255 & t2[e2];
                  }
                  t("../utils").inherits(n, i), n.prototype.byteAt = function(t2) {
                    return this.data[this.zero + t2];
                  }, n.prototype.lastIndexOfSignature = function(t2) {
                    for (var e2 = t2.charCodeAt(0), r2 = t2.charCodeAt(1), i2 = t2.charCodeAt(2), n2 = t2.charCodeAt(3), s = this.length - 4; 0 <= s; --s) if (this.data[s] === e2 && this.data[s + 1] === r2 && this.data[s + 2] === i2 && this.data[s + 3] === n2) return s - this.zero;
                    return -1;
                  }, n.prototype.readAndCheckSignature = function(t2) {
                    var e2 = t2.charCodeAt(0), r2 = t2.charCodeAt(1), i2 = t2.charCodeAt(2), n2 = t2.charCodeAt(3), s = this.readData(4);
                    return e2 === s[0] && r2 === s[1] && i2 === s[2] && n2 === s[3];
                  }, n.prototype.readData = function(t2) {
                    if (this.checkOffset(t2), 0 === t2) return [];
                    var e2 = this.data.slice(this.zero + this.index, this.zero + this.index + t2);
                    return this.index += t2, e2;
                  }, e.exports = n;
                }, { "../utils": 32, "./DataReader": 18 }], 18: [function(t, e, r) {
                  "use strict";
                  var i = t("../utils");
                  function n(t2) {
                    this.data = t2, this.length = t2.length, this.index = 0, this.zero = 0;
                  }
                  n.prototype = { checkOffset: function(t2) {
                    this.checkIndex(this.index + t2);
                  }, checkIndex: function(t2) {
                    if (this.length < this.zero + t2 || t2 < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + t2 + "). Corrupted zip ?");
                  }, setIndex: function(t2) {
                    this.checkIndex(t2), this.index = t2;
                  }, skip: function(t2) {
                    this.setIndex(this.index + t2);
                  }, byteAt: function(t2) {
                  }, readInt: function(t2) {
                    var e2, r2 = 0;
                    for (this.checkOffset(t2), e2 = this.index + t2 - 1; e2 >= this.index; e2--) r2 = (r2 << 8) + this.byteAt(e2);
                    return this.index += t2, r2;
                  }, readString: function(t2) {
                    return i.transformTo("string", this.readData(t2));
                  }, readData: function(t2) {
                  }, lastIndexOfSignature: function(t2) {
                  }, readAndCheckSignature: function(t2) {
                  }, readDate: function() {
                    var t2 = this.readInt(4);
                    return new Date(Date.UTC(1980 + (t2 >> 25 & 127), (t2 >> 21 & 15) - 1, t2 >> 16 & 31, t2 >> 11 & 31, t2 >> 5 & 63, (31 & t2) << 1));
                  } }, e.exports = n;
                }, { "../utils": 32 }], 19: [function(t, e, r) {
                  "use strict";
                  var i = t("./Uint8ArrayReader");
                  function n(t2) {
                    i.call(this, t2);
                  }
                  t("../utils").inherits(n, i), n.prototype.readData = function(t2) {
                    this.checkOffset(t2);
                    var e2 = this.data.slice(this.zero + this.index, this.zero + this.index + t2);
                    return this.index += t2, e2;
                  }, e.exports = n;
                }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(t, e, r) {
                  "use strict";
                  var i = t("./DataReader");
                  function n(t2) {
                    i.call(this, t2);
                  }
                  t("../utils").inherits(n, i), n.prototype.byteAt = function(t2) {
                    return this.data.charCodeAt(this.zero + t2);
                  }, n.prototype.lastIndexOfSignature = function(t2) {
                    return this.data.lastIndexOf(t2) - this.zero;
                  }, n.prototype.readAndCheckSignature = function(t2) {
                    return t2 === this.readData(4);
                  }, n.prototype.readData = function(t2) {
                    this.checkOffset(t2);
                    var e2 = this.data.slice(this.zero + this.index, this.zero + this.index + t2);
                    return this.index += t2, e2;
                  }, e.exports = n;
                }, { "../utils": 32, "./DataReader": 18 }], 21: [function(t, e, r) {
                  "use strict";
                  var i = t("./ArrayReader");
                  function n(t2) {
                    i.call(this, t2);
                  }
                  t("../utils").inherits(n, i), n.prototype.readData = function(t2) {
                    if (this.checkOffset(t2), 0 === t2) return new Uint8Array(0);
                    var e2 = this.data.subarray(this.zero + this.index, this.zero + this.index + t2);
                    return this.index += t2, e2;
                  }, e.exports = n;
                }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(t, e, r) {
                  "use strict";
                  var i = t("../utils"), n = t("../support"), s = t("./ArrayReader"), a = t("./StringReader"), o = t("./NodeBufferReader"), h = t("./Uint8ArrayReader");
                  e.exports = function(t2) {
                    var e2 = i.getTypeOf(t2);
                    return i.checkSupport(e2), "string" !== e2 || n.uint8array ? "nodebuffer" === e2 ? new o(t2) : n.uint8array ? new h(i.transformTo("uint8array", t2)) : new s(i.transformTo("array", t2)) : new a(t2);
                  };
                }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(t, e, r) {
                  "use strict";
                  r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
                }, {}], 24: [function(t, e, r) {
                  "use strict";
                  var i = t("./GenericWorker"), n = t("../utils");
                  function s(t2) {
                    i.call(this, "ConvertWorker to " + t2), this.destType = t2;
                  }
                  n.inherits(s, i), s.prototype.processChunk = function(t2) {
                    this.push({ data: n.transformTo(this.destType, t2.data), meta: t2.meta });
                  }, e.exports = s;
                }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(t, e, r) {
                  "use strict";
                  var i = t("./GenericWorker"), n = t("../crc32");
                  function s() {
                    i.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
                  }
                  t("../utils").inherits(s, i), s.prototype.processChunk = function(t2) {
                    this.streamInfo.crc32 = n(t2.data, this.streamInfo.crc32 || 0), this.push(t2);
                  }, e.exports = s;
                }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(t, e, r) {
                  "use strict";
                  var i = t("../utils"), n = t("./GenericWorker");
                  function s(t2) {
                    n.call(this, "DataLengthProbe for " + t2), this.propName = t2, this.withStreamInfo(t2, 0);
                  }
                  i.inherits(s, n), s.prototype.processChunk = function(t2) {
                    if (t2) {
                      var e2 = this.streamInfo[this.propName] || 0;
                      this.streamInfo[this.propName] = e2 + t2.data.length;
                    }
                    n.prototype.processChunk.call(this, t2);
                  }, e.exports = s;
                }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(t, e, r) {
                  "use strict";
                  var i = t("../utils"), n = t("./GenericWorker");
                  function s(t2) {
                    n.call(this, "DataWorker");
                    var e2 = this;
                    this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, t2.then(function(t3) {
                      e2.dataIsReady = true, e2.data = t3, e2.max = t3 && t3.length || 0, e2.type = i.getTypeOf(t3), e2.isPaused || e2._tickAndRepeat();
                    }, function(t3) {
                      e2.error(t3);
                    });
                  }
                  i.inherits(s, n), s.prototype.cleanUp = function() {
                    n.prototype.cleanUp.call(this), this.data = null;
                  }, s.prototype.resume = function() {
                    return !!n.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, i.delay(this._tickAndRepeat, [], this)), true);
                  }, s.prototype._tickAndRepeat = function() {
                    this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (i.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
                  }, s.prototype._tick = function() {
                    if (this.isPaused || this.isFinished) return false;
                    var t2 = null, e2 = Math.min(this.max, this.index + 16384);
                    if (this.index >= this.max) return this.end();
                    switch (this.type) {
                      case "string":
                        t2 = this.data.substring(this.index, e2);
                        break;
                      case "uint8array":
                        t2 = this.data.subarray(this.index, e2);
                        break;
                      case "array":
                      case "nodebuffer":
                        t2 = this.data.slice(this.index, e2);
                    }
                    return this.index = e2, this.push({ data: t2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
                  }, e.exports = s;
                }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(t, e, r) {
                  "use strict";
                  function i(t2) {
                    this.name = t2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
                  }
                  i.prototype = { push: function(t2) {
                    this.emit("data", t2);
                  }, end: function() {
                    if (this.isFinished) return false;
                    this.flush();
                    try {
                      this.emit("end"), this.cleanUp(), this.isFinished = true;
                    } catch (t2) {
                      this.emit("error", t2);
                    }
                    return true;
                  }, error: function(t2) {
                    return !this.isFinished && (this.isPaused ? this.generatedError = t2 : (this.isFinished = true, this.emit("error", t2), this.previous && this.previous.error(t2), this.cleanUp()), true);
                  }, on: function(t2, e2) {
                    return this._listeners[t2].push(e2), this;
                  }, cleanUp: function() {
                    this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
                  }, emit: function(t2, e2) {
                    if (this._listeners[t2]) for (var r2 = 0; r2 < this._listeners[t2].length; r2++) this._listeners[t2][r2].call(this, e2);
                  }, pipe: function(t2) {
                    return t2.registerPrevious(this);
                  }, registerPrevious: function(t2) {
                    if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
                    this.streamInfo = t2.streamInfo, this.mergeStreamInfo(), this.previous = t2;
                    var e2 = this;
                    return t2.on("data", function(t3) {
                      e2.processChunk(t3);
                    }), t2.on("end", function() {
                      e2.end();
                    }), t2.on("error", function(t3) {
                      e2.error(t3);
                    }), this;
                  }, pause: function() {
                    return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
                  }, resume: function() {
                    if (!this.isPaused || this.isFinished) return false;
                    var t2 = this.isPaused = false;
                    return this.generatedError && (this.error(this.generatedError), t2 = true), this.previous && this.previous.resume(), !t2;
                  }, flush: function() {
                  }, processChunk: function(t2) {
                    this.push(t2);
                  }, withStreamInfo: function(t2, e2) {
                    return this.extraStreamInfo[t2] = e2, this.mergeStreamInfo(), this;
                  }, mergeStreamInfo: function() {
                    for (var t2 in this.extraStreamInfo) this.extraStreamInfo.hasOwnProperty(t2) && (this.streamInfo[t2] = this.extraStreamInfo[t2]);
                  }, lock: function() {
                    if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
                    this.isLocked = true, this.previous && this.previous.lock();
                  }, toString: function() {
                    var t2 = "Worker " + this.name;
                    return this.previous ? this.previous + " -> " + t2 : t2;
                  } }, e.exports = i;
                }, {}], 29: [function(t, e, r) {
                  "use strict";
                  var h = t("../utils"), n = t("./ConvertWorker"), s = t("./GenericWorker"), u = t("../base64"), i = t("../support"), a = t("../external"), o = null;
                  if (i.nodestream) try {
                    o = t("../nodejs/NodejsStreamOutputAdapter");
                  } catch (t2) {
                  }
                  function l(t2, o2) {
                    return new a.Promise(function(e2, r2) {
                      var i2 = [], n2 = t2._internalType, s2 = t2._outputType, a2 = t2._mimeType;
                      t2.on("data", function(t3, e3) {
                        i2.push(t3), o2 && o2(e3);
                      }).on("error", function(t3) {
                        i2 = [], r2(t3);
                      }).on("end", function() {
                        try {
                          var t3 = function(t4, e3, r3) {
                            switch (t4) {
                              case "blob":
                                return h.newBlob(h.transformTo("arraybuffer", e3), r3);
                              case "base64":
                                return u.encode(e3);
                              default:
                                return h.transformTo(t4, e3);
                            }
                          }(s2, function(t4, e3) {
                            var r3, i3 = 0, n3 = null, s3 = 0;
                            for (r3 = 0; r3 < e3.length; r3++) s3 += e3[r3].length;
                            switch (t4) {
                              case "string":
                                return e3.join("");
                              case "array":
                                return Array.prototype.concat.apply([], e3);
                              case "uint8array":
                                for (n3 = new Uint8Array(s3), r3 = 0; r3 < e3.length; r3++) n3.set(e3[r3], i3), i3 += e3[r3].length;
                                return n3;
                              case "nodebuffer":
                                return Buffer2.concat(e3);
                              default:
                                throw new Error("concat : unsupported type '" + t4 + "'");
                            }
                          }(n2, i2), a2);
                          e2(t3);
                        } catch (t4) {
                          r2(t4);
                        }
                        i2 = [];
                      }).resume();
                    });
                  }
                  function f(t2, e2, r2) {
                    var i2 = e2;
                    switch (e2) {
                      case "blob":
                      case "arraybuffer":
                        i2 = "uint8array";
                        break;
                      case "base64":
                        i2 = "string";
                    }
                    try {
                      this._internalType = i2, this._outputType = e2, this._mimeType = r2, h.checkSupport(i2), this._worker = t2.pipe(new n(i2)), t2.lock();
                    } catch (t3) {
                      this._worker = new s("error"), this._worker.error(t3);
                    }
                  }
                  f.prototype = { accumulate: function(t2) {
                    return l(this, t2);
                  }, on: function(t2, e2) {
                    var r2 = this;
                    return "data" === t2 ? this._worker.on(t2, function(t3) {
                      e2.call(r2, t3.data, t3.meta);
                    }) : this._worker.on(t2, function() {
                      h.delay(e2, arguments, r2);
                    }), this;
                  }, resume: function() {
                    return h.delay(this._worker.resume, [], this._worker), this;
                  }, pause: function() {
                    return this._worker.pause(), this;
                  }, toNodejsStream: function(t2) {
                    if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType) throw new Error(this._outputType + " is not supported by this method");
                    return new o(this, { objectMode: "nodebuffer" !== this._outputType }, t2);
                  } }, e.exports = f;
                }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(t, e, r) {
                  "use strict";
                  if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer2, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer) r.blob = false;
                  else {
                    var i = new ArrayBuffer(0);
                    try {
                      r.blob = 0 === new Blob([i], { type: "application/zip" }).size;
                    } catch (t2) {
                      try {
                        var n = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                        n.append(i), r.blob = 0 === n.getBlob("application/zip").size;
                      } catch (t3) {
                        r.blob = false;
                      }
                    }
                  }
                  try {
                    r.nodestream = !!t("readable-stream").Readable;
                  } catch (t2) {
                    r.nodestream = false;
                  }
                }, { "readable-stream": 16 }], 31: [function(t, e, s) {
                  "use strict";
                  for (var o = t("./utils"), h = t("./support"), r = t("./nodejsUtils"), i = t("./stream/GenericWorker"), u = new Array(256), n = 0; n < 256; n++) u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
                  u[254] = u[254] = 1;
                  function a() {
                    i.call(this, "utf-8 decode"), this.leftOver = null;
                  }
                  function l() {
                    i.call(this, "utf-8 encode");
                  }
                  s.utf8encode = function(t2) {
                    return h.nodebuffer ? r.newBufferFrom(t2, "utf-8") : function(t3) {
                      var e2, r2, i2, n2, s2, a2 = t3.length, o2 = 0;
                      for (n2 = 0; n2 < a2; n2++) 55296 == (64512 & (r2 = t3.charCodeAt(n2))) && n2 + 1 < a2 && 56320 == (64512 & (i2 = t3.charCodeAt(n2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (i2 - 56320), n2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
                      for (e2 = h.uint8array ? new Uint8Array(o2) : new Array(o2), n2 = s2 = 0; s2 < o2; n2++) 55296 == (64512 & (r2 = t3.charCodeAt(n2))) && n2 + 1 < a2 && 56320 == (64512 & (i2 = t3.charCodeAt(n2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (i2 - 56320), n2++), r2 < 128 ? e2[s2++] = r2 : (r2 < 2048 ? e2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? e2[s2++] = 224 | r2 >>> 12 : (e2[s2++] = 240 | r2 >>> 18, e2[s2++] = 128 | r2 >>> 12 & 63), e2[s2++] = 128 | r2 >>> 6 & 63), e2[s2++] = 128 | 63 & r2);
                      return e2;
                    }(t2);
                  }, s.utf8decode = function(t2) {
                    return h.nodebuffer ? o.transformTo("nodebuffer", t2).toString("utf-8") : function(t3) {
                      var e2, r2, i2, n2, s2 = t3.length, a2 = new Array(2 * s2);
                      for (e2 = r2 = 0; e2 < s2; ) if ((i2 = t3[e2++]) < 128) a2[r2++] = i2;
                      else if (4 < (n2 = u[i2])) a2[r2++] = 65533, e2 += n2 - 1;
                      else {
                        for (i2 &= 2 === n2 ? 31 : 3 === n2 ? 15 : 7; 1 < n2 && e2 < s2; ) i2 = i2 << 6 | 63 & t3[e2++], n2--;
                        1 < n2 ? a2[r2++] = 65533 : i2 < 65536 ? a2[r2++] = i2 : (i2 -= 65536, a2[r2++] = 55296 | i2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & i2);
                      }
                      return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
                    }(t2 = o.transformTo(h.uint8array ? "uint8array" : "array", t2));
                  }, o.inherits(a, i), a.prototype.processChunk = function(t2) {
                    var e2 = o.transformTo(h.uint8array ? "uint8array" : "array", t2.data);
                    if (this.leftOver && this.leftOver.length) {
                      if (h.uint8array) {
                        var r2 = e2;
                        (e2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), e2.set(r2, this.leftOver.length);
                      } else e2 = this.leftOver.concat(e2);
                      this.leftOver = null;
                    }
                    var i2 = function(t3, e3) {
                      var r3;
                      for ((e3 = e3 || t3.length) > t3.length && (e3 = t3.length), r3 = e3 - 1; 0 <= r3 && 128 == (192 & t3[r3]); ) r3--;
                      return r3 < 0 ? e3 : 0 === r3 ? e3 : r3 + u[t3[r3]] > e3 ? r3 : e3;
                    }(e2), n2 = e2;
                    i2 !== e2.length && (h.uint8array ? (n2 = e2.subarray(0, i2), this.leftOver = e2.subarray(i2, e2.length)) : (n2 = e2.slice(0, i2), this.leftOver = e2.slice(i2, e2.length))), this.push({ data: s.utf8decode(n2), meta: t2.meta });
                  }, a.prototype.flush = function() {
                    this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
                  }, s.Utf8DecodeWorker = a, o.inherits(l, i), l.prototype.processChunk = function(t2) {
                    this.push({ data: s.utf8encode(t2.data), meta: t2.meta });
                  }, s.Utf8EncodeWorker = l;
                }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(t, e, a) {
                  "use strict";
                  var o = t("./support"), h = t("./base64"), r = t("./nodejsUtils"), i = t("set-immediate-shim"), u = t("./external");
                  function n(t2) {
                    return t2;
                  }
                  function l(t2, e2) {
                    for (var r2 = 0; r2 < t2.length; ++r2) e2[r2] = 255 & t2.charCodeAt(r2);
                    return e2;
                  }
                  a.newBlob = function(e2, r2) {
                    a.checkSupport("blob");
                    try {
                      return new Blob([e2], { type: r2 });
                    } catch (t2) {
                      try {
                        var i2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
                        return i2.append(e2), i2.getBlob(r2);
                      } catch (t3) {
                        throw new Error("Bug : can't construct the Blob.");
                      }
                    }
                  };
                  var s = { stringifyByChunk: function(t2, e2, r2) {
                    var i2 = [], n2 = 0, s2 = t2.length;
                    if (s2 <= r2) return String.fromCharCode.apply(null, t2);
                    for (; n2 < s2; ) "array" === e2 || "nodebuffer" === e2 ? i2.push(String.fromCharCode.apply(null, t2.slice(n2, Math.min(n2 + r2, s2)))) : i2.push(String.fromCharCode.apply(null, t2.subarray(n2, Math.min(n2 + r2, s2)))), n2 += r2;
                    return i2.join("");
                  }, stringifyByChar: function(t2) {
                    for (var e2 = "", r2 = 0; r2 < t2.length; r2++) e2 += String.fromCharCode(t2[r2]);
                    return e2;
                  }, applyCanBeUsed: { uint8array: function() {
                    try {
                      return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
                    } catch (t2) {
                      return false;
                    }
                  }(), nodebuffer: function() {
                    try {
                      return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
                    } catch (t2) {
                      return false;
                    }
                  }() } };
                  function f(t2) {
                    var e2 = 65536, r2 = a.getTypeOf(t2), i2 = true;
                    if ("uint8array" === r2 ? i2 = s.applyCanBeUsed.uint8array : "nodebuffer" === r2 && (i2 = s.applyCanBeUsed.nodebuffer), i2) for (; 1 < e2; ) try {
                      return s.stringifyByChunk(t2, r2, e2);
                    } catch (t3) {
                      e2 = Math.floor(e2 / 2);
                    }
                    return s.stringifyByChar(t2);
                  }
                  function d(t2, e2) {
                    for (var r2 = 0; r2 < t2.length; r2++) e2[r2] = t2[r2];
                    return e2;
                  }
                  a.applyFromCharCode = f;
                  var c = {};
                  c.string = { string: n, array: function(t2) {
                    return l(t2, new Array(t2.length));
                  }, arraybuffer: function(t2) {
                    return c.string.uint8array(t2).buffer;
                  }, uint8array: function(t2) {
                    return l(t2, new Uint8Array(t2.length));
                  }, nodebuffer: function(t2) {
                    return l(t2, r.allocBuffer(t2.length));
                  } }, c.array = { string: f, array: n, arraybuffer: function(t2) {
                    return new Uint8Array(t2).buffer;
                  }, uint8array: function(t2) {
                    return new Uint8Array(t2);
                  }, nodebuffer: function(t2) {
                    return r.newBufferFrom(t2);
                  } }, c.arraybuffer = { string: function(t2) {
                    return f(new Uint8Array(t2));
                  }, array: function(t2) {
                    return d(new Uint8Array(t2), new Array(t2.byteLength));
                  }, arraybuffer: n, uint8array: function(t2) {
                    return new Uint8Array(t2);
                  }, nodebuffer: function(t2) {
                    return r.newBufferFrom(new Uint8Array(t2));
                  } }, c.uint8array = { string: f, array: function(t2) {
                    return d(t2, new Array(t2.length));
                  }, arraybuffer: function(t2) {
                    return t2.buffer;
                  }, uint8array: n, nodebuffer: function(t2) {
                    return r.newBufferFrom(t2);
                  } }, c.nodebuffer = { string: f, array: function(t2) {
                    return d(t2, new Array(t2.length));
                  }, arraybuffer: function(t2) {
                    return c.nodebuffer.uint8array(t2).buffer;
                  }, uint8array: function(t2) {
                    return d(t2, new Uint8Array(t2.length));
                  }, nodebuffer: n }, a.transformTo = function(t2, e2) {
                    if (e2 = e2 || "", !t2) return e2;
                    a.checkSupport(t2);
                    var r2 = a.getTypeOf(e2);
                    return c[r2][t2](e2);
                  }, a.getTypeOf = function(t2) {
                    return "string" == typeof t2 ? "string" : "[object Array]" === Object.prototype.toString.call(t2) ? "array" : o.nodebuffer && r.isBuffer(t2) ? "nodebuffer" : o.uint8array && t2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && t2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
                  }, a.checkSupport = function(t2) {
                    if (!o[t2.toLowerCase()]) throw new Error(t2 + " is not supported by this platform");
                  }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(t2) {
                    var e2, r2, i2 = "";
                    for (r2 = 0; r2 < (t2 || "").length; r2++) i2 += "\\x" + ((e2 = t2.charCodeAt(r2)) < 16 ? "0" : "") + e2.toString(16).toUpperCase();
                    return i2;
                  }, a.delay = function(t2, e2, r2) {
                    i(function() {
                      t2.apply(r2 || null, e2 || []);
                    });
                  }, a.inherits = function(t2, e2) {
                    function r2() {
                    }
                    r2.prototype = e2.prototype, t2.prototype = new r2();
                  }, a.extend = function() {
                    var t2, e2, r2 = {};
                    for (t2 = 0; t2 < arguments.length; t2++) for (e2 in arguments[t2]) arguments[t2].hasOwnProperty(e2) && void 0 === r2[e2] && (r2[e2] = arguments[t2][e2]);
                    return r2;
                  }, a.prepareContent = function(r2, t2, i2, n2, s2) {
                    return u.Promise.resolve(t2).then(function(i3) {
                      return o.blob && (i3 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(i3))) && "undefined" != typeof FileReader ? new u.Promise(function(e2, r3) {
                        var t3 = new FileReader();
                        t3.onload = function(t4) {
                          e2(t4.target.result);
                        }, t3.onerror = function(t4) {
                          r3(t4.target.error);
                        }, t3.readAsArrayBuffer(i3);
                      }) : i3;
                    }).then(function(t3) {
                      var e2 = a.getTypeOf(t3);
                      return e2 ? ("arraybuffer" === e2 ? t3 = a.transformTo("uint8array", t3) : "string" === e2 && (s2 ? t3 = h.decode(t3) : i2 && true !== n2 && (t3 = function(t4) {
                        return l(t4, o.uint8array ? new Uint8Array(t4.length) : new Array(t4.length));
                      }(t3))), t3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
                    });
                  };
                }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, "set-immediate-shim": 54 }], 33: [function(t, e, r) {
                  "use strict";
                  var i = t("./reader/readerFor"), n = t("./utils"), s = t("./signature"), a = t("./zipEntry"), o = (t("./utf8"), t("./support"));
                  function h(t2) {
                    this.files = [], this.loadOptions = t2;
                  }
                  h.prototype = { checkSignature: function(t2) {
                    if (!this.reader.readAndCheckSignature(t2)) {
                      this.reader.index -= 4;
                      var e2 = this.reader.readString(4);
                      throw new Error("Corrupted zip or bug: unexpected signature (" + n.pretty(e2) + ", expected " + n.pretty(t2) + ")");
                    }
                  }, isSignature: function(t2, e2) {
                    var r2 = this.reader.index;
                    this.reader.setIndex(t2);
                    var i2 = this.reader.readString(4) === e2;
                    return this.reader.setIndex(r2), i2;
                  }, readBlockEndOfCentral: function() {
                    this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
                    var t2 = this.reader.readData(this.zipCommentLength), e2 = o.uint8array ? "uint8array" : "array", r2 = n.transformTo(e2, t2);
                    this.zipComment = this.loadOptions.decodeFileName(r2);
                  }, readBlockZip64EndOfCentral: function() {
                    this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
                    for (var t2, e2, r2, i2 = this.zip64EndOfCentralSize - 44; 0 < i2; ) t2 = this.reader.readInt(2), e2 = this.reader.readInt(4), r2 = this.reader.readData(e2), this.zip64ExtensibleData[t2] = { id: t2, length: e2, value: r2 };
                  }, readBlockZip64EndOfCentralLocator: function() {
                    if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
                  }, readLocalFiles: function() {
                    var t2, e2;
                    for (t2 = 0; t2 < this.files.length; t2++) e2 = this.files[t2], this.reader.setIndex(e2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), e2.readLocalPart(this.reader), e2.handleUTF8(), e2.processAttributes();
                  }, readCentralDir: function() {
                    var t2;
                    for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); ) (t2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(t2);
                    if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
                  }, readEndOfCentral: function() {
                    var t2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
                    if (t2 < 0) throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
                    this.reader.setIndex(t2);
                    var e2 = t2;
                    if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === n.MAX_VALUE_16BITS || this.diskWithCentralDirStart === n.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === n.MAX_VALUE_16BITS || this.centralDirRecords === n.MAX_VALUE_16BITS || this.centralDirSize === n.MAX_VALUE_32BITS || this.centralDirOffset === n.MAX_VALUE_32BITS) {
                      if (this.zip64 = true, (t2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
                      if (this.reader.setIndex(t2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                      this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
                    }
                    var r2 = this.centralDirOffset + this.centralDirSize;
                    this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
                    var i2 = e2 - r2;
                    if (0 < i2) this.isSignature(e2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = i2);
                    else if (i2 < 0) throw new Error("Corrupted zip: missing " + Math.abs(i2) + " bytes.");
                  }, prepareReader: function(t2) {
                    this.reader = i(t2);
                  }, load: function(t2) {
                    this.prepareReader(t2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
                  } }, e.exports = h;
                }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utf8": 31, "./utils": 32, "./zipEntry": 34 }], 34: [function(t, e, r) {
                  "use strict";
                  var i = t("./reader/readerFor"), s = t("./utils"), n = t("./compressedObject"), a = t("./crc32"), o = t("./utf8"), h = t("./compressions"), u = t("./support");
                  function l(t2, e2) {
                    this.options = t2, this.loadOptions = e2;
                  }
                  l.prototype = { isEncrypted: function() {
                    return 1 == (1 & this.bitFlag);
                  }, useUTF8: function() {
                    return 2048 == (2048 & this.bitFlag);
                  }, readLocalPart: function(t2) {
                    var e2, r2;
                    if (t2.skip(22), this.fileNameLength = t2.readInt(2), r2 = t2.readInt(2), this.fileName = t2.readData(this.fileNameLength), t2.skip(r2), -1 === this.compressedSize || -1 === this.uncompressedSize) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
                    if (null === (e2 = function(t3) {
                      for (var e3 in h) if (h.hasOwnProperty(e3) && h[e3].magic === t3) return h[e3];
                      return null;
                    }(this.compressionMethod))) throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
                    this.decompressed = new n(this.compressedSize, this.uncompressedSize, this.crc32, e2, t2.readData(this.compressedSize));
                  }, readCentralPart: function(t2) {
                    this.versionMadeBy = t2.readInt(2), t2.skip(2), this.bitFlag = t2.readInt(2), this.compressionMethod = t2.readString(2), this.date = t2.readDate(), this.crc32 = t2.readInt(4), this.compressedSize = t2.readInt(4), this.uncompressedSize = t2.readInt(4);
                    var e2 = t2.readInt(2);
                    if (this.extraFieldsLength = t2.readInt(2), this.fileCommentLength = t2.readInt(2), this.diskNumberStart = t2.readInt(2), this.internalFileAttributes = t2.readInt(2), this.externalFileAttributes = t2.readInt(4), this.localHeaderOffset = t2.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
                    t2.skip(e2), this.readExtraFields(t2), this.parseZIP64ExtraField(t2), this.fileComment = t2.readData(this.fileCommentLength);
                  }, processAttributes: function() {
                    this.unixPermissions = null, this.dosPermissions = null;
                    var t2 = this.versionMadeBy >> 8;
                    this.dir = !!(16 & this.externalFileAttributes), 0 == t2 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == t2 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
                  }, parseZIP64ExtraField: function(t2) {
                    if (this.extraFields[1]) {
                      var e2 = i(this.extraFields[1].value);
                      this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
                    }
                  }, readExtraFields: function(t2) {
                    var e2, r2, i2, n2 = t2.index + this.extraFieldsLength;
                    for (this.extraFields || (this.extraFields = {}); t2.index < n2; ) e2 = t2.readInt(2), r2 = t2.readInt(2), i2 = t2.readData(r2), this.extraFields[e2] = { id: e2, length: r2, value: i2 };
                  }, handleUTF8: function() {
                    var t2 = u.uint8array ? "uint8array" : "array";
                    if (this.useUTF8()) this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
                    else {
                      var e2 = this.findExtraFieldUnicodePath();
                      if (null !== e2) this.fileNameStr = e2;
                      else {
                        var r2 = s.transformTo(t2, this.fileName);
                        this.fileNameStr = this.loadOptions.decodeFileName(r2);
                      }
                      var i2 = this.findExtraFieldUnicodeComment();
                      if (null !== i2) this.fileCommentStr = i2;
                      else {
                        var n2 = s.transformTo(t2, this.fileComment);
                        this.fileCommentStr = this.loadOptions.decodeFileName(n2);
                      }
                    }
                  }, findExtraFieldUnicodePath: function() {
                    var t2 = this.extraFields[28789];
                    if (t2) {
                      var e2 = i(t2.value);
                      return 1 !== e2.readInt(1) ? null : a(this.fileName) !== e2.readInt(4) ? null : o.utf8decode(e2.readData(t2.length - 5));
                    }
                    return null;
                  }, findExtraFieldUnicodeComment: function() {
                    var t2 = this.extraFields[25461];
                    if (t2) {
                      var e2 = i(t2.value);
                      return 1 !== e2.readInt(1) ? null : a(this.fileComment) !== e2.readInt(4) ? null : o.utf8decode(e2.readData(t2.length - 5));
                    }
                    return null;
                  } }, e.exports = l;
                }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(t, e, r) {
                  "use strict";
                  function i(t2, e2, r2) {
                    this.name = t2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = e2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
                  }
                  var s = t("./stream/StreamHelper"), n = t("./stream/DataWorker"), a = t("./utf8"), o = t("./compressedObject"), h = t("./stream/GenericWorker");
                  i.prototype = { internalStream: function(t2) {
                    var e2 = null, r2 = "string";
                    try {
                      if (!t2) throw new Error("No output type specified.");
                      var i2 = "string" === (r2 = t2.toLowerCase()) || "text" === r2;
                      "binarystring" !== r2 && "text" !== r2 || (r2 = "string"), e2 = this._decompressWorker();
                      var n2 = !this._dataBinary;
                      n2 && !i2 && (e2 = e2.pipe(new a.Utf8EncodeWorker())), !n2 && i2 && (e2 = e2.pipe(new a.Utf8DecodeWorker()));
                    } catch (t3) {
                      (e2 = new h("error")).error(t3);
                    }
                    return new s(e2, r2, "");
                  }, async: function(t2, e2) {
                    return this.internalStream(t2).accumulate(e2);
                  }, nodeStream: function(t2, e2) {
                    return this.internalStream(t2 || "nodebuffer").toNodejsStream(e2);
                  }, _compressWorker: function(t2, e2) {
                    if (this._data instanceof o && this._data.compression.magic === t2.magic) return this._data.getCompressedWorker();
                    var r2 = this._decompressWorker();
                    return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, t2, e2);
                  }, _decompressWorker: function() {
                    return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new n(this._data);
                  } };
                  for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
                    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
                  }, f = 0; f < u.length; f++) i.prototype[u[f]] = l;
                  e.exports = i;
                }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(t, l, e) {
                  (function(e2) {
                    "use strict";
                    var r, i, t2 = e2.MutationObserver || e2.WebKitMutationObserver;
                    if (t2) {
                      var n = 0, s = new t2(u), a = e2.document.createTextNode("");
                      s.observe(a, { characterData: true }), r = function() {
                        a.data = n = ++n % 2;
                      };
                    } else if (e2.setImmediate || void 0 === e2.MessageChannel) r = "document" in e2 && "onreadystatechange" in e2.document.createElement("script") ? function() {
                      var t3 = e2.document.createElement("script");
                      t3.onreadystatechange = function() {
                        u(), t3.onreadystatechange = null, t3.parentNode.removeChild(t3), t3 = null;
                      }, e2.document.documentElement.appendChild(t3);
                    } : function() {
                      setTimeout(u, 0);
                    };
                    else {
                      var o = new e2.MessageChannel();
                      o.port1.onmessage = u, r = function() {
                        o.port2.postMessage(0);
                      };
                    }
                    var h = [];
                    function u() {
                      var t3, e3;
                      i = true;
                      for (var r2 = h.length; r2; ) {
                        for (e3 = h, h = [], t3 = -1; ++t3 < r2; ) e3[t3]();
                        r2 = h.length;
                      }
                      i = false;
                    }
                    l.exports = function(t3) {
                      1 !== h.push(t3) || i || r();
                    };
                  }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
                }, {}], 37: [function(t, e, r) {
                  "use strict";
                  var n = t("immediate");
                  function u() {
                  }
                  var l = {}, s = ["REJECTED"], a = ["FULFILLED"], i = ["PENDING"];
                  function o(t2) {
                    if ("function" != typeof t2) throw new TypeError("resolver must be a function");
                    this.state = i, this.queue = [], this.outcome = void 0, t2 !== u && c(this, t2);
                  }
                  function h(t2, e2, r2) {
                    this.promise = t2, "function" == typeof e2 && (this.onFulfilled = e2, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r2 && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
                  }
                  function f(e2, r2, i2) {
                    n(function() {
                      var t2;
                      try {
                        t2 = r2(i2);
                      } catch (t3) {
                        return l.reject(e2, t3);
                      }
                      t2 === e2 ? l.reject(e2, new TypeError("Cannot resolve promise with itself")) : l.resolve(e2, t2);
                    });
                  }
                  function d(t2) {
                    var e2 = t2 && t2.then;
                    if (t2 && ("object" == typeof t2 || "function" == typeof t2) && "function" == typeof e2) return function() {
                      e2.apply(t2, arguments);
                    };
                  }
                  function c(e2, t2) {
                    var r2 = false;
                    function i2(t3) {
                      r2 || (r2 = true, l.reject(e2, t3));
                    }
                    function n2(t3) {
                      r2 || (r2 = true, l.resolve(e2, t3));
                    }
                    var s2 = p(function() {
                      t2(n2, i2);
                    });
                    "error" === s2.status && i2(s2.value);
                  }
                  function p(t2, e2) {
                    var r2 = {};
                    try {
                      r2.value = t2(e2), r2.status = "success";
                    } catch (t3) {
                      r2.status = "error", r2.value = t3;
                    }
                    return r2;
                  }
                  (e.exports = o).prototype.finally = function(e2) {
                    if ("function" != typeof e2) return this;
                    var r2 = this.constructor;
                    return this.then(function(t2) {
                      return r2.resolve(e2()).then(function() {
                        return t2;
                      });
                    }, function(t2) {
                      return r2.resolve(e2()).then(function() {
                        throw t2;
                      });
                    });
                  }, o.prototype.catch = function(t2) {
                    return this.then(null, t2);
                  }, o.prototype.then = function(t2, e2) {
                    if ("function" != typeof t2 && this.state === a || "function" != typeof e2 && this.state === s) return this;
                    var r2 = new this.constructor(u);
                    this.state !== i ? f(r2, this.state === a ? t2 : e2, this.outcome) : this.queue.push(new h(r2, t2, e2));
                    return r2;
                  }, h.prototype.callFulfilled = function(t2) {
                    l.resolve(this.promise, t2);
                  }, h.prototype.otherCallFulfilled = function(t2) {
                    f(this.promise, this.onFulfilled, t2);
                  }, h.prototype.callRejected = function(t2) {
                    l.reject(this.promise, t2);
                  }, h.prototype.otherCallRejected = function(t2) {
                    f(this.promise, this.onRejected, t2);
                  }, l.resolve = function(t2, e2) {
                    var r2 = p(d, e2);
                    if ("error" === r2.status) return l.reject(t2, r2.value);
                    var i2 = r2.value;
                    if (i2) c(t2, i2);
                    else {
                      t2.state = a, t2.outcome = e2;
                      for (var n2 = -1, s2 = t2.queue.length; ++n2 < s2; ) t2.queue[n2].callFulfilled(e2);
                    }
                    return t2;
                  }, l.reject = function(t2, e2) {
                    t2.state = s, t2.outcome = e2;
                    for (var r2 = -1, i2 = t2.queue.length; ++r2 < i2; ) t2.queue[r2].callRejected(e2);
                    return t2;
                  }, o.resolve = function(t2) {
                    if (t2 instanceof this) return t2;
                    return l.resolve(new this(u), t2);
                  }, o.reject = function(t2) {
                    var e2 = new this(u);
                    return l.reject(e2, t2);
                  }, o.all = function(t2) {
                    var r2 = this;
                    if ("[object Array]" !== Object.prototype.toString.call(t2)) return this.reject(new TypeError("must be an array"));
                    var i2 = t2.length, n2 = false;
                    if (!i2) return this.resolve([]);
                    var s2 = new Array(i2), a2 = 0, e2 = -1, o2 = new this(u);
                    for (; ++e2 < i2; ) h2(t2[e2], e2);
                    return o2;
                    function h2(t3, e3) {
                      r2.resolve(t3).then(function(t4) {
                        s2[e3] = t4, ++a2 !== i2 || n2 || (n2 = true, l.resolve(o2, s2));
                      }, function(t4) {
                        n2 || (n2 = true, l.reject(o2, t4));
                      });
                    }
                  }, o.race = function(t2) {
                    var e2 = this;
                    if ("[object Array]" !== Object.prototype.toString.call(t2)) return this.reject(new TypeError("must be an array"));
                    var r2 = t2.length, i2 = false;
                    if (!r2) return this.resolve([]);
                    var n2 = -1, s2 = new this(u);
                    for (; ++n2 < r2; ) a2 = t2[n2], e2.resolve(a2).then(function(t3) {
                      i2 || (i2 = true, l.resolve(s2, t3));
                    }, function(t3) {
                      i2 || (i2 = true, l.reject(s2, t3));
                    });
                    var a2;
                    return s2;
                  };
                }, { immediate: 36 }], 38: [function(t, e, r) {
                  "use strict";
                  var i = {};
                  (0, t("./lib/utils/common").assign)(i, t("./lib/deflate"), t("./lib/inflate"), t("./lib/zlib/constants")), e.exports = i;
                }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(t, e, r) {
                  "use strict";
                  var a = t("./zlib/deflate"), o = t("./utils/common"), h = t("./utils/strings"), n = t("./zlib/messages"), s = t("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, d = 0, c = 8;
                  function p(t2) {
                    if (!(this instanceof p)) return new p(t2);
                    this.options = o.assign({ level: f, method: c, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: d, to: "" }, t2 || {});
                    var e2 = this.options;
                    e2.raw && 0 < e2.windowBits ? e2.windowBits = -e2.windowBits : e2.gzip && 0 < e2.windowBits && e2.windowBits < 16 && (e2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
                    var r2 = a.deflateInit2(this.strm, e2.level, e2.method, e2.windowBits, e2.memLevel, e2.strategy);
                    if (r2 !== l) throw new Error(n[r2]);
                    if (e2.header && a.deflateSetHeader(this.strm, e2.header), e2.dictionary) {
                      var i2;
                      if (i2 = "string" == typeof e2.dictionary ? h.string2buf(e2.dictionary) : "[object ArrayBuffer]" === u.call(e2.dictionary) ? new Uint8Array(e2.dictionary) : e2.dictionary, (r2 = a.deflateSetDictionary(this.strm, i2)) !== l) throw new Error(n[r2]);
                      this._dict_set = true;
                    }
                  }
                  function i(t2, e2) {
                    var r2 = new p(e2);
                    if (r2.push(t2, true), r2.err) throw r2.msg || n[r2.err];
                    return r2.result;
                  }
                  p.prototype.push = function(t2, e2) {
                    var r2, i2, n2 = this.strm, s2 = this.options.chunkSize;
                    if (this.ended) return false;
                    i2 = e2 === ~~e2 ? e2 : true === e2 ? 4 : 0, "string" == typeof t2 ? n2.input = h.string2buf(t2) : "[object ArrayBuffer]" === u.call(t2) ? n2.input = new Uint8Array(t2) : n2.input = t2, n2.next_in = 0, n2.avail_in = n2.input.length;
                    do {
                      if (0 === n2.avail_out && (n2.output = new o.Buf8(s2), n2.next_out = 0, n2.avail_out = s2), 1 !== (r2 = a.deflate(n2, i2)) && r2 !== l) return this.onEnd(r2), !(this.ended = true);
                      0 !== n2.avail_out && (0 !== n2.avail_in || 4 !== i2 && 2 !== i2) || ("string" === this.options.to ? this.onData(h.buf2binstring(o.shrinkBuf(n2.output, n2.next_out))) : this.onData(o.shrinkBuf(n2.output, n2.next_out)));
                    } while ((0 < n2.avail_in || 0 === n2.avail_out) && 1 !== r2);
                    return 4 === i2 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : 2 !== i2 || (this.onEnd(l), !(n2.avail_out = 0));
                  }, p.prototype.onData = function(t2) {
                    this.chunks.push(t2);
                  }, p.prototype.onEnd = function(t2) {
                    t2 === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = t2, this.msg = this.strm.msg;
                  }, r.Deflate = p, r.deflate = i, r.deflateRaw = function(t2, e2) {
                    return (e2 = e2 || {}).raw = true, i(t2, e2);
                  }, r.gzip = function(t2, e2) {
                    return (e2 = e2 || {}).gzip = true, i(t2, e2);
                  };
                }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(t, e, r) {
                  "use strict";
                  var d = t("./zlib/inflate"), c = t("./utils/common"), p = t("./utils/strings"), m = t("./zlib/constants"), i = t("./zlib/messages"), n = t("./zlib/zstream"), s = t("./zlib/gzheader"), _ = Object.prototype.toString;
                  function a(t2) {
                    if (!(this instanceof a)) return new a(t2);
                    this.options = c.assign({ chunkSize: 16384, windowBits: 0, to: "" }, t2 || {});
                    var e2 = this.options;
                    e2.raw && 0 <= e2.windowBits && e2.windowBits < 16 && (e2.windowBits = -e2.windowBits, 0 === e2.windowBits && (e2.windowBits = -15)), !(0 <= e2.windowBits && e2.windowBits < 16) || t2 && t2.windowBits || (e2.windowBits += 32), 15 < e2.windowBits && e2.windowBits < 48 && 0 == (15 & e2.windowBits) && (e2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new n(), this.strm.avail_out = 0;
                    var r2 = d.inflateInit2(this.strm, e2.windowBits);
                    if (r2 !== m.Z_OK) throw new Error(i[r2]);
                    this.header = new s(), d.inflateGetHeader(this.strm, this.header);
                  }
                  function o(t2, e2) {
                    var r2 = new a(e2);
                    if (r2.push(t2, true), r2.err) throw r2.msg || i[r2.err];
                    return r2.result;
                  }
                  a.prototype.push = function(t2, e2) {
                    var r2, i2, n2, s2, a2, o2, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
                    if (this.ended) return false;
                    i2 = e2 === ~~e2 ? e2 : true === e2 ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof t2 ? h.input = p.binstring2buf(t2) : "[object ArrayBuffer]" === _.call(t2) ? h.input = new Uint8Array(t2) : h.input = t2, h.next_in = 0, h.avail_in = h.input.length;
                    do {
                      if (0 === h.avail_out && (h.output = new c.Buf8(u), h.next_out = 0, h.avail_out = u), (r2 = d.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = "string" == typeof l ? p.string2buf(l) : "[object ArrayBuffer]" === _.call(l) ? new Uint8Array(l) : l, r2 = d.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && true === f && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK) return this.onEnd(r2), !(this.ended = true);
                      h.next_out && (0 !== h.avail_out && r2 !== m.Z_STREAM_END && (0 !== h.avail_in || i2 !== m.Z_FINISH && i2 !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (n2 = p.utf8border(h.output, h.next_out), s2 = h.next_out - n2, a2 = p.buf2string(h.output, n2), h.next_out = s2, h.avail_out = u - s2, s2 && c.arraySet(h.output, h.output, n2, s2, 0), this.onData(a2)) : this.onData(c.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f = true);
                    } while ((0 < h.avail_in || 0 === h.avail_out) && r2 !== m.Z_STREAM_END);
                    return r2 === m.Z_STREAM_END && (i2 = m.Z_FINISH), i2 === m.Z_FINISH ? (r2 = d.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : i2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));
                  }, a.prototype.onData = function(t2) {
                    this.chunks.push(t2);
                  }, a.prototype.onEnd = function(t2) {
                    t2 === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = c.flattenChunks(this.chunks)), this.chunks = [], this.err = t2, this.msg = this.strm.msg;
                  }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(t2, e2) {
                    return (e2 = e2 || {}).raw = true, o(t2, e2);
                  }, r.ungzip = o;
                }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(t, e, r) {
                  "use strict";
                  var i = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
                  r.assign = function(t2) {
                    for (var e2 = Array.prototype.slice.call(arguments, 1); e2.length; ) {
                      var r2 = e2.shift();
                      if (r2) {
                        if ("object" != typeof r2) throw new TypeError(r2 + "must be non-object");
                        for (var i2 in r2) r2.hasOwnProperty(i2) && (t2[i2] = r2[i2]);
                      }
                    }
                    return t2;
                  }, r.shrinkBuf = function(t2, e2) {
                    return t2.length === e2 ? t2 : t2.subarray ? t2.subarray(0, e2) : (t2.length = e2, t2);
                  };
                  var n = { arraySet: function(t2, e2, r2, i2, n2) {
                    if (e2.subarray && t2.subarray) t2.set(e2.subarray(r2, r2 + i2), n2);
                    else for (var s2 = 0; s2 < i2; s2++) t2[n2 + s2] = e2[r2 + s2];
                  }, flattenChunks: function(t2) {
                    var e2, r2, i2, n2, s2, a;
                    for (e2 = i2 = 0, r2 = t2.length; e2 < r2; e2++) i2 += t2[e2].length;
                    for (a = new Uint8Array(i2), e2 = n2 = 0, r2 = t2.length; e2 < r2; e2++) s2 = t2[e2], a.set(s2, n2), n2 += s2.length;
                    return a;
                  } }, s = { arraySet: function(t2, e2, r2, i2, n2) {
                    for (var s2 = 0; s2 < i2; s2++) t2[n2 + s2] = e2[r2 + s2];
                  }, flattenChunks: function(t2) {
                    return [].concat.apply([], t2);
                  } };
                  r.setTyped = function(t2) {
                    t2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, n)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
                  }, r.setTyped(i);
                }, {}], 42: [function(t, e, r) {
                  "use strict";
                  var h = t("./common"), n = true, s = true;
                  try {
                    String.fromCharCode.apply(null, [0]);
                  } catch (t2) {
                    n = false;
                  }
                  try {
                    String.fromCharCode.apply(null, new Uint8Array(1));
                  } catch (t2) {
                    s = false;
                  }
                  for (var u = new h.Buf8(256), i = 0; i < 256; i++) u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
                  function l(t2, e2) {
                    if (e2 < 65537 && (t2.subarray && s || !t2.subarray && n)) return String.fromCharCode.apply(null, h.shrinkBuf(t2, e2));
                    for (var r2 = "", i2 = 0; i2 < e2; i2++) r2 += String.fromCharCode(t2[i2]);
                    return r2;
                  }
                  u[254] = u[254] = 1, r.string2buf = function(t2) {
                    var e2, r2, i2, n2, s2, a = t2.length, o = 0;
                    for (n2 = 0; n2 < a; n2++) 55296 == (64512 & (r2 = t2.charCodeAt(n2))) && n2 + 1 < a && 56320 == (64512 & (i2 = t2.charCodeAt(n2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (i2 - 56320), n2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
                    for (e2 = new h.Buf8(o), n2 = s2 = 0; s2 < o; n2++) 55296 == (64512 & (r2 = t2.charCodeAt(n2))) && n2 + 1 < a && 56320 == (64512 & (i2 = t2.charCodeAt(n2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (i2 - 56320), n2++), r2 < 128 ? e2[s2++] = r2 : (r2 < 2048 ? e2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? e2[s2++] = 224 | r2 >>> 12 : (e2[s2++] = 240 | r2 >>> 18, e2[s2++] = 128 | r2 >>> 12 & 63), e2[s2++] = 128 | r2 >>> 6 & 63), e2[s2++] = 128 | 63 & r2);
                    return e2;
                  }, r.buf2binstring = function(t2) {
                    return l(t2, t2.length);
                  }, r.binstring2buf = function(t2) {
                    for (var e2 = new h.Buf8(t2.length), r2 = 0, i2 = e2.length; r2 < i2; r2++) e2[r2] = t2.charCodeAt(r2);
                    return e2;
                  }, r.buf2string = function(t2, e2) {
                    var r2, i2, n2, s2, a = e2 || t2.length, o = new Array(2 * a);
                    for (r2 = i2 = 0; r2 < a; ) if ((n2 = t2[r2++]) < 128) o[i2++] = n2;
                    else if (4 < (s2 = u[n2])) o[i2++] = 65533, r2 += s2 - 1;
                    else {
                      for (n2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r2 < a; ) n2 = n2 << 6 | 63 & t2[r2++], s2--;
                      1 < s2 ? o[i2++] = 65533 : n2 < 65536 ? o[i2++] = n2 : (n2 -= 65536, o[i2++] = 55296 | n2 >> 10 & 1023, o[i2++] = 56320 | 1023 & n2);
                    }
                    return l(o, i2);
                  }, r.utf8border = function(t2, e2) {
                    var r2;
                    for ((e2 = e2 || t2.length) > t2.length && (e2 = t2.length), r2 = e2 - 1; 0 <= r2 && 128 == (192 & t2[r2]); ) r2--;
                    return r2 < 0 ? e2 : 0 === r2 ? e2 : r2 + u[t2[r2]] > e2 ? r2 : e2;
                  };
                }, { "./common": 41 }], 43: [function(t, e, r) {
                  "use strict";
                  e.exports = function(t2, e2, r2, i) {
                    for (var n = 65535 & t2 | 0, s = t2 >>> 16 & 65535 | 0, a = 0; 0 !== r2; ) {
                      for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (n = n + e2[i++] | 0) | 0, --a; ) ;
                      n %= 65521, s %= 65521;
                    }
                    return n | s << 16 | 0;
                  };
                }, {}], 44: [function(t, e, r) {
                  "use strict";
                  e.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
                }, {}], 45: [function(t, e, r) {
                  "use strict";
                  var o = function() {
                    for (var t2, e2 = [], r2 = 0; r2 < 256; r2++) {
                      t2 = r2;
                      for (var i = 0; i < 8; i++) t2 = 1 & t2 ? 3988292384 ^ t2 >>> 1 : t2 >>> 1;
                      e2[r2] = t2;
                    }
                    return e2;
                  }();
                  e.exports = function(t2, e2, r2, i) {
                    var n = o, s = i + r2;
                    t2 ^= -1;
                    for (var a = i; a < s; a++) t2 = t2 >>> 8 ^ n[255 & (t2 ^ e2[a])];
                    return -1 ^ t2;
                  };
                }, {}], 46: [function(t, e, r) {
                  "use strict";
                  var h, d = t("../utils/common"), u = t("./trees"), c = t("./adler32"), p = t("./crc32"), i = t("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, n = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
                  function R(t2, e2) {
                    return t2.msg = i[e2], e2;
                  }
                  function T(t2) {
                    return (t2 << 1) - (4 < t2 ? 9 : 0);
                  }
                  function D(t2) {
                    for (var e2 = t2.length; 0 <= --e2; ) t2[e2] = 0;
                  }
                  function F(t2) {
                    var e2 = t2.state, r2 = e2.pending;
                    r2 > t2.avail_out && (r2 = t2.avail_out), 0 !== r2 && (d.arraySet(t2.output, e2.pending_buf, e2.pending_out, r2, t2.next_out), t2.next_out += r2, e2.pending_out += r2, t2.total_out += r2, t2.avail_out -= r2, e2.pending -= r2, 0 === e2.pending && (e2.pending_out = 0));
                  }
                  function N(t2, e2) {
                    u._tr_flush_block(t2, 0 <= t2.block_start ? t2.block_start : -1, t2.strstart - t2.block_start, e2), t2.block_start = t2.strstart, F(t2.strm);
                  }
                  function U(t2, e2) {
                    t2.pending_buf[t2.pending++] = e2;
                  }
                  function P(t2, e2) {
                    t2.pending_buf[t2.pending++] = e2 >>> 8 & 255, t2.pending_buf[t2.pending++] = 255 & e2;
                  }
                  function L(t2, e2) {
                    var r2, i2, n2 = t2.max_chain_length, s2 = t2.strstart, a2 = t2.prev_length, o2 = t2.nice_match, h2 = t2.strstart > t2.w_size - z ? t2.strstart - (t2.w_size - z) : 0, u2 = t2.window, l2 = t2.w_mask, f2 = t2.prev, d2 = t2.strstart + S, c2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
                    t2.prev_length >= t2.good_match && (n2 >>= 2), o2 > t2.lookahead && (o2 = t2.lookahead);
                    do {
                      if (u2[(r2 = e2) + a2] === p2 && u2[r2 + a2 - 1] === c2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
                        s2 += 2, r2++;
                        do {
                        } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < d2);
                        if (i2 = S - (d2 - s2), s2 = d2 - S, a2 < i2) {
                          if (t2.match_start = e2, o2 <= (a2 = i2)) break;
                          c2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
                        }
                      }
                    } while ((e2 = f2[e2 & l2]) > h2 && 0 != --n2);
                    return a2 <= t2.lookahead ? a2 : t2.lookahead;
                  }
                  function j(t2) {
                    var e2, r2, i2, n2, s2, a2, o2, h2, u2, l2, f2 = t2.w_size;
                    do {
                      if (n2 = t2.window_size - t2.lookahead - t2.strstart, t2.strstart >= f2 + (f2 - z)) {
                        for (d.arraySet(t2.window, t2.window, f2, f2, 0), t2.match_start -= f2, t2.strstart -= f2, t2.block_start -= f2, e2 = r2 = t2.hash_size; i2 = t2.head[--e2], t2.head[e2] = f2 <= i2 ? i2 - f2 : 0, --r2; ) ;
                        for (e2 = r2 = f2; i2 = t2.prev[--e2], t2.prev[e2] = f2 <= i2 ? i2 - f2 : 0, --r2; ) ;
                        n2 += f2;
                      }
                      if (0 === t2.strm.avail_in) break;
                      if (a2 = t2.strm, o2 = t2.window, h2 = t2.strstart + t2.lookahead, u2 = n2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = 0 === l2 ? 0 : (a2.avail_in -= l2, d.arraySet(o2, a2.input, a2.next_in, l2, h2), 1 === a2.state.wrap ? a2.adler = c(a2.adler, o2, l2, h2) : 2 === a2.state.wrap && (a2.adler = p(a2.adler, o2, l2, h2)), a2.next_in += l2, a2.total_in += l2, l2), t2.lookahead += r2, t2.lookahead + t2.insert >= x) for (s2 = t2.strstart - t2.insert, t2.ins_h = t2.window[s2], t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[s2 + 1]) & t2.hash_mask; t2.insert && (t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[s2 + x - 1]) & t2.hash_mask, t2.prev[s2 & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = s2, s2++, t2.insert--, !(t2.lookahead + t2.insert < x)); ) ;
                    } while (t2.lookahead < z && 0 !== t2.strm.avail_in);
                  }
                  function Z(t2, e2) {
                    for (var r2, i2; ; ) {
                      if (t2.lookahead < z) {
                        if (j(t2), t2.lookahead < z && e2 === l) return A;
                        if (0 === t2.lookahead) break;
                      }
                      if (r2 = 0, t2.lookahead >= x && (t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + x - 1]) & t2.hash_mask, r2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart), 0 !== r2 && t2.strstart - r2 <= t2.w_size - z && (t2.match_length = L(t2, r2)), t2.match_length >= x) if (i2 = u._tr_tally(t2, t2.strstart - t2.match_start, t2.match_length - x), t2.lookahead -= t2.match_length, t2.match_length <= t2.max_lazy_match && t2.lookahead >= x) {
                        for (t2.match_length--; t2.strstart++, t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + x - 1]) & t2.hash_mask, r2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart, 0 != --t2.match_length; ) ;
                        t2.strstart++;
                      } else t2.strstart += t2.match_length, t2.match_length = 0, t2.ins_h = t2.window[t2.strstart], t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + 1]) & t2.hash_mask;
                      else i2 = u._tr_tally(t2, 0, t2.window[t2.strstart]), t2.lookahead--, t2.strstart++;
                      if (i2 && (N(t2, false), 0 === t2.strm.avail_out)) return A;
                    }
                    return t2.insert = t2.strstart < x - 1 ? t2.strstart : x - 1, e2 === f ? (N(t2, true), 0 === t2.strm.avail_out ? O : B) : t2.last_lit && (N(t2, false), 0 === t2.strm.avail_out) ? A : I;
                  }
                  function W(t2, e2) {
                    for (var r2, i2, n2; ; ) {
                      if (t2.lookahead < z) {
                        if (j(t2), t2.lookahead < z && e2 === l) return A;
                        if (0 === t2.lookahead) break;
                      }
                      if (r2 = 0, t2.lookahead >= x && (t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + x - 1]) & t2.hash_mask, r2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart), t2.prev_length = t2.match_length, t2.prev_match = t2.match_start, t2.match_length = x - 1, 0 !== r2 && t2.prev_length < t2.max_lazy_match && t2.strstart - r2 <= t2.w_size - z && (t2.match_length = L(t2, r2), t2.match_length <= 5 && (1 === t2.strategy || t2.match_length === x && 4096 < t2.strstart - t2.match_start) && (t2.match_length = x - 1)), t2.prev_length >= x && t2.match_length <= t2.prev_length) {
                        for (n2 = t2.strstart + t2.lookahead - x, i2 = u._tr_tally(t2, t2.strstart - 1 - t2.prev_match, t2.prev_length - x), t2.lookahead -= t2.prev_length - 1, t2.prev_length -= 2; ++t2.strstart <= n2 && (t2.ins_h = (t2.ins_h << t2.hash_shift ^ t2.window[t2.strstart + x - 1]) & t2.hash_mask, r2 = t2.prev[t2.strstart & t2.w_mask] = t2.head[t2.ins_h], t2.head[t2.ins_h] = t2.strstart), 0 != --t2.prev_length; ) ;
                        if (t2.match_available = 0, t2.match_length = x - 1, t2.strstart++, i2 && (N(t2, false), 0 === t2.strm.avail_out)) return A;
                      } else if (t2.match_available) {
                        if ((i2 = u._tr_tally(t2, 0, t2.window[t2.strstart - 1])) && N(t2, false), t2.strstart++, t2.lookahead--, 0 === t2.strm.avail_out) return A;
                      } else t2.match_available = 1, t2.strstart++, t2.lookahead--;
                    }
                    return t2.match_available && (i2 = u._tr_tally(t2, 0, t2.window[t2.strstart - 1]), t2.match_available = 0), t2.insert = t2.strstart < x - 1 ? t2.strstart : x - 1, e2 === f ? (N(t2, true), 0 === t2.strm.avail_out ? O : B) : t2.last_lit && (N(t2, false), 0 === t2.strm.avail_out) ? A : I;
                  }
                  function M(t2, e2, r2, i2, n2) {
                    this.good_length = t2, this.max_lazy = e2, this.nice_length = r2, this.max_chain = i2, this.func = n2;
                  }
                  function H() {
                    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new d.Buf16(2 * w), this.dyn_dtree = new d.Buf16(2 * (2 * a + 1)), this.bl_tree = new d.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new d.Buf16(k + 1), this.heap = new d.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new d.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
                  }
                  function G(t2) {
                    var e2;
                    return t2 && t2.state ? (t2.total_in = t2.total_out = 0, t2.data_type = n, (e2 = t2.state).pending = 0, e2.pending_out = 0, e2.wrap < 0 && (e2.wrap = -e2.wrap), e2.status = e2.wrap ? C : E, t2.adler = 2 === e2.wrap ? 0 : 1, e2.last_flush = l, u._tr_init(e2), m) : R(t2, _);
                  }
                  function K(t2) {
                    var e2 = G(t2);
                    return e2 === m && function(t3) {
                      t3.window_size = 2 * t3.w_size, D(t3.head), t3.max_lazy_match = h[t3.level].max_lazy, t3.good_match = h[t3.level].good_length, t3.nice_match = h[t3.level].nice_length, t3.max_chain_length = h[t3.level].max_chain, t3.strstart = 0, t3.block_start = 0, t3.lookahead = 0, t3.insert = 0, t3.match_length = t3.prev_length = x - 1, t3.match_available = 0, t3.ins_h = 0;
                    }(t2.state), e2;
                  }
                  function Y(t2, e2, r2, i2, n2, s2) {
                    if (!t2) return _;
                    var a2 = 1;
                    if (e2 === g && (e2 = 6), i2 < 0 ? (a2 = 0, i2 = -i2) : 15 < i2 && (a2 = 2, i2 -= 16), n2 < 1 || y < n2 || r2 !== v || i2 < 8 || 15 < i2 || e2 < 0 || 9 < e2 || s2 < 0 || b < s2) return R(t2, _);
                    8 === i2 && (i2 = 9);
                    var o2 = new H();
                    return (t2.state = o2).strm = t2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = i2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = n2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new d.Buf8(2 * o2.w_size), o2.head = new d.Buf16(o2.hash_size), o2.prev = new d.Buf16(o2.w_size), o2.lit_bufsize = 1 << n2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new d.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = e2, o2.strategy = s2, o2.method = r2, K(t2);
                  }
                  h = [new M(0, 0, 0, 0, function(t2, e2) {
                    var r2 = 65535;
                    for (r2 > t2.pending_buf_size - 5 && (r2 = t2.pending_buf_size - 5); ; ) {
                      if (t2.lookahead <= 1) {
                        if (j(t2), 0 === t2.lookahead && e2 === l) return A;
                        if (0 === t2.lookahead) break;
                      }
                      t2.strstart += t2.lookahead, t2.lookahead = 0;
                      var i2 = t2.block_start + r2;
                      if ((0 === t2.strstart || t2.strstart >= i2) && (t2.lookahead = t2.strstart - i2, t2.strstart = i2, N(t2, false), 0 === t2.strm.avail_out)) return A;
                      if (t2.strstart - t2.block_start >= t2.w_size - z && (N(t2, false), 0 === t2.strm.avail_out)) return A;
                    }
                    return t2.insert = 0, e2 === f ? (N(t2, true), 0 === t2.strm.avail_out ? O : B) : (t2.strstart > t2.block_start && (N(t2, false), t2.strm.avail_out), A);
                  }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(t2, e2) {
                    return Y(t2, e2, v, 15, 8, 0);
                  }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(t2, e2) {
                    return t2 && t2.state ? 2 !== t2.state.wrap ? _ : (t2.state.gzhead = e2, m) : _;
                  }, r.deflate = function(t2, e2) {
                    var r2, i2, n2, s2;
                    if (!t2 || !t2.state || 5 < e2 || e2 < 0) return t2 ? R(t2, _) : _;
                    if (i2 = t2.state, !t2.output || !t2.input && 0 !== t2.avail_in || 666 === i2.status && e2 !== f) return R(t2, 0 === t2.avail_out ? -5 : _);
                    if (i2.strm = t2, r2 = i2.last_flush, i2.last_flush = e2, i2.status === C) if (2 === i2.wrap) t2.adler = 0, U(i2, 31), U(i2, 139), U(i2, 8), i2.gzhead ? (U(i2, (i2.gzhead.text ? 1 : 0) + (i2.gzhead.hcrc ? 2 : 0) + (i2.gzhead.extra ? 4 : 0) + (i2.gzhead.name ? 8 : 0) + (i2.gzhead.comment ? 16 : 0)), U(i2, 255 & i2.gzhead.time), U(i2, i2.gzhead.time >> 8 & 255), U(i2, i2.gzhead.time >> 16 & 255), U(i2, i2.gzhead.time >> 24 & 255), U(i2, 9 === i2.level ? 2 : 2 <= i2.strategy || i2.level < 2 ? 4 : 0), U(i2, 255 & i2.gzhead.os), i2.gzhead.extra && i2.gzhead.extra.length && (U(i2, 255 & i2.gzhead.extra.length), U(i2, i2.gzhead.extra.length >> 8 & 255)), i2.gzhead.hcrc && (t2.adler = p(t2.adler, i2.pending_buf, i2.pending, 0)), i2.gzindex = 0, i2.status = 69) : (U(i2, 0), U(i2, 0), U(i2, 0), U(i2, 0), U(i2, 0), U(i2, 9 === i2.level ? 2 : 2 <= i2.strategy || i2.level < 2 ? 4 : 0), U(i2, 3), i2.status = E);
                    else {
                      var a2 = v + (i2.w_bits - 8 << 4) << 8;
                      a2 |= (2 <= i2.strategy || i2.level < 2 ? 0 : i2.level < 6 ? 1 : 6 === i2.level ? 2 : 3) << 6, 0 !== i2.strstart && (a2 |= 32), a2 += 31 - a2 % 31, i2.status = E, P(i2, a2), 0 !== i2.strstart && (P(i2, t2.adler >>> 16), P(i2, 65535 & t2.adler)), t2.adler = 1;
                    }
                    if (69 === i2.status) if (i2.gzhead.extra) {
                      for (n2 = i2.pending; i2.gzindex < (65535 & i2.gzhead.extra.length) && (i2.pending !== i2.pending_buf_size || (i2.gzhead.hcrc && i2.pending > n2 && (t2.adler = p(t2.adler, i2.pending_buf, i2.pending - n2, n2)), F(t2), n2 = i2.pending, i2.pending !== i2.pending_buf_size)); ) U(i2, 255 & i2.gzhead.extra[i2.gzindex]), i2.gzindex++;
                      i2.gzhead.hcrc && i2.pending > n2 && (t2.adler = p(t2.adler, i2.pending_buf, i2.pending - n2, n2)), i2.gzindex === i2.gzhead.extra.length && (i2.gzindex = 0, i2.status = 73);
                    } else i2.status = 73;
                    if (73 === i2.status) if (i2.gzhead.name) {
                      n2 = i2.pending;
                      do {
                        if (i2.pending === i2.pending_buf_size && (i2.gzhead.hcrc && i2.pending > n2 && (t2.adler = p(t2.adler, i2.pending_buf, i2.pending - n2, n2)), F(t2), n2 = i2.pending, i2.pending === i2.pending_buf_size)) {
                          s2 = 1;
                          break;
                        }
                        s2 = i2.gzindex < i2.gzhead.name.length ? 255 & i2.gzhead.name.charCodeAt(i2.gzindex++) : 0, U(i2, s2);
                      } while (0 !== s2);
                      i2.gzhead.hcrc && i2.pending > n2 && (t2.adler = p(t2.adler, i2.pending_buf, i2.pending - n2, n2)), 0 === s2 && (i2.gzindex = 0, i2.status = 91);
                    } else i2.status = 91;
                    if (91 === i2.status) if (i2.gzhead.comment) {
                      n2 = i2.pending;
                      do {
                        if (i2.pending === i2.pending_buf_size && (i2.gzhead.hcrc && i2.pending > n2 && (t2.adler = p(t2.adler, i2.pending_buf, i2.pending - n2, n2)), F(t2), n2 = i2.pending, i2.pending === i2.pending_buf_size)) {
                          s2 = 1;
                          break;
                        }
                        s2 = i2.gzindex < i2.gzhead.comment.length ? 255 & i2.gzhead.comment.charCodeAt(i2.gzindex++) : 0, U(i2, s2);
                      } while (0 !== s2);
                      i2.gzhead.hcrc && i2.pending > n2 && (t2.adler = p(t2.adler, i2.pending_buf, i2.pending - n2, n2)), 0 === s2 && (i2.status = 103);
                    } else i2.status = 103;
                    if (103 === i2.status && (i2.gzhead.hcrc ? (i2.pending + 2 > i2.pending_buf_size && F(t2), i2.pending + 2 <= i2.pending_buf_size && (U(i2, 255 & t2.adler), U(i2, t2.adler >> 8 & 255), t2.adler = 0, i2.status = E)) : i2.status = E), 0 !== i2.pending) {
                      if (F(t2), 0 === t2.avail_out) return i2.last_flush = -1, m;
                    } else if (0 === t2.avail_in && T(e2) <= T(r2) && e2 !== f) return R(t2, -5);
                    if (666 === i2.status && 0 !== t2.avail_in) return R(t2, -5);
                    if (0 !== t2.avail_in || 0 !== i2.lookahead || e2 !== l && 666 !== i2.status) {
                      var o2 = 2 === i2.strategy ? function(t3, e3) {
                        for (var r3; ; ) {
                          if (0 === t3.lookahead && (j(t3), 0 === t3.lookahead)) {
                            if (e3 === l) return A;
                            break;
                          }
                          if (t3.match_length = 0, r3 = u._tr_tally(t3, 0, t3.window[t3.strstart]), t3.lookahead--, t3.strstart++, r3 && (N(t3, false), 0 === t3.strm.avail_out)) return A;
                        }
                        return t3.insert = 0, e3 === f ? (N(t3, true), 0 === t3.strm.avail_out ? O : B) : t3.last_lit && (N(t3, false), 0 === t3.strm.avail_out) ? A : I;
                      }(i2, e2) : 3 === i2.strategy ? function(t3, e3) {
                        for (var r3, i3, n3, s3, a3 = t3.window; ; ) {
                          if (t3.lookahead <= S) {
                            if (j(t3), t3.lookahead <= S && e3 === l) return A;
                            if (0 === t3.lookahead) break;
                          }
                          if (t3.match_length = 0, t3.lookahead >= x && 0 < t3.strstart && (i3 = a3[n3 = t3.strstart - 1]) === a3[++n3] && i3 === a3[++n3] && i3 === a3[++n3]) {
                            s3 = t3.strstart + S;
                            do {
                            } while (i3 === a3[++n3] && i3 === a3[++n3] && i3 === a3[++n3] && i3 === a3[++n3] && i3 === a3[++n3] && i3 === a3[++n3] && i3 === a3[++n3] && i3 === a3[++n3] && n3 < s3);
                            t3.match_length = S - (s3 - n3), t3.match_length > t3.lookahead && (t3.match_length = t3.lookahead);
                          }
                          if (t3.match_length >= x ? (r3 = u._tr_tally(t3, 1, t3.match_length - x), t3.lookahead -= t3.match_length, t3.strstart += t3.match_length, t3.match_length = 0) : (r3 = u._tr_tally(t3, 0, t3.window[t3.strstart]), t3.lookahead--, t3.strstart++), r3 && (N(t3, false), 0 === t3.strm.avail_out)) return A;
                        }
                        return t3.insert = 0, e3 === f ? (N(t3, true), 0 === t3.strm.avail_out ? O : B) : t3.last_lit && (N(t3, false), 0 === t3.strm.avail_out) ? A : I;
                      }(i2, e2) : h[i2.level].func(i2, e2);
                      if (o2 !== O && o2 !== B || (i2.status = 666), o2 === A || o2 === O) return 0 === t2.avail_out && (i2.last_flush = -1), m;
                      if (o2 === I && (1 === e2 ? u._tr_align(i2) : 5 !== e2 && (u._tr_stored_block(i2, 0, 0, false), 3 === e2 && (D(i2.head), 0 === i2.lookahead && (i2.strstart = 0, i2.block_start = 0, i2.insert = 0))), F(t2), 0 === t2.avail_out)) return i2.last_flush = -1, m;
                    }
                    return e2 !== f ? m : i2.wrap <= 0 ? 1 : (2 === i2.wrap ? (U(i2, 255 & t2.adler), U(i2, t2.adler >> 8 & 255), U(i2, t2.adler >> 16 & 255), U(i2, t2.adler >> 24 & 255), U(i2, 255 & t2.total_in), U(i2, t2.total_in >> 8 & 255), U(i2, t2.total_in >> 16 & 255), U(i2, t2.total_in >> 24 & 255)) : (P(i2, t2.adler >>> 16), P(i2, 65535 & t2.adler)), F(t2), 0 < i2.wrap && (i2.wrap = -i2.wrap), 0 !== i2.pending ? m : 1);
                  }, r.deflateEnd = function(t2) {
                    var e2;
                    return t2 && t2.state ? (e2 = t2.state.status) !== C && 69 !== e2 && 73 !== e2 && 91 !== e2 && 103 !== e2 && e2 !== E && 666 !== e2 ? R(t2, _) : (t2.state = null, e2 === E ? R(t2, -3) : m) : _;
                  }, r.deflateSetDictionary = function(t2, e2) {
                    var r2, i2, n2, s2, a2, o2, h2, u2, l2 = e2.length;
                    if (!t2 || !t2.state) return _;
                    if (2 === (s2 = (r2 = t2.state).wrap) || 1 === s2 && r2.status !== C || r2.lookahead) return _;
                    for (1 === s2 && (t2.adler = c(t2.adler, e2, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (0 === s2 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new d.Buf8(r2.w_size), d.arraySet(u2, e2, l2 - r2.w_size, r2.w_size, 0), e2 = u2, l2 = r2.w_size), a2 = t2.avail_in, o2 = t2.next_in, h2 = t2.input, t2.avail_in = l2, t2.next_in = 0, t2.input = e2, j(r2); r2.lookahead >= x; ) {
                      for (i2 = r2.strstart, n2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[i2 + x - 1]) & r2.hash_mask, r2.prev[i2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = i2, i2++, --n2; ) ;
                      r2.strstart = i2, r2.lookahead = x - 1, j(r2);
                    }
                    return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, t2.next_in = o2, t2.input = h2, t2.avail_in = a2, r2.wrap = s2, m;
                  }, r.deflateInfo = "pako deflate (from Nodeca project)";
                }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(t, e, r) {
                  "use strict";
                  e.exports = function() {
                    this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
                  };
                }, {}], 48: [function(t, e, r) {
                  "use strict";
                  e.exports = function(t2, e2) {
                    var r2, i, n, s, a, o, h, u, l, f, d, c, p, m, _, g, b, v, y, w, k, x, S, z, C;
                    r2 = t2.state, i = t2.next_in, z = t2.input, n = i + (t2.avail_in - 5), s = t2.next_out, C = t2.output, a = s - (e2 - t2.avail_out), o = s + (t2.avail_out - 257), h = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, d = r2.window, c = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
                    t: do {
                      p < 15 && (c += z[i++] << p, p += 8, c += z[i++] << p, p += 8), v = m[c & g];
                      e: for (; ; ) {
                        if (c >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255)) C[s++] = 65535 & v;
                        else {
                          if (!(16 & y)) {
                            if (0 == (64 & y)) {
                              v = m[(65535 & v) + (c & (1 << y) - 1)];
                              continue e;
                            }
                            if (32 & y) {
                              r2.mode = 12;
                              break t;
                            }
                            t2.msg = "invalid literal/length code", r2.mode = 30;
                            break t;
                          }
                          w = 65535 & v, (y &= 15) && (p < y && (c += z[i++] << p, p += 8), w += c & (1 << y) - 1, c >>>= y, p -= y), p < 15 && (c += z[i++] << p, p += 8, c += z[i++] << p, p += 8), v = _[c & b];
                          r: for (; ; ) {
                            if (c >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                              if (0 == (64 & y)) {
                                v = _[(65535 & v) + (c & (1 << y) - 1)];
                                continue r;
                              }
                              t2.msg = "invalid distance code", r2.mode = 30;
                              break t;
                            }
                            if (k = 65535 & v, p < (y &= 15) && (c += z[i++] << p, (p += 8) < y && (c += z[i++] << p, p += 8)), h < (k += c & (1 << y) - 1)) {
                              t2.msg = "invalid distance too far back", r2.mode = 30;
                              break t;
                            }
                            if (c >>>= y, p -= y, (y = s - a) < k) {
                              if (l < (y = k - y) && r2.sane) {
                                t2.msg = "invalid distance too far back", r2.mode = 30;
                                break t;
                              }
                              if (S = d, (x = 0) === f) {
                                if (x += u - y, y < w) {
                                  for (w -= y; C[s++] = d[x++], --y; ) ;
                                  x = s - k, S = C;
                                }
                              } else if (f < y) {
                                if (x += u + f - y, (y -= f) < w) {
                                  for (w -= y; C[s++] = d[x++], --y; ) ;
                                  if (x = 0, f < w) {
                                    for (w -= y = f; C[s++] = d[x++], --y; ) ;
                                    x = s - k, S = C;
                                  }
                                }
                              } else if (x += f - y, y < w) {
                                for (w -= y; C[s++] = d[x++], --y; ) ;
                                x = s - k, S = C;
                              }
                              for (; 2 < w; ) C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                              w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                            } else {
                              for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); ) ;
                              w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                            }
                            break;
                          }
                        }
                        break;
                      }
                    } while (i < n && s < o);
                    i -= w = p >> 3, c &= (1 << (p -= w << 3)) - 1, t2.next_in = i, t2.next_out = s, t2.avail_in = i < n ? n - i + 5 : 5 - (i - n), t2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = c, r2.bits = p;
                  };
                }, {}], 49: [function(t, e, r) {
                  "use strict";
                  var I = t("../utils/common"), O = t("./adler32"), B = t("./crc32"), R = t("./inffast"), T = t("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, i = 852, n = 592;
                  function L(t2) {
                    return (t2 >>> 24 & 255) + (t2 >>> 8 & 65280) + ((65280 & t2) << 8) + ((255 & t2) << 24);
                  }
                  function s() {
                    this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
                  }
                  function a(t2) {
                    var e2;
                    return t2 && t2.state ? (e2 = t2.state, t2.total_in = t2.total_out = e2.total = 0, t2.msg = "", e2.wrap && (t2.adler = 1 & e2.wrap), e2.mode = P, e2.last = 0, e2.havedict = 0, e2.dmax = 32768, e2.head = null, e2.hold = 0, e2.bits = 0, e2.lencode = e2.lendyn = new I.Buf32(i), e2.distcode = e2.distdyn = new I.Buf32(n), e2.sane = 1, e2.back = -1, N) : U;
                  }
                  function o(t2) {
                    var e2;
                    return t2 && t2.state ? ((e2 = t2.state).wsize = 0, e2.whave = 0, e2.wnext = 0, a(t2)) : U;
                  }
                  function h(t2, e2) {
                    var r2, i2;
                    return t2 && t2.state ? (i2 = t2.state, e2 < 0 ? (r2 = 0, e2 = -e2) : (r2 = 1 + (e2 >> 4), e2 < 48 && (e2 &= 15)), e2 && (e2 < 8 || 15 < e2) ? U : (null !== i2.window && i2.wbits !== e2 && (i2.window = null), i2.wrap = r2, i2.wbits = e2, o(t2))) : U;
                  }
                  function u(t2, e2) {
                    var r2, i2;
                    return t2 ? (i2 = new s(), (t2.state = i2).window = null, (r2 = h(t2, e2)) !== N && (t2.state = null), r2) : U;
                  }
                  var l, f, d = true;
                  function j(t2) {
                    if (d) {
                      var e2;
                      for (l = new I.Buf32(512), f = new I.Buf32(32), e2 = 0; e2 < 144; ) t2.lens[e2++] = 8;
                      for (; e2 < 256; ) t2.lens[e2++] = 9;
                      for (; e2 < 280; ) t2.lens[e2++] = 7;
                      for (; e2 < 288; ) t2.lens[e2++] = 8;
                      for (T(D, t2.lens, 0, 288, l, 0, t2.work, { bits: 9 }), e2 = 0; e2 < 32; ) t2.lens[e2++] = 5;
                      T(F, t2.lens, 0, 32, f, 0, t2.work, { bits: 5 }), d = false;
                    }
                    t2.lencode = l, t2.lenbits = 9, t2.distcode = f, t2.distbits = 5;
                  }
                  function Z(t2, e2, r2, i2) {
                    var n2, s2 = t2.state;
                    return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), i2 >= s2.wsize ? (I.arraySet(s2.window, e2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (i2 < (n2 = s2.wsize - s2.wnext) && (n2 = i2), I.arraySet(s2.window, e2, r2 - i2, n2, s2.wnext), (i2 -= n2) ? (I.arraySet(s2.window, e2, r2 - i2, i2, 0), s2.wnext = i2, s2.whave = s2.wsize) : (s2.wnext += n2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += n2))), 0;
                  }
                  r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(t2) {
                    return u(t2, 15);
                  }, r.inflateInit2 = u, r.inflate = function(t2, e2) {
                    var r2, i2, n2, s2, a2, o2, h2, u2, l2, f2, d2, c, p, m, _, g, b, v, y, w, k, x, S, z, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
                    if (!t2 || !t2.state || !t2.output || !t2.input && 0 !== t2.avail_in) return U;
                    12 === (r2 = t2.state).mode && (r2.mode = 13), a2 = t2.next_out, n2 = t2.output, h2 = t2.avail_out, s2 = t2.next_in, i2 = t2.input, o2 = t2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, d2 = h2, x = N;
                    t: for (; ; ) switch (r2.mode) {
                      case P:
                        if (0 === r2.wrap) {
                          r2.mode = 13;
                          break;
                        }
                        for (; l2 < 16; ) {
                          if (0 === o2) break t;
                          o2--, u2 += i2[s2++] << l2, l2 += 8;
                        }
                        if (2 & r2.wrap && 35615 === u2) {
                          E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
                          break;
                        }
                        if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                          t2.msg = "incorrect header check", r2.mode = 30;
                          break;
                        }
                        if (8 != (15 & u2)) {
                          t2.msg = "unknown compression method", r2.mode = 30;
                          break;
                        }
                        if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), 0 === r2.wbits) r2.wbits = k;
                        else if (k > r2.wbits) {
                          t2.msg = "invalid window size", r2.mode = 30;
                          break;
                        }
                        r2.dmax = 1 << k, t2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
                        break;
                      case 2:
                        for (; l2 < 16; ) {
                          if (0 === o2) break t;
                          o2--, u2 += i2[s2++] << l2, l2 += 8;
                        }
                        if (r2.flags = u2, 8 != (255 & r2.flags)) {
                          t2.msg = "unknown compression method", r2.mode = 30;
                          break;
                        }
                        if (57344 & r2.flags) {
                          t2.msg = "unknown header flags set", r2.mode = 30;
                          break;
                        }
                        r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
                      case 3:
                        for (; l2 < 32; ) {
                          if (0 === o2) break t;
                          o2--, u2 += i2[s2++] << l2, l2 += 8;
                        }
                        r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
                      case 4:
                        for (; l2 < 16; ) {
                          if (0 === o2) break t;
                          o2--, u2 += i2[s2++] << l2, l2 += 8;
                        }
                        r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
                      case 5:
                        if (1024 & r2.flags) {
                          for (; l2 < 16; ) {
                            if (0 === o2) break t;
                            o2--, u2 += i2[s2++] << l2, l2 += 8;
                          }
                          r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;
                        } else r2.head && (r2.head.extra = null);
                        r2.mode = 6;
                      case 6:
                        if (1024 & r2.flags && (o2 < (c = r2.length) && (c = o2), c && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, i2, s2, c, k)), 512 & r2.flags && (r2.check = B(r2.check, i2, c, s2)), o2 -= c, s2 += c, r2.length -= c), r2.length)) break t;
                        r2.length = 0, r2.mode = 7;
                      case 7:
                        if (2048 & r2.flags) {
                          if (0 === o2) break t;
                          for (c = 0; k = i2[s2 + c++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && c < o2; ) ;
                          if (512 & r2.flags && (r2.check = B(r2.check, i2, c, s2)), o2 -= c, s2 += c, k) break t;
                        } else r2.head && (r2.head.name = null);
                        r2.length = 0, r2.mode = 8;
                      case 8:
                        if (4096 & r2.flags) {
                          if (0 === o2) break t;
                          for (c = 0; k = i2[s2 + c++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && c < o2; ) ;
                          if (512 & r2.flags && (r2.check = B(r2.check, i2, c, s2)), o2 -= c, s2 += c, k) break t;
                        } else r2.head && (r2.head.comment = null);
                        r2.mode = 9;
                      case 9:
                        if (512 & r2.flags) {
                          for (; l2 < 16; ) {
                            if (0 === o2) break t;
                            o2--, u2 += i2[s2++] << l2, l2 += 8;
                          }
                          if (u2 !== (65535 & r2.check)) {
                            t2.msg = "header crc mismatch", r2.mode = 30;
                            break;
                          }
                          l2 = u2 = 0;
                        }
                        r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), t2.adler = r2.check = 0, r2.mode = 12;
                        break;
                      case 10:
                        for (; l2 < 32; ) {
                          if (0 === o2) break t;
                          o2--, u2 += i2[s2++] << l2, l2 += 8;
                        }
                        t2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
                      case 11:
                        if (0 === r2.havedict) return t2.next_out = a2, t2.avail_out = h2, t2.next_in = s2, t2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
                        t2.adler = r2.check = 1, r2.mode = 12;
                      case 12:
                        if (5 === e2 || 6 === e2) break t;
                      case 13:
                        if (r2.last) {
                          u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                          break;
                        }
                        for (; l2 < 3; ) {
                          if (0 === o2) break t;
                          o2--, u2 += i2[s2++] << l2, l2 += 8;
                        }
                        switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                          case 0:
                            r2.mode = 14;
                            break;
                          case 1:
                            if (j(r2), r2.mode = 20, 6 !== e2) break;
                            u2 >>>= 2, l2 -= 2;
                            break t;
                          case 2:
                            r2.mode = 17;
                            break;
                          case 3:
                            t2.msg = "invalid block type", r2.mode = 30;
                        }
                        u2 >>>= 2, l2 -= 2;
                        break;
                      case 14:
                        for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                          if (0 === o2) break t;
                          o2--, u2 += i2[s2++] << l2, l2 += 8;
                        }
                        if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                          t2.msg = "invalid stored block lengths", r2.mode = 30;
                          break;
                        }
                        if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, 6 === e2) break t;
                      case 15:
                        r2.mode = 16;
                      case 16:
                        if (c = r2.length) {
                          if (o2 < c && (c = o2), h2 < c && (c = h2), 0 === c) break t;
                          I.arraySet(n2, i2, s2, c, a2), o2 -= c, s2 += c, h2 -= c, a2 += c, r2.length -= c;
                          break;
                        }
                        r2.mode = 12;
                        break;
                      case 17:
                        for (; l2 < 14; ) {
                          if (0 === o2) break t;
                          o2--, u2 += i2[s2++] << l2, l2 += 8;
                        }
                        if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                          t2.msg = "too many length or distance symbols", r2.mode = 30;
                          break;
                        }
                        r2.have = 0, r2.mode = 18;
                      case 18:
                        for (; r2.have < r2.ncode; ) {
                          for (; l2 < 3; ) {
                            if (0 === o2) break t;
                            o2--, u2 += i2[s2++] << l2, l2 += 8;
                          }
                          r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
                        }
                        for (; r2.have < 19; ) r2.lens[A[r2.have++]] = 0;
                        if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                          t2.msg = "invalid code lengths set", r2.mode = 30;
                          break;
                        }
                        r2.have = 0, r2.mode = 19;
                      case 19:
                        for (; r2.have < r2.nlen + r2.ndist; ) {
                          for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                            if (0 === o2) break t;
                            o2--, u2 += i2[s2++] << l2, l2 += 8;
                          }
                          if (b < 16) u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;
                          else {
                            if (16 === b) {
                              for (z = _ + 2; l2 < z; ) {
                                if (0 === o2) break t;
                                o2--, u2 += i2[s2++] << l2, l2 += 8;
                              }
                              if (u2 >>>= _, l2 -= _, 0 === r2.have) {
                                t2.msg = "invalid bit length repeat", r2.mode = 30;
                                break;
                              }
                              k = r2.lens[r2.have - 1], c = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                            } else if (17 === b) {
                              for (z = _ + 3; l2 < z; ) {
                                if (0 === o2) break t;
                                o2--, u2 += i2[s2++] << l2, l2 += 8;
                              }
                              l2 -= _, k = 0, c = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
                            } else {
                              for (z = _ + 7; l2 < z; ) {
                                if (0 === o2) break t;
                                o2--, u2 += i2[s2++] << l2, l2 += 8;
                              }
                              l2 -= _, k = 0, c = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
                            }
                            if (r2.have + c > r2.nlen + r2.ndist) {
                              t2.msg = "invalid bit length repeat", r2.mode = 30;
                              break;
                            }
                            for (; c--; ) r2.lens[r2.have++] = k;
                          }
                        }
                        if (30 === r2.mode) break;
                        if (0 === r2.lens[256]) {
                          t2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                          break;
                        }
                        if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                          t2.msg = "invalid literal/lengths set", r2.mode = 30;
                          break;
                        }
                        if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                          t2.msg = "invalid distances set", r2.mode = 30;
                          break;
                        }
                        if (r2.mode = 20, 6 === e2) break t;
                      case 20:
                        r2.mode = 21;
                      case 21:
                        if (6 <= o2 && 258 <= h2) {
                          t2.next_out = a2, t2.avail_out = h2, t2.next_in = s2, t2.avail_in = o2, r2.hold = u2, r2.bits = l2, R(t2, d2), a2 = t2.next_out, n2 = t2.output, h2 = t2.avail_out, s2 = t2.next_in, i2 = t2.input, o2 = t2.avail_in, u2 = r2.hold, l2 = r2.bits, 12 === r2.mode && (r2.back = -1);
                          break;
                        }
                        for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                          if (0 === o2) break t;
                          o2--, u2 += i2[s2++] << l2, l2 += 8;
                        }
                        if (g && 0 == (240 & g)) {
                          for (v = _, y = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                            if (0 === o2) break t;
                            o2--, u2 += i2[s2++] << l2, l2 += 8;
                          }
                          u2 >>>= v, l2 -= v, r2.back += v;
                        }
                        if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, 0 === g) {
                          r2.mode = 26;
                          break;
                        }
                        if (32 & g) {
                          r2.back = -1, r2.mode = 12;
                          break;
                        }
                        if (64 & g) {
                          t2.msg = "invalid literal/length code", r2.mode = 30;
                          break;
                        }
                        r2.extra = 15 & g, r2.mode = 22;
                      case 22:
                        if (r2.extra) {
                          for (z = r2.extra; l2 < z; ) {
                            if (0 === o2) break t;
                            o2--, u2 += i2[s2++] << l2, l2 += 8;
                          }
                          r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                        }
                        r2.was = r2.length, r2.mode = 23;
                      case 23:
                        for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                          if (0 === o2) break t;
                          o2--, u2 += i2[s2++] << l2, l2 += 8;
                        }
                        if (0 == (240 & g)) {
                          for (v = _, y = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                            if (0 === o2) break t;
                            o2--, u2 += i2[s2++] << l2, l2 += 8;
                          }
                          u2 >>>= v, l2 -= v, r2.back += v;
                        }
                        if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {
                          t2.msg = "invalid distance code", r2.mode = 30;
                          break;
                        }
                        r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
                      case 24:
                        if (r2.extra) {
                          for (z = r2.extra; l2 < z; ) {
                            if (0 === o2) break t;
                            o2--, u2 += i2[s2++] << l2, l2 += 8;
                          }
                          r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                        }
                        if (r2.offset > r2.dmax) {
                          t2.msg = "invalid distance too far back", r2.mode = 30;
                          break;
                        }
                        r2.mode = 25;
                      case 25:
                        if (0 === h2) break t;
                        if (c = d2 - h2, r2.offset > c) {
                          if ((c = r2.offset - c) > r2.whave && r2.sane) {
                            t2.msg = "invalid distance too far back", r2.mode = 30;
                            break;
                          }
                          p = c > r2.wnext ? (c -= r2.wnext, r2.wsize - c) : r2.wnext - c, c > r2.length && (c = r2.length), m = r2.window;
                        } else m = n2, p = a2 - r2.offset, c = r2.length;
                        for (h2 < c && (c = h2), h2 -= c, r2.length -= c; n2[a2++] = m[p++], --c; ) ;
                        0 === r2.length && (r2.mode = 21);
                        break;
                      case 26:
                        if (0 === h2) break t;
                        n2[a2++] = r2.length, h2--, r2.mode = 21;
                        break;
                      case 27:
                        if (r2.wrap) {
                          for (; l2 < 32; ) {
                            if (0 === o2) break t;
                            o2--, u2 |= i2[s2++] << l2, l2 += 8;
                          }
                          if (d2 -= h2, t2.total_out += d2, r2.total += d2, d2 && (t2.adler = r2.check = r2.flags ? B(r2.check, n2, d2, a2 - d2) : O(r2.check, n2, d2, a2 - d2)), d2 = h2, (r2.flags ? u2 : L(u2)) !== r2.check) {
                            t2.msg = "incorrect data check", r2.mode = 30;
                            break;
                          }
                          l2 = u2 = 0;
                        }
                        r2.mode = 28;
                      case 28:
                        if (r2.wrap && r2.flags) {
                          for (; l2 < 32; ) {
                            if (0 === o2) break t;
                            o2--, u2 += i2[s2++] << l2, l2 += 8;
                          }
                          if (u2 !== (4294967295 & r2.total)) {
                            t2.msg = "incorrect length check", r2.mode = 30;
                            break;
                          }
                          l2 = u2 = 0;
                        }
                        r2.mode = 29;
                      case 29:
                        x = 1;
                        break t;
                      case 30:
                        x = -3;
                        break t;
                      case 31:
                        return -4;
                      case 32:
                      default:
                        return U;
                    }
                    return t2.next_out = a2, t2.avail_out = h2, t2.next_in = s2, t2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || d2 !== t2.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== e2)) && Z(t2, t2.output, t2.next_out, d2 - t2.avail_out) ? (r2.mode = 31, -4) : (f2 -= t2.avail_in, d2 -= t2.avail_out, t2.total_in += f2, t2.total_out += d2, r2.total += d2, r2.wrap && d2 && (t2.adler = r2.check = r2.flags ? B(r2.check, n2, d2, t2.next_out - d2) : O(r2.check, n2, d2, t2.next_out - d2)), t2.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 == f2 && 0 === d2 || 4 === e2) && x === N && (x = -5), x);
                  }, r.inflateEnd = function(t2) {
                    if (!t2 || !t2.state) return U;
                    var e2 = t2.state;
                    return e2.window && (e2.window = null), t2.state = null, N;
                  }, r.inflateGetHeader = function(t2, e2) {
                    var r2;
                    return t2 && t2.state ? 0 == (2 & (r2 = t2.state).wrap) ? U : ((r2.head = e2).done = false, N) : U;
                  }, r.inflateSetDictionary = function(t2, e2) {
                    var r2, i2 = e2.length;
                    return t2 && t2.state ? 0 !== (r2 = t2.state).wrap && 11 !== r2.mode ? U : 11 === r2.mode && O(1, e2, i2, 0) !== r2.check ? -3 : Z(t2, e2, i2, i2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
                  }, r.inflateInfo = "pako inflate (from Nodeca project)";
                }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(t, e, r) {
                  "use strict";
                  var D = t("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
                  e.exports = function(t2, e2, r2, i, n, s, a, o) {
                    var h, u, l, f, d, c, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
                    for (b = 0; b <= 15; b++) O[b] = 0;
                    for (v = 0; v < i; v++) O[e2[r2 + v]]++;
                    for (k = g, w = 15; 1 <= w && 0 === O[w]; w--) ;
                    if (w < k && (k = w), 0 === w) return n[s++] = 20971520, n[s++] = 20971520, o.bits = 1, 0;
                    for (y = 1; y < w && 0 === O[y]; y++) ;
                    for (k < y && (k = y), b = z = 1; b <= 15; b++) if (z <<= 1, (z -= O[b]) < 0) return -1;
                    if (0 < z && (0 === t2 || 1 !== w)) return -1;
                    for (B[1] = 0, b = 1; b < 15; b++) B[b + 1] = B[b] + O[b];
                    for (v = 0; v < i; v++) 0 !== e2[r2 + v] && (a[B[e2[r2 + v]]++] = v);
                    if (c = 0 === t2 ? (A = R = a, 19) : 1 === t2 ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, d = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === t2 && 852 < C || 2 === t2 && 592 < C) return 1;
                    for (; ; ) {
                      for (p = b - S, _ = a[v] < c ? (m = 0, a[v]) : a[v] > c ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; n[d + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, 0 !== u; ) ;
                      for (h = 1 << b - 1; E & h; ) h >>= 1;
                      if (0 !== h ? (E &= h - 1, E += h) : E = 0, v++, 0 == --O[b]) {
                        if (b === w) break;
                        b = e2[r2 + a[v]];
                      }
                      if (k < b && (E & f) !== l) {
                        for (0 === S && (S = k), d += y, z = 1 << (x = b - S); x + S < w && !((z -= O[x + S]) <= 0); ) x++, z <<= 1;
                        if (C += 1 << x, 1 === t2 && 852 < C || 2 === t2 && 592 < C) return 1;
                        n[l = E & f] = k << 24 | x << 16 | d - s | 0;
                      }
                    }
                    return 0 !== E && (n[d + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
                  };
                }, { "../utils/common": 41 }], 51: [function(t, e, r) {
                  "use strict";
                  e.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
                }, {}], 52: [function(t, e, r) {
                  "use strict";
                  var n = t("../utils/common"), o = 0, h = 1;
                  function i(t2) {
                    for (var e2 = t2.length; 0 <= --e2; ) t2[e2] = 0;
                  }
                  var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, d = 19, _ = 2 * l + 1, g = 15, c = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2));
                  i(z);
                  var C = new Array(2 * f);
                  i(C);
                  var E = new Array(512);
                  i(E);
                  var A = new Array(256);
                  i(A);
                  var I = new Array(a);
                  i(I);
                  var O, B, R, T = new Array(f);
                  function D(t2, e2, r2, i2, n2) {
                    this.static_tree = t2, this.extra_bits = e2, this.extra_base = r2, this.elems = i2, this.max_length = n2, this.has_stree = t2 && t2.length;
                  }
                  function F(t2, e2) {
                    this.dyn_tree = t2, this.max_code = 0, this.stat_desc = e2;
                  }
                  function N(t2) {
                    return t2 < 256 ? E[t2] : E[256 + (t2 >>> 7)];
                  }
                  function U(t2, e2) {
                    t2.pending_buf[t2.pending++] = 255 & e2, t2.pending_buf[t2.pending++] = e2 >>> 8 & 255;
                  }
                  function P(t2, e2, r2) {
                    t2.bi_valid > c - r2 ? (t2.bi_buf |= e2 << t2.bi_valid & 65535, U(t2, t2.bi_buf), t2.bi_buf = e2 >> c - t2.bi_valid, t2.bi_valid += r2 - c) : (t2.bi_buf |= e2 << t2.bi_valid & 65535, t2.bi_valid += r2);
                  }
                  function L(t2, e2, r2) {
                    P(t2, r2[2 * e2], r2[2 * e2 + 1]);
                  }
                  function j(t2, e2) {
                    for (var r2 = 0; r2 |= 1 & t2, t2 >>>= 1, r2 <<= 1, 0 < --e2; ) ;
                    return r2 >>> 1;
                  }
                  function Z(t2, e2, r2) {
                    var i2, n2, s2 = new Array(g + 1), a2 = 0;
                    for (i2 = 1; i2 <= g; i2++) s2[i2] = a2 = a2 + r2[i2 - 1] << 1;
                    for (n2 = 0; n2 <= e2; n2++) {
                      var o2 = t2[2 * n2 + 1];
                      0 !== o2 && (t2[2 * n2] = j(s2[o2]++, o2));
                    }
                  }
                  function W(t2) {
                    var e2;
                    for (e2 = 0; e2 < l; e2++) t2.dyn_ltree[2 * e2] = 0;
                    for (e2 = 0; e2 < f; e2++) t2.dyn_dtree[2 * e2] = 0;
                    for (e2 = 0; e2 < d; e2++) t2.bl_tree[2 * e2] = 0;
                    t2.dyn_ltree[2 * m] = 1, t2.opt_len = t2.static_len = 0, t2.last_lit = t2.matches = 0;
                  }
                  function M(t2) {
                    8 < t2.bi_valid ? U(t2, t2.bi_buf) : 0 < t2.bi_valid && (t2.pending_buf[t2.pending++] = t2.bi_buf), t2.bi_buf = 0, t2.bi_valid = 0;
                  }
                  function H(t2, e2, r2, i2) {
                    var n2 = 2 * e2, s2 = 2 * r2;
                    return t2[n2] < t2[s2] || t2[n2] === t2[s2] && i2[e2] <= i2[r2];
                  }
                  function G(t2, e2, r2) {
                    for (var i2 = t2.heap[r2], n2 = r2 << 1; n2 <= t2.heap_len && (n2 < t2.heap_len && H(e2, t2.heap[n2 + 1], t2.heap[n2], t2.depth) && n2++, !H(e2, i2, t2.heap[n2], t2.depth)); ) t2.heap[r2] = t2.heap[n2], r2 = n2, n2 <<= 1;
                    t2.heap[r2] = i2;
                  }
                  function K(t2, e2, r2) {
                    var i2, n2, s2, a2, o2 = 0;
                    if (0 !== t2.last_lit) for (; i2 = t2.pending_buf[t2.d_buf + 2 * o2] << 8 | t2.pending_buf[t2.d_buf + 2 * o2 + 1], n2 = t2.pending_buf[t2.l_buf + o2], o2++, 0 === i2 ? L(t2, n2, e2) : (L(t2, (s2 = A[n2]) + u + 1, e2), 0 !== (a2 = w[s2]) && P(t2, n2 -= I[s2], a2), L(t2, s2 = N(--i2), r2), 0 !== (a2 = k[s2]) && P(t2, i2 -= T[s2], a2)), o2 < t2.last_lit; ) ;
                    L(t2, m, e2);
                  }
                  function Y(t2, e2) {
                    var r2, i2, n2, s2 = e2.dyn_tree, a2 = e2.stat_desc.static_tree, o2 = e2.stat_desc.has_stree, h2 = e2.stat_desc.elems, u2 = -1;
                    for (t2.heap_len = 0, t2.heap_max = _, r2 = 0; r2 < h2; r2++) 0 !== s2[2 * r2] ? (t2.heap[++t2.heap_len] = u2 = r2, t2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
                    for (; t2.heap_len < 2; ) s2[2 * (n2 = t2.heap[++t2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, t2.depth[n2] = 0, t2.opt_len--, o2 && (t2.static_len -= a2[2 * n2 + 1]);
                    for (e2.max_code = u2, r2 = t2.heap_len >> 1; 1 <= r2; r2--) G(t2, s2, r2);
                    for (n2 = h2; r2 = t2.heap[1], t2.heap[1] = t2.heap[t2.heap_len--], G(t2, s2, 1), i2 = t2.heap[1], t2.heap[--t2.heap_max] = r2, t2.heap[--t2.heap_max] = i2, s2[2 * n2] = s2[2 * r2] + s2[2 * i2], t2.depth[n2] = (t2.depth[r2] >= t2.depth[i2] ? t2.depth[r2] : t2.depth[i2]) + 1, s2[2 * r2 + 1] = s2[2 * i2 + 1] = n2, t2.heap[1] = n2++, G(t2, s2, 1), 2 <= t2.heap_len; ) ;
                    t2.heap[--t2.heap_max] = t2.heap[1], function(t3, e3) {
                      var r3, i3, n3, s3, a3, o3, h3 = e3.dyn_tree, u3 = e3.max_code, l2 = e3.stat_desc.static_tree, f2 = e3.stat_desc.has_stree, d2 = e3.stat_desc.extra_bits, c2 = e3.stat_desc.extra_base, p2 = e3.stat_desc.max_length, m2 = 0;
                      for (s3 = 0; s3 <= g; s3++) t3.bl_count[s3] = 0;
                      for (h3[2 * t3.heap[t3.heap_max] + 1] = 0, r3 = t3.heap_max + 1; r3 < _; r3++) p2 < (s3 = h3[2 * h3[2 * (i3 = t3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h3[2 * i3 + 1] = s3, u3 < i3 || (t3.bl_count[s3]++, a3 = 0, c2 <= i3 && (a3 = d2[i3 - c2]), o3 = h3[2 * i3], t3.opt_len += o3 * (s3 + a3), f2 && (t3.static_len += o3 * (l2[2 * i3 + 1] + a3)));
                      if (0 !== m2) {
                        do {
                          for (s3 = p2 - 1; 0 === t3.bl_count[s3]; ) s3--;
                          t3.bl_count[s3]--, t3.bl_count[s3 + 1] += 2, t3.bl_count[p2]--, m2 -= 2;
                        } while (0 < m2);
                        for (s3 = p2; 0 !== s3; s3--) for (i3 = t3.bl_count[s3]; 0 !== i3; ) u3 < (n3 = t3.heap[--r3]) || (h3[2 * n3 + 1] !== s3 && (t3.opt_len += (s3 - h3[2 * n3 + 1]) * h3[2 * n3], h3[2 * n3 + 1] = s3), i3--);
                      }
                    }(t2, e2), Z(s2, u2, t2.bl_count);
                  }
                  function X(t2, e2, r2) {
                    var i2, n2, s2 = -1, a2 = e2[1], o2 = 0, h2 = 7, u2 = 4;
                    for (0 === a2 && (h2 = 138, u2 = 3), e2[2 * (r2 + 1) + 1] = 65535, i2 = 0; i2 <= r2; i2++) n2 = a2, a2 = e2[2 * (i2 + 1) + 1], ++o2 < h2 && n2 === a2 || (o2 < u2 ? t2.bl_tree[2 * n2] += o2 : 0 !== n2 ? (n2 !== s2 && t2.bl_tree[2 * n2]++, t2.bl_tree[2 * b]++) : o2 <= 10 ? t2.bl_tree[2 * v]++ : t2.bl_tree[2 * y]++, s2 = n2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : n2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4));
                  }
                  function V(t2, e2, r2) {
                    var i2, n2, s2 = -1, a2 = e2[1], o2 = 0, h2 = 7, u2 = 4;
                    for (0 === a2 && (h2 = 138, u2 = 3), i2 = 0; i2 <= r2; i2++) if (n2 = a2, a2 = e2[2 * (i2 + 1) + 1], !(++o2 < h2 && n2 === a2)) {
                      if (o2 < u2) for (; L(t2, n2, t2.bl_tree), 0 != --o2; ) ;
                      else 0 !== n2 ? (n2 !== s2 && (L(t2, n2, t2.bl_tree), o2--), L(t2, b, t2.bl_tree), P(t2, o2 - 3, 2)) : o2 <= 10 ? (L(t2, v, t2.bl_tree), P(t2, o2 - 3, 3)) : (L(t2, y, t2.bl_tree), P(t2, o2 - 11, 7));
                      s2 = n2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : n2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4);
                    }
                  }
                  i(T);
                  var q = false;
                  function J(t2, e2, r2, i2) {
                    P(t2, (s << 1) + (i2 ? 1 : 0), 3), function(t3, e3, r3, i3) {
                      M(t3), i3 && (U(t3, r3), U(t3, ~r3)), n.arraySet(t3.pending_buf, t3.window, e3, r3, t3.pending), t3.pending += r3;
                    }(t2, e2, r2, true);
                  }
                  r._tr_init = function(t2) {
                    q || (function() {
                      var t3, e2, r2, i2, n2, s2 = new Array(g + 1);
                      for (i2 = r2 = 0; i2 < a - 1; i2++) for (I[i2] = r2, t3 = 0; t3 < 1 << w[i2]; t3++) A[r2++] = i2;
                      for (A[r2 - 1] = i2, i2 = n2 = 0; i2 < 16; i2++) for (T[i2] = n2, t3 = 0; t3 < 1 << k[i2]; t3++) E[n2++] = i2;
                      for (n2 >>= 7; i2 < f; i2++) for (T[i2] = n2 << 7, t3 = 0; t3 < 1 << k[i2] - 7; t3++) E[256 + n2++] = i2;
                      for (e2 = 0; e2 <= g; e2++) s2[e2] = 0;
                      for (t3 = 0; t3 <= 143; ) z[2 * t3 + 1] = 8, t3++, s2[8]++;
                      for (; t3 <= 255; ) z[2 * t3 + 1] = 9, t3++, s2[9]++;
                      for (; t3 <= 279; ) z[2 * t3 + 1] = 7, t3++, s2[7]++;
                      for (; t3 <= 287; ) z[2 * t3 + 1] = 8, t3++, s2[8]++;
                      for (Z(z, l + 1, s2), t3 = 0; t3 < f; t3++) C[2 * t3 + 1] = 5, C[2 * t3] = j(t3, 5);
                      O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, d, p);
                    }(), q = true), t2.l_desc = new F(t2.dyn_ltree, O), t2.d_desc = new F(t2.dyn_dtree, B), t2.bl_desc = new F(t2.bl_tree, R), t2.bi_buf = 0, t2.bi_valid = 0, W(t2);
                  }, r._tr_stored_block = J, r._tr_flush_block = function(t2, e2, r2, i2) {
                    var n2, s2, a2 = 0;
                    0 < t2.level ? (2 === t2.strm.data_type && (t2.strm.data_type = function(t3) {
                      var e3, r3 = 4093624447;
                      for (e3 = 0; e3 <= 31; e3++, r3 >>>= 1) if (1 & r3 && 0 !== t3.dyn_ltree[2 * e3]) return o;
                      if (0 !== t3.dyn_ltree[18] || 0 !== t3.dyn_ltree[20] || 0 !== t3.dyn_ltree[26]) return h;
                      for (e3 = 32; e3 < u; e3++) if (0 !== t3.dyn_ltree[2 * e3]) return h;
                      return o;
                    }(t2)), Y(t2, t2.l_desc), Y(t2, t2.d_desc), a2 = function(t3) {
                      var e3;
                      for (X(t3, t3.dyn_ltree, t3.l_desc.max_code), X(t3, t3.dyn_dtree, t3.d_desc.max_code), Y(t3, t3.bl_desc), e3 = d - 1; 3 <= e3 && 0 === t3.bl_tree[2 * S[e3] + 1]; e3--) ;
                      return t3.opt_len += 3 * (e3 + 1) + 5 + 5 + 4, e3;
                    }(t2), n2 = t2.opt_len + 3 + 7 >>> 3, (s2 = t2.static_len + 3 + 7 >>> 3) <= n2 && (n2 = s2)) : n2 = s2 = r2 + 5, r2 + 4 <= n2 && -1 !== e2 ? J(t2, e2, r2, i2) : 4 === t2.strategy || s2 === n2 ? (P(t2, 2 + (i2 ? 1 : 0), 3), K(t2, z, C)) : (P(t2, 4 + (i2 ? 1 : 0), 3), function(t3, e3, r3, i3) {
                      var n3;
                      for (P(t3, e3 - 257, 5), P(t3, r3 - 1, 5), P(t3, i3 - 4, 4), n3 = 0; n3 < i3; n3++) P(t3, t3.bl_tree[2 * S[n3] + 1], 3);
                      V(t3, t3.dyn_ltree, e3 - 1), V(t3, t3.dyn_dtree, r3 - 1);
                    }(t2, t2.l_desc.max_code + 1, t2.d_desc.max_code + 1, a2 + 1), K(t2, t2.dyn_ltree, t2.dyn_dtree)), W(t2), i2 && M(t2);
                  }, r._tr_tally = function(t2, e2, r2) {
                    return t2.pending_buf[t2.d_buf + 2 * t2.last_lit] = e2 >>> 8 & 255, t2.pending_buf[t2.d_buf + 2 * t2.last_lit + 1] = 255 & e2, t2.pending_buf[t2.l_buf + t2.last_lit] = 255 & r2, t2.last_lit++, 0 === e2 ? t2.dyn_ltree[2 * r2]++ : (t2.matches++, e2--, t2.dyn_ltree[2 * (A[r2] + u + 1)]++, t2.dyn_dtree[2 * N(e2)]++), t2.last_lit === t2.lit_bufsize - 1;
                  }, r._tr_align = function(t2) {
                    P(t2, 2, 3), L(t2, m, z), function(t3) {
                      16 === t3.bi_valid ? (U(t3, t3.bi_buf), t3.bi_buf = 0, t3.bi_valid = 0) : 8 <= t3.bi_valid && (t3.pending_buf[t3.pending++] = 255 & t3.bi_buf, t3.bi_buf >>= 8, t3.bi_valid -= 8);
                    }(t2);
                  };
                }, { "../utils/common": 41 }], 53: [function(t, e, r) {
                  "use strict";
                  e.exports = function() {
                    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
                  };
                }, {}], 54: [function(t, e, r) {
                  "use strict";
                  e.exports = "function" == typeof setImmediate ? setImmediate : function() {
                    var t2 = [].slice.apply(arguments);
                    t2.splice(1, 0, 0), setTimeout.apply(null, t2);
                  };
                }, {}] }, {}, [10])(10);
              });
            }).call(this, __webpack_require__2(9).Buffer, __webpack_require__2(17), __webpack_require__2(104).setImmediate);
          },
          /* 116 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const initDebug = __webpack_require__2(8);
            const mm = __webpack_require__2(122);
            const toBuffer = __webpack_require__2(188);
            const Browser2NodeStream_1 = __webpack_require__2(190);
            const debug = initDebug("music-metadata-browser");
            exports2.parseNodeStream = mm.parseStream;
            function parseReadableStream(stream2, contentType, options) {
              const ns = new Browser2NodeStream_1.Browser2NodeStream(stream2);
              return exports2.parseNodeStream(ns, contentType, options).then((res) => {
                debug(`Completed parsing from stream 1bytesRead=${ns.bytesRead} / fileSize=${options && options.fileSize ? options.fileSize : "?"}`);
                return res;
              });
            }
            exports2.parseReadableStream = parseReadableStream;
            exports2.parseBuffer = mm.parseBuffer;
            function parseBlob(blob, options) {
              return convertBlobToBuffer(blob).then((buf) => {
                return mm.parseBuffer(buf, blob.type, options);
              });
            }
            exports2.parseBlob = parseBlob;
            function fetchFromUrl(audioTrackUrl, options) {
              return fetch(audioTrackUrl).then((response) => {
                const contentType = response.headers.get("Content-Type");
                const headers = [];
                response.headers.forEach((header) => {
                  headers.push(header);
                });
                if (response.ok) {
                  if (response.body) {
                    return this.parseReadableStream(response.body, contentType, options).then((res) => {
                      response.body.cancel();
                      return res;
                    });
                  } else {
                    return response.blob().then((blob) => {
                      return this.parseBlob(blob, options);
                    });
                  }
                } else {
                  throw new Error(`HTTP error status=${response.status}: ${response.statusText}`);
                }
              });
            }
            exports2.fetchFromUrl = fetchFromUrl;
            exports2.parseFromTokenizer = mm.parseFromTokenizer;
            function convertBlobToBuffer(blob) {
              return new Promise((resolve2, reject2) => {
                const fileReader = new FileReader();
                fileReader.onloadend = (event) => {
                  let data = event.target.result;
                  if (data instanceof ArrayBuffer) {
                    data = toBuffer(new Uint8Array(event.target.result));
                  }
                  resolve2(data);
                };
                fileReader.onerror = (error) => {
                  reject2(new Error(error.type));
                };
                fileReader.onabort = (error) => {
                  reject2(new Error(error.type));
                };
                fileReader.readAsArrayBuffer(blob);
              });
            }
            exports2.orderTags = mm.orderTags;
            exports2.ratingToStars = mm.ratingToStars;
          },
          /* 117 */
          /***/
          function(module2, __webpack_exports__, __webpack_require__2) {
            "use strict";
            __webpack_require__2.r(__webpack_exports__);
            __webpack_require__2.d(__webpack_exports__, "default", function() {
              return Webamp;
            });
            var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(2);
            var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__2.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);
            var jszip__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__2(115);
            var jszip__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__2.n(jszip__WEBPACK_IMPORTED_MODULE_1__);
            var music_metadata_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__2(116);
            var music_metadata_browser__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__2.n(music_metadata_browser__WEBPACK_IMPORTED_MODULE_2__);
            var _webampLazy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__2(47);
            function ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function _objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  ownKeys(Object(source), true).forEach(function(key) {
                    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            class Webamp extends _webampLazy__WEBPACK_IMPORTED_MODULE_3__["default"] {
              constructor(options) {
                super(_objectSpread(_objectSpread({}, options), {}, {
                  requireJSZip: () => jszip__WEBPACK_IMPORTED_MODULE_1___default.a,
                  requireMusicMetadata: () => music_metadata_browser__WEBPACK_IMPORTED_MODULE_2__
                }));
              }
            }
          },
          /* 118 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            exports2.byteLength = byteLength;
            exports2.toByteArray = toByteArray;
            exports2.fromByteArray = fromByteArray;
            var lookup = [];
            var revLookup = [];
            var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
            var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            for (var i = 0, len = code.length; i < len; ++i) {
              lookup[i] = code[i];
              revLookup[code.charCodeAt(i)] = i;
            }
            revLookup["-".charCodeAt(0)] = 62;
            revLookup["_".charCodeAt(0)] = 63;
            function getLens(b64) {
              var len2 = b64.length;
              if (len2 % 4 > 0) {
                throw new Error("Invalid string. Length must be a multiple of 4");
              }
              var validLen = b64.indexOf("=");
              if (validLen === -1) validLen = len2;
              var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
              return [validLen, placeHoldersLen];
            }
            function byteLength(b64) {
              var lens = getLens(b64);
              var validLen = lens[0];
              var placeHoldersLen = lens[1];
              return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
            }
            function _byteLength(b64, validLen, placeHoldersLen) {
              return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
            }
            function toByteArray(b64) {
              var tmp;
              var lens = getLens(b64);
              var validLen = lens[0];
              var placeHoldersLen = lens[1];
              var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
              var curByte = 0;
              var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
              var i2;
              for (i2 = 0; i2 < len2; i2 += 4) {
                tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
                arr[curByte++] = tmp >> 16 & 255;
                arr[curByte++] = tmp >> 8 & 255;
                arr[curByte++] = tmp & 255;
              }
              if (placeHoldersLen === 2) {
                tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
                arr[curByte++] = tmp & 255;
              }
              if (placeHoldersLen === 1) {
                tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
                arr[curByte++] = tmp >> 8 & 255;
                arr[curByte++] = tmp & 255;
              }
              return arr;
            }
            function tripletToBase64(num) {
              return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
            }
            function encodeChunk(uint8, start, end) {
              var tmp;
              var output = [];
              for (var i2 = start; i2 < end; i2 += 3) {
                tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
                output.push(tripletToBase64(tmp));
              }
              return output.join("");
            }
            function fromByteArray(uint8) {
              var tmp;
              var len2 = uint8.length;
              var extraBytes = len2 % 3;
              var parts = [];
              var maxChunkLength = 16383;
              for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
                parts.push(encodeChunk(
                  uint8,
                  i2,
                  i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength
                ));
              }
              if (extraBytes === 1) {
                tmp = uint8[len2 - 1];
                parts.push(
                  lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
                );
              } else if (extraBytes === 2) {
                tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
                parts.push(
                  lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
                );
              }
              return parts.join("");
            }
          },
          /* 119 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            (function(global, process) {
              (function(global2, undefined2) {
                "use strict";
                if (global2.setImmediate) {
                  return;
                }
                var nextHandle = 1;
                var tasksByHandle = {};
                var currentlyRunningATask = false;
                var doc = global2.document;
                var registerImmediate;
                function setImmediate(callback) {
                  if (typeof callback !== "function") {
                    callback = new Function("" + callback);
                  }
                  var args = new Array(arguments.length - 1);
                  for (var i = 0; i < args.length; i++) {
                    args[i] = arguments[i + 1];
                  }
                  var task = { callback, args };
                  tasksByHandle[nextHandle] = task;
                  registerImmediate(nextHandle);
                  return nextHandle++;
                }
                function clearImmediate(handle) {
                  delete tasksByHandle[handle];
                }
                function run(task) {
                  var callback = task.callback;
                  var args = task.args;
                  switch (args.length) {
                    case 0:
                      callback();
                      break;
                    case 1:
                      callback(args[0]);
                      break;
                    case 2:
                      callback(args[0], args[1]);
                      break;
                    case 3:
                      callback(args[0], args[1], args[2]);
                      break;
                    default:
                      callback.apply(undefined2, args);
                      break;
                  }
                }
                function runIfPresent(handle) {
                  if (currentlyRunningATask) {
                    setTimeout(runIfPresent, 0, handle);
                  } else {
                    var task = tasksByHandle[handle];
                    if (task) {
                      currentlyRunningATask = true;
                      try {
                        run(task);
                      } finally {
                        clearImmediate(handle);
                        currentlyRunningATask = false;
                      }
                    }
                  }
                }
                function installNextTickImplementation() {
                  registerImmediate = function(handle) {
                    process.nextTick(function() {
                      runIfPresent(handle);
                    });
                  };
                }
                function canUsePostMessage() {
                  if (global2.postMessage && !global2.importScripts) {
                    var postMessageIsAsynchronous = true;
                    var oldOnMessage = global2.onmessage;
                    global2.onmessage = function() {
                      postMessageIsAsynchronous = false;
                    };
                    global2.postMessage("", "*");
                    global2.onmessage = oldOnMessage;
                    return postMessageIsAsynchronous;
                  }
                }
                function installPostMessageImplementation() {
                  var messagePrefix = "setImmediate$" + Math.random() + "$";
                  var onGlobalMessage = function(event) {
                    if (event.source === global2 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                      runIfPresent(+event.data.slice(messagePrefix.length));
                    }
                  };
                  if (global2.addEventListener) {
                    global2.addEventListener("message", onGlobalMessage, false);
                  } else {
                    global2.attachEvent("onmessage", onGlobalMessage);
                  }
                  registerImmediate = function(handle) {
                    global2.postMessage(messagePrefix + handle, "*");
                  };
                }
                function installMessageChannelImplementation() {
                  var channel = new MessageChannel();
                  channel.port1.onmessage = function(event) {
                    var handle = event.data;
                    runIfPresent(handle);
                  };
                  registerImmediate = function(handle) {
                    channel.port2.postMessage(handle);
                  };
                }
                function installReadyStateChangeImplementation() {
                  var html = doc.documentElement;
                  registerImmediate = function(handle) {
                    var script = doc.createElement("script");
                    script.onreadystatechange = function() {
                      runIfPresent(handle);
                      script.onreadystatechange = null;
                      html.removeChild(script);
                      script = null;
                    };
                    html.appendChild(script);
                  };
                }
                function installSetTimeoutImplementation() {
                  registerImmediate = function(handle) {
                    setTimeout(runIfPresent, 0, handle);
                  };
                }
                var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
                attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
                if ({}.toString.call(global2.process) === "[object process]") {
                  installNextTickImplementation();
                } else if (canUsePostMessage()) {
                  installPostMessageImplementation();
                } else if (global2.MessageChannel) {
                  installMessageChannelImplementation();
                } else if (doc && "onreadystatechange" in doc.createElement("script")) {
                  installReadyStateChangeImplementation();
                } else {
                  installSetTimeoutImplementation();
                }
                attachTo.setImmediate = setImmediate;
                attachTo.clearImmediate = clearImmediate;
              })(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
            }).call(this, __webpack_require__2(17), __webpack_require__2(30));
          },
          /* 120 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            function setup(env) {
              createDebug.debug = createDebug;
              createDebug.default = createDebug;
              createDebug.coerce = coerce;
              createDebug.disable = disable;
              createDebug.enable = enable;
              createDebug.enabled = enabled;
              createDebug.humanize = __webpack_require__2(121);
              Object.keys(env).forEach((key) => {
                createDebug[key] = env[key];
              });
              createDebug.instances = [];
              createDebug.names = [];
              createDebug.skips = [];
              createDebug.formatters = {};
              function selectColor(namespace) {
                let hash = 0;
                for (let i = 0; i < namespace.length; i++) {
                  hash = (hash << 5) - hash + namespace.charCodeAt(i);
                  hash |= 0;
                }
                return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
              }
              createDebug.selectColor = selectColor;
              function createDebug(namespace) {
                let prevTime;
                function debug(...args) {
                  if (!debug.enabled) {
                    return;
                  }
                  const self2 = debug;
                  const curr = Number(/* @__PURE__ */ new Date());
                  const ms = curr - (prevTime || curr);
                  self2.diff = ms;
                  self2.prev = prevTime;
                  self2.curr = curr;
                  prevTime = curr;
                  args[0] = createDebug.coerce(args[0]);
                  if (typeof args[0] !== "string") {
                    args.unshift("%O");
                  }
                  let index = 0;
                  args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
                    if (match === "%%") {
                      return match;
                    }
                    index++;
                    const formatter = createDebug.formatters[format];
                    if (typeof formatter === "function") {
                      const val = args[index];
                      match = formatter.call(self2, val);
                      args.splice(index, 1);
                      index--;
                    }
                    return match;
                  });
                  createDebug.formatArgs.call(self2, args);
                  const logFn = self2.log || createDebug.log;
                  logFn.apply(self2, args);
                }
                debug.namespace = namespace;
                debug.enabled = createDebug.enabled(namespace);
                debug.useColors = createDebug.useColors();
                debug.color = selectColor(namespace);
                debug.destroy = destroy;
                debug.extend = extend;
                if (typeof createDebug.init === "function") {
                  createDebug.init(debug);
                }
                createDebug.instances.push(debug);
                return debug;
              }
              function destroy() {
                const index = createDebug.instances.indexOf(this);
                if (index !== -1) {
                  createDebug.instances.splice(index, 1);
                  return true;
                }
                return false;
              }
              function extend(namespace, delimiter) {
                const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
                newDebug.log = this.log;
                return newDebug;
              }
              function enable(namespaces) {
                createDebug.save(namespaces);
                createDebug.names = [];
                createDebug.skips = [];
                let i;
                const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
                const len = split.length;
                for (i = 0; i < len; i++) {
                  if (!split[i]) {
                    continue;
                  }
                  namespaces = split[i].replace(/\*/g, ".*?");
                  if (namespaces[0] === "-") {
                    createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
                  } else {
                    createDebug.names.push(new RegExp("^" + namespaces + "$"));
                  }
                }
                for (i = 0; i < createDebug.instances.length; i++) {
                  const instance = createDebug.instances[i];
                  instance.enabled = createDebug.enabled(instance.namespace);
                }
              }
              function disable() {
                const namespaces = [
                  ...createDebug.names.map(toNamespace),
                  ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
                ].join(",");
                createDebug.enable("");
                return namespaces;
              }
              function enabled(name) {
                if (name[name.length - 1] === "*") {
                  return true;
                }
                let i;
                let len;
                for (i = 0, len = createDebug.skips.length; i < len; i++) {
                  if (createDebug.skips[i].test(name)) {
                    return false;
                  }
                }
                for (i = 0, len = createDebug.names.length; i < len; i++) {
                  if (createDebug.names[i].test(name)) {
                    return true;
                  }
                }
                return false;
              }
              function toNamespace(regexp) {
                return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
              }
              function coerce(val) {
                if (val instanceof Error) {
                  return val.stack || val.message;
                }
                return val;
              }
              createDebug.enable(createDebug.load());
              return createDebug;
            }
            module2.exports = setup;
          },
          /* 121 */
          /***/
          function(module2, exports2) {
            var s = 1e3;
            var m = s * 60;
            var h = m * 60;
            var d = h * 24;
            var w = d * 7;
            var y = d * 365.25;
            module2.exports = function(val, options) {
              options = options || {};
              var type = typeof val;
              if (type === "string" && val.length > 0) {
                return parse(val);
              } else if (type === "number" && isFinite(val)) {
                return options.long ? fmtLong(val) : fmtShort(val);
              }
              throw new Error(
                "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
              );
            };
            function parse(str) {
              str = String(str);
              if (str.length > 100) {
                return;
              }
              var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
                str
              );
              if (!match) {
                return;
              }
              var n = parseFloat(match[1]);
              var type = (match[2] || "ms").toLowerCase();
              switch (type) {
                case "years":
                case "year":
                case "yrs":
                case "yr":
                case "y":
                  return n * y;
                case "weeks":
                case "week":
                case "w":
                  return n * w;
                case "days":
                case "day":
                case "d":
                  return n * d;
                case "hours":
                case "hour":
                case "hrs":
                case "hr":
                case "h":
                  return n * h;
                case "minutes":
                case "minute":
                case "mins":
                case "min":
                case "m":
                  return n * m;
                case "seconds":
                case "second":
                case "secs":
                case "sec":
                case "s":
                  return n * s;
                case "milliseconds":
                case "millisecond":
                case "msecs":
                case "msec":
                case "ms":
                  return n;
                default:
                  return void 0;
              }
            }
            function fmtShort(ms) {
              var msAbs = Math.abs(ms);
              if (msAbs >= d) {
                return Math.round(ms / d) + "d";
              }
              if (msAbs >= h) {
                return Math.round(ms / h) + "h";
              }
              if (msAbs >= m) {
                return Math.round(ms / m) + "m";
              }
              if (msAbs >= s) {
                return Math.round(ms / s) + "s";
              }
              return ms + "ms";
            }
            function fmtLong(ms) {
              var msAbs = Math.abs(ms);
              if (msAbs >= d) {
                return plural(ms, msAbs, d, "day");
              }
              if (msAbs >= h) {
                return plural(ms, msAbs, h, "hour");
              }
              if (msAbs >= m) {
                return plural(ms, msAbs, m, "minute");
              }
              if (msAbs >= s) {
                return plural(ms, msAbs, s, "second");
              }
              return ms + " ms";
            }
            function plural(ms, msAbs, n, name) {
              var isPlural = msAbs >= n * 1.5;
              return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
            }
          },
          /* 122 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const strtok3 = __webpack_require__2(43);
            const ParserFactory_1 = __webpack_require__2(130);
            function parseStream(stream2, mimeType, options = {}) {
              return parseFromTokenizer(strtok3.fromStream(stream2), mimeType, options);
            }
            exports2.parseStream = parseStream;
            function parseBuffer(buf, mimeType, options = {}) {
              const tokenizer = strtok3.fromBuffer(buf);
              return parseFromTokenizer(tokenizer, mimeType, options);
            }
            exports2.parseBuffer = parseBuffer;
            function parseFromTokenizer(tokenizer, mimeType, options = {}) {
              if (!tokenizer.fileSize && options.fileSize) {
                tokenizer.fileSize = options.fileSize;
              }
              return ParserFactory_1.ParserFactory.parse(tokenizer, mimeType, options);
            }
            exports2.parseFromTokenizer = parseFromTokenizer;
            function orderTags(nativeTags) {
              const tags = {};
              for (const tag of nativeTags) {
                (tags[tag.id] = tags[tag.id] || []).push(tag.value);
              }
              return tags;
            }
            exports2.orderTags = orderTags;
            function ratingToStars(rating) {
              return rating === void 0 ? 0 : 1 + Math.round(rating * 4);
            }
            exports2.ratingToStars = ratingToStars;
          },
          /* 123 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            (function(Buffer2) {
              var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function(resolve2, reject2) {
                  function fulfilled(value) {
                    try {
                      step(generator.next(value));
                    } catch (e) {
                      reject2(e);
                    }
                  }
                  function rejected(value) {
                    try {
                      step(generator["throw"](value));
                    } catch (e) {
                      reject2(e);
                    }
                  }
                  function step(result) {
                    result.done ? resolve2(result.value) : new P(function(resolve3) {
                      resolve3(result.value);
                    }).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
              };
              Object.defineProperty(exports2, "__esModule", { value: true });
              const AbstractTokenizer_1 = __webpack_require__2(124);
              const type_1 = __webpack_require__2(22);
              const then_read_stream_1 = __webpack_require__2(125);
              const _debug = __webpack_require__2(8);
              const debug = _debug("strtok3:ReadStreamTokenizer");
              class ReadStreamTokenizer extends AbstractTokenizer_1.AbstractTokenizer {
                constructor(stream2, fileSize) {
                  super();
                  this.streamReader = new then_read_stream_1.StreamReader(stream2);
                  this.fileSize = fileSize;
                }
                /**
                 * Read buffer from stream
                 * @param buffer
                 * @param offset is the offset in the buffer to start writing at; if not provided, start at 0
                 * @param length is an integer specifying the number of bytes to read
                 * @returns Promise number of bytes read
                 */
                readBuffer(buffer, offset = 0, length = buffer.length, position) {
                  return __awaiter(this, void 0, void 0, function* () {
                    if (length === 0) {
                      return 0;
                    }
                    if (position) {
                      const skipBytes = position - this.position;
                      if (skipBytes > 0) {
                        yield this.ignore(position - this.position);
                        return this.readBuffer(buffer, offset, length);
                      } else if (skipBytes < 0) {
                        throw new Error("Cannot read from a negative offset in a stream");
                      }
                    }
                    let bytesRead;
                    try {
                      bytesRead = yield this.streamReader.read(buffer, offset, length);
                      this.position += bytesRead;
                    } catch (err) {
                      if (err.message === then_read_stream_1.endOfStream)
                        throw new Error(type_1.endOfFile);
                      else
                        throw err;
                    }
                    if (bytesRead < length) {
                      throw new Error(type_1.endOfFile);
                    }
                    return bytesRead;
                  });
                }
                /**
                 * Peek (read ahead) buffer from tokenizer
                 * @param buffer
                 * @param offset is the offset in the buffer to start writing at; if not provided, start at 0
                 * @param length is an integer specifying the number of bytes to read
                 * @param position is an integer specifying where to begin reading from in the file. If position is null, data will be read from the current file position.
                 * @param maybeless If set, will not throw an EOF error if the less then the requested length could be read
                 * @returns {Promise<number>}
                 */
                peekBuffer(buffer, offset = 0, length = buffer.length, position, maybeless) {
                  return __awaiter(this, void 0, void 0, function* () {
                    let bytesRead;
                    if (position) {
                      const skipBytes = position - this.position;
                      if (skipBytes > 0) {
                        const skipBuffer = Buffer2.alloc(length + skipBytes);
                        bytesRead = yield this.peekBuffer(skipBuffer, 0, skipBytes + length, void 0, maybeless);
                        skipBuffer.copy(buffer, offset, skipBytes);
                        return bytesRead - skipBytes;
                      } else if (skipBytes < 0) {
                        throw new Error("Cannot peek from a negative offset in a stream");
                      }
                    }
                    try {
                      bytesRead = yield this.streamReader.peek(buffer, offset, length);
                    } catch (err) {
                      if (err.message === then_read_stream_1.endOfStream)
                        throw new Error(type_1.endOfFile);
                      else
                        throw err;
                    }
                    if (!maybeless && bytesRead < length) {
                      throw new Error(type_1.endOfFile);
                    }
                    return bytesRead;
                  });
                }
                ignore(length) {
                  return __awaiter(this, void 0, void 0, function* () {
                    debug(`ignore ${this.position}...${this.position + length - 1}`);
                    const buf = Buffer2.alloc(length);
                    return this.readBuffer(buf);
                  });
                }
              }
              exports2.ReadStreamTokenizer = ReadStreamTokenizer;
            }).call(this, __webpack_require__2(9).Buffer);
          },
          /* 124 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            (function(Buffer2) {
              var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function(resolve2, reject2) {
                  function fulfilled(value) {
                    try {
                      step(generator.next(value));
                    } catch (e) {
                      reject2(e);
                    }
                  }
                  function rejected(value) {
                    try {
                      step(generator["throw"](value));
                    } catch (e) {
                      reject2(e);
                    }
                  }
                  function step(result) {
                    result.done ? resolve2(result.value) : new P(function(resolve3) {
                      resolve3(result.value);
                    }).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
              };
              Object.defineProperty(exports2, "__esModule", { value: true });
              const type_1 = __webpack_require__2(22);
              class AbstractTokenizer {
                constructor() {
                  this.position = 0;
                  this.numBuffer = Buffer2.alloc(4);
                }
                readToken(token, position = null, maybeless) {
                  return __awaiter(this, void 0, void 0, function* () {
                    const buffer = Buffer2.alloc(token.len);
                    const len = yield this.readBuffer(buffer, 0, token.len, position);
                    if (!maybeless && len < token.len)
                      throw new Error(type_1.endOfFile);
                    return token.get(buffer, 0);
                  });
                }
                peekToken(token, position = this.position, maybeless) {
                  return __awaiter(this, void 0, void 0, function* () {
                    const buffer = Buffer2.alloc(token.len);
                    const len = yield this.peekBuffer(buffer, 0, token.len, position);
                    if (!maybeless && len < token.len)
                      throw new Error(type_1.endOfFile);
                    return token.get(buffer, 0);
                  });
                }
                readNumber(token) {
                  return __awaiter(this, void 0, void 0, function* () {
                    const len = yield this.readBuffer(this.numBuffer, 0, token.len, null);
                    if (len < token.len)
                      throw new Error(type_1.endOfFile);
                    return token.get(this.numBuffer, 0);
                  });
                }
                peekNumber(token) {
                  return __awaiter(this, void 0, void 0, function* () {
                    const len = yield this.peekBuffer(this.numBuffer, 0, token.len);
                    if (len < token.len)
                      throw new Error(type_1.endOfFile);
                    return token.get(this.numBuffer, 0);
                  });
                }
                close() {
                  return __awaiter(this, void 0, void 0, function* () {
                  });
                }
              }
              exports2.AbstractTokenizer = AbstractTokenizer;
            }).call(this, __webpack_require__2(9).Buffer);
          },
          /* 125 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))(function(resolve2, reject2) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function rejected(value) {
                  try {
                    step(generator["throw"](value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function step(result) {
                  result.done ? resolve2(result.value) : new P(function(resolve3) {
                    resolve3(result.value);
                  }).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
              });
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            const assert = __webpack_require__2(18);
            class Deferred {
              constructor() {
                this.promise = new Promise((resolve2, reject2) => {
                  this.reject = reject2;
                  this.resolve = resolve2;
                });
              }
            }
            exports2.endOfStream = "End-Of-Stream";
            class StreamReader {
              constructor(s) {
                this.s = s;
                this.endOfStream = false;
                this.peekQueue = [];
                if (!s.read || !s.once) {
                  throw new Error("Expected an instance of stream.Readable");
                }
                this.s.once("end", () => this.reject(new Error(exports2.endOfStream)));
                this.s.once("error", (err) => this.reject(err));
                this.s.once("close", () => this.reject(new Error("Stream closed")));
              }
              /**
               * Read ahead (peek) from stream. Subsequent read or peeks will return the same data
               * @param buffer Buffer to store data read from stream in
               * @param offset Offset buffer
               * @param length Number of bytes to read
               * @param position Source offset
               * @returns {any}
               */
              peek(buffer, offset, length) {
                return __awaiter(this, void 0, void 0, function* () {
                  const bytesRead = yield this.read(buffer, offset, length);
                  this.peekQueue.push(buffer.slice(offset, offset + bytesRead));
                  return bytesRead;
                });
              }
              /**
               * Read chunk from stream
               * @param buffer Target buffer to store data read from stream in
               * @param offset Offset of target buffer
               * @param length Number of bytes to read
               * @returns {any}
               */
              read(buffer, offset, length) {
                return __awaiter(this, void 0, void 0, function* () {
                  if (length === 0) {
                    return 0;
                  }
                  if (this.peekQueue.length === 0 && this.endOfStream) {
                    throw new Error(exports2.endOfStream);
                  }
                  let remaining = length;
                  let bytesRead = 0;
                  while (this.peekQueue.length > 0 && remaining > 0) {
                    const peekData = this.peekQueue.pop();
                    const lenCopy = Math.min(peekData.length, remaining);
                    peekData.copy(buffer, offset + bytesRead, 0, lenCopy);
                    bytesRead += lenCopy;
                    remaining -= lenCopy;
                    if (lenCopy < peekData.length) {
                      this.peekQueue.push(peekData.slice(lenCopy));
                    }
                  }
                  if (remaining > 0 && !this.endOfStream) {
                    bytesRead += yield this._read(buffer, offset + bytesRead, remaining);
                  }
                  return bytesRead;
                });
              }
              /**
               * Read chunk from stream
               * @param buffer Buffer to store data read from stream in
               * @param offset Offset buffer
               * @param length Number of bytes to read
               * @returns {any}
               */
              _read(buffer, offset, length) {
                return __awaiter(this, void 0, void 0, function* () {
                  assert.ok(!this.request, "Concurrent read operation?");
                  const readBuffer = this.s.read(length);
                  if (readBuffer) {
                    readBuffer.copy(buffer, offset);
                    return readBuffer.length;
                  } else {
                    this.request = {
                      buffer,
                      offset,
                      length,
                      deferred: new Deferred()
                    };
                    this.s.once("readable", () => {
                      this.tryRead();
                    });
                    return this.request.deferred.promise.then((n) => {
                      this.request = null;
                      return n;
                    }).catch((err) => {
                      this.request = null;
                      throw err;
                    });
                  }
                });
              }
              tryRead() {
                const readBuffer = this.s.read(this.request.length);
                if (readBuffer) {
                  readBuffer.copy(this.request.buffer, this.request.offset);
                  this.request.deferred.resolve(readBuffer.length);
                } else {
                  this.s.once("readable", () => {
                    this.tryRead();
                  });
                }
              }
              reject(err) {
                this.endOfStream = true;
                if (this.request) {
                  this.request.deferred.reject(err);
                  this.request = null;
                }
              }
            }
            exports2.StreamReader = StreamReader;
          },
          /* 126 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            (function(process) {
              var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
                var keys = Object.keys(obj);
                var descriptors = {};
                for (var i = 0; i < keys.length; i++) {
                  descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
                }
                return descriptors;
              };
              var formatRegExp = /%[sdj%]/g;
              exports2.format = function(f) {
                if (!isString(f)) {
                  var objects = [];
                  for (var i = 0; i < arguments.length; i++) {
                    objects.push(inspect(arguments[i]));
                  }
                  return objects.join(" ");
                }
                var i = 1;
                var args = arguments;
                var len = args.length;
                var str = String(f).replace(formatRegExp, function(x2) {
                  if (x2 === "%%") return "%";
                  if (i >= len) return x2;
                  switch (x2) {
                    case "%s":
                      return String(args[i++]);
                    case "%d":
                      return Number(args[i++]);
                    case "%j":
                      try {
                        return JSON.stringify(args[i++]);
                      } catch (_) {
                        return "[Circular]";
                      }
                    default:
                      return x2;
                  }
                });
                for (var x = args[i]; i < len; x = args[++i]) {
                  if (isNull(x) || !isObject(x)) {
                    str += " " + x;
                  } else {
                    str += " " + inspect(x);
                  }
                }
                return str;
              };
              exports2.deprecate = function(fn, msg) {
                if (typeof process !== "undefined" && process.noDeprecation === true) {
                  return fn;
                }
                if (typeof process === "undefined") {
                  return function() {
                    return exports2.deprecate(fn, msg).apply(this, arguments);
                  };
                }
                var warned = false;
                function deprecated() {
                  if (!warned) {
                    if (process.throwDeprecation) {
                      throw new Error(msg);
                    } else if (process.traceDeprecation) {
                      console.trace(msg);
                    } else {
                      console.error(msg);
                    }
                    warned = true;
                  }
                  return fn.apply(this, arguments);
                }
                return deprecated;
              };
              var debugs = {};
              var debugEnviron;
              exports2.debuglog = function(set) {
                if (isUndefined(debugEnviron))
                  debugEnviron = process.env.NODE_DEBUG || "";
                set = set.toUpperCase();
                if (!debugs[set]) {
                  if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
                    var pid = process.pid;
                    debugs[set] = function() {
                      var msg = exports2.format.apply(exports2, arguments);
                      console.error("%s %d: %s", set, pid, msg);
                    };
                  } else {
                    debugs[set] = function() {
                    };
                  }
                }
                return debugs[set];
              };
              function inspect(obj, opts) {
                var ctx = {
                  seen: [],
                  stylize: stylizeNoColor
                };
                if (arguments.length >= 3) ctx.depth = arguments[2];
                if (arguments.length >= 4) ctx.colors = arguments[3];
                if (isBoolean(opts)) {
                  ctx.showHidden = opts;
                } else if (opts) {
                  exports2._extend(ctx, opts);
                }
                if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
                if (isUndefined(ctx.depth)) ctx.depth = 2;
                if (isUndefined(ctx.colors)) ctx.colors = false;
                if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
                if (ctx.colors) ctx.stylize = stylizeWithColor;
                return formatValue(ctx, obj, ctx.depth);
              }
              exports2.inspect = inspect;
              inspect.colors = {
                "bold": [1, 22],
                "italic": [3, 23],
                "underline": [4, 24],
                "inverse": [7, 27],
                "white": [37, 39],
                "grey": [90, 39],
                "black": [30, 39],
                "blue": [34, 39],
                "cyan": [36, 39],
                "green": [32, 39],
                "magenta": [35, 39],
                "red": [31, 39],
                "yellow": [33, 39]
              };
              inspect.styles = {
                "special": "cyan",
                "number": "yellow",
                "boolean": "yellow",
                "undefined": "grey",
                "null": "bold",
                "string": "green",
                "date": "magenta",
                // "name": intentionally not styling
                "regexp": "red"
              };
              function stylizeWithColor(str, styleType) {
                var style = inspect.styles[styleType];
                if (style) {
                  return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
                } else {
                  return str;
                }
              }
              function stylizeNoColor(str, styleType) {
                return str;
              }
              function arrayToHash(array) {
                var hash = {};
                array.forEach(function(val, idx) {
                  hash[val] = true;
                });
                return hash;
              }
              function formatValue(ctx, value, recurseTimes) {
                if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
                value.inspect !== exports2.inspect && // Also filter out any prototype objects using the circular check.
                !(value.constructor && value.constructor.prototype === value)) {
                  var ret = value.inspect(recurseTimes, ctx);
                  if (!isString(ret)) {
                    ret = formatValue(ctx, ret, recurseTimes);
                  }
                  return ret;
                }
                var primitive = formatPrimitive(ctx, value);
                if (primitive) {
                  return primitive;
                }
                var keys = Object.keys(value);
                var visibleKeys = arrayToHash(keys);
                if (ctx.showHidden) {
                  keys = Object.getOwnPropertyNames(value);
                }
                if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
                  return formatError(value);
                }
                if (keys.length === 0) {
                  if (isFunction(value)) {
                    var name = value.name ? ": " + value.name : "";
                    return ctx.stylize("[Function" + name + "]", "special");
                  }
                  if (isRegExp(value)) {
                    return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                  }
                  if (isDate(value)) {
                    return ctx.stylize(Date.prototype.toString.call(value), "date");
                  }
                  if (isError(value)) {
                    return formatError(value);
                  }
                }
                var base = "", array = false, braces = ["{", "}"];
                if (isArray(value)) {
                  array = true;
                  braces = ["[", "]"];
                }
                if (isFunction(value)) {
                  var n = value.name ? ": " + value.name : "";
                  base = " [Function" + n + "]";
                }
                if (isRegExp(value)) {
                  base = " " + RegExp.prototype.toString.call(value);
                }
                if (isDate(value)) {
                  base = " " + Date.prototype.toUTCString.call(value);
                }
                if (isError(value)) {
                  base = " " + formatError(value);
                }
                if (keys.length === 0 && (!array || value.length == 0)) {
                  return braces[0] + base + braces[1];
                }
                if (recurseTimes < 0) {
                  if (isRegExp(value)) {
                    return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                  } else {
                    return ctx.stylize("[Object]", "special");
                  }
                }
                ctx.seen.push(value);
                var output;
                if (array) {
                  output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
                } else {
                  output = keys.map(function(key) {
                    return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                  });
                }
                ctx.seen.pop();
                return reduceToSingleString(output, base, braces);
              }
              function formatPrimitive(ctx, value) {
                if (isUndefined(value))
                  return ctx.stylize("undefined", "undefined");
                if (isString(value)) {
                  var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                  return ctx.stylize(simple, "string");
                }
                if (isNumber(value))
                  return ctx.stylize("" + value, "number");
                if (isBoolean(value))
                  return ctx.stylize("" + value, "boolean");
                if (isNull(value))
                  return ctx.stylize("null", "null");
              }
              function formatError(value) {
                return "[" + Error.prototype.toString.call(value) + "]";
              }
              function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                var output = [];
                for (var i = 0, l = value.length; i < l; ++i) {
                  if (hasOwnProperty(value, String(i))) {
                    output.push(formatProperty(
                      ctx,
                      value,
                      recurseTimes,
                      visibleKeys,
                      String(i),
                      true
                    ));
                  } else {
                    output.push("");
                  }
                }
                keys.forEach(function(key) {
                  if (!key.match(/^\d+$/)) {
                    output.push(formatProperty(
                      ctx,
                      value,
                      recurseTimes,
                      visibleKeys,
                      key,
                      true
                    ));
                  }
                });
                return output;
              }
              function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                var name, str, desc;
                desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
                if (desc.get) {
                  if (desc.set) {
                    str = ctx.stylize("[Getter/Setter]", "special");
                  } else {
                    str = ctx.stylize("[Getter]", "special");
                  }
                } else {
                  if (desc.set) {
                    str = ctx.stylize("[Setter]", "special");
                  }
                }
                if (!hasOwnProperty(visibleKeys, key)) {
                  name = "[" + key + "]";
                }
                if (!str) {
                  if (ctx.seen.indexOf(desc.value) < 0) {
                    if (isNull(recurseTimes)) {
                      str = formatValue(ctx, desc.value, null);
                    } else {
                      str = formatValue(ctx, desc.value, recurseTimes - 1);
                    }
                    if (str.indexOf("\n") > -1) {
                      if (array) {
                        str = str.split("\n").map(function(line) {
                          return "  " + line;
                        }).join("\n").substr(2);
                      } else {
                        str = "\n" + str.split("\n").map(function(line) {
                          return "   " + line;
                        }).join("\n");
                      }
                    }
                  } else {
                    str = ctx.stylize("[Circular]", "special");
                  }
                }
                if (isUndefined(name)) {
                  if (array && key.match(/^\d+$/)) {
                    return str;
                  }
                  name = JSON.stringify("" + key);
                  if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                    name = name.substr(1, name.length - 2);
                    name = ctx.stylize(name, "name");
                  } else {
                    name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                    name = ctx.stylize(name, "string");
                  }
                }
                return name + ": " + str;
              }
              function reduceToSingleString(output, base, braces) {
                var numLinesEst = 0;
                var length = output.reduce(function(prev, cur) {
                  numLinesEst++;
                  if (cur.indexOf("\n") >= 0) numLinesEst++;
                  return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
                }, 0);
                if (length > 60) {
                  return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
                }
                return braces[0] + base + " " + output.join(", ") + " " + braces[1];
              }
              function isArray(ar) {
                return Array.isArray(ar);
              }
              exports2.isArray = isArray;
              function isBoolean(arg) {
                return typeof arg === "boolean";
              }
              exports2.isBoolean = isBoolean;
              function isNull(arg) {
                return arg === null;
              }
              exports2.isNull = isNull;
              function isNullOrUndefined(arg) {
                return arg == null;
              }
              exports2.isNullOrUndefined = isNullOrUndefined;
              function isNumber(arg) {
                return typeof arg === "number";
              }
              exports2.isNumber = isNumber;
              function isString(arg) {
                return typeof arg === "string";
              }
              exports2.isString = isString;
              function isSymbol(arg) {
                return typeof arg === "symbol";
              }
              exports2.isSymbol = isSymbol;
              function isUndefined(arg) {
                return arg === void 0;
              }
              exports2.isUndefined = isUndefined;
              function isRegExp(re) {
                return isObject(re) && objectToString(re) === "[object RegExp]";
              }
              exports2.isRegExp = isRegExp;
              function isObject(arg) {
                return typeof arg === "object" && arg !== null;
              }
              exports2.isObject = isObject;
              function isDate(d) {
                return isObject(d) && objectToString(d) === "[object Date]";
              }
              exports2.isDate = isDate;
              function isError(e) {
                return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
              }
              exports2.isError = isError;
              function isFunction(arg) {
                return typeof arg === "function";
              }
              exports2.isFunction = isFunction;
              function isPrimitive(arg) {
                return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
                typeof arg === "undefined";
              }
              exports2.isPrimitive = isPrimitive;
              exports2.isBuffer = __webpack_require__2(127);
              function objectToString(o) {
                return Object.prototype.toString.call(o);
              }
              function pad(n) {
                return n < 10 ? "0" + n.toString(10) : n.toString(10);
              }
              var months = [
                "Jan",
                "Feb",
                "Mar",
                "Apr",
                "May",
                "Jun",
                "Jul",
                "Aug",
                "Sep",
                "Oct",
                "Nov",
                "Dec"
              ];
              function timestamp() {
                var d = /* @__PURE__ */ new Date();
                var time = [
                  pad(d.getHours()),
                  pad(d.getMinutes()),
                  pad(d.getSeconds())
                ].join(":");
                return [d.getDate(), months[d.getMonth()], time].join(" ");
              }
              exports2.log = function() {
                console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
              };
              exports2.inherits = __webpack_require__2(128);
              exports2._extend = function(origin, add) {
                if (!add || !isObject(add)) return origin;
                var keys = Object.keys(add);
                var i = keys.length;
                while (i--) {
                  origin[keys[i]] = add[keys[i]];
                }
                return origin;
              };
              function hasOwnProperty(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop);
              }
              var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
              exports2.promisify = function promisify(original) {
                if (typeof original !== "function")
                  throw new TypeError('The "original" argument must be of type Function');
                if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
                  var fn = original[kCustomPromisifiedSymbol];
                  if (typeof fn !== "function") {
                    throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                  }
                  Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                    value: fn,
                    enumerable: false,
                    writable: false,
                    configurable: true
                  });
                  return fn;
                }
                function fn() {
                  var promiseResolve, promiseReject;
                  var promise = new Promise(function(resolve2, reject2) {
                    promiseResolve = resolve2;
                    promiseReject = reject2;
                  });
                  var args = [];
                  for (var i = 0; i < arguments.length; i++) {
                    args.push(arguments[i]);
                  }
                  args.push(function(err, value) {
                    if (err) {
                      promiseReject(err);
                    } else {
                      promiseResolve(value);
                    }
                  });
                  try {
                    original.apply(this, args);
                  } catch (err) {
                    promiseReject(err);
                  }
                  return promise;
                }
                Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
                if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                  value: fn,
                  enumerable: false,
                  writable: false,
                  configurable: true
                });
                return Object.defineProperties(
                  fn,
                  getOwnPropertyDescriptors(original)
                );
              };
              exports2.promisify.custom = kCustomPromisifiedSymbol;
              function callbackifyOnRejected(reason, cb) {
                if (!reason) {
                  var newReason = new Error("Promise was rejected with a falsy value");
                  newReason.reason = reason;
                  reason = newReason;
                }
                return cb(reason);
              }
              function callbackify(original) {
                if (typeof original !== "function") {
                  throw new TypeError('The "original" argument must be of type Function');
                }
                function callbackified() {
                  var args = [];
                  for (var i = 0; i < arguments.length; i++) {
                    args.push(arguments[i]);
                  }
                  var maybeCb = args.pop();
                  if (typeof maybeCb !== "function") {
                    throw new TypeError("The last argument must be of type Function");
                  }
                  var self2 = this;
                  var cb = function() {
                    return maybeCb.apply(self2, arguments);
                  };
                  original.apply(this, args).then(
                    function(ret) {
                      process.nextTick(cb, null, ret);
                    },
                    function(rej) {
                      process.nextTick(callbackifyOnRejected, rej, cb);
                    }
                  );
                }
                Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
                Object.defineProperties(
                  callbackified,
                  getOwnPropertyDescriptors(original)
                );
                return callbackified;
              }
              exports2.callbackify = callbackify;
            }).call(this, __webpack_require__2(30));
          },
          /* 127 */
          /***/
          function(module2, exports2) {
            module2.exports = function isBuffer(arg) {
              return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
            };
          },
          /* 128 */
          /***/
          function(module2, exports2) {
            if (typeof Object.create === "function") {
              module2.exports = function inherits(ctor, superCtor) {
                ctor.super_ = superCtor;
                ctor.prototype = Object.create(superCtor.prototype, {
                  constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
              };
            } else {
              module2.exports = function inherits(ctor, superCtor) {
                ctor.super_ = superCtor;
                var TempCtor = function() {
                };
                TempCtor.prototype = superCtor.prototype;
                ctor.prototype = new TempCtor();
                ctor.prototype.constructor = ctor;
              };
            }
          },
          /* 129 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))(function(resolve2, reject2) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function rejected(value) {
                  try {
                    step(generator["throw"](value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function step(result) {
                  result.done ? resolve2(result.value) : new P(function(resolve3) {
                    resolve3(result.value);
                  }).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
              });
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            const type_1 = __webpack_require__2(22);
            class BufferTokenizer {
              constructor(buffer) {
                this.buffer = buffer;
                this.position = 0;
                this.fileSize = buffer.length;
              }
              /**
               * Read buffer from tokenizer
               * @param buffer
               * @param offset is the offset in the buffer to start writing at; if not provided, start at 0
               * @param length is an integer specifying the number of bytes to read
               * @param position is an integer specifying where to begin reading from in the file. If position is null, data will be read from the current file position.
               * @returns {Promise<TResult|number>}
               */
              readBuffer(buffer, offset, length, position) {
                return __awaiter(this, void 0, void 0, function* () {
                  this.position = position || this.position;
                  return this.peekBuffer(buffer, offset, length, this.position).then((bytesRead) => {
                    this.position += bytesRead;
                    return bytesRead;
                  });
                });
              }
              /**
               * Peek (read ahead) buffer from tokenizer
               * @param buffer
               * @param offset is the offset in the buffer to start writing at; if not provided, start at 0
               * @param length is an integer specifying the number of bytes to read
               * @param position is an integer specifying where to begin reading from in the file. If position is null, data will be read from the current file position.
               * @param maybeLess If true, will return the bytes available if available bytes is less then length.
               * @returns {Promise<TResult|number>}
               */
              peekBuffer(buffer, offset, length, position, maybeLess = false) {
                return __awaiter(this, void 0, void 0, function* () {
                  position = position || this.position;
                  if (!length) {
                    length = buffer.length;
                  }
                  const bytes2read = Math.min(this.buffer.length - position, length);
                  if (!maybeLess && bytes2read < length) {
                    throw new Error(type_1.endOfFile);
                  } else {
                    this.buffer.copy(buffer, offset, position, position + bytes2read);
                    return bytes2read;
                  }
                });
              }
              readToken(token, position) {
                return __awaiter(this, void 0, void 0, function* () {
                  this.position = position || this.position;
                  try {
                    const tv = this.peekToken(token, this.position);
                    this.position += token.len;
                    return tv;
                  } catch (err) {
                    this.position += this.buffer.length - position;
                    throw err;
                  }
                });
              }
              peekToken(token, position = this.position) {
                return __awaiter(this, void 0, void 0, function* () {
                  if (this.buffer.length - position < token.len) {
                    throw new Error(type_1.endOfFile);
                  }
                  return token.get(this.buffer, position);
                });
              }
              readNumber(token) {
                return __awaiter(this, void 0, void 0, function* () {
                  return this.readToken(token);
                });
              }
              peekNumber(token) {
                return __awaiter(this, void 0, void 0, function* () {
                  return this.peekToken(token);
                });
              }
              /**
               * @return actual number of bytes ignored
               */
              ignore(length) {
                return __awaiter(this, void 0, void 0, function* () {
                  const bytesIgnored = Math.min(this.buffer.length - this.position, length);
                  this.position += bytesIgnored;
                  return bytesIgnored;
                });
              }
              close() {
                return __awaiter(this, void 0, void 0, function* () {
                });
              }
            }
            exports2.BufferTokenizer = BufferTokenizer;
          },
          /* 130 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            (function(Buffer2) {
              var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function(resolve2, reject2) {
                  function fulfilled(value) {
                    try {
                      step(generator.next(value));
                    } catch (e) {
                      reject2(e);
                    }
                  }
                  function rejected(value) {
                    try {
                      step(generator["throw"](value));
                    } catch (e) {
                      reject2(e);
                    }
                  }
                  function step(result) {
                    result.done ? resolve2(result.value) : new P(function(resolve3) {
                      resolve3(result.value);
                    }).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
              };
              Object.defineProperty(exports2, "__esModule", { value: true });
              const fileType2 = __webpack_require__2(105);
              const MimeType = __webpack_require__2(132);
              const _debug = __webpack_require__2(8);
              const MetadataCollector_1 = __webpack_require__2(133);
              const AiffParser_1 = __webpack_require__2(145);
              const APEv2Parser_1 = __webpack_require__2(45);
              const AsfParser_1 = __webpack_require__2(160);
              const FlacParser_1 = __webpack_require__2(163);
              const MP4Parser_1 = __webpack_require__2(164);
              const MpegParser_1 = __webpack_require__2(166);
              const musepack_1 = __webpack_require__2(168);
              const OggParser_1 = __webpack_require__2(174);
              const WaveParser_1 = __webpack_require__2(179);
              const WavPackParser_1 = __webpack_require__2(182);
              const DsfParser_1 = __webpack_require__2(184);
              const DsdiffParser_1 = __webpack_require__2(186);
              const debug = _debug("music-metadata:parser:factory");
              class ParserFactory {
                constructor() {
                  this.warning = [];
                }
                /**
                 *  Parse metadata from tokenizer
                 * @param {ITokenizer} tokenizer
                 * @param {string} contentType
                 * @param {IOptions} opts
                 * @returns {Promise<INativeAudioMetadata>}
                 */
                static parse(tokenizer, contentType, opts) {
                  return __awaiter(this, void 0, void 0, function* () {
                    let parserId = ParserFactory.getParserIdForMimeType(contentType) || ParserFactory.getParserIdForExtension(contentType);
                    if (!parserId) {
                      debug("No parser found for MIME-type / extension: " + contentType);
                      const buf = Buffer2.alloc(4100);
                      yield tokenizer.peekBuffer(buf, 0, buf.byteLength, tokenizer.position, true);
                      const guessedType = fileType2(buf);
                      if (!guessedType)
                        throw new Error("Failed to guess MIME-type");
                      debug(`Guessed file type is mime=${guessedType.mime}, extension=${guessedType.ext}`);
                      parserId = ParserFactory.getParserIdForMimeType(guessedType.mime);
                      if (!parserId)
                        throw new Error("Guessed MIME-type not supported: " + guessedType.mime);
                      return this._parse(tokenizer, parserId, opts);
                    }
                    return this._parse(tokenizer, parserId, opts);
                  });
                }
                /**
                 * @param filePath Path, filename or extension to audio file
                 * @return Parser sub-module name
                 */
                static getParserIdForExtension(filePath) {
                  if (!filePath)
                    return;
                  const extension = this.getExtension(filePath).toLocaleLowerCase() || filePath;
                  switch (extension) {
                    case ".mp2":
                    case ".mp3":
                    case ".m2a":
                    case ".aac":
                      return "mpeg";
                    case ".ape":
                      return "apev2";
                    case ".mp4":
                    case ".m4a":
                    case ".m4b":
                    case ".m4pa":
                    case ".m4v":
                    case ".m4r":
                    case ".3gp":
                      return "mp4";
                    case ".wma":
                    case ".wmv":
                    case ".asf":
                      return "asf";
                    case ".flac":
                      return "flac";
                    case ".ogg":
                    case ".ogv":
                    case ".oga":
                    case ".ogm":
                    case ".ogx":
                    case ".opus":
                    case ".spx":
                      return "ogg";
                    case ".aif":
                    case ".aiff":
                    case ".aifc":
                      return "aiff";
                    case ".wav":
                      return "riff";
                    case ".wv":
                    case ".wvp":
                      return "wavpack";
                    case ".mpc":
                      return "musepack";
                    case ".dsf":
                      return "dsf";
                    case ".dff":
                      return "dsdiff";
                  }
                }
                static loadParser(moduleName, options) {
                  return __awaiter(this, void 0, void 0, function* () {
                    switch (moduleName) {
                      case "aiff":
                        return new AiffParser_1.AIFFParser();
                      case "apev2":
                        return new APEv2Parser_1.APEv2Parser();
                      case "asf":
                        return new AsfParser_1.AsfParser();
                      case "dsf":
                        return new DsfParser_1.DsfParser();
                      case "dsdiff":
                        return new DsdiffParser_1.DsdiffParser();
                      case "flac":
                        return new FlacParser_1.FlacParser();
                      case "mp4":
                        return new MP4Parser_1.MP4Parser();
                      case "mpeg":
                        return new MpegParser_1.MpegParser();
                      case "musepack":
                        return new musepack_1.default();
                      case "ogg":
                        return new OggParser_1.OggParser();
                      case "riff":
                        return new WaveParser_1.WaveParser();
                      case "wavpack":
                        return new WavPackParser_1.WavPackParser();
                      default:
                        throw new Error(`Unknown parser type: ${moduleName}`);
                    }
                  });
                }
                static _parse(tokenizer, parserId, opts = {}) {
                  return __awaiter(this, void 0, void 0, function* () {
                    const parser = yield ParserFactory.loadParser(parserId, opts);
                    const metadata = new MetadataCollector_1.MetadataCollector(opts);
                    yield parser.init(metadata, tokenizer, opts).parse();
                    return metadata.toCommonMetadata();
                  });
                }
                static getExtension(fname) {
                  const i = fname.lastIndexOf(".");
                  return i === -1 ? "" : fname.slice(i);
                }
                /**
                 * @param {string} mimeType MIME-Type, extension, path or filename
                 * @returns {string} Parser sub-module name
                 */
                static getParserIdForMimeType(mimeType) {
                  let mime;
                  try {
                    mime = MimeType.parse(mimeType);
                  } catch (err) {
                    debug(`Invalid MIME-type: ${mimeType}`);
                    return;
                  }
                  const subType = mime.subtype.indexOf("x-") === 0 ? mime.subtype.substring(2) : mime.subtype;
                  switch (mime.type) {
                    case "audio":
                      switch (subType) {
                        case "mp3":
                        case "mpeg":
                          return "mpeg";
                        case "flac":
                          return "flac";
                        case "ape":
                        case "monkeys-audio":
                          return "apev2";
                        case "mp4":
                        case "aac":
                        case "aacp":
                        case "m4a":
                          return "mp4";
                        case "ogg":
                        case "opus":
                        case "speex":
                          return "ogg";
                        case "ms-wma":
                        case "ms-wmv":
                        case "ms-asf":
                          return "asf";
                        case "aiff":
                        case "aif":
                        case "aifc":
                          return "aiff";
                        case "vnd.wave":
                        case "wav":
                        case "wave":
                          return "riff";
                        case "wavpack":
                          return "wavpack";
                        case "musepack":
                          return "musepack";
                        case "dsf":
                          return "dsf";
                      }
                      break;
                    case "video":
                      switch (subType) {
                        case "ms-asf":
                        case "ms-wmv":
                          return "asf";
                        case "m4v":
                        case "mp4":
                          return "mp4";
                        case "ogg":
                          return "ogg";
                      }
                      break;
                    case "application":
                      switch (subType) {
                        case "vnd.ms-asf":
                          return "asf";
                        case "ogg":
                          return "ogg";
                      }
                      break;
                  }
                }
              }
              exports2.ParserFactory = ParserFactory;
            }).call(this, __webpack_require__2(9).Buffer);
          },
          /* 131 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            exports2.stringToBytes = (string) => [...string].map((character) => character.charCodeAt(0));
            const uint8ArrayUtf8ByteString2 = (array, start, end) => {
              return String.fromCharCode(...array.slice(start, end));
            };
            exports2.readUInt64LE = (buffer, offset = 0) => {
              let n = buffer[offset];
              let mul = 1;
              let i = 0;
              while (++i < 8) {
                mul *= 256;
                n += buffer[offset + i] * mul;
              }
              return n;
            };
            exports2.tarHeaderChecksumMatches = (buffer) => {
              if (buffer.length < 512) {
                return false;
              }
              const MASK_8TH_BIT = 128;
              let sum = 256;
              let signedBitSum = 0;
              for (let i = 0; i < 148; i++) {
                const byte = buffer[i];
                sum += byte;
                signedBitSum += byte & MASK_8TH_BIT;
              }
              for (let i = 156; i < 512; i++) {
                const byte = buffer[i];
                sum += byte;
                signedBitSum += byte & MASK_8TH_BIT;
              }
              const readSum = parseInt(uint8ArrayUtf8ByteString2(buffer, 148, 154), 8);
              return (
                // Checksum in header equals the sum we calculated
                readSum === sum || // Checksum in header equals sum we calculated plus signed-to-unsigned delta
                readSum === sum - (signedBitSum << 1)
              );
            };
            exports2.uint8ArrayUtf8ByteString = uint8ArrayUtf8ByteString2;
          },
          /* 132 */
          /***/
          function(module2, exports2) {
            var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
            var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
            var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;
            var qescRegExp = /\\([\u0000-\u007f])/g;
            var quoteRegExp = /([\\"])/g;
            var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
            var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
            var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
            exports2.format = format;
            exports2.parse = parse;
            function format(obj) {
              if (!obj || typeof obj !== "object") {
                throw new TypeError("argument obj is required");
              }
              var parameters = obj.parameters;
              var subtype = obj.subtype;
              var suffix = obj.suffix;
              var type = obj.type;
              if (!type || !typeNameRegExp.test(type)) {
                throw new TypeError("invalid type");
              }
              if (!subtype || !subtypeNameRegExp.test(subtype)) {
                throw new TypeError("invalid subtype");
              }
              var string = type + "/" + subtype;
              if (suffix) {
                if (!typeNameRegExp.test(suffix)) {
                  throw new TypeError("invalid suffix");
                }
                string += "+" + suffix;
              }
              if (parameters && typeof parameters === "object") {
                var param;
                var params = Object.keys(parameters).sort();
                for (var i = 0; i < params.length; i++) {
                  param = params[i];
                  if (!tokenRegExp.test(param)) {
                    throw new TypeError("invalid parameter name");
                  }
                  string += "; " + param + "=" + qstring(parameters[param]);
                }
              }
              return string;
            }
            function parse(string) {
              if (!string) {
                throw new TypeError("argument string is required");
              }
              if (typeof string === "object") {
                string = getcontenttype(string);
              }
              if (typeof string !== "string") {
                throw new TypeError("argument string is required to be a string");
              }
              var index = string.indexOf(";");
              var type = index !== -1 ? string.substr(0, index) : string;
              var key;
              var match;
              var obj = splitType(type);
              var params = {};
              var value;
              paramRegExp.lastIndex = index;
              while (match = paramRegExp.exec(string)) {
                if (match.index !== index) {
                  throw new TypeError("invalid parameter format");
                }
                index += match[0].length;
                key = match[1].toLowerCase();
                value = match[2];
                if (value[0] === '"') {
                  value = value.substr(1, value.length - 2).replace(qescRegExp, "$1");
                }
                params[key] = value;
              }
              if (index !== -1 && index !== string.length) {
                throw new TypeError("invalid parameter format");
              }
              obj.parameters = params;
              return obj;
            }
            function getcontenttype(obj) {
              if (typeof obj.getHeader === "function") {
                return obj.getHeader("content-type");
              }
              if (typeof obj.headers === "object") {
                return obj.headers && obj.headers["content-type"];
              }
            }
            function qstring(val) {
              var str = String(val);
              if (tokenRegExp.test(str)) {
                return str;
              }
              if (str.length > 0 && !textRegExp.test(str)) {
                throw new TypeError("invalid parameter value");
              }
              return '"' + str.replace(quoteRegExp, "\\$1") + '"';
            }
            function splitType(string) {
              var match = typeRegExp.exec(string.toLowerCase());
              if (!match) {
                throw new TypeError("invalid media type");
              }
              var type = match[1];
              var subtype = match[2];
              var suffix;
              var index = subtype.lastIndexOf("+");
              if (index !== -1) {
                suffix = subtype.substr(index + 1);
                subtype = subtype.substr(0, index);
              }
              var obj = {
                type,
                subtype,
                suffix
              };
              return obj;
            }
          },
          /* 133 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const _debug = __webpack_require__2(8);
            const GenericTagTypes_1 = __webpack_require__2(134);
            const CombinedTagMapper_1 = __webpack_require__2(135);
            const GenericTagMapper_1 = __webpack_require__2(21);
            const debug = _debug("music-metadata:collector");
            const TagPriority = ["APEv2", "vorbis", "ID3v2.4", "ID3v2.3", "ID3v2.2", "exif", "asf", "iTunes", "ID3v1"];
            class MetadataCollector {
              constructor(opts) {
                this.opts = opts;
                this.format = {
                  tagTypes: []
                };
                this.native = {};
                this.common = {
                  track: { no: null, of: null },
                  disk: { no: null, of: null }
                };
                this.commonOrigin = {};
                this.originPriority = {};
                this.tagMapper = new CombinedTagMapper_1.CombinedTagMapper();
                let priority = 1;
                for (const tagType of TagPriority) {
                  this.originPriority[tagType] = priority++;
                }
                this.originPriority.artificial = 500;
                this.originPriority.id3v1 = 600;
              }
              /**
               * @returns {boolean} true if one or more tags have been found
               */
              hasAny() {
                for (const tagType in this.native) {
                  return true;
                }
                return false;
              }
              setFormat(key, value) {
                debug(`format: ${key} = ${value}`);
                this.format[key] = value;
                if (this.opts.observer) {
                  this.opts.observer({ metadata: this, tag: { type: "format", id: key, value } });
                }
              }
              addTag(tagType, tagId, value) {
                debug(`tag ${tagType}.${tagId} = ${value}`);
                if (!this.native[tagType]) {
                  this.format.tagTypes.push(tagType);
                  this.native[tagType] = [];
                }
                this.native[tagType].push({ id: tagId, value });
                this.toCommon(tagType, tagId, value);
              }
              getNativeMetadata() {
                return {
                  format: this.format,
                  native: this.native
                };
              }
              postMap(tagType, tag) {
                switch (tag.id) {
                  case "artist":
                    if (this.commonOrigin.artist === this.originPriority[tagType]) {
                      return this.postMap("artificial", { id: "artists", value: tag.value });
                    }
                    if (!this.common.artists) {
                      this.setGenericTag("artificial", { id: "artists", value: tag.value });
                    }
                    break;
                  case "artists":
                    if (!this.common.artist || this.commonOrigin.artist === this.originPriority.artificial) {
                      if (!this.common.artists || this.common.artists.indexOf(tag.value) === -1) {
                        const artists = (this.common.artists || []).concat([tag.value]);
                        const value = joinArtists(artists);
                        const artistTag = { id: "artist", value };
                        this.setGenericTag("artificial", artistTag);
                      }
                    }
                    break;
                  case "genre":
                    tag.value = GenericTagMapper_1.CommonTagMapper.parseGenre(tag.value);
                    break;
                  case "picture":
                    tag.value.format = GenericTagMapper_1.CommonTagMapper.fixPictureMimeType(tag.value.format);
                    break;
                  case "totaltracks":
                    this.common.track.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);
                    return;
                  case "totaldiscs":
                    this.common.disk.of = GenericTagMapper_1.CommonTagMapper.toIntOrNull(tag.value);
                    return;
                  case "track":
                  case "disk":
                    const of = this.common[tag.id].of;
                    this.common[tag.id] = GenericTagMapper_1.CommonTagMapper.normalizeTrack(tag.value);
                    this.common[tag.id].of = of != null ? of : this.common[tag.id].of;
                    return;
                  case "year":
                  case "originalyear":
                    tag.value = parseInt(tag.value, 10);
                    break;
                  case "date":
                    const year = parseInt(tag.value.substr(0, 4), 10);
                    if (year && !isNaN(year)) {
                      this.common.year = year;
                    }
                    break;
                  case "discogs_label_id":
                  case "discogs_release_id":
                  case "discogs_master_release_id":
                  case "discogs_artist_id":
                  case "discogs_votes":
                    tag.value = typeof tag.value === "string" ? parseInt(tag.value, 10) : tag.value;
                    break;
                  case "replaygain_track_peak":
                    tag.value = typeof tag.value === "string" ? parseFloat(tag.value) : tag.value;
                    break;
                  case "gapless":
                    tag.value = tag.value === "1";
                    break;
                  default:
                }
                this.setGenericTag(tagType, tag);
              }
              /**
               * Convert native tags to common tags
               * @returns {IAudioMetadata} Native + common tags
               */
              toCommonMetadata() {
                return {
                  format: this.format,
                  native: this.opts.native ? this.native : void 0,
                  common: this.common
                };
              }
              /**
               * Convert native tag to common tags
               */
              toCommon(tagType, tagId, value) {
                const tag = { id: tagId, value };
                const genericTag = this.tagMapper.mapTag(tagType, tag);
                if (genericTag) {
                  this.postMap(tagType, genericTag);
                }
              }
              /**
               * Set generic tag
               * @param {GenericTagId} tagId
               * @param {TagType} tagType originating header type, used to prioritize concurrent mappings
               * @param value
               */
              setGenericTag(tagType, tag) {
                debug(`common.${tag.id} = ${tag.value}`);
                const prio0 = this.commonOrigin[tag.id] || 1e3;
                const prio1 = this.originPriority[tagType];
                if (GenericTagTypes_1.isSingleton(tag.id)) {
                  if (prio1 <= prio0) {
                    this.common[tag.id] = tag.value;
                    this.commonOrigin[tag.id] = prio1;
                  } else {
                    return debug(`Ignore native tag (singleton): ${tagType}.${tag.id} = ${tag.value}`);
                  }
                } else {
                  if (prio1 === prio0) {
                    if (!GenericTagTypes_1.isUnique(tag.id) || this.common[tag.id].indexOf(tag.value) === -1) {
                      this.common[tag.id].push(tag.value);
                    } else {
                      debug(`Ignore duplicate value: ${tagType}.${tag.id} = ${tag.value}`);
                    }
                  } else if (prio1 < prio0) {
                    this.common[tag.id] = [tag.value];
                    this.commonOrigin[tag.id] = prio1;
                  } else {
                    return debug(`Ignore native tag (list): ${tagType}.${tag.id} = ${tag.value}`);
                  }
                }
                if (this.opts.observer) {
                  this.opts.observer({ metadata: this, tag: { type: "common", id: tag.id, value: tag.value } });
                }
              }
            }
            exports2.MetadataCollector = MetadataCollector;
            function joinArtists(artists) {
              if (artists.length > 2) {
                return artists.slice(0, artists.length - 1).join(", ") + " & " + artists[artists.length - 1];
              }
              return artists.join(" & ");
            }
            exports2.joinArtists = joinArtists;
          },
          /* 134 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.commonTags = {
              year: { multiple: false },
              track: { multiple: false },
              disk: { multiple: false },
              title: { multiple: false },
              artist: { multiple: false },
              artists: { multiple: true, unique: true },
              albumartist: { multiple: false },
              album: { multiple: false },
              date: { multiple: false },
              originaldate: { multiple: false },
              originalyear: { multiple: false },
              comment: { multiple: true, unique: false },
              genre: { multiple: true, unique: true },
              picture: { multiple: true, unique: true },
              composer: { multiple: true, unique: true },
              lyrics: { multiple: true, unique: false },
              albumsort: { multiple: false, unique: true },
              titlesort: { multiple: false, unique: true },
              work: { multiple: false, unique: true },
              artistsort: { multiple: false, unique: true },
              albumartistsort: { multiple: false, unique: true },
              composersort: { multiple: true, unique: true },
              lyricist: { multiple: true, unique: true },
              writer: { multiple: true, unique: true },
              conductor: { multiple: true, unique: true },
              remixer: { multiple: true, unique: true },
              arranger: { multiple: true, unique: true },
              engineer: { multiple: true, unique: true },
              producer: { multiple: true, unique: true },
              technician: { multiple: true, unique: true },
              djmixer: { multiple: true, unique: true },
              mixer: { multiple: true, unique: true },
              label: { multiple: true, unique: true },
              grouping: { multiple: false },
              subtitle: { multiple: false },
              discsubtitle: { multiple: false },
              totaltracks: { multiple: false },
              totaldiscs: { multiple: false },
              compilation: { multiple: false },
              rating: { multiple: true },
              bpm: { multiple: false },
              mood: { multiple: false },
              media: { multiple: false },
              catalognumber: { multiple: true, unique: true },
              tvShow: { multiple: false },
              tvShowSort: { multiple: false },
              tvSeason: { multiple: false },
              tvEpisode: { multiple: false },
              tvEpisodeId: { multiple: false },
              tvNetwork: { multiple: false },
              podcast: { multiple: false },
              podcasturl: { multiple: false },
              releasestatus: { multiple: false },
              releasetype: { multiple: true },
              releasecountry: { multiple: false },
              script: { multiple: false },
              language: { multiple: false },
              copyright: { multiple: false },
              license: { multiple: false },
              encodedby: { multiple: false },
              encodersettings: { multiple: false },
              gapless: { multiple: false },
              barcode: { multiple: false },
              isrc: { multiple: true },
              asin: { multiple: false },
              musicbrainz_recordingid: { multiple: false },
              musicbrainz_trackid: { multiple: false },
              musicbrainz_albumid: { multiple: false },
              musicbrainz_artistid: { multiple: true },
              musicbrainz_albumartistid: { multiple: true },
              musicbrainz_releasegroupid: { multiple: false },
              musicbrainz_workid: { multiple: false },
              musicbrainz_trmid: { multiple: false },
              musicbrainz_discid: { multiple: false },
              acoustid_id: { multiple: false },
              acoustid_fingerprint: { multiple: false },
              musicip_puid: { multiple: false },
              musicip_fingerprint: { multiple: false },
              website: { multiple: false },
              "performer:instrument": { multiple: true, unique: true },
              averageLevel: { multiple: false },
              peakLevel: { multiple: false },
              notes: { multiple: true, unique: false },
              key: { multiple: false },
              originalalbum: { multiple: false },
              originalartist: { multiple: false },
              discogs_artist_id: { multiple: true, unique: true },
              discogs_release_id: { multiple: false },
              discogs_label_id: { multiple: false },
              discogs_master_release_id: { multiple: false },
              discogs_votes: { multiple: false },
              discogs_rating: { multiple: false },
              replaygain_track_peak: { multiple: false },
              replaygain_track_gain: { multiple: false },
              description: { multiple: true }
            };
            function isSingleton(alias) {
              return exports2.commonTags.hasOwnProperty(alias) && !exports2.commonTags[alias].multiple;
            }
            exports2.isSingleton = isSingleton;
            function isUnique(alias) {
              return !exports2.commonTags[alias].multiple || exports2.commonTags[alias].unique;
            }
            exports2.isUnique = isUnique;
          },
          /* 135 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const ID3v1TagMap_1 = __webpack_require__2(136);
            const ID3v24TagMapper_1 = __webpack_require__2(138);
            const AsfTagMapper_1 = __webpack_require__2(139);
            const ID3v22TagMapper_1 = __webpack_require__2(140);
            const APEv2TagMapper_1 = __webpack_require__2(141);
            const MP4TagMapper_1 = __webpack_require__2(142);
            const VorbisTagMapper_1 = __webpack_require__2(143);
            const RiffInfoTagMap_1 = __webpack_require__2(144);
            class CombinedTagMapper {
              constructor() {
                this.tagMappers = {};
                [
                  new ID3v1TagMap_1.ID3v1TagMapper(),
                  new ID3v22TagMapper_1.ID3v22TagMapper(),
                  new ID3v24TagMapper_1.ID3v24TagMapper(),
                  new MP4TagMapper_1.MP4TagMapper(),
                  new MP4TagMapper_1.MP4TagMapper(),
                  new VorbisTagMapper_1.VorbisTagMapper(),
                  new APEv2TagMapper_1.APEv2TagMapper(),
                  new AsfTagMapper_1.AsfTagMapper(),
                  new RiffInfoTagMap_1.RiffInfoTagMapper()
                ].forEach((mapper) => {
                  this.registerTagMapper(mapper);
                });
              }
              /**
               * Convert native to generic (common) tags
               * @param tagType Originating tag format
               * @param tag     Native tag to map to a generic tag id
               * @return Generic tag result (output of this function)
               */
              mapTag(tagType, tag) {
                const tagMapper = this.tagMappers[tagType];
                if (tagMapper) {
                  return this.tagMappers[tagType].mapGenericTag(tag);
                }
                throw new Error("No generic tag mapper defined for tag-format: " + tagType);
              }
              registerTagMapper(genericTagMapper) {
                for (const tagType of genericTagMapper.tagTypes) {
                  this.tagMappers[tagType] = genericTagMapper;
                }
              }
            }
            exports2.CombinedTagMapper = CombinedTagMapper;
          },
          /* 136 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const GenericTagMapper_1 = __webpack_require__2(21);
            const id3v1TagMap = {
              title: "title",
              artist: "artist",
              album: "album",
              year: "year",
              comment: "comment",
              track: "track",
              genre: "genre"
            };
            class ID3v1TagMapper extends GenericTagMapper_1.CommonTagMapper {
              constructor() {
                super(["ID3v1"], id3v1TagMap);
              }
            }
            exports2.ID3v1TagMapper = ID3v1TagMapper;
          },
          /* 137 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            class Windows1292Decoder {
              static decode(buffer) {
                let str = "";
                for (const i in buffer) {
                  if (buffer.hasOwnProperty(i)) {
                    str += Windows1292Decoder.codePointToString(Windows1292Decoder.singleByteDecoder(buffer[i]));
                  }
                }
                return str;
              }
              static inRange(a, min, max) {
                return min <= a && a <= max;
              }
              static codePointToString(cp) {
                if (cp <= 65535) {
                  return String.fromCharCode(cp);
                } else {
                  cp -= 65536;
                  return String.fromCharCode((cp >> 10) + 55296, (cp & 1023) + 56320);
                }
              }
              static singleByteDecoder(bite) {
                if (Windows1292Decoder.inRange(bite, 0, 127)) {
                  return bite;
                }
                const codePoint = Windows1292Decoder.windows1252[bite - 128];
                if (codePoint === null) {
                  throw Error("invaliding encoding");
                }
                return codePoint;
              }
            }
            Windows1292Decoder.windows1252 = [
              8364,
              129,
              8218,
              402,
              8222,
              8230,
              8224,
              8225,
              710,
              8240,
              352,
              8249,
              338,
              141,
              381,
              143,
              144,
              8216,
              8217,
              8220,
              8221,
              8226,
              8211,
              8212,
              732,
              8482,
              353,
              8250,
              339,
              157,
              382,
              376,
              160,
              161,
              162,
              163,
              164,
              165,
              166,
              167,
              168,
              169,
              170,
              171,
              172,
              173,
              174,
              175,
              176,
              177,
              178,
              179,
              180,
              181,
              182,
              183,
              184,
              185,
              186,
              187,
              188,
              189,
              190,
              191,
              192,
              193,
              194,
              195,
              196,
              197,
              198,
              199,
              200,
              201,
              202,
              203,
              204,
              205,
              206,
              207,
              208,
              209,
              210,
              211,
              212,
              213,
              214,
              215,
              216,
              217,
              218,
              219,
              220,
              221,
              222,
              223,
              224,
              225,
              226,
              227,
              228,
              229,
              230,
              231,
              232,
              233,
              234,
              235,
              236,
              237,
              238,
              239,
              240,
              241,
              242,
              243,
              244,
              245,
              246,
              247,
              248,
              249,
              250,
              251,
              252,
              253,
              254,
              255
            ];
            exports2.Windows1292Decoder = Windows1292Decoder;
          },
          /* 138 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const GenericTagMapper_1 = __webpack_require__2(21);
            const Util_1 = __webpack_require__2(14);
            const id3v24TagMap = {
              // id3v2.3
              TIT2: "title",
              TPE1: "artist",
              "TXXX:Artists": "artists",
              TPE2: "albumartist",
              TALB: "album",
              TDRV: "date",
              /**
               * Original release year
               */
              TORY: "originalyear",
              TPOS: "disk",
              TCON: "genre",
              APIC: "picture",
              TCOM: "composer",
              "USLT:description": "lyrics",
              TSOA: "albumsort",
              TSOT: "titlesort",
              TOAL: "originalalbum",
              TSOP: "artistsort",
              TSO2: "albumartistsort",
              TSOC: "composersort",
              TEXT: "lyricist",
              "TXXX:Writer": "writer",
              TPE3: "conductor",
              // 'IPLS:instrument': 'performer:instrument', // ToDo
              TPE4: "remixer",
              "IPLS:arranger": "arranger",
              "IPLS:engineer": "engineer",
              "IPLS:producer": "producer",
              "IPLS:DJ-mix": "djmixer",
              "IPLS:mix": "mixer",
              TPUB: "label",
              TIT1: "grouping",
              TIT3: "subtitle",
              TRCK: "track",
              TCMP: "compilation",
              POPM: "rating",
              TBPM: "bpm",
              TMED: "media",
              "TXXX:CATALOGNUMBER": "catalognumber",
              "TXXX:MusicBrainz Album Status": "releasestatus",
              "TXXX:MusicBrainz Album Type": "releasetype",
              /**
               * Release country as documented: https://picard.musicbrainz.org/docs/mappings/#cite_note-0
               */
              "TXXX:MusicBrainz Album Release Country": "releasecountry",
              /**
               * Release country as implemented // ToDo: report
               */
              "TXXX:RELEASECOUNTRY": "releasecountry",
              "TXXX:SCRIPT": "script",
              TLAN: "language",
              TCOP: "copyright",
              WCOP: "license",
              TENC: "encodedby",
              TSSE: "encodersettings",
              "TXXX:BARCODE": "barcode",
              TSRC: "isrc",
              "TXXX:ASIN": "asin",
              "TXXX:originalyear": "originalyear",
              "UFID:http://musicbrainz.org": "musicbrainz_recordingid",
              "TXXX:MusicBrainz Release Track Id": "musicbrainz_trackid",
              "TXXX:MusicBrainz Album Id": "musicbrainz_albumid",
              "TXXX:MusicBrainz Artist Id": "musicbrainz_artistid",
              "TXXX:MusicBrainz Album Artist Id": "musicbrainz_albumartistid",
              "TXXX:MusicBrainz Release Group Id": "musicbrainz_releasegroupid",
              "TXXX:MusicBrainz Work Id": "musicbrainz_workid",
              "TXXX:MusicBrainz TRM Id": "musicbrainz_trmid",
              "TXXX:MusicBrainz Disc Id": "musicbrainz_discid",
              "TXXX:ACOUSTID_ID": "acoustid_id",
              "TXXX:Acoustid Id": "acoustid_id",
              "TXXX:Acoustid Fingerprint": "acoustid_fingerprint",
              "TXXX:MusicIP PUID": "musicip_puid",
              "TXXX:MusicMagic Fingerprint": "musicip_fingerprint",
              WOAR: "website",
              // id3v2.4
              // ToDo: In same sequence as defined at http://id3.org/id3v2.4.0-frames
              TDRC: "date",
              TYER: "year",
              TDOR: "originaldate",
              // 'TMCL:instrument': 'performer:instrument',
              "TIPL:arranger": "arranger",
              "TIPL:engineer": "engineer",
              "TIPL:producer": "producer",
              "TIPL:DJ-mix": "djmixer",
              "TIPL:mix": "mixer",
              TMOO: "mood",
              // additional mappings:
              SYLT: "lyrics",
              TSST: "discsubtitle",
              TKEY: "key",
              COMM: "comment",
              TOPE: "originalartist",
              // Windows Media Player
              "PRIV:AverageLevel": "averageLevel",
              "PRIV:PeakLevel": "peakLevel",
              // Discogs
              "TXXX:DISCOGS_ARTIST_ID": "discogs_artist_id",
              "TXXX:DISCOGS_ARTISTS": "artists",
              "TXXX:DISCOGS_ARTIST_NAME": "artists",
              "TXXX:DISCOGS_ALBUM_ARTISTS": "albumartist",
              "TXXX:DISCOGS_CATALOG": "catalognumber",
              "TXXX:DISCOGS_COUNTRY": "releasecountry",
              "TXXX:DISCOGS_DATE": "originaldate",
              "TXXX:DISCOGS_LABEL": "label",
              "TXXX:DISCOGS_LABEL_ID": "discogs_label_id",
              "TXXX:DISCOGS_MASTER_RELEASE_ID": "discogs_master_release_id",
              "TXXX:DISCOGS_RATING": "discogs_rating",
              "TXXX:DISCOGS_RELEASED": "date",
              "TXXX:DISCOGS_RELEASE_ID": "discogs_release_id",
              "TXXX:DISCOGS_VOTES": "discogs_votes",
              "TXXX:CATALOGID": "catalognumber",
              "TXXX:STYLE": "genre",
              "TXXX:replaygain_track_peak": "replaygain_track_peak",
              "TXXX:replaygain_track_gain": "replaygain_track_gain"
            };
            class ID3v24TagMapper extends GenericTagMapper_1.CommonTagMapper {
              static toRating(popm) {
                return {
                  source: popm.email,
                  rating: popm.rating > 0 ? (popm.rating - 1) / 254 * GenericTagMapper_1.CommonTagMapper.maxRatingScore : void 0
                };
              }
              constructor() {
                super(["ID3v2.3", "ID3v2.4"], id3v24TagMap);
              }
              /**
               * Handle post mapping exceptions / correction
               * @param {string} id Tag key e.g. "©alb"
               * @param id e.g. "Buena Vista Social Club"
               * @return Common value e.g. "Buena Vista Social Club"
               */
              postMap(tag) {
                switch (tag.id) {
                  case "UFID":
                    if (tag.value.owner_identifier === "http://musicbrainz.org") {
                      tag.id += ":" + tag.value.owner_identifier;
                      tag.value = Util_1.default.decodeString(tag.value.identifier, "iso-8859-1");
                    }
                    break;
                  case "PRIV":
                    switch (tag.value.owner_identifier) {
                      case "AverageLevel":
                      case "PeakValue":
                        tag.id += ":" + tag.value.owner_identifier;
                        tag.value = tag.value.data.length === 4 ? tag.value.data.readUInt32LE() : null;
                        break;
                      default:
                    }
                    break;
                  case "COMM":
                    tag.value = tag.value ? tag.value.text : null;
                    break;
                  case "POPM":
                    tag.value = ID3v24TagMapper.toRating(tag.value);
                    break;
                  default:
                    break;
                }
              }
            }
            exports2.ID3v24TagMapper = ID3v24TagMapper;
          },
          /* 139 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const GenericTagMapper_1 = __webpack_require__2(21);
            const asfTagMap = {
              Title: "title",
              Author: "artist",
              "WM/AlbumArtist": "albumartist",
              "WM/AlbumTitle": "album",
              "WM/Year": "date",
              "WM/OriginalReleaseTime": "originaldate",
              "WM/OriginalReleaseYear": "originalyear",
              Description: "comment",
              "WM/TrackNumber": "track",
              "WM/PartOfSet": "disk",
              "WM/Genre": "genre",
              "WM/Composer": "composer",
              "WM/Lyrics": "lyrics",
              "WM/AlbumSortOrder": "albumsort",
              "WM/TitleSortOrder": "titlesort",
              "WM/ArtistSortOrder": "artistsort",
              "WM/AlbumArtistSortOrder": "albumartistsort",
              "WM/ComposerSortOrder": "composersort",
              "WM/Writer": "lyricist",
              "WM/Conductor": "conductor",
              "WM/ModifiedBy": "remixer",
              "WM/Engineer": "engineer",
              "WM/Producer": "producer",
              "WM/DJMixer": "djmixer",
              "WM/Mixer": "mixer",
              "WM/Publisher": "label",
              "WM/ContentGroupDescription": "grouping",
              "WM/SubTitle": "subtitle",
              "WM/SetSubTitle": "discsubtitle",
              // 'WM/PartOfSet': 'totaldiscs',
              "WM/IsCompilation": "compilation",
              "WM/SharedUserRating": "rating",
              "WM/BeatsPerMinute": "bpm",
              "WM/Mood": "mood",
              "WM/Media": "media",
              "WM/CatalogNo": "catalognumber",
              "MusicBrainz/Album Status": "releasestatus",
              "MusicBrainz/Album Type": "releasetype",
              "MusicBrainz/Album Release Country": "releasecountry",
              "WM/Script": "script",
              "WM/Language": "language",
              Copyright: "copyright",
              LICENSE: "license",
              "WM/EncodedBy": "encodedby",
              "WM/EncodingSettings": "encodersettings",
              "WM/Barcode": "barcode",
              "WM/ISRC": "isrc",
              "MusicBrainz/Track Id": "musicbrainz_recordingid",
              "MusicBrainz/Release Track Id": "musicbrainz_trackid",
              "MusicBrainz/Album Id": "musicbrainz_albumid",
              "MusicBrainz/Artist Id": "musicbrainz_artistid",
              "MusicBrainz/Album Artist Id": "musicbrainz_albumartistid",
              "MusicBrainz/Release Group Id": "musicbrainz_releasegroupid",
              "MusicBrainz/Work Id": "musicbrainz_workid",
              "MusicBrainz/TRM Id": "musicbrainz_trmid",
              "MusicBrainz/Disc Id": "musicbrainz_discid",
              "Acoustid/Id": "acoustid_id",
              "Acoustid/Fingerprint": "acoustid_fingerprint",
              "MusicIP/PUID": "musicip_puid",
              "WM/ARTISTS": "artists",
              "WM/InitialKey": "key",
              ASIN: "asin",
              "WM/Work": "work",
              "WM/AuthorURL": "website",
              "WM/Picture": "picture"
            };
            class AsfTagMapper extends GenericTagMapper_1.CommonTagMapper {
              static toRating(rating) {
                return {
                  rating: parseFloat(rating + 1) / 5
                };
              }
              constructor() {
                super(["asf"], asfTagMap);
              }
              postMap(tag) {
                switch (tag.id) {
                  case "WM/SharedUserRating":
                    const keys = tag.id.split(":");
                    tag.value = AsfTagMapper.toRating(tag.value);
                    tag.id = keys[0];
                    break;
                }
              }
            }
            exports2.AsfTagMapper = AsfTagMapper;
          },
          /* 140 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const GenericTagMapper_1 = __webpack_require__2(21);
            exports2.id3v22TagMap = {
              TT2: "title",
              TP1: "artist",
              TP2: "albumartist",
              TAL: "album",
              TYE: "year",
              COM: "comment",
              TRK: "track",
              TPA: "disk",
              TCO: "genre",
              PIC: "picture",
              TCM: "composer",
              TOR: "originaldate",
              TOT: "work",
              TXT: "lyricist",
              TP3: "conductor",
              TPB: "label",
              TT1: "grouping",
              TT3: "subtitle",
              TLA: "language",
              TCR: "copyright",
              WCP: "license",
              TEN: "encodedby",
              TSS: "encodersettings",
              WAR: "website",
              "COM:iTunPGAP": "gapless"
              /* ToDo: iTunes tags:
              'COM:iTunNORM': ,
              'COM:iTunSMPB': 'encoder delay',
              'COM:iTunes_CDDB_IDs'
              */
            };
            class ID3v22TagMapper extends GenericTagMapper_1.CommonTagMapper {
              constructor() {
                super(["ID3v2.2"], exports2.id3v22TagMap);
              }
            }
            exports2.ID3v22TagMapper = ID3v22TagMapper;
          },
          /* 141 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const GenericTagMapper_1 = __webpack_require__2(21);
            const apev2TagMap = {
              Title: "title",
              Artist: "artist",
              Artists: "artists",
              "Album Artist": "albumartist",
              Album: "album",
              Year: "date",
              Originalyear: "originalyear",
              Originaldate: "originaldate",
              Comment: "comment",
              Track: "track",
              Disc: "disk",
              DISCNUMBER: "disk",
              Genre: "genre",
              "Cover Art (Front)": "picture",
              "Cover Art (Back)": "picture",
              Composer: "composer",
              Lyrics: "lyrics",
              ALBUMSORT: "albumsort",
              TITLESORT: "titlesort",
              WORK: "work",
              ARTISTSORT: "artistsort",
              ALBUMARTISTSORT: "albumartistsort",
              COMPOSERSORT: "composersort",
              Lyricist: "lyricist",
              Writer: "writer",
              Conductor: "conductor",
              // 'Performer=artist (instrument)': 'performer:instrument',
              MixArtist: "remixer",
              Arranger: "arranger",
              Engineer: "engineer",
              Producer: "producer",
              DJMixer: "djmixer",
              Mixer: "mixer",
              Label: "label",
              Grouping: "grouping",
              Subtitle: "subtitle",
              DiscSubtitle: "discsubtitle",
              Compilation: "compilation",
              BPM: "bpm",
              Mood: "mood",
              Media: "media",
              CatalogNumber: "catalognumber",
              MUSICBRAINZ_ALBUMSTATUS: "releasestatus",
              MUSICBRAINZ_ALBUMTYPE: "releasetype",
              RELEASECOUNTRY: "releasecountry",
              Script: "script",
              Language: "language",
              Copyright: "copyright",
              LICENSE: "license",
              EncodedBy: "encodedby",
              EncoderSettings: "encodersettings",
              Barcode: "barcode",
              ISRC: "isrc",
              ASIN: "asin",
              musicbrainz_trackid: "musicbrainz_recordingid",
              musicbrainz_releasetrackid: "musicbrainz_trackid",
              MUSICBRAINZ_ALBUMID: "musicbrainz_albumid",
              MUSICBRAINZ_ARTISTID: "musicbrainz_artistid",
              MUSICBRAINZ_ALBUMARTISTID: "musicbrainz_albumartistid",
              MUSICBRAINZ_RELEASEGROUPID: "musicbrainz_releasegroupid",
              MUSICBRAINZ_WORKID: "musicbrainz_workid",
              MUSICBRAINZ_TRMID: "musicbrainz_trmid",
              MUSICBRAINZ_DISCID: "musicbrainz_discid",
              Acoustid_Id: "acoustid_id",
              ACOUSTID_FINGERPRINT: "acoustid_fingerprint",
              MUSICIP_PUID: "musicip_puid",
              Weblink: "website"
            };
            class APEv2TagMapper extends GenericTagMapper_1.CommonTagMapper {
              constructor() {
                const upperCaseMap = {};
                for (const tag in apev2TagMap) {
                  upperCaseMap[tag.toUpperCase()] = apev2TagMap[tag];
                }
                super(["APEv2"], upperCaseMap);
              }
              /**
               * @tag  Native header tag
               * @return common tag name (alias)
               */
              getCommonName(tag) {
                return this.tagMap[tag.toUpperCase()];
              }
            }
            exports2.APEv2TagMapper = APEv2TagMapper;
          },
          /* 142 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const GenericTagMapper_1 = __webpack_require__2(21);
            const mp4TagMap = {
              "©nam": "title",
              "©ART": "artist",
              aART: "albumartist",
              /**
               * ToDo: Album artist seems to be stored here while Picard documentation says: aART
               */
              "----:com.apple.iTunes:Band": "albumartist",
              "©alb": "album",
              "©day": "date",
              "©cmt": "comment",
              trkn: "track",
              disk: "disk",
              "©gen": "genre",
              covr: "picture",
              "©wrt": "composer",
              "©lyr": "lyrics",
              soal: "albumsort",
              sonm: "titlesort",
              soar: "artistsort",
              soaa: "albumartistsort",
              soco: "composersort",
              "----:com.apple.iTunes:LYRICIST": "lyricist",
              "----:com.apple.iTunes:CONDUCTOR": "conductor",
              "----:com.apple.iTunes:REMIXER": "remixer",
              "----:com.apple.iTunes:ENGINEER": "engineer",
              "----:com.apple.iTunes:PRODUCER": "producer",
              "----:com.apple.iTunes:DJMIXER": "djmixer",
              "----:com.apple.iTunes:MIXER": "mixer",
              "----:com.apple.iTunes:LABEL": "label",
              "©grp": "grouping",
              "----:com.apple.iTunes:SUBTITLE": "subtitle",
              "----:com.apple.iTunes:DISCSUBTITLE": "discsubtitle",
              cpil: "compilation",
              tmpo: "bpm",
              "----:com.apple.iTunes:MOOD": "mood",
              "----:com.apple.iTunes:MEDIA": "media",
              "----:com.apple.iTunes:CATALOGNUMBER": "catalognumber",
              tvsh: "tvShow",
              tvsn: "tvSeason",
              tves: "tvEpisode",
              sosn: "tvShowSort",
              tven: "tvEpisodeId",
              tvnn: "tvNetwork",
              pcst: "podcast",
              purl: "podcasturl",
              "----:com.apple.iTunes:MusicBrainz Album Status": "releasestatus",
              "----:com.apple.iTunes:MusicBrainz Album Type": "releasetype",
              "----:com.apple.iTunes:MusicBrainz Album Release Country": "releasecountry",
              "----:com.apple.iTunes:SCRIPT": "script",
              "----:com.apple.iTunes:LANGUAGE": "language",
              cprt: "copyright",
              "----:com.apple.iTunes:LICENSE": "license",
              "©too": "encodedby",
              pgap: "gapless",
              "----:com.apple.iTunes:BARCODE": "barcode",
              "----:com.apple.iTunes:ISRC": "isrc",
              "----:com.apple.iTunes:ASIN": "asin",
              "----:com.apple.iTunes:NOTES": "comment",
              "----:com.apple.iTunes:MusicBrainz Track Id": "musicbrainz_recordingid",
              "----:com.apple.iTunes:MusicBrainz Release Track Id": "musicbrainz_trackid",
              "----:com.apple.iTunes:MusicBrainz Album Id": "musicbrainz_albumid",
              "----:com.apple.iTunes:MusicBrainz Artist Id": "musicbrainz_artistid",
              "----:com.apple.iTunes:MusicBrainz Album Artist Id": "musicbrainz_albumartistid",
              "----:com.apple.iTunes:MusicBrainz Release Group Id": "musicbrainz_releasegroupid",
              "----:com.apple.iTunes:MusicBrainz Work Id": "musicbrainz_workid",
              "----:com.apple.iTunes:MusicBrainz TRM Id": "musicbrainz_trmid",
              "----:com.apple.iTunes:MusicBrainz Disc Id": "musicbrainz_discid",
              "----:com.apple.iTunes:Acoustid Id": "acoustid_id",
              "----:com.apple.iTunes:Acoustid Fingerprint": "acoustid_fingerprint",
              "----:com.apple.iTunes:MusicIP PUID": "musicip_puid",
              "----:com.apple.iTunes:fingerprint": "musicip_fingerprint",
              // Additional mappings:
              gnre: "genre",
              "----:com.apple.iTunes:ALBUMARTISTSORT": "albumartistsort",
              "----:com.apple.iTunes:ARTISTS": "artists",
              "----:com.apple.iTunes:ORIGINALDATE": "originaldate",
              "----:com.apple.iTunes:ORIGINALYEAR": "originalyear",
              // '----:com.apple.iTunes:PERFORMER': 'performer'
              desc: "description",
              ldes: "description"
            };
            exports2.tagType = "iTunes";
            class MP4TagMapper extends GenericTagMapper_1.CommonTagMapper {
              constructor() {
                super([exports2.tagType], mp4TagMap);
              }
            }
            exports2.MP4TagMapper = MP4TagMapper;
          },
          /* 143 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const GenericTagMapper_1 = __webpack_require__2(21);
            const vorbisTagMap = {
              TITLE: "title",
              ARTIST: "artist",
              ARTISTS: "artists",
              ALBUMARTIST: "albumartist",
              ALBUM: "album",
              DATE: "date",
              ORIGINALDATE: "originaldate",
              ORIGINALYEAR: "originalyear",
              COMMENT: "comment",
              TRACKNUMBER: "track",
              DISCNUMBER: "disk",
              GENRE: "genre",
              METADATA_BLOCK_PICTURE: "picture",
              COMPOSER: "composer",
              LYRICS: "lyrics",
              ALBUMSORT: "albumsort",
              TITLESORT: "titlesort",
              WORK: "work",
              ARTISTSORT: "artistsort",
              ALBUMARTISTSORT: "albumartistsort",
              COMPOSERSORT: "composersort",
              LYRICIST: "lyricist",
              WRITER: "writer",
              CONDUCTOR: "conductor",
              // 'PERFORMER=artist (instrument)': 'performer:instrument', // ToDo
              REMIXER: "remixer",
              ARRANGER: "arranger",
              ENGINEER: "engineer",
              PRODUCER: "producer",
              DJMIXER: "djmixer",
              MIXER: "mixer",
              LABEL: "label",
              GROUPING: "grouping",
              SUBTITLE: "subtitle",
              DISCSUBTITLE: "discsubtitle",
              TRACKTOTAL: "totaltracks",
              DISCTOTAL: "totaldiscs",
              COMPILATION: "compilation",
              RATING: "rating",
              BPM: "bpm",
              MOOD: "mood",
              MEDIA: "media",
              CATALOGNUMBER: "catalognumber",
              RELEASESTATUS: "releasestatus",
              RELEASETYPE: "releasetype",
              RELEASECOUNTRY: "releasecountry",
              SCRIPT: "script",
              LANGUAGE: "language",
              COPYRIGHT: "copyright",
              LICENSE: "license",
              ENCODEDBY: "encodedby",
              ENCODERSETTINGS: "encodersettings",
              BARCODE: "barcode",
              ISRC: "isrc",
              ASIN: "asin",
              MUSICBRAINZ_TRACKID: "musicbrainz_recordingid",
              MUSICBRAINZ_RELEASETRACKID: "musicbrainz_trackid",
              MUSICBRAINZ_ALBUMID: "musicbrainz_albumid",
              MUSICBRAINZ_ARTISTID: "musicbrainz_artistid",
              MUSICBRAINZ_ALBUMARTISTID: "musicbrainz_albumartistid",
              MUSICBRAINZ_RELEASEGROUPID: "musicbrainz_releasegroupid",
              MUSICBRAINZ_WORKID: "musicbrainz_workid",
              MUSICBRAINZ_TRMID: "musicbrainz_trmid",
              MUSICBRAINZ_DISCID: "musicbrainz_discid",
              ACOUSTID_ID: "acoustid_id",
              ACOUSTID_ID_FINGERPRINT: "acoustid_fingerprint",
              MUSICIP_PUID: "musicip_puid",
              // 'FINGERPRINT=MusicMagic Fingerprint {fingerprint}': 'musicip_fingerprint', // ToDo
              WEBSITE: "website",
              NOTES: "notes",
              TOTALTRACKS: "totaltracks",
              TOTALDISCS: "totaldiscs",
              // Discogs
              DISCOGS_ARTIST_ID: "discogs_artist_id",
              DISCOGS_ARTISTS: "artists",
              DISCOGS_ARTIST_NAME: "artists",
              DISCOGS_ALBUM_ARTISTS: "albumartist",
              DISCOGS_CATALOG: "catalognumber",
              DISCOGS_COUNTRY: "releasecountry",
              DISCOGS_DATE: "originaldate",
              DISCOGS_LABEL: "label",
              DISCOGS_LABEL_ID: "discogs_label_id",
              DISCOGS_MASTER_RELEASE_ID: "discogs_master_release_id",
              DISCOGS_RATING: "discogs_rating",
              DISCOGS_RELEASED: "date",
              DISCOGS_RELEASE_ID: "discogs_release_id",
              DISCOGS_VOTES: "discogs_votes",
              CATALOGID: "catalognumber",
              STYLE: "genre",
              REPLAYGAIN_TRACK_GAIN: "replaygain_track_gain",
              REPLAYGAIN_TRACK_PEAK: "replaygain_track_peak"
            };
            class VorbisTagMapper extends GenericTagMapper_1.CommonTagMapper {
              static toRating(email, rating) {
                return {
                  source: email ? email.toLowerCase() : email,
                  rating: parseFloat(rating) * GenericTagMapper_1.CommonTagMapper.maxRatingScore
                };
              }
              constructor() {
                super(["vorbis"], vorbisTagMap);
              }
              postMap(tag) {
                if (tag.id.indexOf("RATING:") === 0) {
                  const keys = tag.id.split(":");
                  tag.value = VorbisTagMapper.toRating(keys[1], tag.value);
                  tag.id = keys[0];
                }
              }
            }
            exports2.VorbisTagMapper = VorbisTagMapper;
          },
          /* 144 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const GenericTagMapper_1 = __webpack_require__2(21);
            exports2.riffInfoTagMap = {
              IART: "artist",
              ICRD: "date",
              INAM: "title",
              TITL: "title",
              IPRD: "album",
              ITRK: "track",
              COMM: "comment",
              ICMT: "comment",
              ICNT: "releasecountry",
              GNRE: "genre",
              IWRI: "writer",
              RATE: "rating",
              YEAR: "year",
              ISFT: "encodedby",
              CODE: "encodedby",
              TURL: "website",
              IGNR: "genre",
              IENG: "engineer",
              ITCH: "technician",
              IMED: "media",
              IRPD: "album"
              // Product, where the file was intended for
            };
            class RiffInfoTagMapper extends GenericTagMapper_1.CommonTagMapper {
              constructor() {
                super(["exif"], exports2.riffInfoTagMap);
              }
            }
            exports2.RiffInfoTagMapper = RiffInfoTagMapper;
          },
          /* 145 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))(function(resolve2, reject2) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function rejected(value) {
                  try {
                    step(generator["throw"](value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function step(result) {
                  result.done ? resolve2(result.value) : new P(function(resolve3) {
                    resolve3(result.value);
                  }).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
              });
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            const Token = __webpack_require__2(6);
            const initDebug = __webpack_require__2(8);
            const type_1 = __webpack_require__2(22);
            const strtok3 = __webpack_require__2(43);
            const ID3v2Parser_1 = __webpack_require__2(32);
            const FourCC_1 = __webpack_require__2(15);
            const BasicParser_1 = __webpack_require__2(20);
            const AiffToken = __webpack_require__2(147);
            const iff = __webpack_require__2(148);
            const ID3Stream_1 = __webpack_require__2(49);
            const debug = initDebug("music-metadata:parser:aiff");
            class AIFFParser extends BasicParser_1.BasicParser {
              parse() {
                return __awaiter(this, void 0, void 0, function* () {
                  const header = yield this.tokenizer.readToken(iff.Header);
                  if (header.chunkID !== "FORM")
                    throw new Error("Invalid Chunk-ID, expected 'FORM'");
                  const type = yield this.tokenizer.readToken(FourCC_1.FourCcToken);
                  switch (type) {
                    case "AIFF":
                      this.metadata.setFormat("dataformat", type);
                      this.isCompressed = false;
                      break;
                    case "AIFC":
                      this.metadata.setFormat("dataformat", "AIFF-C");
                      this.isCompressed = true;
                      break;
                    default:
                      throw Error("Unsupported AIFF type: " + type);
                  }
                  this.metadata.setFormat("lossless", !this.isCompressed);
                  try {
                    do {
                      const chunkHeader = yield this.tokenizer.readToken(iff.Header);
                      debug(`Chunk id=${chunkHeader.chunkID}`);
                      const nextChunk = 2 * Math.round(chunkHeader.chunkSize / 2);
                      const bytesRead = yield this.readData(chunkHeader);
                      yield this.tokenizer.ignore(nextChunk - bytesRead);
                    } while (true);
                  } catch (err) {
                    if (err.message !== type_1.endOfFile) {
                      throw err;
                    }
                  }
                });
              }
              readData(header) {
                return __awaiter(this, void 0, void 0, function* () {
                  switch (header.chunkID) {
                    case "COMM":
                      const common = yield this.tokenizer.readToken(new AiffToken.Common(header, this.isCompressed));
                      this.metadata.setFormat("bitsPerSample", common.sampleSize);
                      this.metadata.setFormat("sampleRate", common.sampleRate);
                      this.metadata.setFormat("numberOfChannels", common.numChannels);
                      this.metadata.setFormat("numberOfSamples", common.numSampleFrames);
                      this.metadata.setFormat("duration", common.numSampleFrames / common.sampleRate);
                      this.metadata.setFormat("encoder", common.compressionName);
                      return header.chunkSize;
                    case "ID3 ":
                      const id3_data = yield this.tokenizer.readToken(new Token.BufferType(header.chunkSize));
                      const id3stream = new ID3Stream_1.ID3Stream(id3_data);
                      const rst = strtok3.fromStream(id3stream);
                      yield new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);
                      return header.chunkSize;
                    case "SSND":
                      if (this.metadata.format.duration) {
                        this.metadata.setFormat("bitrate", 8 * header.chunkSize / this.metadata.format.duration);
                      }
                      return 0;
                    default:
                      return 0;
                  }
                });
              }
            }
            exports2.AIFFParser = AIFFParser;
          },
          /* 146 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            (function(Buffer2) {
              Object.defineProperty(exports2, "__esModule", { value: true });
              const initDebug = __webpack_require__2(8);
              const Token = __webpack_require__2(6);
              const Util_1 = __webpack_require__2(14);
              const ID3v2_1 = __webpack_require__2(33);
              const debug = initDebug("music-metadata:id3v2:frame-parser");
              class FrameParser {
                static readData(b, type, major, includeCovers) {
                  const encoding = FrameParser.getTextEncoding(b[0]);
                  const length = b.length;
                  let offset = 0;
                  let output = [];
                  const nullTerminatorLength = FrameParser.getNullTerminatorLength(encoding);
                  let fzero;
                  const out = {};
                  switch (type !== "TXXX" && type[0] === "T" ? "T*" : type) {
                    case "T*":
                    case "IPLS":
                      const text = Util_1.default.decodeString(b.slice(1), encoding).replace(/\x00+$/, "");
                      switch (type) {
                        case "TMCL":
                        case "TIPL":
                        case "IPLS":
                          output = FrameParser.splitValue(4, text);
                          output = FrameParser.functionList(output);
                          break;
                        case "TRK":
                        case "TRCK":
                        case "TPOS":
                          output = text;
                          break;
                        case "TCOM":
                        case "TEXT":
                        case "TOLY":
                        case "TOPE":
                        case "TPE1":
                        case "TSRC":
                          output = FrameParser.splitValue(major, text);
                          break;
                        default:
                          output = major >= 4 ? FrameParser.splitValue(major, text) : [text];
                      }
                      break;
                    case "TXXX":
                      output = FrameParser.readIdentifierAndData(b, offset + 1, length, encoding);
                      output = {
                        description: output.id,
                        text: FrameParser.splitValue(major, Util_1.default.decodeString(output.data, encoding).replace(/\x00+$/, ""))
                      };
                      break;
                    case "PIC":
                    case "APIC":
                      if (includeCovers) {
                        const pic = {};
                        offset += 1;
                        switch (major) {
                          case 2:
                            pic.format = Util_1.default.decodeString(b.slice(offset, offset + 3), encoding);
                            offset += 3;
                            break;
                          case 3:
                          case 4:
                            const enc = "iso-8859-1";
                            fzero = Util_1.default.findZero(b, offset, length, enc);
                            pic.format = Util_1.default.decodeString(b.slice(offset, fzero), enc);
                            offset = fzero + 1;
                            break;
                          default:
                            throw new Error("Warning: unexpected major versionIndex: " + major);
                        }
                        pic.format = FrameParser.fixPictureMimeType(pic.format);
                        pic.type = ID3v2_1.AttachedPictureType[b[offset]];
                        offset += 1;
                        fzero = Util_1.default.findZero(b, offset, length, encoding);
                        pic.description = Util_1.default.decodeString(b.slice(offset, fzero), encoding);
                        offset = fzero + nullTerminatorLength;
                        pic.data = Buffer2.from(b.slice(offset, length));
                        output = pic;
                      }
                      break;
                    case "CNT":
                    case "PCNT":
                      output = Token.UINT32_BE.get(b, 0);
                      break;
                    case "SYLT":
                      offset += 7;
                      output = [];
                      while (offset < length) {
                        const txt = b.slice(offset, offset = Util_1.default.findZero(b, offset, length, encoding));
                        offset += 5;
                        output.push(Util_1.default.decodeString(txt, encoding));
                      }
                      break;
                    case "ULT":
                    case "USLT":
                    case "COM":
                    case "COMM":
                      offset += 1;
                      out.language = Util_1.default.decodeString(b.slice(offset, offset + 3), "iso-8859-1");
                      offset += 3;
                      fzero = Util_1.default.findZero(b, offset, length, encoding);
                      out.description = Util_1.default.decodeString(b.slice(offset, fzero), encoding);
                      offset = fzero + nullTerminatorLength;
                      out.text = Util_1.default.decodeString(b.slice(offset, length), encoding).replace(/\x00+$/, "");
                      output = [out];
                      break;
                    case "UFID":
                      output = FrameParser.readIdentifierAndData(b, offset, length, "iso-8859-1");
                      output = { owner_identifier: output.id, identifier: output.data };
                      break;
                    case "PRIV":
                      output = FrameParser.readIdentifierAndData(b, offset, length, "iso-8859-1");
                      output = { owner_identifier: output.id, data: output.data };
                      break;
                    case "POPM":
                      fzero = Util_1.default.findZero(b, offset, length, encoding);
                      const email = Util_1.default.decodeString(b.slice(offset, fzero), encoding);
                      offset = fzero + FrameParser.getNullTerminatorLength(encoding);
                      const dataLen = length - offset;
                      output = {
                        email,
                        rating: b.readUInt8(offset),
                        counter: dataLen >= 5 ? b.readUInt32BE(offset + 1) : void 0
                      };
                      break;
                    case "GEOB": {
                      fzero = Util_1.default.findZero(b, offset + 1, length, encoding);
                      const mimeType = Util_1.default.decodeString(b.slice(offset + 1, fzero), "iso-8859-1");
                      offset = fzero + 1;
                      fzero = Util_1.default.findZero(b, offset, length - offset, encoding);
                      const filename = Util_1.default.decodeString(b.slice(offset + 1, fzero), "iso-8859-1");
                      offset = fzero + 1;
                      fzero = Util_1.default.findZero(b, offset, length - offset, encoding);
                      const description = Util_1.default.decodeString(b.slice(offset + 1, fzero), "iso-8859-1");
                      output = {
                        type: mimeType,
                        filename,
                        description,
                        data: b.slice(offset + 1, length)
                      };
                      break;
                    }
                    case "WCOM":
                    case "WCOP":
                    case "WOAF":
                    case "WOAR":
                    case "WOAS":
                    case "WORS":
                    case "WPAY":
                    case "WPUB":
                      output = Util_1.default.decodeString(b.slice(offset, fzero), encoding);
                      break;
                    case "WXXX": {
                      fzero = Util_1.default.findZero(b, offset + 1, length, encoding);
                      const description = Util_1.default.decodeString(b.slice(offset + 1, fzero), "iso-8859-1");
                      offset = fzero + 1;
                      fzero = Util_1.default.findZero(b, offset, length - offset, encoding);
                      output = { description, url: Util_1.default.decodeString(b.slice(offset, length - offset), encoding) };
                      break;
                    }
                    case "MCDI": {
                      output = b.slice(0, length);
                      break;
                    }
                    default:
                      debug("Warning: unsupported id3v2-tag-type: " + type);
                      break;
                  }
                  return output;
                }
                static fixPictureMimeType(pictureType) {
                  pictureType = pictureType.toLocaleLowerCase();
                  switch (pictureType) {
                    case "jpg":
                      return "image/jpeg";
                    case "png":
                      return "image/png";
                  }
                  return pictureType;
                }
                /**
                 * Converts TMCL (Musician credits list) or TIPL (Involved people list)
                 * @param entries
                 */
                static functionList(entries) {
                  const res = {};
                  for (let i = 0; i + 1 < entries.length; i += 2) {
                    const names = entries[i + 1].split(",");
                    res[entries[i]] = res.hasOwnProperty(entries[i]) ? res[entries[i]].concat(names) : names;
                  }
                  return res;
                }
                /**
                 * id3v2.4 defines that multiple T* values are separated by 0x00
                 * id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /
                 * @param {number} major Major version, e.g. (4) for  id3v2.4
                 * @param {string} text Concatenated tag value
                 * @returns {string[]} Slitted value
                 */
                static splitValue(major, text) {
                  const values = text.split(major >= 4 ? /\x00/g : /\//g);
                  return FrameParser.trimArray(values);
                }
                static trimArray(values) {
                  for (let i = 0; i < values.length; ++i) {
                    values[i] = values[i].replace(/\x00+$/, "").trim();
                  }
                  return values;
                }
                static readIdentifierAndData(b, offset, length, encoding) {
                  const fzero = Util_1.default.findZero(b, offset, length, encoding);
                  const id = Util_1.default.decodeString(b.slice(offset, fzero), encoding);
                  offset = fzero + FrameParser.getNullTerminatorLength(encoding);
                  return { id, data: b.slice(offset, length) };
                }
                static getTextEncoding(byte) {
                  switch (byte) {
                    case 0:
                      return "iso-8859-1";
                    case 1:
                    case 2:
                      return "utf16";
                    case 3:
                      return "utf8";
                    default:
                      return "utf8";
                  }
                }
                static getNullTerminatorLength(enc) {
                  switch (enc) {
                    case "utf16":
                      return 2;
                    default:
                      return 1;
                  }
                }
              }
              exports2.default = FrameParser;
            }).call(this, __webpack_require__2(9).Buffer);
          },
          /* 147 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const Token = __webpack_require__2(6);
            const assert = __webpack_require__2(18);
            const FourCC_1 = __webpack_require__2(15);
            class Common {
              constructor(header, isAifc) {
                this.isAifc = isAifc;
                const minimumChunkSize = isAifc ? 22 : 18;
                assert.ok(header.chunkSize >= minimumChunkSize, `COMMON CHUNK size should always be at least ${minimumChunkSize}`);
                this.len = header.chunkSize;
              }
              get(buf, off) {
                const shift = buf.readUInt16BE(off + 8) - 16398;
                const baseSampleRate = buf.readUInt16BE(off + 8 + 2);
                const res = {
                  numChannels: buf.readUInt16BE(off),
                  numSampleFrames: buf.readUInt32BE(off + 2),
                  sampleSize: buf.readUInt16BE(off + 6),
                  sampleRate: shift < 0 ? baseSampleRate >> Math.abs(shift) : baseSampleRate << shift
                };
                if (this.isAifc) {
                  res.compressionType = FourCC_1.FourCcToken.get(buf, off + 18);
                  if (this.len > 22) {
                    const strLen = buf.readInt8(off + 22);
                    const padding = (strLen + 1) % 2;
                    if (23 + strLen + padding === this.len) {
                      res.compressionName = new Token.StringType(strLen, "binary").get(buf, off + 23);
                    } else {
                      throw new Error("Illegal pstring length");
                    }
                  }
                } else {
                  res.compressionName = "PCM";
                }
                return res;
              }
            }
            exports2.Common = Common;
          },
          /* 148 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const FourCC_1 = __webpack_require__2(15);
            exports2.Header = {
              len: 8,
              get: (buf, off) => {
                return {
                  // Chunk type ID
                  chunkID: FourCC_1.FourCcToken.get(buf, off),
                  // Chunk size
                  chunkSize: buf.readUInt32BE(off + 4)
                };
              }
            };
          },
          /* 149 */
          /***/
          function(module2, exports2) {
          },
          /* 150 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var Buffer2 = __webpack_require__2(52).Buffer;
            var util = __webpack_require__2(151);
            function copyBuffer(src, target, offset) {
              src.copy(target, offset);
            }
            module2.exports = function() {
              function BufferList() {
                _classCallCheck(this, BufferList);
                this.head = null;
                this.tail = null;
                this.length = 0;
              }
              BufferList.prototype.push = function push(v) {
                var entry = { data: v, next: null };
                if (this.length > 0) this.tail.next = entry;
                else this.head = entry;
                this.tail = entry;
                ++this.length;
              };
              BufferList.prototype.unshift = function unshift(v) {
                var entry = { data: v, next: this.head };
                if (this.length === 0) this.tail = entry;
                this.head = entry;
                ++this.length;
              };
              BufferList.prototype.shift = function shift() {
                if (this.length === 0) return;
                var ret = this.head.data;
                if (this.length === 1) this.head = this.tail = null;
                else this.head = this.head.next;
                --this.length;
                return ret;
              };
              BufferList.prototype.clear = function clear() {
                this.head = this.tail = null;
                this.length = 0;
              };
              BufferList.prototype.join = function join(s) {
                if (this.length === 0) return "";
                var p = this.head;
                var ret = "" + p.data;
                while (p = p.next) {
                  ret += s + p.data;
                }
                return ret;
              };
              BufferList.prototype.concat = function concat(n) {
                if (this.length === 0) return Buffer2.alloc(0);
                if (this.length === 1) return this.head.data;
                var ret = Buffer2.allocUnsafe(n >>> 0);
                var p = this.head;
                var i = 0;
                while (p) {
                  copyBuffer(p.data, ret, i);
                  i += p.data.length;
                  p = p.next;
                }
                return ret;
              };
              return BufferList;
            }();
            if (util && util.inspect && util.inspect.custom) {
              module2.exports.prototype[util.inspect.custom] = function() {
                var obj = util.inspect({ length: this.length });
                return this.constructor.name + " " + obj;
              };
            }
          },
          /* 151 */
          /***/
          function(module2, exports2) {
          },
          /* 152 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            (function(global) {
              module2.exports = deprecate;
              function deprecate(fn, msg) {
                if (config("noDeprecation")) {
                  return fn;
                }
                var warned = false;
                function deprecated() {
                  if (!warned) {
                    if (config("throwDeprecation")) {
                      throw new Error(msg);
                    } else if (config("traceDeprecation")) {
                      console.trace(msg);
                    } else {
                      console.warn(msg);
                    }
                    warned = true;
                  }
                  return fn.apply(this, arguments);
                }
                return deprecated;
              }
              function config(name) {
                try {
                  if (!global.localStorage) return false;
                } catch (_) {
                  return false;
                }
                var val = global.localStorage[name];
                if (null == val) return false;
                return String(val).toLowerCase() === "true";
              }
            }).call(this, __webpack_require__2(17));
          },
          /* 153 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            var buffer = __webpack_require__2(9);
            var Buffer2 = buffer.Buffer;
            function copyProps(src, dst) {
              for (var key in src) {
                dst[key] = src[key];
              }
            }
            if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
              module2.exports = buffer;
            } else {
              copyProps(buffer, exports2);
              exports2.Buffer = SafeBuffer;
            }
            function SafeBuffer(arg, encodingOrOffset, length) {
              return Buffer2(arg, encodingOrOffset, length);
            }
            SafeBuffer.prototype = Object.create(Buffer2.prototype);
            copyProps(Buffer2, SafeBuffer);
            SafeBuffer.from = function(arg, encodingOrOffset, length) {
              if (typeof arg === "number") {
                throw new TypeError("Argument must not be a number");
              }
              return Buffer2(arg, encodingOrOffset, length);
            };
            SafeBuffer.alloc = function(size, fill, encoding) {
              if (typeof size !== "number") {
                throw new TypeError("Argument must be a number");
              }
              var buf = Buffer2(size);
              if (fill !== void 0) {
                if (typeof encoding === "string") {
                  buf.fill(fill, encoding);
                } else {
                  buf.fill(fill);
                }
              } else {
                buf.fill(0);
              }
              return buf;
            };
            SafeBuffer.allocUnsafe = function(size) {
              if (typeof size !== "number") {
                throw new TypeError("Argument must be a number");
              }
              return Buffer2(size);
            };
            SafeBuffer.allocUnsafeSlow = function(size) {
              if (typeof size !== "number") {
                throw new TypeError("Argument must be a number");
              }
              return buffer.SlowBuffer(size);
            };
          },
          /* 154 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            module2.exports = PassThrough;
            var Transform = __webpack_require__2(111);
            var util = Object.create(__webpack_require__2(34));
            util.inherits = __webpack_require__2(31);
            util.inherits(PassThrough, Transform);
            function PassThrough(options) {
              if (!(this instanceof PassThrough)) return new PassThrough(options);
              Transform.call(this, options);
            }
            PassThrough.prototype._transform = function(chunk, encoding, cb) {
              cb(null, chunk);
            };
          },
          /* 155 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            module2.exports = __webpack_require__2(53);
          },
          /* 156 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            module2.exports = __webpack_require__2(24);
          },
          /* 157 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            module2.exports = __webpack_require__2(51).Transform;
          },
          /* 158 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            module2.exports = __webpack_require__2(51).PassThrough;
          },
          /* 159 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const Token = __webpack_require__2(6);
            const FourCC_1 = __webpack_require__2(15);
            var DataType;
            (function(DataType2) {
              DataType2[DataType2["text_utf8"] = 0] = "text_utf8";
              DataType2[DataType2["binary"] = 1] = "binary";
              DataType2[DataType2["external_info"] = 2] = "external_info";
              DataType2[DataType2["reserved"] = 3] = "reserved";
            })(DataType = exports2.DataType || (exports2.DataType = {}));
            exports2.DescriptorParser = {
              len: 52,
              get: (buf, off) => {
                return {
                  // should equal 'MAC '
                  ID: FourCC_1.FourCcToken.get(buf, off),
                  // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)
                  version: Token.UINT32_LE.get(buf, off + 4) / 1e3,
                  // the number of descriptor bytes (allows later expansion of this header)
                  descriptorBytes: Token.UINT32_LE.get(buf, off + 8),
                  // the number of header APE_HEADER bytes
                  headerBytes: Token.UINT32_LE.get(buf, off + 12),
                  // the number of header APE_HEADER bytes
                  seekTableBytes: Token.UINT32_LE.get(buf, off + 16),
                  // the number of header data bytes (from original file)
                  headerDataBytes: Token.UINT32_LE.get(buf, off + 20),
                  // the number of bytes of APE frame data
                  apeFrameDataBytes: Token.UINT32_LE.get(buf, off + 24),
                  // the high order number of APE frame data bytes
                  apeFrameDataBytesHigh: Token.UINT32_LE.get(buf, off + 28),
                  // the terminating data of the file (not including tag data)
                  terminatingDataBytes: Token.UINT32_LE.get(buf, off + 32),
                  // the MD5 hash of the file (see notes for usage... it's a littly tricky)
                  fileMD5: new Token.BufferType(16).get(buf, off + 36)
                };
              }
            };
            exports2.Header = {
              len: 24,
              get: (buf, off) => {
                return {
                  // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)
                  compressionLevel: Token.UINT16_LE.get(buf, off),
                  // any format flags (for future use)
                  formatFlags: Token.UINT16_LE.get(buf, off + 2),
                  // the number of audio blocks in one frame
                  blocksPerFrame: Token.UINT32_LE.get(buf, off + 4),
                  // the number of audio blocks in the final frame
                  finalFrameBlocks: Token.UINT32_LE.get(buf, off + 8),
                  // the total number of frames
                  totalFrames: Token.UINT32_LE.get(buf, off + 12),
                  // the bits per sample (typically 16)
                  bitsPerSample: Token.UINT16_LE.get(buf, off + 16),
                  // the number of channels (1 or 2)
                  channel: Token.UINT16_LE.get(buf, off + 18),
                  // the sample rate (typically 44100)
                  sampleRate: Token.UINT32_LE.get(buf, off + 20)
                };
              }
            };
            exports2.TagFooter = {
              len: 32,
              get: (buf, off) => {
                return {
                  // should equal 'APETAGEX'
                  ID: new Token.StringType(8, "ascii").get(buf, off),
                  // equals CURRENT_APE_TAG_VERSION
                  version: Token.UINT32_LE.get(buf, off + 8),
                  // the complete size of the tag, including this footer (excludes header)
                  size: Token.UINT32_LE.get(buf, off + 12),
                  // the number of fields in the tag
                  fields: Token.UINT32_LE.get(buf, off + 16),
                  // reserved for later use (must be zero),
                  flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 20))
                };
              }
            };
            exports2.TagItemHeader = {
              len: 8,
              get: (buf, off) => {
                return {
                  // Length of assigned value in bytes
                  size: Token.UINT32_LE.get(buf, off),
                  // reserved for later use (must be zero),
                  flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 4))
                };
              }
            };
            exports2.TagField = (footer) => {
              return new Token.BufferType(footer.size - exports2.TagFooter.len);
            };
            function parseTagFlags(flags) {
              return {
                containsHeader: isBitSet(flags, 31),
                containsFooter: isBitSet(flags, 30),
                isHeader: isBitSet(flags, 31),
                readOnly: isBitSet(flags, 0),
                dataType: (flags & 6) >> 1
              };
            }
            exports2.parseTagFlags = parseTagFlags;
            function isBitSet(num, bit) {
              return (num & 1 << bit) !== 0;
            }
            exports2.isBitSet = isBitSet;
          },
          /* 160 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))(function(resolve2, reject2) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function rejected(value) {
                  try {
                    step(generator["throw"](value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function step(result) {
                  result.done ? resolve2(result.value) : new P(function(resolve3) {
                    resolve3(result.value);
                  }).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
              });
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            const GUID_1 = __webpack_require__2(112);
            const AsfObject = __webpack_require__2(161);
            const _debug = __webpack_require__2(8);
            const BasicParser_1 = __webpack_require__2(20);
            const debug = _debug("music-metadata:parser:ASF");
            const headerType = "asf";
            class AsfParser extends BasicParser_1.BasicParser {
              parse() {
                return __awaiter(this, void 0, void 0, function* () {
                  const header = yield this.tokenizer.readToken(AsfObject.TopLevelHeaderObjectToken);
                  if (!header.objectId.equals(GUID_1.default.HeaderObject)) {
                    throw new Error("expected asf header; but was not found; got: " + header.objectId.str);
                  }
                  try {
                    yield this.parseObjectHeader(header.numberOfHeaderObjects);
                  } catch (err) {
                    debug("Error while parsing ASF: %s", err);
                  }
                });
              }
              parseObjectHeader(numberOfObjectHeaders) {
                return __awaiter(this, void 0, void 0, function* () {
                  let tags;
                  do {
                    const header = yield this.tokenizer.readToken(AsfObject.HeaderObjectToken);
                    debug("header GUID=%s", header.objectId.str);
                    switch (header.objectId.str) {
                      case AsfObject.FilePropertiesObject.guid.str:
                        const fpo = yield this.tokenizer.readToken(new AsfObject.FilePropertiesObject(header));
                        this.metadata.setFormat("duration", fpo.playDuration / 1e7);
                        this.metadata.setFormat("bitrate", fpo.maximumBitrate);
                        break;
                      case AsfObject.StreamPropertiesObject.guid.str:
                        const spo = yield this.tokenizer.readToken(new AsfObject.StreamPropertiesObject(header));
                        this.metadata.setFormat("dataformat", "ASF/" + spo.streamType);
                        break;
                      case AsfObject.HeaderExtensionObject.guid.str:
                        const extHeader = yield this.tokenizer.readToken(new AsfObject.HeaderExtensionObject());
                        yield this.parseExtensionObject(extHeader.extensionDataSize);
                        break;
                      case AsfObject.ContentDescriptionObjectState.guid.str:
                        tags = yield this.tokenizer.readToken(new AsfObject.ContentDescriptionObjectState(header));
                        this.addTags(tags);
                        break;
                      case AsfObject.ExtendedContentDescriptionObjectState.guid.str:
                        tags = yield this.tokenizer.readToken(new AsfObject.ExtendedContentDescriptionObjectState(header));
                        this.addTags(tags);
                        break;
                      case GUID_1.default.CodecListObject.str:
                        yield this.tokenizer.ignore(header.objectSize - AsfObject.HeaderObjectToken.len);
                        break;
                      case GUID_1.default.StreamBitratePropertiesObject.str:
                        yield this.tokenizer.ignore(header.objectSize - AsfObject.HeaderObjectToken.len);
                        break;
                      case GUID_1.default.PaddingObject.str:
                        debug("Padding: %s bytes", header.objectSize - AsfObject.HeaderObjectToken.len);
                        yield this.tokenizer.ignore(header.objectSize - AsfObject.HeaderObjectToken.len);
                        break;
                      default:
                        this.warnings.push("Ignore ASF-Object-GUID: " + header.objectId.str);
                        debug("Ignore ASF-Object-GUID: %s", header.objectId.str);
                        yield this.tokenizer.readToken(new AsfObject.IgnoreObjectState(header));
                    }
                  } while (--numberOfObjectHeaders);
                });
              }
              addTags(tags) {
                tags.forEach((tag) => {
                  this.metadata.addTag(headerType, tag.id, tag.value);
                });
              }
              parseExtensionObject(extensionSize) {
                return __awaiter(this, void 0, void 0, function* () {
                  do {
                    const header = yield this.tokenizer.readToken(AsfObject.HeaderObjectToken);
                    switch (header.objectId.str) {
                      case AsfObject.ExtendedStreamPropertiesObjectState.guid.str:
                        const cd = yield this.tokenizer.readToken(new AsfObject.ExtendedStreamPropertiesObjectState(header));
                        break;
                      case AsfObject.MetadataObjectState.guid.str:
                        const moTags = yield this.tokenizer.readToken(new AsfObject.MetadataObjectState(header));
                        this.addTags(moTags);
                        break;
                      case AsfObject.MetadataLibraryObjectState.guid.str:
                        const mlTags = yield this.tokenizer.readToken(new AsfObject.MetadataLibraryObjectState(header));
                        this.addTags(mlTags);
                        break;
                      case GUID_1.default.PaddingObject.str:
                        yield this.tokenizer.ignore(header.objectSize - AsfObject.HeaderObjectToken.len);
                        break;
                      case GUID_1.default.CompatibilityObject.str:
                        this.tokenizer.ignore(header.objectSize - AsfObject.HeaderObjectToken.len);
                        break;
                      case GUID_1.default.ASF_Index_Placeholder_Object.str:
                        yield this.tokenizer.ignore(header.objectSize - AsfObject.HeaderObjectToken.len);
                        break;
                      default:
                        this.warnings.push("Ignore ASF-Object-GUID: " + header.objectId.str);
                        yield this.tokenizer.readToken(new AsfObject.IgnoreObjectState(header));
                        break;
                    }
                    extensionSize -= header.objectSize;
                  } while (extensionSize > 0);
                });
              }
            }
            exports2.AsfParser = AsfParser;
          },
          /* 161 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            (function(Buffer2) {
              Object.defineProperty(exports2, "__esModule", { value: true });
              const Util_1 = __webpack_require__2(14);
              const Token = __webpack_require__2(6);
              const GUID_1 = __webpack_require__2(112);
              const AsfUtil_1 = __webpack_require__2(162);
              const ID3v2_1 = __webpack_require__2(33);
              var DataType;
              (function(DataType2) {
                DataType2[DataType2["UnicodeString"] = 0] = "UnicodeString";
                DataType2[DataType2["ByteArray"] = 1] = "ByteArray";
                DataType2[DataType2["Bool"] = 2] = "Bool";
                DataType2[DataType2["DWord"] = 3] = "DWord";
                DataType2[DataType2["QWord"] = 4] = "QWord";
                DataType2[DataType2["Word"] = 5] = "Word";
              })(DataType = exports2.DataType || (exports2.DataType = {}));
              exports2.TopLevelHeaderObjectToken = {
                len: 30,
                get: (buf, off) => {
                  return {
                    objectId: GUID_1.default.fromBin(new Token.BufferType(16).get(buf, off)),
                    objectSize: Token.UINT64_LE.get(buf, off + 16),
                    numberOfHeaderObjects: Token.UINT32_LE.get(buf, off + 24)
                    // Reserved: 2 bytes
                  };
                }
              };
              exports2.HeaderObjectToken = {
                len: 24,
                get: (buf, off) => {
                  return {
                    objectId: GUID_1.default.fromBin(new Token.BufferType(16).get(buf, off)),
                    objectSize: Token.UINT64_LE.get(buf, off + 16)
                  };
                }
              };
              class State {
                constructor(header) {
                  this.len = header.objectSize - exports2.HeaderObjectToken.len;
                }
                postProcessTag(tags, name, valueType, data) {
                  if (name === "WM/Picture") {
                    tags.push({ id: name, value: WmPictureToken.fromBuffer(data) });
                  } else {
                    const parseAttr = AsfUtil_1.AsfUtil.getParserForAttr(valueType);
                    if (!parseAttr) {
                      throw new Error("unexpected value headerType: " + valueType);
                    }
                    tags.push({ id: name, value: parseAttr(data) });
                  }
                }
              }
              exports2.State = State;
              class IgnoreObjectState extends State {
                constructor(header) {
                  super(header);
                }
                get(buf, off) {
                  return null;
                }
              }
              exports2.IgnoreObjectState = IgnoreObjectState;
              class FilePropertiesObject extends State {
                constructor(header) {
                  super(header);
                }
                get(buf, off) {
                  return {
                    fileId: GUID_1.default.fromBin(buf, off),
                    fileSize: Token.UINT64_LE.get(buf, off + 16),
                    creationDate: Token.UINT64_LE.get(buf, off + 24),
                    dataPacketsCount: Token.UINT64_LE.get(buf, off + 32),
                    playDuration: Token.UINT64_LE.get(buf, off + 40),
                    sendDuration: Token.UINT64_LE.get(buf, off + 48),
                    preroll: Token.UINT64_LE.get(buf, off + 56),
                    flags: {
                      broadcast: Util_1.default.strtokBITSET.get(buf, off + 64, 24),
                      seekable: Util_1.default.strtokBITSET.get(buf, off + 64, 25)
                    },
                    // flagsNumeric: Token.UINT32_LE.get(buf, off + 64),
                    minimumDataPacketSize: Token.UINT32_LE.get(buf, off + 68),
                    maximumDataPacketSize: Token.UINT32_LE.get(buf, off + 72),
                    maximumBitrate: Token.UINT32_LE.get(buf, off + 76)
                  };
                }
              }
              FilePropertiesObject.guid = GUID_1.default.FilePropertiesObject;
              exports2.FilePropertiesObject = FilePropertiesObject;
              class StreamPropertiesObject extends State {
                constructor(header) {
                  super(header);
                }
                get(buf, off) {
                  return {
                    streamType: GUID_1.default.decodeMediaType(GUID_1.default.fromBin(buf, off)),
                    errorCorrectionType: GUID_1.default.fromBin(buf, off + 8)
                    // ToDo
                  };
                }
              }
              StreamPropertiesObject.guid = GUID_1.default.StreamPropertiesObject;
              exports2.StreamPropertiesObject = StreamPropertiesObject;
              class HeaderExtensionObject {
                constructor() {
                  this.len = 22;
                }
                get(buf, off) {
                  const dataSize = buf.readUInt32LE(off + 18);
                  return {
                    reserved1: GUID_1.default.fromBin(buf, off),
                    reserved2: buf.readUInt16LE(off + 16),
                    extensionDataSize: buf.readUInt32LE(off + 18)
                  };
                }
              }
              HeaderExtensionObject.guid = GUID_1.default.HeaderExtensionObject;
              exports2.HeaderExtensionObject = HeaderExtensionObject;
              class ContentDescriptionObjectState extends State {
                constructor(header) {
                  super(header);
                }
                get(buf, off) {
                  const tags = [];
                  let pos = off + 10;
                  for (let i = 0; i < ContentDescriptionObjectState.contentDescTags.length; ++i) {
                    const length = buf.readUInt16LE(off + i * 2);
                    if (length > 0) {
                      const tagName = ContentDescriptionObjectState.contentDescTags[i];
                      const end = pos + length;
                      tags.push({ id: tagName, value: AsfUtil_1.AsfUtil.parseUnicodeAttr(buf.slice(pos, end)) });
                      pos = end;
                    }
                  }
                  return tags;
                }
              }
              ContentDescriptionObjectState.guid = GUID_1.default.ContentDescriptionObject;
              ContentDescriptionObjectState.contentDescTags = ["Title", "Author", "Copyright", "Description", "Rating"];
              exports2.ContentDescriptionObjectState = ContentDescriptionObjectState;
              class ExtendedContentDescriptionObjectState extends State {
                constructor(header) {
                  super(header);
                }
                get(buf, off) {
                  const tags = [];
                  const attrCount = buf.readUInt16LE(off);
                  let pos = off + 2;
                  for (let i = 0; i < attrCount; i += 1) {
                    const nameLen = buf.readUInt16LE(pos);
                    pos += 2;
                    const name = AsfUtil_1.AsfUtil.parseUnicodeAttr(buf.slice(pos, pos + nameLen));
                    pos += nameLen;
                    const valueType = buf.readUInt16LE(pos);
                    pos += 2;
                    const valueLen = buf.readUInt16LE(pos);
                    pos += 2;
                    const value = buf.slice(pos, pos + valueLen);
                    pos += valueLen;
                    this.postProcessTag(tags, name, valueType, value);
                  }
                  return tags;
                }
              }
              ExtendedContentDescriptionObjectState.guid = GUID_1.default.ExtendedContentDescriptionObject;
              exports2.ExtendedContentDescriptionObjectState = ExtendedContentDescriptionObjectState;
              class ExtendedStreamPropertiesObjectState extends State {
                constructor(header) {
                  super(header);
                }
                get(buf, off) {
                  return {
                    startTime: Token.UINT64_LE.get(buf, off),
                    endTime: Token.UINT64_LE.get(buf, off + 8),
                    dataBitrate: buf.readInt32LE(off + 12),
                    bufferSize: buf.readInt32LE(off + 16),
                    initialBufferFullness: buf.readInt32LE(off + 20),
                    alternateDataBitrate: buf.readInt32LE(off + 24),
                    alternateBufferSize: buf.readInt32LE(off + 28),
                    alternateInitialBufferFullness: buf.readInt32LE(off + 32),
                    maximumObjectSize: buf.readInt32LE(off + 36),
                    flags: {
                      reliableFlag: Util_1.default.strtokBITSET.get(buf, off + 40, 0),
                      seekableFlag: Util_1.default.strtokBITSET.get(buf, off + 40, 1),
                      resendLiveCleanpointsFlag: Util_1.default.strtokBITSET.get(buf, off + 40, 2)
                    },
                    // flagsNumeric: Token.UINT32_LE.get(buf, off + 64),
                    streamNumber: buf.readInt16LE(off + 42),
                    streamLanguageId: buf.readInt16LE(off + 44),
                    averageTimePerFrame: buf.readInt32LE(off + 52),
                    streamNameCount: buf.readInt32LE(off + 54),
                    payloadExtensionSystems: buf.readInt32LE(off + 56),
                    streamNames: [],
                    streamPropertiesObject: null
                  };
                }
              }
              ExtendedStreamPropertiesObjectState.guid = GUID_1.default.ExtendedStreamPropertiesObject;
              exports2.ExtendedStreamPropertiesObjectState = ExtendedStreamPropertiesObjectState;
              class MetadataObjectState extends State {
                constructor(header) {
                  super(header);
                }
                get(buf, off) {
                  const tags = [];
                  const descriptionRecordsCount = buf.readUInt16LE(off);
                  let pos = off + 2;
                  for (let i = 0; i < descriptionRecordsCount; i += 1) {
                    pos += 4;
                    const nameLen = buf.readUInt16LE(pos);
                    pos += 2;
                    const dataType = buf.readUInt16LE(pos);
                    pos += 2;
                    const dataLen = buf.readUInt32LE(pos);
                    pos += 4;
                    const name = AsfUtil_1.AsfUtil.parseUnicodeAttr(buf.slice(pos, pos + nameLen));
                    pos += nameLen;
                    const data = buf.slice(pos, pos + dataLen);
                    pos += dataLen;
                    const parseAttr = AsfUtil_1.AsfUtil.getParserForAttr(dataType);
                    if (!parseAttr) {
                      throw new Error("unexpected value headerType: " + dataType);
                    }
                    this.postProcessTag(tags, name, dataType, data);
                  }
                  return tags;
                }
              }
              MetadataObjectState.guid = GUID_1.default.MetadataObject;
              exports2.MetadataObjectState = MetadataObjectState;
              class MetadataLibraryObjectState extends MetadataObjectState {
                constructor(header) {
                  super(header);
                }
              }
              MetadataLibraryObjectState.guid = GUID_1.default.MetadataLibraryObject;
              exports2.MetadataLibraryObjectState = MetadataLibraryObjectState;
              class WmPictureToken {
                constructor(len) {
                  this.len = len;
                }
                static fromBase64(base64str) {
                  return this.fromBuffer(Buffer2.from(base64str, "base64"));
                }
                static fromBuffer(buffer) {
                  const pic = new WmPictureToken(buffer.length);
                  return pic.get(buffer, 0);
                }
                get(buffer, offset) {
                  const typeId = buffer.readUInt8(offset++);
                  const size = buffer.readInt32LE(offset);
                  let index = 5;
                  while (buffer.readUInt16BE(index) !== 0) {
                    index += 2;
                  }
                  const format = buffer.slice(5, index).toString("utf16le");
                  while (buffer.readUInt16BE(index) !== 0) {
                    index += 2;
                  }
                  const description = buffer.slice(5, index).toString("utf16le");
                  return {
                    type: ID3v2_1.AttachedPictureType[typeId],
                    format,
                    description,
                    size,
                    data: buffer.slice(index + 4)
                  };
                }
              }
              exports2.WmPictureToken = WmPictureToken;
            }).call(this, __webpack_require__2(9).Buffer);
          },
          /* 162 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            (function(Buffer2) {
              Object.defineProperty(exports2, "__esModule", { value: true });
              const Util_1 = __webpack_require__2(14);
              const Token = __webpack_require__2(6);
              class AsfUtil {
                static getParserForAttr(i) {
                  return AsfUtil.attributeParsers[i];
                }
                static parseUnicodeAttr(buf) {
                  return Util_1.default.stripNulls(Util_1.default.decodeString(buf, "utf16le"));
                }
                static parseByteArrayAttr(buf) {
                  const newBuf = Buffer2.alloc(buf.length);
                  buf.copy(newBuf);
                  return newBuf;
                }
                static parseBoolAttr(buf, offset = 0) {
                  return AsfUtil.parseWordAttr(buf, offset) === 1;
                }
                static parseDWordAttr(buf, offset = 0) {
                  return buf.readUInt32LE(offset);
                }
                static parseQWordAttr(buf, offset = 0) {
                  return Token.UINT64_LE.get(buf, offset);
                }
                static parseWordAttr(buf, offset = 0) {
                  return buf.readUInt16LE(offset);
                }
              }
              AsfUtil.attributeParsers = [
                AsfUtil.parseUnicodeAttr,
                AsfUtil.parseByteArrayAttr,
                AsfUtil.parseBoolAttr,
                AsfUtil.parseDWordAttr,
                AsfUtil.parseQWordAttr,
                AsfUtil.parseWordAttr,
                AsfUtil.parseByteArrayAttr
              ];
              exports2.AsfUtil = AsfUtil;
            }).call(this, __webpack_require__2(9).Buffer);
          },
          /* 163 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))(function(resolve2, reject2) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function rejected(value) {
                  try {
                    step(generator["throw"](value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function step(result) {
                  result.done ? resolve2(result.value) : new P(function(resolve3) {
                    resolve3(result.value);
                  }).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
              });
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            const Util_1 = __webpack_require__2(14);
            const Token = __webpack_require__2(6);
            const Vorbis_1 = __webpack_require__2(113);
            const AbstractID3Parser_1 = __webpack_require__2(46);
            const FourCC_1 = __webpack_require__2(15);
            const _debug = __webpack_require__2(8);
            const debug = _debug("music-metadata:parser:FLAC");
            var BlockType;
            (function(BlockType2) {
              BlockType2[BlockType2["STREAMINFO"] = 0] = "STREAMINFO";
              BlockType2[BlockType2["PADDING"] = 1] = "PADDING";
              BlockType2[BlockType2["APPLICATION"] = 2] = "APPLICATION";
              BlockType2[BlockType2["SEEKTABLE"] = 3] = "SEEKTABLE";
              BlockType2[BlockType2["VORBIS_COMMENT"] = 4] = "VORBIS_COMMENT";
              BlockType2[BlockType2["CUESHEET"] = 5] = "CUESHEET";
              BlockType2[BlockType2["PICTURE"] = 6] = "PICTURE";
            })(BlockType || (BlockType = {}));
            class FlacParser extends AbstractID3Parser_1.AbstractID3Parser {
              constructor() {
                super(...arguments);
                this.padding = 0;
              }
              static getInstance() {
                return new FlacParser();
              }
              _parse() {
                return __awaiter(this, void 0, void 0, function* () {
                  const fourCC = yield this.tokenizer.readToken(FourCC_1.FourCcToken);
                  if (fourCC.toString() !== "fLaC") {
                    throw new Error("Invalid FLAC preamble");
                  }
                  let blockHeader;
                  do {
                    blockHeader = yield this.tokenizer.readToken(Metadata.BlockHeader);
                    yield this.parseDataBlock(blockHeader);
                  } while (!blockHeader.lastBlock);
                  if (this.tokenizer.fileSize && this.metadata.format.duration) {
                    const dataSize = this.tokenizer.fileSize - this.tokenizer.position;
                    this.metadata.setFormat("bitrate", 8 * dataSize / this.metadata.format.duration);
                  }
                });
              }
              addTag(id, value) {
                this.metadata.addTag("vorbis", id, value);
              }
              parseDataBlock(blockHeader) {
                debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);
                switch (blockHeader.type) {
                  case BlockType.STREAMINFO:
                    return this.parseBlockStreamInfo(blockHeader.length);
                  case BlockType.PADDING:
                    this.padding += blockHeader.length;
                    break;
                  case BlockType.APPLICATION:
                    break;
                  case BlockType.SEEKTABLE:
                    break;
                  case BlockType.VORBIS_COMMENT:
                    return this.parseComment(blockHeader.length);
                  case BlockType.CUESHEET:
                    break;
                  case BlockType.PICTURE:
                    return this.parsePicture(blockHeader.length);
                  default:
                    this.warnings.push("Unknown block type: " + blockHeader.type);
                }
                return this.tokenizer.readToken(new Token.IgnoreType(blockHeader.length));
              }
              /**
               * Parse STREAMINFO
               */
              parseBlockStreamInfo(dataLen) {
                return __awaiter(this, void 0, void 0, function* () {
                  if (dataLen !== Metadata.BlockStreamInfo.len)
                    throw new Error("Unexpected block-stream-info length");
                  const streamInfo = yield this.tokenizer.readToken(Metadata.BlockStreamInfo);
                  this.metadata.setFormat("dataformat", "flac");
                  this.metadata.setFormat("lossless", true);
                  this.metadata.setFormat("numberOfChannels", streamInfo.channels);
                  this.metadata.setFormat("bitsPerSample", streamInfo.bitsPerSample);
                  this.metadata.setFormat("sampleRate", streamInfo.sampleRate);
                  this.metadata.setFormat("duration", streamInfo.totalSamples / streamInfo.sampleRate);
                });
              }
              /**
               * Parse VORBIS_COMMENT
               * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3
               */
              parseComment(dataLen) {
                return __awaiter(this, void 0, void 0, function* () {
                  const data = yield this.tokenizer.readToken(new Token.BufferType(dataLen));
                  const decoder = new DataDecoder(data);
                  decoder.readStringUtf8();
                  const commentListLength = decoder.readInt32();
                  for (let i = 0; i < commentListLength; i++) {
                    const comment = decoder.readStringUtf8();
                    const split = comment.split("=");
                    this.addTag(split[0].toUpperCase(), split.splice(1).join("="));
                  }
                });
              }
              parsePicture(dataLen) {
                return __awaiter(this, void 0, void 0, function* () {
                  if (this.options.skipCovers) {
                    return this.tokenizer.ignore(dataLen);
                  } else {
                    const picture = yield this.tokenizer.readToken(new Vorbis_1.VorbisPictureToken(dataLen));
                    this.addTag("METADATA_BLOCK_PICTURE", picture);
                  }
                });
              }
            }
            exports2.FlacParser = FlacParser;
            class Metadata {
            }
            Metadata.BlockHeader = {
              len: 4,
              get: (buf, off) => {
                return {
                  lastBlock: Util_1.default.strtokBITSET.get(buf, off, 7),
                  type: Util_1.default.getBitAllignedNumber(buf, off, 1, 7),
                  length: Token.UINT24_BE.get(buf, off + 1)
                };
              }
            };
            Metadata.BlockStreamInfo = {
              len: 34,
              get: (buf, off) => {
                return {
                  // The minimum block size (in samples) used in the stream.
                  minimumBlockSize: Token.UINT16_BE.get(buf, off),
                  // The maximum block size (in samples) used in the stream.
                  // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.
                  maximumBlockSize: Token.UINT16_BE.get(buf, off + 2) / 1e3,
                  // The minimum frame size (in bytes) used in the stream.
                  // May be 0 to imply the value is not known.
                  minimumFrameSize: Token.UINT24_BE.get(buf, off + 4),
                  // The maximum frame size (in bytes) used in the stream.
                  // May be 0 to imply the value is not known.
                  maximumFrameSize: Token.UINT24_BE.get(buf, off + 7),
                  // Sample rate in Hz. Though 20 bits are available,
                  // the maximum sample rate is limited by the structure of frame headers to 655350Hz.
                  // Also, a value of 0 is invalid.
                  sampleRate: Token.UINT24_BE.get(buf, off + 10) >> 4,
                  // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),
                  // (number of channels)-1. FLAC supports from 1 to 8 channels
                  channels: Util_1.default.getBitAllignedNumber(buf, off + 12, 4, 3) + 1,
                  // bits per sample)-1.
                  // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.
                  bitsPerSample: Util_1.default.getBitAllignedNumber(buf, off + 12, 7, 5) + 1,
                  // Total samples in stream.
                  // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.
                  // A value of zero here means the number of total samples is unknown.
                  totalSamples: Util_1.default.getBitAllignedNumber(buf, off + 13, 4, 36),
                  // the MD5 hash of the file (see notes for usage... it's a littly tricky)
                  fileMD5: new Token.BufferType(16).get(buf, off + 18)
                };
              }
            };
            class DataDecoder {
              constructor(data) {
                this.data = data;
                this.offset = 0;
              }
              readInt32() {
                const value = Token.UINT32_LE.get(this.data, this.offset);
                this.offset += 4;
                return value;
              }
              readStringUtf8() {
                const len = this.readInt32();
                const value = this.data.toString("utf8", this.offset, this.offset + len);
                this.offset += len;
                return value;
              }
            }
          },
          /* 164 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            (function(Buffer2) {
              var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function(resolve2, reject2) {
                  function fulfilled(value) {
                    try {
                      step(generator.next(value));
                    } catch (e) {
                      reject2(e);
                    }
                  }
                  function rejected(value) {
                    try {
                      step(generator["throw"](value));
                    } catch (e) {
                      reject2(e);
                    }
                  }
                  function step(result) {
                    result.done ? resolve2(result.value) : new P(function(resolve3) {
                      resolve3(result.value);
                    }).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
              };
              Object.defineProperty(exports2, "__esModule", { value: true });
              const initDebug = __webpack_require__2(8);
              const Token = __webpack_require__2(6);
              const BasicParser_1 = __webpack_require__2(20);
              const Atom_1 = __webpack_require__2(165);
              const AtomToken = __webpack_require__2(114);
              const ID3v1Parser_1 = __webpack_require__2(48);
              const debug = initDebug("music-metadata:parser:MP4");
              const tagFormat = "iTunes";
              const encoderDict = {
                alac: {
                  lossy: false,
                  format: "ALAC"
                },
                mp4a: {
                  lossy: true,
                  format: "MP4A"
                },
                mp4s: {
                  lossy: true,
                  format: "MP4S"
                },
                // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87
                c608: {
                  lossy: true,
                  format: "CEA-608"
                },
                c708: {
                  lossy: true,
                  format: "CEA-708"
                }
              };
              function distinct(value, index, self2) {
                return self2.indexOf(value) === index;
              }
              class MP4Parser extends BasicParser_1.BasicParser {
                static read_BE_Signed_Integer(value) {
                  return Token.readIntBE(value, 0, value.length);
                }
                static read_BE_Unsigned_Integer(value) {
                  return Token.readUIntBE(value, 0, value.length);
                }
                parse() {
                  return __awaiter(this, void 0, void 0, function* () {
                    this.formatList = [];
                    const rootAtom = new Atom_1.Atom({ name: "mp4", length: this.tokenizer.fileSize }, false, null);
                    yield rootAtom.readAtoms(this.tokenizer, (atom) => __awaiter(this, void 0, void 0, function* () {
                      if (atom.parent) {
                        switch (atom.parent.header.name) {
                          case "ilst":
                          case "<id>":
                            return this.parseMetadataItemData(atom);
                          case "stbl":
                            switch (atom.header.name) {
                              case "stsd":
                                return this.parseAtom_stsd(atom.dataLen);
                            }
                        }
                      }
                      switch (atom.header.name) {
                        case "ftyp":
                          const types = yield this.parseAtom_ftyp(atom.dataLen);
                          debug(`ftyp: ${types.join("/")}`);
                          this.metadata.setFormat("dataformat", types.filter(distinct).join("/"));
                          return;
                        case "mdhd":
                          return this.parseAtom_mdhd(atom);
                        case "mvhd":
                          return this.parseAtom_mvhd(atom);
                        case "mdat":
                          if (this.tokenizer.fileSize && this.metadata.format.duration) {
                            this.metadata.setFormat("bitrate", 8 * atom.dataLen / this.metadata.format.duration);
                          }
                          break;
                      }
                      yield this.tokenizer.readToken(new Token.IgnoreType(atom.dataLen));
                      debug(`Ignore atom data: path=${atom.atomPath}, payload-len=${atom.dataLen}`);
                    }), this.tokenizer.fileSize);
                    this.metadata.setFormat("encoder", this.formatList.filter(distinct).join("+"));
                  });
                }
                addTag(id, value) {
                  this.metadata.addTag(tagFormat, id, value);
                }
                addWarning(message) {
                  debug("Warning:" + message);
                  this.warnings.push(message);
                }
                /**
                 * Parse data of Meta-item-list-atom (item of 'ilst' atom)
                 * @param metaAtom
                 * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8
                 */
                parseMetadataItemData(metaAtom) {
                  let tagKey = metaAtom.header.name;
                  return metaAtom.readAtoms(this.tokenizer, (child) => __awaiter(this, void 0, void 0, function* () {
                    switch (child.header.name) {
                      case "data":
                        return this.parseValueAtom(tagKey, child);
                      case "name":
                        const name = yield this.tokenizer.readToken(new AtomToken.NameAtom(child.dataLen));
                        tagKey += ":" + name.name;
                        break;
                      case "mean":
                        const mean = yield this.tokenizer.readToken(new AtomToken.NameAtom(child.dataLen));
                        tagKey += ":" + mean.name;
                        break;
                      default:
                        const dataAtom = yield this.tokenizer.readToken(new Token.BufferType(child.dataLen));
                        this.addWarning("Unsupported meta-item: " + tagKey + "[" + child.header.name + "] => value=" + dataAtom.toString("hex") + " ascii=" + dataAtom.toString("ascii"));
                    }
                  }), metaAtom.dataLen);
                }
                parseValueAtom(tagKey, metaAtom) {
                  return __awaiter(this, void 0, void 0, function* () {
                    const dataAtom = yield this.tokenizer.readToken(new AtomToken.DataAtom(metaAtom.header.length - AtomToken.Header.len));
                    if (dataAtom.type.set !== 0) {
                      throw new Error("Unsupported type-set != 0: " + dataAtom.type.set);
                    }
                    switch (dataAtom.type.type) {
                      case 0:
                        switch (tagKey) {
                          case "trkn":
                          case "disk":
                            const num = Token.UINT8.get(dataAtom.value, 3);
                            const of = Token.UINT8.get(dataAtom.value, 5);
                            this.addTag(tagKey, num + "/" + of);
                            break;
                          case "gnre":
                            const genreInt = Token.UINT8.get(dataAtom.value, 1);
                            const genreStr = ID3v1Parser_1.Genres[genreInt - 1];
                            this.addTag(tagKey, genreStr);
                            break;
                          default:
                        }
                        break;
                      case 1:
                      case 18:
                        this.addTag(tagKey, dataAtom.value.toString("utf-8"));
                        break;
                      case 13:
                        if (this.options.skipCovers)
                          break;
                        this.addTag(tagKey, {
                          format: "image/jpeg",
                          data: Buffer2.from(dataAtom.value)
                        });
                        break;
                      case 14:
                        if (this.options.skipCovers)
                          break;
                        this.addTag(tagKey, {
                          format: "image/png",
                          data: Buffer2.from(dataAtom.value)
                        });
                        break;
                      case 21:
                        this.addTag(tagKey, MP4Parser.read_BE_Signed_Integer(dataAtom.value));
                        break;
                      case 22:
                        this.addTag(tagKey, MP4Parser.read_BE_Unsigned_Integer(dataAtom.value));
                        break;
                      case 65:
                        this.addTag(tagKey, dataAtom.value.readInt8(0));
                        break;
                      case 66:
                        this.addTag(tagKey, dataAtom.value.readInt16BE(0));
                        break;
                      case 67:
                        this.addTag(tagKey, dataAtom.value.readInt32BE(0));
                        break;
                      default:
                        this.addWarning(`atom key=${tagKey}, has unknown well-known-type (data-type): ${dataAtom.type.type}`);
                    }
                  });
                }
                /**
                 * Parse movie header (mvhd) atom
                 * @param mvhd mvhd atom
                 */
                parseAtom_mvhd(mvhd) {
                  return __awaiter(this, void 0, void 0, function* () {
                    const mvhd_data = yield this.tokenizer.readToken(new AtomToken.MvhdAtom(mvhd.dataLen));
                    this.parse_mxhd(mvhd_data);
                  });
                }
                /**
                 * Parse media header (mdhd) atom
                 * @param mdhd mdhd atom
                 */
                parseAtom_mdhd(mdhd) {
                  return __awaiter(this, void 0, void 0, function* () {
                    const mdhd_data = yield this.tokenizer.readToken(new AtomToken.MdhdAtom(mdhd.dataLen));
                    this.parse_mxhd(mdhd_data);
                  });
                }
                parse_mxhd(mxhd) {
                  if (mxhd.timeScale) {
                    this.metadata.setFormat("sampleRate", mxhd.timeScale);
                    if (!this.metadata.format.duration) {
                      const duration = mxhd.duration / mxhd.timeScale;
                      this.metadata.setFormat("duration", duration);
                    }
                  }
                }
                parseAtom_ftyp(len) {
                  return __awaiter(this, void 0, void 0, function* () {
                    const ftype = yield this.tokenizer.readToken(AtomToken.ftyp);
                    len -= AtomToken.ftyp.len;
                    if (len > 0) {
                      const types = yield this.parseAtom_ftyp(len);
                      const value = ftype.type.replace(/\W/g, "");
                      if (value.length > 0) {
                        types.push(value);
                      }
                      return types;
                    }
                    return [];
                  });
                }
                parseAtom_stsd(len) {
                  return __awaiter(this, void 0, void 0, function* () {
                    const stsd = yield this.tokenizer.readToken(new AtomToken.StsdAtom(len));
                    const formatList = [];
                    for (const dfEntry of stsd.table) {
                      const encoderInfo = encoderDict[dfEntry.dataFormat];
                      if (encoderInfo) {
                        this.metadata.setFormat("lossless", !encoderInfo.lossy);
                        formatList.push(encoderInfo.format);
                      } else {
                        debug(`Warning: data-format '${dfEntry.dataFormat}' missing in MP4Parser.encoderDict`);
                        formatList.push(dfEntry.dataFormat);
                      }
                    }
                    this.formatList.push(formatList.join("/"));
                  });
                }
              }
              exports2.MP4Parser = MP4Parser;
            }).call(this, __webpack_require__2(9).Buffer);
          },
          /* 165 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))(function(resolve2, reject2) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function rejected(value) {
                  try {
                    step(generator["throw"](value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function step(result) {
                  result.done ? resolve2(result.value) : new P(function(resolve3) {
                    resolve3(result.value);
                  }).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
              });
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            const type_1 = __webpack_require__2(22);
            const initDebug = __webpack_require__2(8);
            const Token = __webpack_require__2(6);
            const AtomToken = __webpack_require__2(114);
            const debug = initDebug("music-metadata:parser:MP4:Atom");
            class Atom {
              constructor(header, extended, parent) {
                this.header = header;
                this.extended = extended;
                this.parent = parent;
                this.children = [];
                this.atomPath = (this.parent ? this.parent.atomPath + "/" : "") + this.header.name;
                this.dataLen = this.header.length - (extended ? 16 : 8);
              }
              readAtoms(tokenizer, dataHandler, size) {
                return __awaiter(this, void 0, void 0, function* () {
                  const atomBean = yield this.readAtom(tokenizer, dataHandler);
                  this.children.push(atomBean);
                  if (size === void 0) {
                    return this.readAtoms(tokenizer, dataHandler, size).catch((err) => {
                      if (err.message === type_1.endOfFile) {
                        debug(`Reached end-of-file`);
                      } else {
                        throw err;
                      }
                    });
                  }
                  size -= atomBean.header.length;
                  if (size > 0) {
                    return this.readAtoms(tokenizer, dataHandler, size);
                  }
                });
              }
              readAtom(tokenizer, dataHandler) {
                return __awaiter(this, void 0, void 0, function* () {
                  const offset = tokenizer.position;
                  const header = yield tokenizer.readToken(AtomToken.Header);
                  const extended = header.length === 1;
                  if (extended) {
                    header.length = yield tokenizer.readToken(AtomToken.ExtendedSize);
                  }
                  const atomBean = new Atom(header, extended, this);
                  debug(`parse atom name=${atomBean.atomPath}, extended=${atomBean.extended}, offset=${offset}, len=${atomBean.header.length}`);
                  yield atomBean.readData(tokenizer, dataHandler);
                  return atomBean;
                });
              }
              readData(tokenizer, dataHandler) {
                return __awaiter(this, void 0, void 0, function* () {
                  switch (this.header.name) {
                    case "moov":
                    case "udta":
                    case "trak":
                    case "mdia":
                    case "minf":
                    case "stbl":
                    case "<id>":
                    case "ilst":
                      return this.readAtoms(tokenizer, dataHandler, this.dataLen);
                    case "meta":
                      yield tokenizer.readToken(new Token.IgnoreType(4));
                      return this.readAtoms(tokenizer, dataHandler, this.dataLen - 4);
                    case "mdhd":
                    case "mvhd":
                    case "tkhd":
                    case "stsz":
                    case "mdat":
                    default:
                      return dataHandler(this);
                  }
                });
              }
            }
            exports2.Atom = Atom;
          },
          /* 166 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            (function(Buffer2) {
              var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function(resolve2, reject2) {
                  function fulfilled(value) {
                    try {
                      step(generator.next(value));
                    } catch (e) {
                      reject2(e);
                    }
                  }
                  function rejected(value) {
                    try {
                      step(generator["throw"](value));
                    } catch (e) {
                      reject2(e);
                    }
                  }
                  function step(result) {
                    result.done ? resolve2(result.value) : new P(function(resolve3) {
                      resolve3(result.value);
                    }).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
              };
              Object.defineProperty(exports2, "__esModule", { value: true });
              const assert = __webpack_require__2(18);
              const Token = __webpack_require__2(6);
              const type_1 = __webpack_require__2(22);
              const initDebug = __webpack_require__2(8);
              const Util_1 = __webpack_require__2(14);
              const AbstractID3Parser_1 = __webpack_require__2(46);
              const XingTag_1 = __webpack_require__2(167);
              const debug = initDebug("music-metadata:parser:mpeg");
              const maxPeekLen = 1024;
              const MPEG4 = {
                /**
                 * Audio Object Types
                 */
                AudioObjectTypes: [
                  "AAC Main",
                  "AAC LC",
                  "AAC SSR",
                  "AAC LTP"
                  // Long Term Prediction
                ],
                /**
                 * Sampling Frequencies
                 * https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies
                 */
                SamplingFrequencies: [
                  96e3,
                  88200,
                  64e3,
                  48e3,
                  44100,
                  32e3,
                  24e3,
                  22050,
                  16e3,
                  12e3,
                  11025,
                  8e3,
                  7350,
                  void 0,
                  void 0,
                  -1
                ]
                /**
                 * Channel Configurations
                 */
              };
              const MPEG4_ChannelConfigurations = [
                void 0,
                ["front-center"],
                ["front-left", "front-right"],
                ["front-center", "front-left", "front-right"],
                ["front-center", "front-left", "front-right", "back-center"],
                ["front-center", "front-left", "front-right", "back-left", "back-right"],
                ["front-center", "front-left", "front-right", "back-left", "back-right", "LFE-channel"],
                ["front-center", "front-left", "front-right", "side-left", "side-right", "back-left", "back-right", "LFE-channel"]
              ];
              class MpegFrameHeader {
                constructor(buf, off) {
                  this.versionIndex = Util_1.default.getBitAllignedNumber(buf, off + 1, 3, 2);
                  this.layer = MpegFrameHeader.LayerDescription[Util_1.default.getBitAllignedNumber(buf, off + 1, 5, 2)];
                  if (this.versionIndex > 1 && this.layer === 0) {
                    this.parseAdtsHeader(buf, off);
                  } else {
                    this.parseMpegHeader(buf, off);
                  }
                  this.isProtectedByCRC = !Util_1.default.isBitSet(buf, off + 1, 7);
                }
                calcDuration(numFrames) {
                  return numFrames * this.calcSamplesPerFrame() / this.samplingRate;
                }
                calcSamplesPerFrame() {
                  return MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];
                }
                calculateSideInfoLength() {
                  if (this.layer !== 3)
                    return 2;
                  if (this.channelModeIndex === 3) {
                    if (this.version === 1) {
                      return 17;
                    } else if (this.version === 2 || this.version === 2.5) {
                      return 9;
                    }
                  } else {
                    if (this.version === 1) {
                      return 32;
                    } else if (this.version === 2 || this.version === 2.5) {
                      return 17;
                    }
                  }
                }
                calcSlotSize() {
                  return [null, 4, 1, 1][this.layer];
                }
                parseMpegHeader(buf, off) {
                  this.container = "MPEG";
                  this.bitrateIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 0, 4);
                  this.sampRateFreqIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 4, 2);
                  this.padding = Util_1.default.isBitSet(buf, off + 2, 6);
                  this.privateBit = Util_1.default.isBitSet(buf, off + 2, 7);
                  this.channelModeIndex = Util_1.default.getBitAllignedNumber(buf, off + 3, 0, 2);
                  this.modeExtension = Util_1.default.getBitAllignedNumber(buf, off + 3, 2, 2);
                  this.isCopyrighted = Util_1.default.isBitSet(buf, off + 3, 4);
                  this.isOriginalMedia = Util_1.default.isBitSet(buf, off + 3, 5);
                  this.emphasis = Util_1.default.getBitAllignedNumber(buf, off + 3, 7, 2);
                  this.version = MpegFrameHeader.VersionID[this.versionIndex];
                  this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex];
                  this.codec = "mp" + this.layer;
                  const bitrateInKbps = this.calcBitrate();
                  if (!bitrateInKbps) {
                    throw new Error("Cannot determine bit-rate");
                  }
                  this.bitrate = bitrateInKbps === null ? null : bitrateInKbps * 1e3;
                  this.samplingRate = this.calcSamplingRate();
                  if (this.samplingRate == null) {
                    throw new Error("Cannot determine sampling-rate");
                  }
                }
                parseAdtsHeader(buf, off) {
                  debug(`layer=0 => ADTS`);
                  this.version = this.versionIndex === 2 ? 4 : 2;
                  this.container = "ADTS/MPEG-" + this.version;
                  const profileIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 0, 2);
                  this.codec = "AAC";
                  this.codecProfile = MPEG4.AudioObjectTypes[profileIndex];
                  debug(`MPEG-4 audio-codec=${this.codec}`);
                  const samplingFrequencyIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 2, 4);
                  this.samplingRate = MPEG4.SamplingFrequencies[samplingFrequencyIndex];
                  debug(`sampling-rate=${this.samplingRate}`);
                  const channelIndex = Util_1.default.getBitAllignedNumber(buf, off + 2, 7, 3);
                  this.mp4ChannelConfig = MPEG4_ChannelConfigurations[channelIndex];
                  debug(`channel-config=${this.mp4ChannelConfig.join("+")}`);
                  this.frameLength = Util_1.default.getBitAllignedNumber(buf, off + 3, 6, 2) << 11;
                }
                calcBitrate() {
                  if (this.bitrateIndex === 0)
                    return null;
                  if (this.bitrateIndex === 15)
                    return null;
                  const mpegVersion = this.version.toString() + this.layer;
                  return MpegFrameHeader.bitrate_index[this.bitrateIndex][mpegVersion];
                }
                calcSamplingRate() {
                  if (this.sampRateFreqIndex === 3)
                    return null;
                  return MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];
                }
              }
              MpegFrameHeader.SyncByte1 = 255;
              MpegFrameHeader.SyncByte2 = 224;
              MpegFrameHeader.VersionID = [2.5, null, 2, 1];
              MpegFrameHeader.LayerDescription = [0, 3, 2, 1];
              MpegFrameHeader.ChannelMode = ["stereo", "joint_stereo", "dual_channel", "mono"];
              MpegFrameHeader.bitrate_index = {
                1: { 11: 32, 12: 32, 13: 32, 21: 32, 22: 8, 23: 8 },
                2: { 11: 64, 12: 48, 13: 40, 21: 48, 22: 16, 23: 16 },
                3: { 11: 96, 12: 56, 13: 48, 21: 56, 22: 24, 23: 24 },
                4: { 11: 128, 12: 64, 13: 56, 21: 64, 22: 32, 23: 32 },
                5: { 11: 160, 12: 80, 13: 64, 21: 80, 22: 40, 23: 40 },
                6: { 11: 192, 12: 96, 13: 80, 21: 96, 22: 48, 23: 48 },
                7: { 11: 224, 12: 112, 13: 96, 21: 112, 22: 56, 23: 56 },
                8: { 11: 256, 12: 128, 13: 112, 21: 128, 22: 64, 23: 64 },
                9: { 11: 288, 12: 160, 13: 128, 21: 144, 22: 80, 23: 80 },
                10: { 11: 320, 12: 192, 13: 160, 21: 160, 22: 96, 23: 96 },
                11: { 11: 352, 12: 224, 13: 192, 21: 176, 22: 112, 23: 112 },
                12: { 11: 384, 12: 256, 13: 224, 21: 192, 22: 128, 23: 128 },
                13: { 11: 416, 12: 320, 13: 256, 21: 224, 22: 144, 23: 144 },
                14: { 11: 448, 12: 384, 13: 320, 21: 256, 22: 160, 23: 160 }
              };
              MpegFrameHeader.sampling_rate_freq_index = {
                1: { 0: 44100, 1: 48e3, 2: 32e3 },
                2: { 0: 22050, 1: 24e3, 2: 16e3 },
                2.5: { 0: 11025, 1: 12e3, 2: 8e3 }
              };
              MpegFrameHeader.samplesInFrameTable = [
                /* Layer   I    II   III */
                [0, 384, 1152, 1152],
                [0, 384, 1152, 576]
                // MPEG-2(.5
              ];
              const FrameHeader = {
                len: 4,
                get: (buf, off) => {
                  return new MpegFrameHeader(buf, off);
                }
              };
              function getVbrCodecProfile(vbrScale) {
                return "V" + (100 - vbrScale) / 10;
              }
              class MpegParser extends AbstractID3Parser_1.AbstractID3Parser {
                constructor() {
                  super(...arguments);
                  this.frameCount = 0;
                  this.syncFrameCount = -1;
                  this.countSkipFrameData = 0;
                  this.totalAudioLength = 0;
                  this.bitrates = [];
                  this.calculateEofDuration = false;
                  this.buf_frame_header = Buffer2.alloc(4);
                  this.syncPeek = {
                    buf: Buffer2.alloc(maxPeekLen),
                    len: 0
                  };
                }
                /**
                 * Called after ID3 headers have been parsed
                 */
                _parse() {
                  return __awaiter(this, void 0, void 0, function* () {
                    this.metadata.setFormat("lossless", false);
                    try {
                      let quit = false;
                      while (!quit) {
                        yield this.sync();
                        quit = yield this.parseAudioFrameHeader();
                      }
                    } catch (err) {
                      if (err.message === type_1.endOfFile) {
                        if (this.calculateEofDuration) {
                          const numberOfSamples = this.frameCount * this.samplesPerFrame;
                          this.metadata.setFormat("numberOfSamples", numberOfSamples);
                          const duration = numberOfSamples / this.metadata.format.sampleRate;
                          debug(`Calculate duration at EOF: ${duration} sec.`, duration);
                          this.metadata.setFormat("duration", duration);
                        }
                      } else {
                        throw err;
                      }
                    }
                  });
                }
                /**
                 * Called after file has been fully parsed, this allows, if present, to exclude the ID3v1.1 header length
                 * @param metadata
                 * @returns {INativeAudioMetadata}
                 */
                finalize() {
                  const format = this.metadata.format;
                  const hasID3v1 = this.metadata.native.hasOwnProperty("ID3v1");
                  if (format.duration && this.tokenizer.fileSize) {
                    const mpegSize = this.tokenizer.fileSize - this.mpegOffset - (hasID3v1 ? 128 : 0);
                    if (format.codecProfile && format.codecProfile[0] === "V") {
                      this.metadata.setFormat("bitrate", mpegSize * 8 / format.duration);
                    }
                  } else if (this.tokenizer.fileSize && format.codecProfile === "CBR") {
                    const mpegSize = this.tokenizer.fileSize - this.mpegOffset - (hasID3v1 ? 128 : 0);
                    const numberOfSamples = Math.round(mpegSize / this.frame_size) * this.samplesPerFrame;
                    this.metadata.setFormat("numberOfSamples", numberOfSamples);
                    const duration = numberOfSamples / format.sampleRate;
                    debug("Calculate CBR duration based on file size: %s", duration);
                    this.metadata.setFormat("duration", duration);
                  }
                }
                sync() {
                  return __awaiter(this, void 0, void 0, function* () {
                    let gotFirstSync = false;
                    while (true) {
                      let bo = 0;
                      this.syncPeek.len = yield this.tokenizer.peekBuffer(this.syncPeek.buf, 0, maxPeekLen, this.tokenizer.position, true);
                      if (this.syncPeek.len <= 256) {
                        throw new Error(type_1.endOfFile);
                      }
                      if (this.syncPeek.len === 0)
                        throw new Error(type_1.endOfFile);
                      while (true) {
                        if (gotFirstSync && (this.syncPeek.buf[bo] & 224) === 224) {
                          this.buf_frame_header[0] = MpegFrameHeader.SyncByte1;
                          this.buf_frame_header[1] = this.syncPeek.buf[bo];
                          yield this.tokenizer.ignore(bo);
                          debug(`Sync at offset=${this.tokenizer.position - 1}, frameCount=${this.frameCount}`);
                          if (this.syncFrameCount === this.frameCount) {
                            debug(`Re-synced MPEG stream, frameCount=${this.frameCount}`);
                            this.frameCount = 0;
                            this.frame_size = 0;
                          }
                          this.syncFrameCount = this.frameCount;
                          return;
                        } else {
                          gotFirstSync = false;
                          bo = this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, bo);
                          if (bo === -1) {
                            if (this.syncPeek.len < this.syncPeek.buf.length) {
                              throw new Error(type_1.endOfFile);
                            }
                            yield this.tokenizer.ignore(this.syncPeek.len);
                            break;
                          } else {
                            ++bo;
                            gotFirstSync = true;
                          }
                        }
                      }
                    }
                  });
                }
                /**
                 * @return {Promise<boolean>} true if parser should quit
                 */
                parseAudioFrameHeader() {
                  return __awaiter(this, void 0, void 0, function* () {
                    if (this.frameCount === 0) {
                      this.mpegOffset = this.tokenizer.position - 1;
                    }
                    yield this.tokenizer.peekBuffer(this.buf_frame_header, 1, 3);
                    let header;
                    try {
                      header = FrameHeader.get(this.buf_frame_header, 0);
                    } catch (err) {
                      yield this.tokenizer.ignore(1);
                      this.warnings.push("Parse error: " + err.message);
                      return false;
                    }
                    yield this.tokenizer.ignore(3);
                    this.metadata.setFormat("dataformat", header.container);
                    this.metadata.setFormat("encoder", header.codec);
                    this.metadata.setFormat("lossless", false);
                    this.metadata.setFormat("sampleRate", header.samplingRate);
                    if (header.version >= 2 && header.layer === 0) {
                      return this.parseAdts(header);
                    }
                    this.metadata.setFormat("numberOfChannels", header.channelMode === "mono" ? 1 : 2);
                    this.metadata.setFormat("bitrate", header.bitrate);
                    if (this.frameCount < 20 * 1e4) {
                      debug("offset=%s MP%s bitrate=%s sample-rate=%s", this.tokenizer.position - 4, header.layer, header.bitrate, header.samplingRate);
                    }
                    const slot_size = header.calcSlotSize();
                    if (slot_size === null) {
                      throw new Error("invalid slot_size");
                    }
                    const samples_per_frame = header.calcSamplesPerFrame();
                    debug(`samples_per_frame=${samples_per_frame}`);
                    const bps = samples_per_frame / 8;
                    const fsize = bps * header.bitrate / header.samplingRate + (header.padding ? slot_size : 0);
                    this.frame_size = Math.floor(fsize);
                    this.audioFrameHeader = header;
                    this.frameCount++;
                    this.bitrates.push(header.bitrate);
                    if (this.frameCount === 1) {
                      this.offset = FrameHeader.len;
                      yield this.skipSideInformation();
                      return false;
                    }
                    if (this.frameCount === 3) {
                      if (this.areAllSame(this.bitrates)) {
                        this.samplesPerFrame = samples_per_frame;
                        this.metadata.setFormat("codecProfile", "CBR");
                        if (this.tokenizer.fileSize)
                          return true;
                      } else if (this.metadata.format.duration) {
                        return true;
                      }
                      if (!this.options.duration) {
                        return true;
                      }
                    }
                    if (this.options.duration && this.frameCount === 4) {
                      this.samplesPerFrame = samples_per_frame;
                      this.calculateEofDuration = true;
                    }
                    this.offset = 4;
                    if (header.isProtectedByCRC) {
                      yield this.parseCrc();
                      return false;
                    } else {
                      yield this.skipSideInformation();
                      return false;
                    }
                  });
                }
                parseAdts(header) {
                  return __awaiter(this, void 0, void 0, function* () {
                    const buf = Buffer2.alloc(3);
                    yield this.tokenizer.readBuffer(buf);
                    header.frameLength += Util_1.default.getBitAllignedNumber(buf, 0, 0, 11);
                    this.tokenizer.ignore(header.frameLength - 7 + 1);
                    this.frameCount++;
                    this.totalAudioLength += header.frameLength;
                    const framesPerSec = header.samplingRate / 1024;
                    const bytesPerFrame = this.frameCount === 0 ? 0 : this.totalAudioLength / this.frameCount;
                    const bitrate = 8 * bytesPerFrame * framesPerSec + 0.5;
                    this.metadata.setFormat("codecProfile", header.codecProfile);
                    this.metadata.setFormat("bitrate", bitrate);
                    if (header.mp4ChannelConfig) {
                      this.metadata.setFormat("numberOfChannels", header.mp4ChannelConfig.length);
                    }
                    debug(`size=${header.frameLength} bytes, bit-rate=${bitrate}`);
                    return this.frameCount === 3;
                  });
                }
                parseCrc() {
                  return __awaiter(this, void 0, void 0, function* () {
                    this.crc = yield this.tokenizer.readNumber(Token.INT16_BE);
                    this.offset += 2;
                    return this.skipSideInformation();
                  });
                }
                skipSideInformation() {
                  return __awaiter(this, void 0, void 0, function* () {
                    const sideinfo_length = this.audioFrameHeader.calculateSideInfoLength();
                    yield this.tokenizer.readToken(new Token.BufferType(sideinfo_length));
                    this.offset += sideinfo_length;
                    yield this.readXtraInfoHeader();
                    return;
                  });
                }
                readXtraInfoHeader() {
                  return __awaiter(this, void 0, void 0, function* () {
                    const headerTag = yield this.tokenizer.readToken(XingTag_1.InfoTagHeaderTag);
                    this.offset += XingTag_1.InfoTagHeaderTag.len;
                    switch (headerTag) {
                      case "Info":
                        this.metadata.setFormat("codecProfile", "CBR");
                        return this.readXingInfoHeader();
                      case "Xing":
                        const infoTag = yield this.readXingInfoHeader();
                        const codecProfile = getVbrCodecProfile(infoTag.vbrScale);
                        this.metadata.setFormat("codecProfile", codecProfile);
                        return null;
                      case "Xtra":
                        break;
                      case "LAME":
                        const version = yield this.tokenizer.readToken(XingTag_1.LameEncoderVersion);
                        this.offset += XingTag_1.LameEncoderVersion.len;
                        this.metadata.setFormat("tool", "LAME " + version);
                        yield this.skipFrameData(this.frame_size - this.offset);
                        return null;
                    }
                    const frameDataLeft = this.frame_size - this.offset;
                    if (frameDataLeft < 0) {
                      this.warnings.push("Frame " + this.frameCount + "corrupt: negative frameDataLeft");
                    } else {
                      yield this.skipFrameData(frameDataLeft);
                    }
                    return null;
                  });
                }
                /**
                 * Ref: http://gabriel.mp3-tech.org/mp3infotag.html
                 * @returns {Promise<string>}
                 */
                readXingInfoHeader() {
                  return __awaiter(this, void 0, void 0, function* () {
                    const infoTag = yield this.tokenizer.readToken(XingTag_1.XingInfoTag);
                    this.offset += XingTag_1.XingInfoTag.len;
                    this.metadata.setFormat("tool", Util_1.default.stripNulls(infoTag.encoder));
                    if ((infoTag.headerFlags[3] & 1) === 1) {
                      const duration = this.audioFrameHeader.calcDuration(infoTag.numFrames);
                      this.metadata.setFormat("duration", duration);
                      debug("Get duration from Xing header: %s", this.metadata.format.duration);
                      return infoTag;
                    }
                    const frameDataLeft = this.frame_size - this.offset;
                    yield this.skipFrameData(frameDataLeft);
                    return infoTag;
                  });
                }
                skipFrameData(frameDataLeft) {
                  return __awaiter(this, void 0, void 0, function* () {
                    assert.ok(frameDataLeft >= 0, "frame-data-left cannot be negative");
                    yield this.tokenizer.readToken(new Token.IgnoreType(frameDataLeft));
                    this.countSkipFrameData += frameDataLeft;
                  });
                }
                areAllSame(array) {
                  const first = array[0];
                  return array.every((element) => {
                    return element === first;
                  });
                }
              }
              exports2.MpegParser = MpegParser;
            }).call(this, __webpack_require__2(9).Buffer);
          },
          /* 167 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const Token = __webpack_require__2(6);
            exports2.InfoTagHeaderTag = new Token.StringType(4, "ascii");
            exports2.LameEncoderVersion = new Token.StringType(6, "ascii");
            exports2.XingInfoTag = {
              len: 136,
              get: (buf, off) => {
                return {
                  // === ZONE A - Traditional Xing VBR Tag data ===
                  // 4 bytes for HeaderFlags
                  headerFlags: new Token.BufferType(4).get(buf, off),
                  numFrames: Token.UINT32_BE.get(buf, off + 4),
                  streamSize: Token.UINT32_BE.get(buf, off + 8),
                  // the number of header data bytes (from original file)
                  vbrScale: Token.UINT32_BE.get(buf, off + 112),
                  /**
                   * LAME Tag, extends the Xing header format
                   * First added in LAME 3.12 for VBR
                   * The modified header is also included in CBR files (effective LAME 3.94), with "Info" instead of "XING" near the beginning.
                   */
                  // === ZONE B - Initial LAME info  ===
                  //  Initial LAME info, e.g.: LAME3.99r
                  encoder: new Token.StringType(9, "ascii").get(buf, off + 116),
                  // 	 Info tag revision
                  infoTagRevision: Token.UINT8.get(buf, off + 125) >> 4,
                  // VBR method
                  vbrMethod: Token.UINT8.get(buf, off + 125) & 15
                  // $A5
                };
              }
            };
          },
          /* 168 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))(function(resolve2, reject2) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function rejected(value) {
                  try {
                    step(generator["throw"](value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function step(result) {
                  result.done ? resolve2(result.value) : new P(function(resolve3) {
                    resolve3(result.value);
                  }).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
              });
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            const initDebug = __webpack_require__2(8);
            const Token = __webpack_require__2(6);
            const MpcSv8Parser_1 = __webpack_require__2(169);
            const MpcSv7Parser_1 = __webpack_require__2(171);
            const AbstractID3Parser_1 = __webpack_require__2(46);
            const debug = initDebug("music-metadata:parser:musepack");
            class MusepackParser extends AbstractID3Parser_1.AbstractID3Parser {
              _parse() {
                return __awaiter(this, void 0, void 0, function* () {
                  const signature = yield this.tokenizer.peekToken(new Token.StringType(3, "binary"));
                  let mpcParser;
                  switch (signature) {
                    case "MP+": {
                      debug("Musepack stream-version 7");
                      mpcParser = new MpcSv7Parser_1.MpcSv7Parser();
                      break;
                    }
                    case "MPC": {
                      debug("Musepack stream-version 8");
                      mpcParser = new MpcSv8Parser_1.MpcSv8Parser();
                      break;
                    }
                    default: {
                      throw new Error("Invalid Musepack signature prefix");
                    }
                  }
                  mpcParser.init(this.metadata, this.tokenizer, this.options);
                  return mpcParser.parse();
                });
              }
            }
            exports2.default = MusepackParser;
          },
          /* 169 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))(function(resolve2, reject2) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function rejected(value) {
                  try {
                    step(generator["throw"](value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function step(result) {
                  result.done ? resolve2(result.value) : new P(function(resolve3) {
                    resolve3(result.value);
                  }).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
              });
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            const initDebug = __webpack_require__2(8);
            const assert = __webpack_require__2(18);
            const BasicParser_1 = __webpack_require__2(20);
            const SV8 = __webpack_require__2(170);
            const APEv2Parser_1 = __webpack_require__2(45);
            const FourCC_1 = __webpack_require__2(15);
            const debug = initDebug("music-metadata:parser:musepack");
            class MpcSv8Parser extends BasicParser_1.BasicParser {
              constructor() {
                super(...arguments);
                this.audioLength = 0;
              }
              parse() {
                return __awaiter(this, void 0, void 0, function* () {
                  const signature = yield this.tokenizer.readToken(FourCC_1.FourCcToken);
                  assert.equal(signature, "MPCK", "Magic number");
                  this.metadata.setFormat("dataformat", "Musepack, SV8");
                  return this.parsePacket();
                });
              }
              parsePacket() {
                return __awaiter(this, void 0, void 0, function* () {
                  const sv8reader = new SV8.StreamReader(this.tokenizer);
                  do {
                    const header = yield sv8reader.readPacketHeader();
                    debug(`packet-header key=${header.key}, payloadLength=${header.payloadLength}`);
                    switch (header.key) {
                      case "SH":
                        const sh = yield sv8reader.readStreamHeader(header.payloadLength);
                        this.metadata.setFormat("numberOfSamples", sh.sampleCount);
                        this.metadata.setFormat("sampleRate", sh.sampleFrequency);
                        this.metadata.setFormat("duration", sh.sampleCount / sh.sampleFrequency);
                        this.metadata.setFormat("numberOfChannels", sh.channelCount);
                        break;
                      case "AP":
                        this.audioLength += header.payloadLength;
                        yield this.tokenizer.ignore(header.payloadLength);
                        break;
                      case "RG":
                      case "EI":
                      case "SO":
                      case "ST":
                      case "CT":
                        yield this.tokenizer.ignore(header.payloadLength);
                        break;
                      case "SE":
                        this.metadata.setFormat("bitrate", this.audioLength * 8 / this.metadata.format.duration);
                        return APEv2Parser_1.APEv2Parser.parseTagHeader(this.metadata, this.tokenizer, this.options);
                      default:
                        throw new Error(`Unexpected header: ${header.key}`);
                    }
                  } while (true);
                });
              }
            }
            exports2.MpcSv8Parser = MpcSv8Parser;
          },
          /* 170 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))(function(resolve2, reject2) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function rejected(value) {
                  try {
                    step(generator["throw"](value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function step(result) {
                  result.done ? resolve2(result.value) : new P(function(resolve3) {
                    resolve3(result.value);
                  }).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
              });
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            const Token = __webpack_require__2(6);
            const Util_1 = __webpack_require__2(14);
            const initDebug = __webpack_require__2(8);
            const debug = initDebug("music-metadata:parser:musepack:sv8");
            const PacketKey = new Token.StringType(2, "binary");
            const SH_part1 = {
              len: 5,
              get: (buf, off) => {
                return {
                  crc: Token.UINT32_LE.get(buf, off),
                  streamVersion: Token.UINT8.get(buf, off + 4)
                };
              }
            };
            const SH_part3 = {
              len: 2,
              get: (buf, off) => {
                return {
                  sampleFrequency: [44100, 48e3, 37800, 32e3][Util_1.default.getBitAllignedNumber(buf, off, 0, 3)],
                  maxUsedBands: Util_1.default.getBitAllignedNumber(buf, off, 3, 5),
                  channelCount: Util_1.default.getBitAllignedNumber(buf, off + 1, 0, 4) + 1,
                  msUsed: Util_1.default.isBitSet(buf, off + 1, 4),
                  audioBlockFrames: Util_1.default.getBitAllignedNumber(buf, off + 1, 5, 3)
                };
              }
            };
            class StreamReader {
              constructor(tokenizer) {
                this.tokenizer = tokenizer;
              }
              readPacketHeader() {
                return __awaiter(this, void 0, void 0, function* () {
                  const key = yield this.tokenizer.readToken(PacketKey);
                  const size = yield this.readVariableSizeField();
                  return {
                    key,
                    payloadLength: size.value - 2 - size.len
                  };
                });
              }
              readStreamHeader(size) {
                return __awaiter(this, void 0, void 0, function* () {
                  const streamHeader = {};
                  debug(`Reading SH at offset=${this.tokenizer.position}`);
                  const part1 = yield this.tokenizer.readToken(SH_part1);
                  size -= SH_part1.len;
                  Object.assign(streamHeader, part1);
                  debug(`SH.streamVersion = ${part1.streamVersion}`);
                  const sampleCount = yield this.readVariableSizeField();
                  size -= sampleCount.len;
                  streamHeader.sampleCount = sampleCount.value;
                  const bs = yield this.readVariableSizeField();
                  size -= bs.len;
                  streamHeader.beginningOfSilence = bs.value;
                  const part3 = yield this.tokenizer.readToken(SH_part3);
                  size -= SH_part3.len;
                  Object.assign(streamHeader, part3);
                  yield this.tokenizer.ignore(size);
                  return streamHeader;
                });
              }
              readVariableSizeField(len = 1, hb = 0) {
                return __awaiter(this, void 0, void 0, function* () {
                  let n = yield this.tokenizer.readToken(Token.UINT8);
                  if ((n & 128) === 0) {
                    return { len, value: hb + n };
                  }
                  n &= 127;
                  n += hb;
                  return this.readVariableSizeField(len + 1, n << 7);
                });
              }
            }
            exports2.StreamReader = StreamReader;
          },
          /* 171 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))(function(resolve2, reject2) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function rejected(value) {
                  try {
                    step(generator["throw"](value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function step(result) {
                  result.done ? resolve2(result.value) : new P(function(resolve3) {
                    resolve3(result.value);
                  }).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
              });
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            const initDebug = __webpack_require__2(8);
            const assert = __webpack_require__2(18);
            const BasicParser_1 = __webpack_require__2(20);
            const SV7 = __webpack_require__2(172);
            const APEv2Parser_1 = __webpack_require__2(45);
            const BitReader_1 = __webpack_require__2(173);
            const debug = initDebug("music-metadata:parser:musepack");
            class MpcSv7Parser extends BasicParser_1.BasicParser {
              constructor() {
                super(...arguments);
                this.audioLength = 0;
              }
              parse() {
                return __awaiter(this, void 0, void 0, function* () {
                  const header = yield this.tokenizer.readToken(SV7.Header);
                  assert.equal(header.signature, "MP+", "Magic number");
                  debug(`stream-version=${header.streamMajorVersion}.${header.streamMinorVersion}`);
                  this.metadata.setFormat("dataformat", "Musepack, SV7");
                  this.metadata.setFormat("sampleRate", header.sampleFrequency);
                  const numberOfSamples = 1152 * (header.frameCount - 1) + header.lastFrameLength;
                  this.metadata.setFormat("numberOfSamples", numberOfSamples);
                  this.duration = numberOfSamples / header.sampleFrequency;
                  this.metadata.setFormat("duration", this.duration);
                  this.bitreader = new BitReader_1.BitReader(this.tokenizer);
                  this.metadata.setFormat("numberOfChannels", header.midSideStereo || header.intensityStereo ? 2 : 1);
                  const version = yield this.bitreader.read(8);
                  this.metadata.setFormat("encoder", (version / 100).toFixed(2));
                  yield this.skipAudioData(header.frameCount);
                  debug(`End of audio stream, switching to APEv2, offset=${this.tokenizer.position}`);
                  return APEv2Parser_1.APEv2Parser.parseTagHeader(this.metadata, this.tokenizer, this.options);
                });
              }
              skipAudioData(frameCount) {
                return __awaiter(this, void 0, void 0, function* () {
                  while (frameCount-- > 0) {
                    const frameLength = yield this.bitreader.read(20);
                    this.audioLength += 20 + frameLength;
                    yield this.bitreader.ignore(frameLength);
                  }
                  const lastFrameLength = yield this.bitreader.read(11);
                  this.audioLength += lastFrameLength;
                  this.metadata.setFormat("bitrate", this.audioLength / this.duration);
                });
              }
            }
            exports2.MpcSv7Parser = MpcSv7Parser;
          },
          /* 172 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const Token = __webpack_require__2(6);
            const Util_1 = __webpack_require__2(14);
            exports2.Header = {
              len: 6 * 4,
              get: (buf, off) => {
                const header = {
                  // word 0
                  signature: buf.toString("binary", off, off + 3),
                  // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)
                  streamMinorVersion: Util_1.default.getBitAllignedNumber(buf, off + 3, 0, 4),
                  streamMajorVersion: Util_1.default.getBitAllignedNumber(buf, off + 3, 4, 4),
                  // word 1
                  frameCount: Token.UINT32_LE.get(buf, off + 4),
                  // word 2
                  maxLevel: Token.UINT16_LE.get(buf, off + 8),
                  sampleFrequency: [44100, 48e3, 37800, 32e3][Util_1.default.getBitAllignedNumber(buf, off + 10, 0, 2)],
                  link: Util_1.default.getBitAllignedNumber(buf, off + 10, 2, 2),
                  profile: Util_1.default.getBitAllignedNumber(buf, off + 10, 4, 4),
                  maxBand: Util_1.default.getBitAllignedNumber(buf, off + 11, 0, 6),
                  intensityStereo: Util_1.default.isBitSet(buf, off + 11, 6),
                  midSideStereo: Util_1.default.isBitSet(buf, off + 11, 7),
                  // word 3
                  titlePeak: Token.UINT16_LE.get(buf, off + 12),
                  titleGain: Token.UINT16_LE.get(buf, off + 14),
                  // word 4
                  albumPeak: Token.UINT16_LE.get(buf, off + 16),
                  albumGain: Token.UINT16_LE.get(buf, off + 18),
                  // word
                  lastFrameLength: Token.UINT32_LE.get(buf, off + 20) >>> 20 & 2047,
                  trueGapless: Util_1.default.isBitSet(buf, off + 23, 0)
                };
                header.lastFrameLength = header.trueGapless ? Token.UINT32_LE.get(buf, 20) >>> 20 & 2047 : 0;
                return header;
              }
            };
          },
          /* 173 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))(function(resolve2, reject2) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function rejected(value) {
                  try {
                    step(generator["throw"](value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function step(result) {
                  result.done ? resolve2(result.value) : new P(function(resolve3) {
                    resolve3(result.value);
                  }).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
              });
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            const Token = __webpack_require__2(6);
            class BitReader {
              constructor(tokenizer) {
                this.tokenizer = tokenizer;
                this.pos = 0;
                this.dword = void 0;
              }
              /**
               *
               * @param bits 1..30 bits
               */
              read(bits) {
                return __awaiter(this, void 0, void 0, function* () {
                  while (this.dword === void 0) {
                    this.dword = yield this.tokenizer.readToken(Token.UINT32_LE);
                  }
                  let out = this.dword;
                  this.pos += bits;
                  if (this.pos < 32) {
                    out >>>= 32 - this.pos;
                    return out & (1 << bits) - 1;
                  } else {
                    this.pos -= 32;
                    if (this.pos === 0) {
                      this.dword = void 0;
                      return out & (1 << bits) - 1;
                    } else {
                      this.dword = yield this.tokenizer.readToken(Token.UINT32_LE);
                      if (this.pos) {
                        out <<= this.pos;
                        out |= this.dword >>> 32 - this.pos;
                      }
                      return out & (1 << bits) - 1;
                    }
                  }
                });
              }
              ignore(bits) {
                return __awaiter(this, void 0, void 0, function* () {
                  if (this.pos > 0) {
                    const remaining = 32 - this.pos;
                    this.dword = void 0;
                    bits -= remaining;
                    this.pos = 0;
                  }
                  const remainder = bits % 32;
                  const numOfWords = (bits - remainder) / 32;
                  yield this.tokenizer.ignore(numOfWords * 4);
                  return this.read(remainder);
                });
              }
            }
            exports2.BitReader = BitReader;
          },
          /* 174 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))(function(resolve2, reject2) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function rejected(value) {
                  try {
                    step(generator["throw"](value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function step(result) {
                  result.done ? resolve2(result.value) : new P(function(resolve3) {
                    resolve3(result.value);
                  }).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
              });
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            const Token = __webpack_require__2(6);
            const initDebug = __webpack_require__2(8);
            const assert = __webpack_require__2(18);
            const Util_1 = __webpack_require__2(14);
            const FourCC_1 = __webpack_require__2(15);
            const VorbisParser_1 = __webpack_require__2(54);
            const OpusParser_1 = __webpack_require__2(175);
            const SpeexParser_1 = __webpack_require__2(177);
            const BasicParser_1 = __webpack_require__2(20);
            const debug = initDebug("music-metadata:parser:ogg");
            class SegmentTable {
              static sum(buf, off, len) {
                let s = 0;
                for (let i = off; i < off + len; ++i) {
                  s += buf[i];
                }
                return s;
              }
              constructor(header) {
                this.len = header.page_segments;
              }
              get(buf, off) {
                return {
                  totalPageSize: SegmentTable.sum(buf, off, this.len)
                };
              }
            }
            exports2.SegmentTable = SegmentTable;
            class OggParser extends BasicParser_1.BasicParser {
              /**
               * Parse page
               * @returns {Promise<void>}
               */
              parse() {
                return __awaiter(this, void 0, void 0, function* () {
                  debug("pos=%s, parsePage()", this.tokenizer.position);
                  try {
                    let header;
                    do {
                      header = yield this.tokenizer.readToken(OggParser.Header);
                      assert.strictEqual(header.capturePattern, "OggS", "Ogg capture pattern");
                      this.header = header;
                      this.pageNumber = header.pageSequenceNo;
                      debug("page#=%s, Ogg.id=%s", header.pageSequenceNo, header.capturePattern);
                      const segmentTable = yield this.tokenizer.readToken(new SegmentTable(header));
                      debug("totalPageSize=%s", segmentTable.totalPageSize);
                      const pageData = yield this.tokenizer.readToken(new Token.BufferType(segmentTable.totalPageSize));
                      debug("firstPage=%s, lastPage=%s, continued=%s", header.headerType.firstPage, header.headerType.lastPage, header.headerType.continued);
                      if (header.headerType.firstPage) {
                        const id = new Token.StringType(7, "ascii").get(pageData, 0);
                        switch (id) {
                          case "vorbis":
                            debug("Set page consumer to Ogg/Vorbis ");
                            this.pageConsumer = new VorbisParser_1.VorbisParser(this.metadata, this.options);
                            break;
                          case "OpusHea":
                            debug("Set page consumer to Ogg/Opus");
                            this.pageConsumer = new OpusParser_1.OpusParser(this.metadata, this.options, this.tokenizer);
                            break;
                          case "Speex  ":
                            debug("Set page consumer to Ogg/Speex");
                            this.pageConsumer = new SpeexParser_1.SpeexParser(this.metadata, this.options, this.tokenizer);
                            break;
                          default:
                            throw new Error("gg audio-codec not recognized (id=" + id + ")");
                        }
                        this.metadata.setFormat("dataformat", "Ogg/" + this.pageConsumer.codecName);
                      }
                      this.pageConsumer.parsePage(header, pageData);
                    } while (!header.headerType.lastPage);
                  } catch (err) {
                    if (err.message === "End-Of-File") {
                      return;
                    } else if (err.message.startsWith("FourCC")) {
                      if (this.pageNumber > 0) {
                        this.warnings.push("Invalid FourCC ID, maybe last OGG-page is not marked with last-page flag");
                        return this.pageConsumer.flush();
                      }
                    }
                    throw err;
                  }
                });
              }
            }
            OggParser.Header = {
              len: 27,
              get: (buf, off) => {
                return {
                  capturePattern: FourCC_1.FourCcToken.get(buf, off),
                  version: buf.readUInt8(off + 4),
                  headerType: {
                    continued: Util_1.default.strtokBITSET.get(buf, off + 5, 0),
                    firstPage: Util_1.default.strtokBITSET.get(buf, off + 5, 1),
                    lastPage: Util_1.default.strtokBITSET.get(buf, off + 5, 2)
                  },
                  // packet_flag: buf.readUInt8(off + 5),
                  absoluteGranulePosition: buf.readIntLE(off + 6, 6),
                  streamSerialNumber: Token.UINT32_LE.get(buf, off + 14),
                  pageSequenceNo: Token.UINT32_LE.get(buf, off + 18),
                  pageChecksum: Token.UINT32_LE.get(buf, off + 22),
                  page_segments: buf.readUInt8(off + 26)
                };
              }
            };
            exports2.OggParser = OggParser;
          },
          /* 175 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const Token = __webpack_require__2(6);
            const Opus = __webpack_require__2(176);
            const VorbisParser_1 = __webpack_require__2(54);
            class OpusParser extends VorbisParser_1.VorbisParser {
              constructor(metadata, options, tokenizer) {
                super(metadata, options);
                this.tokenizer = tokenizer;
                this.codecName = "Opus";
                this.lastPos = -1;
              }
              /**
               * Parse first Opus Ogg page
               * @param {IPageHeader} header
               * @param {Buffer} pageData
               */
              parseFirstPage(header, pageData) {
                this.idHeader = new Opus.IdHeader(pageData.length).get(pageData, 0);
                if (this.idHeader.magicSignature !== "OpusHead")
                  throw new Error("Illegal ogg/Opus magic-signature");
                this.metadata.setFormat("sampleRate", this.idHeader.inputSampleRate);
                this.metadata.setFormat("numberOfChannels", this.idHeader.channelCount);
              }
              parseFullPage(pageData) {
                const magicSignature = new Token.StringType(8, "ascii").get(pageData, 0);
                switch (magicSignature) {
                  case "OpusTags":
                    this.parseUserCommentList(pageData, 8);
                    this.lastPos = this.tokenizer.position;
                    break;
                  default:
                    break;
                }
              }
              calculateDuration(header) {
                if (this.metadata.format.sampleRate && header.absoluteGranulePosition >= 0) {
                  this.metadata.setFormat("numberOfSamples", header.absoluteGranulePosition - this.idHeader.preSkip);
                  this.metadata.setFormat("duration", this.metadata.format.numberOfSamples / this.idHeader.inputSampleRate);
                  if (this.lastPos !== -1 && this.tokenizer.fileSize && this.metadata.format.duration) {
                    const dataSize = this.tokenizer.fileSize - this.lastPos;
                    this.metadata.setFormat("bitrate", 8 * dataSize / this.metadata.format.duration);
                  }
                }
              }
            }
            exports2.OpusParser = OpusParser;
          },
          /* 176 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const Token = __webpack_require__2(6);
            class IdHeader {
              constructor(len) {
                this.len = len;
                if (len < 19) {
                  throw new Error("ID-header-page 0 should be at least 19 bytes long");
                }
              }
              get(buf, off) {
                return {
                  magicSignature: new Token.StringType(8, "ascii").get(buf, off + 0),
                  version: buf.readUInt8(off + 8),
                  channelCount: buf.readUInt8(off + 9),
                  preSkip: buf.readInt16LE(off + 10),
                  inputSampleRate: buf.readInt32LE(off + 12),
                  outputGain: buf.readInt16LE(off + 16),
                  channelMapping: buf.readUInt8(off + 18)
                };
              }
            }
            exports2.IdHeader = IdHeader;
          },
          /* 177 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const initDebug = __webpack_require__2(8);
            const Speex = __webpack_require__2(178);
            const VorbisParser_1 = __webpack_require__2(54);
            const debug = initDebug("music-metadata:parser:ogg:speex");
            class SpeexParser extends VorbisParser_1.VorbisParser {
              constructor(metadata, options, tokenizer) {
                super(metadata, options);
                this.tokenizer = tokenizer;
                this.codecName = "Speex";
                this.lastPos = -1;
              }
              /**
               * Parse first Speex Ogg page
               * @param {IPageHeader} header
               * @param {Buffer} pageData
               */
              parseFirstPage(header, pageData) {
                debug("First Ogg/Speex page");
                let speexHeader = Speex.Header.get(pageData, 0);
                speexHeader = speexHeader;
                this.metadata.setFormat("numberOfChannels", speexHeader.nb_channels);
                this.metadata.setFormat("sampleRate", speexHeader.rate);
                this.metadata.setFormat("encoder", speexHeader.version);
                if (speexHeader.bitrate !== -1) {
                  this.metadata.setFormat("bitrate", speexHeader.bitrate);
                }
              }
            }
            exports2.SpeexParser = SpeexParser;
          },
          /* 178 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const Token = __webpack_require__2(6);
            const Util_1 = __webpack_require__2(14);
            exports2.Header = {
              len: 80,
              get: (buf, off) => {
                return {
                  speex: new Token.StringType(8, "ascii").get(buf, off + 0),
                  version: Util_1.default.trimRightNull(new Token.StringType(20, "ascii").get(buf, off + 8)),
                  version_id: buf.readInt32LE(off + 28),
                  header_size: buf.readInt32LE(off + 32),
                  rate: buf.readInt32LE(off + 36),
                  mode: buf.readInt32LE(off + 40),
                  mode_bitstream_version: buf.readInt32LE(off + 44),
                  nb_channels: buf.readInt32LE(off + 48),
                  bitrate: buf.readInt32LE(off + 52),
                  frame_size: buf.readInt32LE(off + 56),
                  vbr: buf.readInt32LE(off + 60),
                  frames_per_packet: buf.readInt32LE(off + 64),
                  extra_headers: buf.readInt32LE(off + 68),
                  reserved1: buf.readInt32LE(off + 72),
                  reserved2: buf.readInt32LE(off + 76)
                };
              }
            };
          },
          /* 179 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))(function(resolve2, reject2) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function rejected(value) {
                  try {
                    step(generator["throw"](value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function step(result) {
                  result.done ? resolve2(result.value) : new P(function(resolve3) {
                    resolve3(result.value);
                  }).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
              });
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            const type_1 = __webpack_require__2(22);
            const strtok3 = __webpack_require__2(43);
            const Token = __webpack_require__2(6);
            const initDebug = __webpack_require__2(8);
            const riff = __webpack_require__2(180);
            const WaveChunk = __webpack_require__2(181);
            const ID3v2Parser_1 = __webpack_require__2(32);
            const Util_1 = __webpack_require__2(14);
            const FourCC_1 = __webpack_require__2(15);
            const BasicParser_1 = __webpack_require__2(20);
            const ID3Stream_1 = __webpack_require__2(49);
            const debug = initDebug("music-metadata:parser:RIFF");
            class WaveParser extends BasicParser_1.BasicParser {
              parse() {
                return __awaiter(this, void 0, void 0, function* () {
                  const riffHeader = yield this.tokenizer.readToken(riff.Header);
                  debug(`pos=${this.tokenizer.position}, parse: chunkID=${riffHeader.chunkID}`);
                  if (riffHeader.chunkID !== "RIFF")
                    return;
                  return this.parseRiffChunk().catch((err) => {
                    if (err.message !== type_1.endOfFile) {
                      throw err;
                    }
                  });
                });
              }
              parseRiffChunk() {
                return __awaiter(this, void 0, void 0, function* () {
                  const type = yield this.tokenizer.readToken(FourCC_1.FourCcToken);
                  this.metadata.setFormat("dataformat", type);
                  switch (type) {
                    case "WAVE":
                      return this.readWaveChunk();
                    default:
                      throw new Error(`Unsupported RIFF format: RIFF/${type}`);
                  }
                });
              }
              readWaveChunk() {
                return __awaiter(this, void 0, void 0, function* () {
                  do {
                    const header = yield this.tokenizer.readToken(riff.Header);
                    this.header = header;
                    debug(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${header.chunkID}`);
                    switch (header.chunkID) {
                      case "LIST":
                        yield this.parseListTag(header);
                        break;
                      case "fact":
                        this.metadata.setFormat("lossless", false);
                        this.fact = yield this.tokenizer.readToken(new WaveChunk.FactChunk(header));
                        break;
                      case "fmt ":
                        const fmt = yield this.tokenizer.readToken(new WaveChunk.Format(header));
                        let subFormat = WaveChunk.WaveFormat[fmt.wFormatTag];
                        if (!subFormat) {
                          debug("WAVE/non-PCM format=" + fmt.wFormatTag);
                          subFormat = "non-PCM (" + fmt.wFormatTag + ")";
                        }
                        this.metadata.setFormat("dataformat", "WAVE/" + subFormat);
                        this.metadata.setFormat("bitsPerSample", fmt.wBitsPerSample);
                        this.metadata.setFormat("sampleRate", fmt.nSamplesPerSec);
                        this.metadata.setFormat("numberOfChannels", fmt.nChannels);
                        this.metadata.setFormat("bitrate", fmt.nBlockAlign * fmt.nSamplesPerSec * 8);
                        this.blockAlign = fmt.nBlockAlign;
                        break;
                      case "id3 ":
                      case "ID3 ":
                        const id3_data = yield this.tokenizer.readToken(new Token.BufferType(header.chunkSize));
                        const id3stream = new ID3Stream_1.ID3Stream(id3_data);
                        const rst = strtok3.fromStream(id3stream);
                        yield new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);
                        break;
                      case "data":
                        if (this.metadata.format.lossless !== false) {
                          this.metadata.setFormat("lossless", true);
                        }
                        const numberOfSamples = this.fact ? this.fact.dwSampleLength : header.chunkSize / this.blockAlign;
                        this.metadata.setFormat("numberOfSamples", numberOfSamples);
                        this.metadata.setFormat("duration", numberOfSamples / this.metadata.format.sampleRate);
                        this.metadata.setFormat("bitrate", this.metadata.format.numberOfChannels * this.blockAlign * this.metadata.format.sampleRate);
                        yield this.tokenizer.ignore(header.chunkSize);
                        break;
                      default:
                        debug(`Ignore chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);
                        this.warnings.push("Ignore chunk: RIFF/" + header.chunkID);
                        yield this.tokenizer.ignore(header.chunkSize);
                    }
                    if (this.header.chunkSize % 2 === 1) {
                      debug("Read odd padding byte");
                      yield this.tokenizer.ignore(1);
                    }
                  } while (true);
                });
              }
              parseListTag(listHeader) {
                return __awaiter(this, void 0, void 0, function* () {
                  const listType = yield this.tokenizer.readToken(FourCC_1.FourCcToken);
                  debug("pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s", this.tokenizer.position, listType);
                  switch (listType) {
                    case "INFO":
                      return this.parseRiffInfoTags(listHeader.chunkSize - 4);
                    case "adtl":
                    default:
                      this.warnings.push("Ignore chunk: RIFF/WAVE/LIST/" + listType);
                      debug("Ignoring chunkID=RIFF/WAVE/LIST/" + listType);
                      return this.tokenizer.ignore(listHeader.chunkSize - 4);
                  }
                });
              }
              parseRiffInfoTags(chunkSize) {
                return __awaiter(this, void 0, void 0, function* () {
                  while (chunkSize >= 8) {
                    const header = yield this.tokenizer.readToken(riff.Header);
                    const valueToken = new riff.ListInfoTagValue(header);
                    const value = yield this.tokenizer.readToken(valueToken);
                    this.addTag(header.chunkID, Util_1.default.stripNulls(value));
                    chunkSize -= 8 + valueToken.len;
                  }
                  if (chunkSize !== 0) {
                    throw Error("Illegal remaining size: " + chunkSize);
                  }
                });
              }
              addTag(id, value) {
                this.metadata.addTag("exif", id, value);
              }
            }
            exports2.WaveParser = WaveParser;
          },
          /* 180 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const Token = __webpack_require__2(6);
            const FourCC_1 = __webpack_require__2(15);
            exports2.Header = {
              len: 8,
              get: (buf, off) => {
                return {
                  // Group-ID
                  chunkID: FourCC_1.FourCcToken.get(buf, off),
                  // Size
                  chunkSize: buf.readUInt32LE(off + 4)
                };
              }
            };
            class ListInfoTagValue {
              constructor(tagHeader) {
                this.tagHeader = tagHeader;
                this.len = tagHeader.chunkSize;
                this.len += this.len & 1;
              }
              get(buf, off) {
                return new Token.StringType(this.tagHeader.chunkSize, "ascii").get(buf, off);
              }
            }
            exports2.ListInfoTagValue = ListInfoTagValue;
          },
          /* 181 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const assert = __webpack_require__2(18);
            var WaveFormat;
            (function(WaveFormat2) {
              WaveFormat2[WaveFormat2["PCM"] = 1] = "PCM";
              WaveFormat2[WaveFormat2["ADPCM"] = 2] = "ADPCM";
              WaveFormat2[WaveFormat2["IEEE_FLOAT"] = 3] = "IEEE_FLOAT";
              WaveFormat2[WaveFormat2["MPEG_ADTS_AAC"] = 5632] = "MPEG_ADTS_AAC";
              WaveFormat2[WaveFormat2["MPEG_LOAS"] = 5634] = "MPEG_LOAS";
              WaveFormat2[WaveFormat2["RAW_AAC1"] = 255] = "RAW_AAC1";
              WaveFormat2[WaveFormat2["DOLBY_AC3_SPDIF"] = 146] = "DOLBY_AC3_SPDIF";
              WaveFormat2[WaveFormat2["DVM"] = 8192] = "DVM";
              WaveFormat2[WaveFormat2["RAW_SPORT"] = 576] = "RAW_SPORT";
              WaveFormat2[WaveFormat2["ESST_AC3"] = 577] = "ESST_AC3";
              WaveFormat2[WaveFormat2["DRM"] = 9] = "DRM";
              WaveFormat2[WaveFormat2["DTS2"] = 8193] = "DTS2";
              WaveFormat2[WaveFormat2["MPEG"] = 80] = "MPEG";
            })(WaveFormat = exports2.WaveFormat || (exports2.WaveFormat = {}));
            class Format {
              constructor(header) {
                assert.ok(header.chunkSize >= 16, "16 for PCM.");
                this.len = header.chunkSize;
              }
              get(buf, off) {
                return {
                  wFormatTag: buf.readUInt16LE(off),
                  nChannels: buf.readUInt16LE(off + 2),
                  nSamplesPerSec: buf.readUInt32LE(off + 4),
                  nAvgBytesPerSec: buf.readUInt32LE(off + 8),
                  nBlockAlign: buf.readUInt16LE(off + 12),
                  wBitsPerSample: buf.readUInt16LE(off + 14)
                };
              }
            }
            exports2.Format = Format;
            class FactChunk {
              constructor(header) {
                assert.ok(header.chunkSize >= 4, "minimum fact chunk size.");
                this.len = header.chunkSize;
              }
              get(buf, off) {
                return {
                  dwSampleLength: buf.readUInt32LE(off)
                };
              }
            }
            exports2.FactChunk = FactChunk;
          },
          /* 182 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            (function(Buffer2) {
              var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
                return new (P || (P = Promise))(function(resolve2, reject2) {
                  function fulfilled(value) {
                    try {
                      step(generator.next(value));
                    } catch (e) {
                      reject2(e);
                    }
                  }
                  function rejected(value) {
                    try {
                      step(generator["throw"](value));
                    } catch (e) {
                      reject2(e);
                    }
                  }
                  function step(result) {
                    result.done ? resolve2(result.value) : new P(function(resolve3) {
                      resolve3(result.value);
                    }).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
              };
              Object.defineProperty(exports2, "__esModule", { value: true });
              const Token = __webpack_require__2(6);
              const assert = __webpack_require__2(18);
              const APEv2Parser_1 = __webpack_require__2(45);
              const FourCC_1 = __webpack_require__2(15);
              const BasicParser_1 = __webpack_require__2(20);
              const WavPackToken_1 = __webpack_require__2(183);
              const initDebug = __webpack_require__2(8);
              const debug = initDebug("music-metadata:parser:WavPack");
              class WavPackParser extends BasicParser_1.BasicParser {
                parse() {
                  return __awaiter(this, void 0, void 0, function* () {
                    this.audioDataSize = 0;
                    yield this.parseWavPackBlocks();
                    return APEv2Parser_1.APEv2Parser.parseTagHeader(this.metadata, this.tokenizer, this.options);
                  });
                }
                parseWavPackBlocks() {
                  return __awaiter(this, void 0, void 0, function* () {
                    do {
                      const blockId = yield this.tokenizer.peekToken(FourCC_1.FourCcToken);
                      if (blockId !== "wvpk")
                        break;
                      const header = yield this.tokenizer.readToken(WavPackToken_1.WavPack.BlockHeaderToken);
                      assert.strictEqual(header.BlockID, "wvpk", "WavPack Block-ID");
                      debug(`WavPack header blockIndex=${header.blockIndex}, len=${WavPackToken_1.WavPack.BlockHeaderToken.len}`);
                      if (header.blockIndex === 0 && !this.metadata.format.dataformat) {
                        this.metadata.setFormat("dataformat", "WavPack");
                        this.metadata.setFormat("lossless", !header.flags.isHybrid);
                        this.metadata.setFormat("bitsPerSample", header.flags.bitsPerSample);
                        if (!header.flags.isDSD) {
                          this.metadata.setFormat("sampleRate", header.flags.samplingRate);
                          this.metadata.setFormat("duration", header.totalSamples / header.flags.samplingRate);
                        }
                        this.metadata.setFormat("numberOfChannels", header.flags.isMono ? 1 : 2);
                        this.metadata.setFormat("numberOfSamples", header.totalSamples);
                        this.metadata.setFormat("codecProfile", header.flags.isDSD ? "DSD" : "PCM");
                      }
                      const ignoreBytes = header.blockSize - (WavPackToken_1.WavPack.BlockHeaderToken.len - 8);
                      if (header.blockIndex === 0) {
                        yield this.parseMetadataSubBlock(header, ignoreBytes);
                      } else {
                        yield this.tokenizer.ignore(ignoreBytes);
                      }
                      if (header.blockSamples > 0) {
                        this.audioDataSize += header.blockSize;
                      }
                    } while (!this.tokenizer.fileSize || this.tokenizer.fileSize - this.tokenizer.position >= WavPackToken_1.WavPack.BlockHeaderToken.len);
                    this.metadata.setFormat("bitrate", this.audioDataSize * 8 / this.metadata.format.duration);
                  });
                }
                /**
                 * Ref: http://www.wavpack.com/WavPack5FileFormat.pdf, 3.0 Metadata Sub-blocks
                 * @param remainingLength
                 */
                parseMetadataSubBlock(header, remainingLength) {
                  return __awaiter(this, void 0, void 0, function* () {
                    while (remainingLength > WavPackToken_1.WavPack.MetadataIdToken.len) {
                      const id = yield this.tokenizer.readToken(WavPackToken_1.WavPack.MetadataIdToken);
                      const dataSizeInWords = yield this.tokenizer.readNumber(id.largeBlock ? Token.UINT24_LE : Token.UINT8);
                      const data = Buffer2.alloc(dataSizeInWords * 2 - (id.isOddSize ? 1 : 0));
                      yield this.tokenizer.readBuffer(data, 0, data.length);
                      debug(`Metadata Sub-Blocks functionId=0x${id.functionId.toString(16)}, id.largeBlock=${id.largeBlock},data-size=${data.length}`);
                      switch (id.functionId) {
                        case 0:
                          break;
                        case 14:
                          debug("ID_DSD_BLOCK");
                          const mp = 1 << data.readUInt8(0);
                          const samplingRate = header.flags.samplingRate * mp * 8;
                          assert.ok(header.flags.isDSD, "Only expect DSD block if DSD-flag is set");
                          this.metadata.setFormat("sampleRate", samplingRate);
                          this.metadata.setFormat("duration", header.totalSamples / samplingRate);
                          break;
                        case 36:
                          debug("ID_ALT_TRAILER: trailer for non-wav files");
                          break;
                        case 38:
                          this.metadata.setFormat("audioMD5", data);
                          break;
                        case 47:
                          debug(`ID_BLOCK_CHECKSUM: checksum=${data.toString("hex")}`);
                          break;
                        default:
                          debug(`Ignore unsupported meta-sub-block-id functionId=0x${id.functionId.toString(16)}`);
                          break;
                      }
                      remainingLength -= WavPackToken_1.WavPack.MetadataIdToken.len + (id.largeBlock ? Token.UINT24_LE.len : Token.UINT8.len) + dataSizeInWords * 2;
                      debug(`remainingLength=${remainingLength}`);
                      if (id.isOddSize)
                        this.tokenizer.ignore(1);
                    }
                    assert.strictEqual(remainingLength, 0, "metadata-sub-block should fit it remaining length");
                  });
                }
              }
              exports2.WavPackParser = WavPackParser;
            }).call(this, __webpack_require__2(9).Buffer);
          },
          /* 183 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const Token = __webpack_require__2(6);
            const FourCC_1 = __webpack_require__2(15);
            const SampleRates = [
              6e3,
              8e3,
              9600,
              11025,
              12e3,
              16e3,
              22050,
              24e3,
              32e3,
              44100,
              48e3,
              64e3,
              88200,
              96e3,
              192e3,
              -1
            ];
            class WavPack {
              static isBitSet(flags, bitOffset) {
                return WavPack.getBitAllignedNumber(flags, bitOffset, 1) === 1;
              }
              static getBitAllignedNumber(flags, bitOffset, len) {
                return flags >>> bitOffset & 4294967295 >>> 32 - len;
              }
            }
            WavPack.BlockHeaderToken = {
              len: 32,
              get: (buf, off) => {
                const flags = Token.UINT32_LE.get(buf, off + 24);
                const res = {
                  // should equal 'wvpk'
                  BlockID: FourCC_1.FourCcToken.get(buf, off),
                  //  0x402 to 0x410 are valid for decode
                  blockSize: Token.UINT32_LE.get(buf, off + 4),
                  //  0x402 (1026) to 0x410 are valid for decode
                  version: Token.UINT16_LE.get(buf, off + 8),
                  //  40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)
                  totalSamples: (Token.UINT8.get(buf, off + 11) << 32) + Token.UINT32_LE.get(buf, off + 12),
                  // 40-bit block_index
                  blockIndex: (Token.UINT8.get(buf, off + 10) << 32) + Token.UINT32_LE.get(buf, off + 16),
                  // 40-bit total samples for entire file (if block_index == 0 and a value of -1 indicates an unknown length)
                  blockSamples: Token.UINT32_LE.get(buf, off + 20),
                  // various flags for id and decoding
                  flags: {
                    bitsPerSample: (1 + WavPack.getBitAllignedNumber(flags, 0, 2)) * 8,
                    isMono: WavPack.isBitSet(flags, 2),
                    isHybrid: WavPack.isBitSet(flags, 3),
                    isJointStereo: WavPack.isBitSet(flags, 4),
                    crossChannel: WavPack.isBitSet(flags, 5),
                    hybridNoiseShaping: WavPack.isBitSet(flags, 6),
                    floatingPoint: WavPack.isBitSet(flags, 7),
                    samplingRate: SampleRates[WavPack.getBitAllignedNumber(flags, 23, 4)],
                    isDSD: WavPack.isBitSet(flags, 31)
                  },
                  // crc for actual decoded data
                  crc: new Token.BufferType(4).get(buf, off + 28)
                };
                if (res.flags.isDSD) {
                  res.totalSamples *= 8;
                }
                return res;
              }
            };
            WavPack.MetadataIdToken = {
              len: 1,
              get: (buf, off) => {
                return {
                  functionId: WavPack.getBitAllignedNumber(buf[off], 0, 6),
                  isOptional: WavPack.isBitSet(buf[off], 5),
                  isOddSize: WavPack.isBitSet(buf[off], 6),
                  largeBlock: WavPack.isBitSet(buf[off], 7)
                };
              }
            };
            exports2.WavPack = WavPack;
          },
          /* 184 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))(function(resolve2, reject2) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function rejected(value) {
                  try {
                    step(generator["throw"](value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function step(result) {
                  result.done ? resolve2(result.value) : new P(function(resolve3) {
                    resolve3(result.value);
                  }).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
              });
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            const AbstractID3Parser_1 = __webpack_require__2(46);
            const assert = __webpack_require__2(18);
            const _debug = __webpack_require__2(8);
            const DsfChunk_1 = __webpack_require__2(185);
            const ID3v2Parser_1 = __webpack_require__2(32);
            const debug = _debug("music-metadata:parser:DSF");
            class DsfParser extends AbstractID3Parser_1.AbstractID3Parser {
              _parse() {
                return __awaiter(this, void 0, void 0, function* () {
                  const p0 = this.tokenizer.position;
                  const chunkHeader = yield this.tokenizer.readToken(DsfChunk_1.ChunkHeader);
                  assert.strictEqual(chunkHeader.id, "DSD ", "Invalid chunk signature");
                  this.metadata.setFormat("dataformat", "DSF");
                  this.metadata.setFormat("lossless", true);
                  const dsdChunk = yield this.tokenizer.readToken(DsfChunk_1.DsdChunk);
                  if (dsdChunk.metadataPointer === 0) {
                    debug(`No ID3v2 tag present`);
                  } else {
                    debug(`expect ID3v2 at offset=${dsdChunk.metadataPointer}`);
                    yield this.parseChunks(dsdChunk.fileSize - chunkHeader.size);
                    yield this.tokenizer.ignore(dsdChunk.metadataPointer - this.tokenizer.position - p0);
                    return new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, this.tokenizer, this.options);
                  }
                });
              }
              parseChunks(bytesRemaining) {
                return __awaiter(this, void 0, void 0, function* () {
                  while (bytesRemaining >= DsfChunk_1.ChunkHeader.len) {
                    const chunkHeader = yield this.tokenizer.readToken(DsfChunk_1.ChunkHeader);
                    debug(`Parsing chunk name=${chunkHeader.id} size=${chunkHeader.size}`);
                    switch (chunkHeader.id) {
                      case "fmt ":
                        const formatChunk = yield this.tokenizer.readToken(DsfChunk_1.FormatChunk);
                        this.metadata.setFormat("numberOfChannels", formatChunk.channelNum);
                        this.metadata.setFormat("sampleRate", formatChunk.samplingFrequency);
                        this.metadata.setFormat("bitsPerSample", formatChunk.bitsPerSample);
                        this.metadata.setFormat("numberOfSamples", formatChunk.sampleCount);
                        this.metadata.setFormat("duration", formatChunk.sampleCount / formatChunk.samplingFrequency);
                        const bitrate = formatChunk.bitsPerSample * formatChunk.samplingFrequency * formatChunk.channelNum;
                        this.metadata.setFormat("bitrate", bitrate);
                        return;
                      default:
                        this.tokenizer.ignore(chunkHeader.size - DsfChunk_1.ChunkHeader.len);
                        break;
                    }
                    bytesRemaining -= chunkHeader.size;
                  }
                });
              }
            }
            exports2.DsfParser = DsfParser;
          },
          /* 185 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const Token = __webpack_require__2(6);
            const FourCC_1 = __webpack_require__2(15);
            exports2.ChunkHeader = {
              len: 12,
              get: (buf, off) => {
                return { id: FourCC_1.FourCcToken.get(buf, off), size: Token.UINT64_LE.get(buf, off + 4) };
              }
            };
            exports2.DsdChunk = {
              len: 16,
              get: (buf, off) => {
                return {
                  fileSize: Token.INT64_LE.get(buf, off),
                  metadataPointer: Token.INT64_LE.get(buf, off + 8)
                };
              }
            };
            var ChannelType;
            (function(ChannelType2) {
              ChannelType2[ChannelType2["mono"] = 1] = "mono";
              ChannelType2[ChannelType2["stereo"] = 2] = "stereo";
              ChannelType2[ChannelType2["channels"] = 3] = "channels";
              ChannelType2[ChannelType2["quad"] = 4] = "quad";
              ChannelType2[ChannelType2["4 channels"] = 5] = "4 channels";
              ChannelType2[ChannelType2["5 channels"] = 6] = "5 channels";
              ChannelType2[ChannelType2["5.1 channels"] = 7] = "5.1 channels";
            })(ChannelType = exports2.ChannelType || (exports2.ChannelType = {}));
            exports2.FormatChunk = {
              len: 40,
              get: (buf, off) => {
                return {
                  formatVersion: Token.INT32_LE.get(buf, off),
                  formatID: Token.INT32_LE.get(buf, off + 4),
                  channelType: Token.INT32_LE.get(buf, off + 8),
                  channelNum: Token.INT32_LE.get(buf, off + 12),
                  samplingFrequency: Token.INT32_LE.get(buf, off + 16),
                  bitsPerSample: Token.INT32_LE.get(buf, off + 20),
                  sampleCount: Token.INT64_LE.get(buf, off + 24),
                  blockSizePerChannel: Token.INT32_LE.get(buf, off + 32)
                };
              }
            };
          },
          /* 186 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))(function(resolve2, reject2) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function rejected(value) {
                  try {
                    step(generator["throw"](value));
                  } catch (e) {
                    reject2(e);
                  }
                }
                function step(result) {
                  result.done ? resolve2(result.value) : new P(function(resolve3) {
                    resolve3(result.value);
                  }).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
              });
            };
            Object.defineProperty(exports2, "__esModule", { value: true });
            const assert = __webpack_require__2(18);
            const Token = __webpack_require__2(6);
            const initDebug = __webpack_require__2(8);
            const FourCC_1 = __webpack_require__2(15);
            const BasicParser_1 = __webpack_require__2(20);
            const ID3Stream_1 = __webpack_require__2(49);
            const DsdiffToken_1 = __webpack_require__2(187);
            const strtok3 = __webpack_require__2(43);
            const ID3v2Parser_1 = __webpack_require__2(32);
            const debug = initDebug("music-metadata:parser:aiff");
            class DsdiffParser extends BasicParser_1.BasicParser {
              parse() {
                return __awaiter(this, void 0, void 0, function* () {
                  const header = yield this.tokenizer.readToken(DsdiffToken_1.ChunkHeader);
                  assert.strictEqual(header.chunkID, "FRM8");
                  const type = (yield this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();
                  switch (type) {
                    case "DSD":
                      this.metadata.setFormat("dataformat", `DSDIFF/${type}`);
                      this.metadata.setFormat("lossless", true);
                      return this.readFmt8Chunks(header.chunkSize - FourCC_1.FourCcToken.len);
                    default:
                      throw Error(`Unsupported DSDIFF type: ${type}`);
                  }
                });
              }
              readFmt8Chunks(remainingSize) {
                return __awaiter(this, void 0, void 0, function* () {
                  while (remainingSize >= DsdiffToken_1.ChunkHeader.len) {
                    const chunkHeader = yield this.tokenizer.readToken(DsdiffToken_1.ChunkHeader);
                    debug(`Chunk id=${chunkHeader.chunkID}`);
                    yield this.readData(chunkHeader);
                    remainingSize -= DsdiffToken_1.ChunkHeader.len + chunkHeader.chunkSize;
                  }
                });
              }
              readData(header) {
                return __awaiter(this, void 0, void 0, function* () {
                  debug(`Reading data of chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);
                  const p0 = this.tokenizer.position;
                  switch (header.chunkID.trim()) {
                    case "FVER":
                      const version = yield this.tokenizer.readToken(Token.UINT32_LE);
                      debug(`DSDIFF version=${version}`);
                      break;
                    case "PROP":
                      const propType = yield this.tokenizer.readToken(FourCC_1.FourCcToken);
                      assert.strictEqual(propType, "SND ");
                      yield this.handleSoundPropertyChunks(header.chunkSize - FourCC_1.FourCcToken.len);
                      break;
                    case "ID3":
                      const id3_data = yield this.tokenizer.readToken(new Token.BufferType(header.chunkSize));
                      const id3stream = new ID3Stream_1.ID3Stream(id3_data);
                      const rst = strtok3.fromStream(id3stream);
                      yield new ID3v2Parser_1.ID3v2Parser().parse(this.metadata, rst, this.options);
                      break;
                    default:
                      debug(`Ignore chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);
                      break;
                    case "DSD":
                      this.metadata.setFormat("numberOfSamples", header.chunkSize * 8 / this.metadata.format.numberOfChannels);
                      this.metadata.setFormat("duration", this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);
                      break;
                  }
                  const remaining = header.chunkSize - (this.tokenizer.position - p0);
                  if (remaining > 0) {
                    debug(`After Parsing chunk, remaining ${remaining} bytes`);
                    yield this.tokenizer.ignore(remaining);
                  }
                });
              }
              handleSoundPropertyChunks(remainingSize) {
                return __awaiter(this, void 0, void 0, function* () {
                  debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);
                  while (remainingSize > 0) {
                    const sndPropHeader = yield this.tokenizer.readToken(DsdiffToken_1.ChunkHeader);
                    debug(`Sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);
                    const p0 = this.tokenizer.position;
                    switch (sndPropHeader.chunkID.trim()) {
                      case "FS":
                        const sampleRate = yield this.tokenizer.readToken(Token.UINT32_BE);
                        this.metadata.setFormat("sampleRate", sampleRate);
                        break;
                      case "CHNL":
                        const numChannels = yield this.tokenizer.readToken(Token.UINT16_BE);
                        this.metadata.setFormat("numberOfChannels", numChannels);
                        yield this.handleChannelChunks(sndPropHeader.chunkSize - Token.UINT16_BE.len);
                        break;
                      case "CMPR":
                        const compressionIdCode = (yield this.tokenizer.readToken(FourCC_1.FourCcToken)).trim();
                        const count = yield this.tokenizer.readToken(Token.UINT8);
                        const compressionName = yield this.tokenizer.readToken(new Token.StringType(count, "ascii"));
                        if (compressionIdCode === "DSD") {
                          this.metadata.setFormat("lossless", true);
                          this.metadata.setFormat("bitsPerSample", 1);
                        }
                        this.metadata.setFormat("encoder", `${compressionIdCode} (${compressionName})`);
                        break;
                      case "ABSS":
                        const hours = yield this.tokenizer.readToken(Token.UINT16_BE);
                        const minutes = yield this.tokenizer.readToken(Token.UINT8);
                        const seconds = yield this.tokenizer.readToken(Token.UINT8);
                        const samples = yield this.tokenizer.readToken(Token.UINT32_BE);
                        debug(`ABSS ${hours}:${minutes}:${seconds}.${samples}`);
                        break;
                      case "LSCO":
                        const lsConfig = yield this.tokenizer.readToken(Token.UINT16_BE);
                        debug(`LSCO lsConfig=${lsConfig}`);
                        break;
                      case "COMT":
                      default:
                        debug(`Unknown sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);
                        yield this.tokenizer.ignore(sndPropHeader.chunkSize);
                    }
                    const remaining = sndPropHeader.chunkSize - (this.tokenizer.position - p0);
                    if (remaining > 0) {
                      debug(`After Parsing sound-property-chunk ${sndPropHeader.chunkSize}, remaining ${remaining} bytes`);
                      yield this.tokenizer.ignore(remaining);
                    }
                    remainingSize -= DsdiffToken_1.ChunkHeader.len + sndPropHeader.chunkSize;
                    debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);
                  }
                  if (this.metadata.format.lossless && this.metadata.format.sampleRate && this.metadata.format.numberOfChannels && this.metadata.format.bitsPerSample) {
                    const bitrate = this.metadata.format.sampleRate * this.metadata.format.numberOfChannels * this.metadata.format.bitsPerSample;
                    this.metadata.setFormat("bitrate", bitrate);
                  }
                });
              }
              handleChannelChunks(remainingSize) {
                return __awaiter(this, void 0, void 0, function* () {
                  debug(`Parsing channel-chunks, remainingSize=${remainingSize}`);
                  const channels = [];
                  while (remainingSize >= FourCC_1.FourCcToken.len) {
                    const channelId = yield this.tokenizer.readToken(FourCC_1.FourCcToken);
                    debug(`Channel[ID=${channelId}]`);
                    channels.push(channelId);
                    remainingSize -= FourCC_1.FourCcToken.len;
                  }
                  debug(`Channels: ${channels.join(", ")}`);
                  return channels;
                });
              }
            }
            exports2.DsdiffParser = DsdiffParser;
          },
          /* 187 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const Token = __webpack_require__2(6);
            const FourCC_1 = __webpack_require__2(15);
            exports2.ChunkHeader = {
              len: 12,
              get: (buf, off) => {
                return {
                  // Group-ID
                  chunkID: FourCC_1.FourCcToken.get(buf, off),
                  // Size
                  chunkSize: Token.INT64_BE.get(buf, off + 4)
                };
              }
            };
          },
          /* 188 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            (function(Buffer2) {
              var isTypedArray = __webpack_require__2(189).strict;
              module2.exports = function typedarrayToBuffer(arr) {
                if (isTypedArray(arr)) {
                  var buf = Buffer2.from(arr.buffer);
                  if (arr.byteLength !== arr.buffer.byteLength) {
                    buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
                  }
                  return buf;
                } else {
                  return Buffer2.from(arr);
                }
              };
            }).call(this, __webpack_require__2(9).Buffer);
          },
          /* 189 */
          /***/
          function(module2, exports2) {
            module2.exports = isTypedArray;
            isTypedArray.strict = isStrictTypedArray;
            isTypedArray.loose = isLooseTypedArray;
            var toString = Object.prototype.toString;
            var names = {
              "[object Int8Array]": true,
              "[object Int16Array]": true,
              "[object Int32Array]": true,
              "[object Uint8Array]": true,
              "[object Uint8ClampedArray]": true,
              "[object Uint16Array]": true,
              "[object Uint32Array]": true,
              "[object Float32Array]": true,
              "[object Float64Array]": true
            };
            function isTypedArray(arr) {
              return isStrictTypedArray(arr) || isLooseTypedArray(arr);
            }
            function isStrictTypedArray(arr) {
              return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
            }
            function isLooseTypedArray(arr) {
              return names[toString.call(arr)];
            }
          },
          /* 190 */
          /***/
          function(module2, exports2, __webpack_require__2) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            const stream_1 = __webpack_require__2(106);
            class Browser2NodeStream extends stream_1.Readable {
              constructor(stream2) {
                super();
                this.bytesRead = 0;
                this.reader = stream2.getReader();
              }
              _read() {
                this.reader.read().then((res) => {
                  if (res.done) {
                    this.push(null);
                  } else {
                    this.bytesRead += res.value.length;
                    this.push(res.value);
                  }
                });
              }
              _destroy(error, callback) {
                this.reader.cancel().then(() => {
                  callback(null);
                }).catch((err) => {
                  callback(err);
                });
              }
            }
            exports2.Browser2NodeStream = Browser2NodeStream;
          }
          /******/
        ])["default"]
      );
    });
  }
});
export default require_webamp_bundle();
/*! Bundled license information:

webamp/built/webamp.bundle.js:
  (*!
    Copyright (c) 2017 Jed Watson.
    Licensed under the MIT License (MIT), see
    http://jedwatson.github.io/classnames
  *)
  (*!
  * The buffer module from node.js, for the browser.
  *
  * @author   Feross Aboukhadijeh <http://feross.org>
  * @license  MIT
  *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)
  (** @license React v17.0.1
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (** @license React v17.0.1
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (** @license React v17.0.1
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (** @license React v0.20.1
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (*!
  
  JSZip v3.3.0 - A JavaScript class for generating and reading zip files
  <http://stuartk.com/jszip>
  
  (c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
  Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.
  
  JSZip uses the library pako released under the MIT license :
  https://github.com/nodeca/pako/blob/master/LICENSE
  *)
  (*!
   * media-typer
   * Copyright(c) 2014 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=webamp.js.map
