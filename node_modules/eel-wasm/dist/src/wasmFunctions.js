"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const encoding_1 = require("./encoding");
const constants_1 = require("./constants");
exports.localFuncMap = {
    sqr: {
        args: [encoding_1.VAL_TYPE.f64],
        returns: [encoding_1.VAL_TYPE.f64],
        binary: [...encoding_1.op.local_get(0), ...encoding_1.op.local_get(0), encoding_1.op.f64_mul],
    },
    bor: {
        args: [encoding_1.VAL_TYPE.f64, encoding_1.VAL_TYPE.f64],
        returns: [encoding_1.VAL_TYPE.f64],
        binary: [
            ...encoding_1.op.local_get(0),
            ...encoding_1.IS_NOT_ZEROISH,
            ...encoding_1.op.local_get(1),
            ...encoding_1.IS_NOT_ZEROISH,
            encoding_1.op.i32_or,
            ...encoding_1.op.i32_const(0),
            encoding_1.op.i32_ne,
            encoding_1.op.f64_convert_i32_s,
        ],
    },
    band: {
        args: [encoding_1.VAL_TYPE.f64, encoding_1.VAL_TYPE.f64],
        returns: [encoding_1.VAL_TYPE.f64],
        binary: [
            ...encoding_1.op.local_get(0),
            ...encoding_1.IS_NOT_ZEROISH,
            ...encoding_1.op.local_get(1),
            ...encoding_1.IS_NOT_ZEROISH,
            encoding_1.op.i32_and,
            ...encoding_1.op.i32_const(0),
            encoding_1.op.i32_ne,
            encoding_1.op.f64_convert_i32_s,
        ],
    },
    sign: {
        args: [encoding_1.VAL_TYPE.f64],
        returns: [encoding_1.VAL_TYPE.f64],
        binary: [
            ...encoding_1.op.f64_const(0),
            ...encoding_1.op.local_get(0),
            encoding_1.op.f64_lt,
            ...encoding_1.op.local_get(0),
            ...encoding_1.op.f64_const(0),
            encoding_1.op.f64_lt,
            encoding_1.op.i32_sub,
            encoding_1.op.f64_convert_i32_s,
        ],
    },
    mod: {
        args: [encoding_1.VAL_TYPE.f64, encoding_1.VAL_TYPE.f64],
        returns: [encoding_1.VAL_TYPE.f64],
        localVariables: [encoding_1.VAL_TYPE.i32],
        // TODO: Simplify all this type coersion
        binary: [
            ...encoding_1.op.local_get(1),
            encoding_1.op.i32_trunc_f64_s,
            ...encoding_1.op.local_tee(2),
            ...encoding_1.op.i32_const(0),
            encoding_1.op.i32_ne,
            ...encoding_1.op.if(encoding_1.BLOCK.f64),
            ...encoding_1.op.local_get(0),
            encoding_1.op.i32_trunc_f64_s,
            ...encoding_1.op.local_get(2),
            encoding_1.op.i32_rem_s,
            encoding_1.op.f64_convert_i32_s,
            encoding_1.op.else,
            ...encoding_1.op.f64_const(0),
            encoding_1.op.end,
        ],
    },
    bitwiseOr: {
        args: [encoding_1.VAL_TYPE.f64, encoding_1.VAL_TYPE.f64],
        returns: [encoding_1.VAL_TYPE.f64],
        binary: [
            ...encoding_1.op.local_get(0),
            encoding_1.op.i64_trunc_s_f64,
            ...encoding_1.op.local_get(1),
            encoding_1.op.i64_trunc_s_f64,
            encoding_1.op.i64_or,
            encoding_1.op.f64_convert_i64_s,
        ],
    },
    bitwiseAnd: {
        args: [encoding_1.VAL_TYPE.f64, encoding_1.VAL_TYPE.f64],
        returns: [encoding_1.VAL_TYPE.f64],
        binary: [
            ...encoding_1.op.local_get(0),
            encoding_1.op.i64_trunc_s_f64,
            ...encoding_1.op.local_get(1),
            encoding_1.op.i64_trunc_s_f64,
            encoding_1.op.i64_and,
            encoding_1.op.f64_convert_i64_s,
        ],
    },
    div: {
        args: [encoding_1.VAL_TYPE.f64, encoding_1.VAL_TYPE.f64],
        returns: [encoding_1.VAL_TYPE.f64],
        localVariables: [encoding_1.VAL_TYPE.i32],
        binary: [
            ...encoding_1.op.local_get(1),
            ...encoding_1.op.f64_const(0),
            encoding_1.op.f64_ne,
            ...encoding_1.op.if(encoding_1.BLOCK.f64),
            ...encoding_1.op.local_get(0),
            ...encoding_1.op.local_get(1),
            encoding_1.op.f64_div,
            encoding_1.op.else,
            ...encoding_1.op.f64_const(0),
            encoding_1.op.end,
        ],
    },
    // Takes a float buffer index and converts it to an int. Values out of range
    // are returned as `-1`.
    //
    // NOTE: There's actually a subtle bug that exists in Milkdrop's Eel
    // implementation, which we reproduce here.
    //
    // Wasm's `trunc()` rounds towards zero. This means that for index `-1` we
    // will return zero, since: `roundTowardZero(-1 + EPSILON) == 0`
    //
    // A subsequent check handles negative indexes, so negative indexes > than
    // `-1` are not affected.
    _getBufferIndex: {
        args: [encoding_1.VAL_TYPE.f64 /* 0: $index */],
        returns: [encoding_1.VAL_TYPE.i32 /* $noramlizedIndex */],
        localVariables: [
            encoding_1.VAL_TYPE.f64,
            encoding_1.VAL_TYPE.i32,
        ],
        binary: [
            ...encoding_1.op.f64_const(encoding_1.EPSILON),
            ...encoding_1.op.local_get(0),
            encoding_1.op.f64_add,
            // STACK: [$i + EPSILON]
            ...encoding_1.op.local_tee(1),
            encoding_1.op.i32_trunc_f64_s,
            // TODO We could probably make this a tee and get rid of the next get if we swap the final condition
            ...encoding_1.op.local_set(2),
            // STACK: []
            ...encoding_1.op.i32_const(-1),
            ...encoding_1.op.local_get(2),
            // STACK: [-1, $truncated]
            ...encoding_1.op.i32_const(8),
            encoding_1.op.i32_mul,
            // STACK: [-1, $truncated * 8]
            ...encoding_1.op.local_get(2),
            ...encoding_1.op.i32_const(0),
            // STACK: [-1, $truncated * 8, $truncated, 0]
            encoding_1.op.i32_lt_s,
            // STACK: [-1, $truncated * 8, <is index less than 0>]
            ...encoding_1.op.local_get(2),
            ...encoding_1.op.i32_const(constants_1.BUFFER_SIZE - 1),
            encoding_1.op.i32_gt_s,
            // STACK: [-1, $truncated * 8, <is index less than 0>, <is index more than MAX>]
            encoding_1.op.i32_or,
            // STACK: [-1, $truncated * 8, <is index out of range>]
            encoding_1.op.select,
        ],
    },
};
//# sourceMappingURL=wasmFunctions.js.map