"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const encoding_1 = require("./encoding");
const shims_1 = __importDefault(require("./shims"));
const errorUtils_1 = require("./errorUtils");
const wasmFunctions_1 = require("./wasmFunctions");
const utils_1 = require("./utils");
const constants_1 = require("./constants");
function emit(ast, context) {
    var _a, _b, _c;
    switch (ast.type) {
        case "SCRIPT": {
            const body = ast.body.map((statement, i) => {
                return [...emit(statement, context), encoding_1.op.drop];
            });
            return utils_1.flatten(body);
        }
        case "EXPRESSION_BLOCK": {
            return emitExpressionBlock(ast.body, context);
        }
        case "BINARY_EXPRESSION": {
            const left = emit(ast.left, context);
            const right = emit(ast.right, context);
            const operatorToOps = {
                "+": [encoding_1.op.f64_add],
                "-": [encoding_1.op.f64_sub],
                "*": [encoding_1.op.f64_mul],
                "/": context.resolveFunc("div"),
                "%": context.resolveFunc("mod"),
                "|": context.resolveFunc("bitwiseOr"),
                "&": context.resolveFunc("bitwiseAnd"),
                "^": context.resolveFunc("pow"),
                // Comparison operators
                "==": [encoding_1.op.f64_sub, ...encoding_1.IS_ZEROISH, encoding_1.op.f64_convert_i32_s],
                "!=": [encoding_1.op.f64_sub, ...encoding_1.IS_NOT_ZEROISH, encoding_1.op.f64_convert_i32_s],
                "<": [encoding_1.op.f64_lt, encoding_1.op.f64_convert_i32_s],
                ">": [encoding_1.op.f64_gt, encoding_1.op.f64_convert_i32_s],
                "<=": [encoding_1.op.f64_le, encoding_1.op.f64_convert_i32_s],
                ">=": [encoding_1.op.f64_ge, encoding_1.op.f64_convert_i32_s],
            };
            const code = operatorToOps[ast.operator];
            if (code == null) {
                throw errorUtils_1.createCompilerError(`Unknown binary expression operator ${ast.operator}`, ast.loc, context.rawSource);
            }
            return [...left, ...right, ...code];
        }
        case "CALL_EXPRESSION": {
            const functionName = ast.callee.value;
            // Destructure this so that TypeScript knows it won't get mutated.
            const argList = ast.arguments;
            const assertArity = (arity) => {
                if (argList.length < arity) {
                    throw errorUtils_1.createUserError(`Too few arguments passed to \`${functionName}()\`. Expected ${arity} but only got ${argList.length}.`, ast.loc, context.rawSource);
                }
                if (argList.length > arity) {
                    throw errorUtils_1.createUserError(`Too many arguments passed to \`${functionName}()\`. Expected ${arity} but got ${argList.length}.`, argList[arity].loc, context.rawSource);
                }
            };
            // Some functions have special behavior
            switch (functionName) {
                case "exec2":
                    assertArity(2);
                    return emitExpressionBlock(ast.arguments, context);
                case "exec3":
                    assertArity(3);
                    return emitExpressionBlock(ast.arguments, context);
                case "if":
                    assertArity(3);
                    const [test, consiquent, alternate] = ast.arguments;
                    return emitConditional(test, consiquent, alternate, context);
                case "while":
                    assertArity(1);
                    return emitWhile(ast.arguments[0], context);
                case "loop":
                    assertArity(2);
                    return emitLoop(ast.arguments[0], ast.arguments[1], context);
                case "megabuf":
                case "gmegabuf":
                    assertArity(1);
                    const index = context.resolveLocal(encoding_1.VAL_TYPE.i32);
                    return [
                        ...emit(ast.arguments[0], context),
                        ...((_a = context.resolveFunc("_getBufferIndex")) !== null && _a !== void 0 ? _a : []),
                        ...encoding_1.op.local_tee(index),
                        ...encoding_1.op.i32_const(-1),
                        encoding_1.op.i32_ne,
                        // STACK: [in range]
                        ...encoding_1.op.if(encoding_1.BLOCK.f64),
                        ...encoding_1.op.local_get(index),
                        ...encoding_1.op.f64_load(3, emitAddMemoryOffset(functionName)),
                        encoding_1.op.else,
                        ...encoding_1.op.f64_const(0),
                        encoding_1.op.end,
                    ];
                case "assign":
                    assertArity(2);
                    const variableIdentifier = ast.arguments[0];
                    if (variableIdentifier.type != "IDENTIFIER") {
                        throw errorUtils_1.createUserError("Expected the first argument of `assign()` to be an identifier.", variableIdentifier.loc, context.rawSource);
                    }
                    const resolvedName = context.resolveVar(variableIdentifier.value);
                    return [
                        ...emit(ast.arguments[1], context),
                        ...encoding_1.op.global_set(resolvedName),
                        ...encoding_1.op.global_get(resolvedName),
                    ];
            }
            // Function calls which can be linlined
            const args = utils_1.flatten(ast.arguments.map(node => emit(node, context)));
            // This is just a continuation of the above switch statement, but it's for functions which all parse their args the same.
            switch (functionName) {
                case "abs":
                    assertArity(1);
                    return [...args, encoding_1.op.f64_abs];
                case "sqrt":
                    assertArity(1);
                    return [...args, encoding_1.op.f64_abs, encoding_1.op.f64_sqrt];
                case "int":
                    assertArity(1);
                    return [...args, encoding_1.op.f64_floor];
                case "min":
                    assertArity(2);
                    return [...args, encoding_1.op.f64_min];
                case "max":
                    assertArity(2);
                    return [...args, encoding_1.op.f64_max];
                case "above":
                    assertArity(2);
                    return [...args, encoding_1.op.f64_gt, encoding_1.op.f64_convert_i32_s];
                case "below":
                    assertArity(2);
                    return [...args, encoding_1.op.f64_lt, encoding_1.op.f64_convert_i32_s];
                case "equal":
                    assertArity(2);
                    return [...args, encoding_1.op.f64_sub, ...encoding_1.IS_ZEROISH, encoding_1.op.f64_convert_i32_s];
                case "bnot":
                    assertArity(1);
                    return [...args, ...encoding_1.IS_ZEROISH, encoding_1.op.f64_convert_i32_s];
                case "floor":
                    assertArity(1);
                    return [...args, encoding_1.op.f64_floor];
                case "ceil":
                    assertArity(1);
                    return [...args, encoding_1.op.f64_ceil];
            }
            const invocation = context.resolveFunc(functionName);
            if (invocation == null ||
                // Ensure this isn't a private function. This is a bit awkward becuase
                // Eel does implement some _ functions but while they are _intended_ to be
                // private, they accidentally expose them. We should find a cleaner way
                // to defining user accessible functions vs utility functions used by
                // the compiler.
                functionName.startsWith("_")) {
                throw errorUtils_1.createUserError(`"${functionName}" is not defined.`, ast.callee.loc, context.rawSource);
            }
            if (shims_1.default[functionName] != null) {
                assertArity(shims_1.default[functionName].length);
            }
            else if (wasmFunctions_1.localFuncMap[functionName] != null) {
                assertArity(wasmFunctions_1.localFuncMap[functionName].args.length);
            }
            else {
                throw errorUtils_1.createCompilerError(`Missing arity information for the function \`${functionName}()\``, ast.callee.loc, context.rawSource);
            }
            return [...args, ...invocation];
        }
        case "ASSIGNMENT_EXPRESSION": {
            const { left } = ast;
            const rightCode = emit(ast.right, context);
            const mutationCode = getAssignmentOperatorMutation(ast, context);
            if (left.type === "IDENTIFIER") {
                const resolvedName = context.resolveVar(left.value);
                // TODO: In lots of cases we don't care about the return value. In those
                // cases we should try to find a way to omit the `get/drop` combo.
                // Peephole optimization seems to be the conventional way to do this.
                // https://en.wikipedia.org/wiki/Peephole_optimization
                const get = encoding_1.op.global_get(resolvedName);
                const set = encoding_1.op.global_set(resolvedName);
                // `=` is a special case in that it does not need the original value.
                if (mutationCode === null) {
                    return [...rightCode, ...set, ...get];
                }
                return [...get, ...rightCode, ...mutationCode, ...set, ...get];
            }
            if (left.type !== "CALL_EXPRESSION") {
                throw errorUtils_1.createCompilerError(
                // @ts-ignore This is a guard in case the parser has an error
                `Unexpected left hand side type for assignment: ${left.type}`, ast.loc, context.rawSource);
            }
            // Special assignment case for `megabuf(n) = e` and `gmegabuf(n) = e`.
            const localIndex = context.resolveLocal(encoding_1.VAL_TYPE.i32);
            if (left.arguments.length !== 1) {
                throw errorUtils_1.createUserError(`Expected 1 argument when assinging to a buffer but got ${left.arguments.length}.`, left.arguments.length === 0 ? left.loc : left.arguments[1].loc, context.rawSource);
            }
            const bufferName = left.callee.value;
            if (bufferName !== "gmegabuf" && bufferName !== "megabuf") {
                throw errorUtils_1.createUserError("The only function calls which may be assigned to are `gmegabuf()` and `megabuf()`.", left.callee.loc, context.rawSource);
            }
            const addOffset = emitAddMemoryOffset(bufferName);
            if (mutationCode === null) {
                // TODO: Move this to wasmFunctions once we know how to call functions
                // from within functions (need to get the offset).
                const unnormalizedIndex = context.resolveLocal(encoding_1.VAL_TYPE.i32);
                const rightValue = context.resolveLocal(encoding_1.VAL_TYPE.f64);
                return [
                    // Emit the right hand side unconditionally to ensure it always runs.
                    ...rightCode,
                    ...encoding_1.op.local_set(rightValue),
                    ...emit(left.arguments[0], context),
                    ...((_b = context.resolveFunc("_getBufferIndex")) !== null && _b !== void 0 ? _b : []),
                    ...encoding_1.op.local_tee(unnormalizedIndex),
                    ...encoding_1.op.i32_const(0),
                    encoding_1.op.i32_lt_s,
                    // STACK: [is the index out of range?]
                    ...encoding_1.op.if(encoding_1.BLOCK.f64),
                    ...encoding_1.op.f64_const(0),
                    encoding_1.op.else,
                    ...encoding_1.op.local_get(unnormalizedIndex),
                    ...encoding_1.op.local_tee(localIndex),
                    // STACK: [buffer index]
                    ...encoding_1.op.local_get(rightValue),
                    // STACK: [buffer index, right]
                    ...encoding_1.op.f64_store(3, addOffset),
                    // STACK: []
                    ...encoding_1.op.local_get(rightValue),
                    // STACK: [Right/Buffer value]
                    encoding_1.op.end,
                ];
            }
            // TODO: Move this to wasmFunctions once we know how to call functions
            // from within functions (need to get the offset).
            const index = context.resolveLocal(encoding_1.VAL_TYPE.i32);
            const inBounds = context.resolveLocal(encoding_1.VAL_TYPE.i32);
            const rightValue = context.resolveLocal(encoding_1.VAL_TYPE.f64);
            const result = context.resolveLocal(encoding_1.VAL_TYPE.f64);
            return [
                ...rightCode,
                ...encoding_1.op.local_set(rightValue),
                ...emit(left.arguments[0], context),
                ...((_c = context.resolveFunc("_getBufferIndex")) !== null && _c !== void 0 ? _c : []),
                ...encoding_1.op.local_tee(index),
                // STACK: [index]
                ...encoding_1.op.i32_const(-1),
                encoding_1.op.i32_ne,
                ...encoding_1.op.local_tee(inBounds),
                ...encoding_1.op.if(encoding_1.BLOCK.f64),
                ...encoding_1.op.local_get(index),
                ...encoding_1.op.f64_load(3, addOffset),
                encoding_1.op.else,
                ...encoding_1.op.f64_const(0),
                encoding_1.op.end,
                // STACK: [current value from memory || 0]
                // Apply the mutation
                ...encoding_1.op.local_get(rightValue),
                ...mutationCode,
                ...encoding_1.op.local_tee(result),
                // STACK: [new value]
                ...encoding_1.op.local_get(inBounds),
                ...encoding_1.op.if(encoding_1.BLOCK.void),
                ...encoding_1.op.local_get(index),
                ...encoding_1.op.local_get(result),
                ...encoding_1.op.f64_store(3, addOffset),
                encoding_1.op.end,
            ];
        }
        case "LOGICAL_EXPRESSION": {
            const left = emit(ast.left, context);
            const right = emit(ast.right, context);
            const behaviorMap = {
                "&&": {
                    comparison: encoding_1.IS_ZEROISH,
                    shortCircutValue: 0,
                },
                "||": {
                    comparison: encoding_1.IS_NOT_ZEROISH,
                    shortCircutValue: 1,
                },
            };
            const behavior = behaviorMap[ast.operator];
            if (behavior == null) {
                throw errorUtils_1.createCompilerError(`Unknown logical expression operator ${ast.operator}`, ast.loc, context.rawSource);
            }
            const { comparison, shortCircutValue } = behavior;
            return [
                ...left,
                ...comparison,
                ...encoding_1.op.if(encoding_1.BLOCK.f64),
                ...encoding_1.op.f64_const(shortCircutValue),
                encoding_1.op.else,
                ...right,
                ...encoding_1.IS_NOT_ZEROISH,
                encoding_1.op.f64_convert_i32_s,
                encoding_1.op.end,
            ];
        }
        case "UNARY_EXPRESSION": {
            const value = emit(ast.value, context);
            const operatorToCode = {
                "-": [encoding_1.op.f64_neg],
                "+": [],
                "!": [...encoding_1.IS_ZEROISH, encoding_1.op.f64_convert_i32_s],
            };
            const code = operatorToCode[ast.operator];
            if (code == null) {
                throw errorUtils_1.createCompilerError(`Unknown logical unary operator ${ast.operator}`, ast.loc, context.rawSource);
            }
            return [...value, ...code];
        }
        case "IDENTIFIER":
            const variableName = ast.value;
            // TODO: It's a bit odd that not every IDENTIFIER node gets emitted. In
            // function calls and assignments we just peek at the name and never emit
            // it.
            return encoding_1.op.global_get(context.resolveVar(variableName));
        case "NUMBER_LITERAL":
            return encoding_1.op.f64_const(ast.value);
        default:
            throw errorUtils_1.createCompilerError(
            // @ts-ignore This runtime check is here because the caller may not be type-checked
            `Unknown AST node type ${ast.type}`, 
            // @ts-ignore This runtime check is here because the caller may not be type-checked
            ast.loc, context.rawSource);
    }
}
exports.emit = emit;
function emitExpressionBlock(body, context) {
    const statements = body.map((statement, i) => {
        return emit(statement, context);
    });
    return utils_1.flatten(utils_1.arrayJoin(statements, [encoding_1.op.drop]));
}
function emitWhile(expression, context) {
    const body = emit(expression, context);
    const iterationCount = context.resolveLocal(encoding_1.VAL_TYPE.i32);
    return [
        ...encoding_1.op.i32_const(0),
        ...encoding_1.op.local_set(iterationCount),
        ...encoding_1.op.loop(encoding_1.BLOCK.void),
        // Increment and check loop count
        ...encoding_1.op.local_get(iterationCount),
        ...encoding_1.op.i32_const(1),
        encoding_1.op.i32_add,
        ...encoding_1.op.local_tee(iterationCount),
        // STACK: [iteration count]
        ...encoding_1.op.i32_const(constants_1.MAX_LOOP_COUNT),
        encoding_1.op.i32_lt_u,
        // STACK: [loop in range]
        ...body,
        ...encoding_1.IS_NOT_ZEROISH,
        // STACK: [loop in range, body is truthy]
        encoding_1.op.i32_and,
        // STACK: [can continue]
        ...encoding_1.op.br_if(0),
        encoding_1.op.end,
        ...encoding_1.op.f64_const(0),
    ];
}
function emitLoop(count, expression, context) {
    const body = emit(expression, context);
    const localIndex = context.resolveLocal(encoding_1.VAL_TYPE.i32);
    return [
        ...encoding_1.op.block(encoding_1.BLOCK.void),
        // Assign the count to a variable
        ...emit(count, context),
        encoding_1.op.i32_trunc_f64_s,
        ...encoding_1.op.local_tee(localIndex),
        ...encoding_1.op.i32_const(0),
        encoding_1.op.i32_le_s,
        ...encoding_1.op.br_if(1),
        ...encoding_1.op.loop(encoding_1.BLOCK.void),
        // Run the body
        ...body,
        encoding_1.op.drop,
        // Decrement the count
        ...encoding_1.op.local_get(localIndex),
        ...encoding_1.op.i32_const(1),
        encoding_1.op.i32_sub,
        ...encoding_1.op.local_tee(localIndex),
        ...encoding_1.op.i32_const(0),
        encoding_1.op.i32_ne,
        ...encoding_1.op.br_if(0),
        encoding_1.op.end,
        encoding_1.op.end,
        ...encoding_1.op.f64_const(0),
    ];
}
function emitConditional(test, consiquent, alternate, context) {
    // TODO: In some cases https://webassembly.studio/ compiles these to use `select`.
    // Is that an optimization that we might want as well?
    return [
        ...emit(test, context),
        ...encoding_1.IS_NOT_ZEROISH,
        ...encoding_1.op.if(encoding_1.BLOCK.f64),
        ...emit(consiquent, context),
        encoding_1.op.else,
        ...emit(alternate, context),
        encoding_1.op.end,
    ];
}
// There are two sections of memory. This function emits code to add the correct
// offset to an i32 index already on the stack.
function emitAddMemoryOffset(name) {
    switch (name) {
        case "gmegabuf":
            return constants_1.BUFFER_SIZE * 8;
        case "megabuf":
            return 0;
    }
}
function getAssignmentOperatorMutation(ast, context) {
    const operatorToCode = {
        "+=": [encoding_1.op.f64_add],
        "-=": [encoding_1.op.f64_sub],
        "*=": [encoding_1.op.f64_mul],
        "/=": [encoding_1.op.f64_div],
        "%=": context.resolveFunc("mod"),
        "=": null,
    };
    const operatorCode = operatorToCode[ast.operator];
    if (operatorCode === undefined) {
        throw errorUtils_1.createCompilerError(`Unknown assignment operator "${ast.operator}"`, ast.loc, context.rawSource);
    }
    return operatorCode;
}
//# sourceMappingURL=emitter.js.map