"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const parser_1 = require("./parser");
const emitter_1 = require("./emitter");
const encoding_1 = require("./encoding");
const shims_1 = __importDefault(require("./shims"));
const Utils = __importStar(require("./utils"));
const wasmFunctions_1 = require("./wasmFunctions");
const constants_1 = require("./constants");
function compileModule({ pools, functions: funcs, eelVersion = 2, preParsed = false, }) {
    if (Object.keys(pools).includes("shims")) {
        throw new Error('You may not name a pool "shims". "shims" is reserved for injected JavaScript functions.');
    }
    // Collect all the globals that we expect to get as imports.
    const importedVars = [];
    Object.entries(pools).forEach(([poolName, pool]) => {
        pool.forEach(variableName => {
            importedVars.push([poolName, variableName]);
        });
    });
    // Ensure all the imported globals get the first ids.
    const varResolver = new Utils.ScopedIdMap();
    importedVars.forEach(([poolName, variableName]) => {
        varResolver.get(poolName, variableName);
    });
    const functionImports = Object.entries(shims_1.default).map(([name, func]) => {
        return {
            args: new Array(func.length).fill(null).map(_ => encoding_1.VAL_TYPE.f64),
            // Shims implicitly always return a number
            returns: [encoding_1.VAL_TYPE.f64],
            name,
        };
    });
    const localFuncOrder = [];
    const moduleFuncs = [];
    Object.entries(funcs).forEach(([name, { pool, code }]) => {
        if (pools[pool] == null) {
            const poolsList = Object.keys(pools);
            if (poolsList.length === 0) {
                throw new Error(`The function "${name}" was declared as using a variable ` +
                    `pool named "${pool}" but no pools were defined.`);
            }
            throw new Error(`The function "${name}" was declared as using a variable ` +
                `pool named "${pool}" which is not among the variable ` +
                `pools defined. The defined variable pools are: ` +
                `${Utils.formatList(poolsList)}.`);
        }
        const ast = preParsed ? code : parser_1.parse(code);
        if (typeof ast === "string") {
            // TODO: Change the API so this can be enforced by types
            throw new Error("Got passed unparsed code without setting the preParsed flag");
        }
        if (ast.type !== "SCRIPT") {
            throw new Error("Invalid AST");
        }
        if (ast.body.length === 0) {
            return;
        }
        const localVariables = [];
        const context = {
            resolveVar: name => {
                // The `reg00`-`reg99` variables are special in that they are shared between all pools.
                if (/^reg\d\d$/.test(name)) {
                    return varResolver.get(null, name);
                }
                return varResolver.get(pool, name);
            },
            resolveLocal: type => {
                // TODO: We could provide a way for the emitter to release a local
                // variable so that we can reuse it, much in the same way a traditional
                // compiler does in register allocation.
                localVariables.push(type);
                return localVariables.length - 1;
            },
            resolveFunc: name => {
                // If this is a shim, return the shim index.
                const shimdex = functionImports.findIndex(func => func.name === name);
                if (shimdex !== -1) {
                    const call = encoding_1.op.call(shimdex);
                    if (name === "rand" && eelVersion === 1) {
                        return [...call, encoding_1.op.f64_floor];
                    }
                    return call;
                }
                // If it's not a shim and it's not a defined function, return null.
                // The emitter will generate a nice error.
                if (wasmFunctions_1.localFuncMap[name] == null) {
                    return null;
                }
                let index = localFuncOrder.indexOf(name);
                if (index === -1) {
                    localFuncOrder.push(name);
                    index = localFuncOrder.length - 1;
                }
                return encoding_1.op.call(index + functionImports.length);
            },
            rawSource: code,
        };
        const binary = emitter_1.emit(ast, context);
        moduleFuncs.push({
            binary,
            exportName: name,
            args: [],
            returns: [],
            localVariables,
        });
    });
    const localFuncs = localFuncOrder.map(name => {
        const func = wasmFunctions_1.localFuncMap[name];
        // This check is technicaly redundant since we check inside resolveLocalFunc
        // in the compiler context. It's here just to catch potential compiler bugs.
        if (func == null) {
            throw new Error(`Undefined local function "${name}"`);
        }
        return func;
    });
    // Given a function definition, return a hashable string representation of its signature.
    const getSignatureKey = (func) => {
        return [...func.args, "|", ...func.returns].join("-");
    };
    // https://webassembly.github.io/spec/core/binary/modules.html#type-section
    const types = [];
    const typeIndexByKey = new Map();
    [...functionImports, ...localFuncs, ...moduleFuncs].forEach(func => {
        const key = getSignatureKey(func);
        if (typeIndexByKey.has(key)) {
            return;
        }
        types.push([
            encoding_1.FUNCTION_TYPE,
            ...encoding_1.encodeFlatVector(func.args),
            ...encoding_1.encodeFlatVector(func.returns),
        ]);
        typeIndexByKey.set(key, types.length - 1);
    });
    function getTypeIndex(func) {
        const key = getSignatureKey(func);
        const typeIndex = typeIndexByKey.get(key);
        if (typeIndex == null) {
            throw new Error(`Failed to get a type index for key ${key}`);
        }
        return typeIndex;
    }
    // https://webassembly.github.io/spec/core/binary/modules.html#import-section
    const imports = [
        ...importedVars.map(([namespace, name]) => {
            return [
                ...encoding_1.encodeString(namespace),
                ...encoding_1.encodeString(name),
                ...[encoding_1.GLOBAL_TYPE, encoding_1.VAL_TYPE.f64, encoding_1.MUTABILITY.var],
            ];
        }),
        ...functionImports.map((func, i) => {
            const typeIndex = getTypeIndex(func);
            return [
                ...encoding_1.encodeString("shims"),
                ...encoding_1.encodeString(func.name),
                ...[encoding_1.TYPE_IDX, ...encoding_1.unsignedLEB128(typeIndex)],
            ];
        }),
    ];
    // https://webassembly.github.io/spec/core/binary/modules.html#function-section
    //
    // > Functions are referenced through function indices, starting with the smallest
    // > index not referencing a function import.
    const functions = [...localFuncs, ...moduleFuncs].map(func => {
        const typeIndex = getTypeIndex(func);
        return encoding_1.unsignedLEB128(typeIndex);
    });
    const memories = [
        // Only one memory
        [
            0x01,
            ...encoding_1.unsignedLEB128(constants_1.WASM_MEMORY_SIZE),
            ...encoding_1.unsignedLEB128(constants_1.WASM_MEMORY_SIZE),
        ],
    ];
    // https://webassembly.github.io/spec/core/binary/modules.html#global-section
    const globalCount = varResolver.size() - importedVars.length;
    const globals = Utils.times(globalCount, () => {
        return [
            encoding_1.VAL_TYPE.f64,
            encoding_1.MUTABILITY.var,
            ...encoding_1.op.f64_const(0),
            encoding_1.op.end,
        ];
    });
    // https://webassembly.github.io/spec/core/binary/modules.html#binary-exportsec
    const xports = [...moduleFuncs].map((func, i) => {
        const funcIndex = i + functionImports.length + localFuncs.length;
        return [
            ...encoding_1.encodeString(func.exportName),
            encoding_1.EXPORT_TYPE.FUNC,
            ...encoding_1.unsignedLEB128(funcIndex),
        ];
    });
    /* Uncomment this to expose memory
    xports.push([
      ...encodeString("memory"),
      EXPORT_TYPE.MEMORY,
      ...unsignedLEB128(0),
    ]);
    */
    // https://webassembly.github.io/spec/core/binary/modules.html#code-section
    const codes = [...localFuncs, ...moduleFuncs].map(func => {
        var _a;
        // TODO: We could collapose consecutive types here, or even move to a two
        // pass approach where ids are resolved after the emitter is run.
        const localTypes = ((_a = func.localVariables) !== null && _a !== void 0 ? _a : []).map(type => {
            return [...encoding_1.unsignedLEB128(1), type];
        });
        // It's a bit odd that every other section is an array of arrays and this
        // one is an array of vectors. The spec says this is so that when navigating
        // the binary functions can be skipped efficiently.
        return encoding_1.encodeFlatVector([
            ...encoding_1.encodeNestedVector(localTypes),
            ...func.binary,
            encoding_1.op.end,
        ]);
    });
    return new Uint8Array([
        // Magic module header
        ...encoding_1.MAGIC,
        // Version number
        ...encoding_1.WASM_VERSION,
        ...encoding_1.encodeSection(encoding_1.SECTION.TYPE, types),
        ...encoding_1.encodeSection(encoding_1.SECTION.IMPORT, imports),
        ...encoding_1.encodeSection(encoding_1.SECTION.FUNC, functions),
        ...encoding_1.encodeSection(encoding_1.SECTION.MEMORY, memories),
        ...encoding_1.encodeSection(encoding_1.SECTION.GLOBAL, globals),
        ...encoding_1.encodeSection(encoding_1.SECTION.EXPORT, xports),
        ...encoding_1.encodeSection(encoding_1.SECTION.CODE, codes),
    ]);
}
exports.compileModule = compileModule;
//# sourceMappingURL=compiler.js.map