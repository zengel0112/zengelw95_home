"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function arrayJoin(arr, joiner) {
    const newArr = [];
    for (let i = 0; i < arr.length; i++) {
        newArr.push(arr[i]);
        const last = i === arr.length - 1;
        if (!last) {
            newArr.push(joiner);
        }
    }
    return newArr;
}
exports.arrayJoin = arrayJoin;
function flatten(arr) {
    return [].concat.apply([], arr);
}
exports.flatten = flatten;
function times(n, cb) {
    return new Array(n).fill(null).map((_, i) => cb(i));
}
exports.times = times;
function repeat(n, char) {
    return new Array(n).fill(char).join("");
}
exports.repeat = repeat;
// Maintain an ordered list of indexes for namespace/key pairs.
// In Wasm binary variables are referenced by their index. In our emitter we
// want to emit variables indexes as we encounter their names. This data
// structure lets us issue variable indexes on demmand and then iterate through
// them post facto.
//
// `null` may be passed for the namespace argument in order to get a global
// variable that exists in all namespaces.
class ScopedIdMap {
    constructor() {
        this._map = new Map();
    }
    // Get the index of a given namespace/key pair
    get(namespace, key) {
        const jointKey = namespace == null ? key : `${namespace}::${key}`;
        if (!this._map.has(jointKey)) {
            this._map.set(jointKey, this._map.size);
        }
        // @ts-ignore We know the key is here.
        return this._map.get(jointKey);
    }
    size() {
        return this._map.size;
    }
}
exports.ScopedIdMap = ScopedIdMap;
function formatList(list) {
    if (list.length === 0) {
        throw new Error("Cannot format an empty list");
    }
    if (list.length === 1) {
        return list[0];
    }
    const quoted = list.map(name => `"${name}"`);
    const last = quoted.pop();
    return quoted.join(", ") + ` and ${last}`;
}
exports.formatList = formatList;
//# sourceMappingURL=utils.js.map